diff --git a/.clang-format b/.clang-format
new file mode 100644
index 0000000..a84fb8e
--- /dev/null
+++ b/.clang-format
@@ -0,0 +1,11 @@
+BasedOnStyle: Google
+IndentWidth: 2
+TabWidth: 2
+UseTab: Never
+ColumnLimit: 150
+BreakBeforeBraces: Attach
+AllowShortFunctionsOnASingleLine: false
+DerivePointerAlignment: false
+PointerAlignment: Left
+SortIncludes: false
+AllowShortIfStatementsOnASingleLine: false
\ No newline at end of file
diff --git a/.github/workflows/clang-format-fix-pr.yml b/.github/workflows/clang-format-fix-pr.yml
index 521679d..2154aeb 100644
--- a/.github/workflows/clang-format-fix-pr.yml
+++ b/.github/workflows/clang-format-fix-pr.yml
@@ -1 +1 @@
-name: Auto Clang Format Fix PR
+name: Clang Format PR Suggestions
@@ -8 +8 @@ jobs:
-  format-and-fix:
+  clang-format-suggest:
@@ -11 +10,0 @@ jobs:
-      contents: write
@@ -12,0 +12 @@ jobs:
+      contents: read
@@ -15 +15 @@ jobs:
-      - name: Checkout PR branch
+      - name: Checkout code
@@ -18,2 +18 @@ jobs:
-          fetch-depth: 0
-          ref: ${{ github.head_ref }}
+          fetch-depth: 0  # full history is needed for diff
@@ -21 +20 @@ jobs:
-      - name: Install clang-format and deps
+      - name: Install clang-format and dependencies
@@ -28 +27,2 @@ jobs:
-      - name: Download clang-format-diff.py
+      - name: Generate clang-format suggestions
+        id: clang_format
@@ -30,2 +30,3 @@ jobs:
-          curl -o clang-format-diff.py https://raw.githubusercontent.com/llvm/llvm-project/release/15.x/clang/tools/clang-format/clang-format-diff.py
-          chmod +x clang-format-diff.py
+          # Ensure no local changes or untracked files from previous steps
+          git reset --hard
+          git clean -fdx  # Remove untracked files and dirs
@@ -33,2 +34 @@ jobs:
-      - name: Apply clang-format to changed lines
-        run: |
+          # Fetch master branch for diffing
@@ -35,0 +36,7 @@ jobs:
+
+          echo "Get clang-format-diff.py"
+          curl -o clang-format-diff.py https://raw.githubusercontent.com/llvm/llvm-project/release/14.x/clang/tools/clang-format/clang-format-diff.py
+          chmod +x clang-format-diff.py
+
+
+          # Generate diff and clang-format suggestions
@@ -37 +44,5 @@ jobs:
-          python3 clang-format-diff.py -i -p1 -style=file < pr.diff
+          python3 clang-format-diff.py -p1 -style=file < pr.diff > format_suggestions.txt
+          
+          # Store diff line count and contents
+          SUGGESTION_LINES=$(wc -l < format_suggestions.txt)
+          echo "lines=$SUGGESTION_LINES" >> "$GITHUB_OUTPUT"
@@ -39,16 +50,3 @@ jobs:
-      - name: Commit and push to new branch (if needed)
-        id: maybe_push
-        run: |
-          if [[ -n "$(git status --porcelain)" ]]; then
-            export FIX_BRANCH="clang-format-fix/pr-${{ github.event.pull_request.number }}"
-            git config user.name "clang-format-bot"
-            git config user.email "actions@github.com"
-            git checkout -b "$FIX_BRANCH"
-            git commit -am "style: apply clang-format to changed lines in PR #${{ github.event.pull_request.number }}"
-            git push origin "$FIX_BRANCH"
-            echo "pushed=true" >> "$GITHUB_OUTPUT"
-            echo "branch=$FIX_BRANCH" >> "$GITHUB_OUTPUT"
-          else
-            echo "No changes to commit"
-            echo "pushed=false" >> "$GITHUB_OUTPUT"
-          fi
+          # Escape special characters and save contents to output
+          SUGGESTIONS=$(cat format_suggestions.txt | sed -e 's/%/%25/g' -e 's/\r/%0D/g' -e 's/\n/%0A/g')
+          echo "suggestions=$SUGGESTIONS" >> "$GITHUB_OUTPUT"
@@ -56,3 +54,3 @@ jobs:
-      - name: Create and auto-merge PR
-        if: steps.maybe_push.outputs.pushed == 'true'
-        uses: actions/github-script@v7
+      - name: Comment on PR with suggestions
+        if: steps.clang_format.outputs.lines != '0'
+        uses: peter-evans/create-or-update-comment@v4
@@ -60,4 +58,6 @@ jobs:
-          github-token: ${{ secrets.GITHUB_TOKEN }}
-          script: |
-            const fixBranch = '${{ steps.maybe_push.outputs.branch }}';
-            const originalPR = context.payload.pull_request.number;
+          token: ${{ secrets.GITHUB_TOKEN }}
+          issue-number: ${{ github.event.pull_request.number }}
+          body: |
+            âš ï¸ **Clang-Format Style Suggestions**
+
+            The following formatting issues were found in the changed lines of your PR:
@@ -65,8 +65,3 @@ jobs:
-            const { data: pr } = await github.rest.pulls.create({
-              owner: context.repo.owner,
-              repo: context.repo.repo,
-              title: `ðŸ”§ Clang-Format Fix for PR #${originalPR}`,
-              head: fixBranch,
-              base: context.payload.pull_request.base.ref,
-              body: `This PR auto-applies \`clang-format\` to the changed lines in #${originalPR}.`
-            });
+            ```
+            ${{ steps.clang_format.outputs.suggestions }}
+            ```
@@ -74,18 +69 @@ jobs:
-            // Enable auto-merge (requires auto-merge to be enabled in repo settings)
-            await github.graphql(`
-              mutation EnableAutoMerge($prId: ID!) {
-                enablePullRequestAutoMerge(input: {
-                  pullRequestId: $prId,
-                  mergeMethod: SQUASH
-                }) {
-                  pullRequest {
-                    number
-                    autoMergeRequest {
-                      enabledAt
-                    }
-                  }
-                }
-              }
-            `, {
-              prId: pr.node_id
-            });
+            Please run `clang-format.sh` on the changed lines or commit these suggestions manually.
diff --git a/CamParser.cpp b/CamParser.cpp
index 6ea26e5..03b3fe4 100644
--- a/CamParser.cpp
+++ b/CamParser.cpp
@@ -2 +2 @@
-//sensorCAM parser.cpp version 3.03  Sep 2024
+// sensorCAM parser.cpp version 3.03  Sep 2024
@@ -7,2 +7,2 @@
-#ifndef SENSORCAM_VPIN       //define CAM vpin (700?) in config.h
-#define SENSORCAM_VPIN 0     
+#ifndef SENSORCAM_VPIN  // define CAM vpin (700?) in config.h
+#define SENSORCAM_VPIN 0
@@ -11 +11 @@
-#ifndef SENSORCAM2_VPIN 
+#ifndef SENSORCAM2_VPIN
@@ -14 +14 @@
-#ifndef SENSORCAM3_VPIN 
+#ifndef SENSORCAM3_VPIN
@@ -17,3 +17,3 @@
-const int CAMVPINS[] = {CAM_VPIN,SENSORCAM_VPIN,SENSORCAM2_VPIN,SENSORCAM3_VPIN};
-const int16_t ver=30177;
-const int16_t ve =2899;
+const int CAMVPINS[] = {CAM_VPIN, SENSORCAM_VPIN, SENSORCAM2_VPIN, SENSORCAM3_VPIN};
+const int16_t ver = 30177;
+const int16_t ve = 2899;
@@ -23,3 +23,3 @@ VPIN EXSensorCAM::CAMBaseVpin = CAM_VPIN;
-bool CamParser::parseN(Print * stream, byte paramCount, int16_t p[]) {
-  (void)stream;  // probably unused parameter 
-  VPIN vpin=EXSensorCAM::CAMBaseVpin;   //use current CAM selection
+bool CamParser::parseN(Print* stream, byte paramCount, int16_t p[]) {
+  (void)stream;                          // probably unused parameter
+  VPIN vpin = EXSensorCAM::CAMBaseVpin;  // use current CAM selection
@@ -27,3 +27,3 @@ bool CamParser::parseN(Print * stream, byte paramCount, int16_t p[]) {
-  if (paramCount==0) { 
-    DIAG(F("vpin:%d EXSensorCAMs defined at Vpins #1@ %d #2@ %d #3@ %d"),vpin,CAMVPINS[1],CAMVPINS[2],CAMVPINS[3]);
-    return true; 
+  if (paramCount == 0) {
+    DIAG(F("vpin:%d EXSensorCAMs defined at Vpins #1@ %d #2@ %d #3@ %d"), vpin, CAMVPINS[1], CAMVPINS[2], CAMVPINS[3]);
+    return true;
@@ -31,3 +31,3 @@ bool CamParser::parseN(Print * stream, byte paramCount, int16_t p[]) {
-  uint8_t camop=p[0]; // cam oprerator 
-  int param1=0;
-  int16_t param3=9999;   // =0 could invoke parameter changes. & -1 gives later errors
+  uint8_t camop = p[0];  // cam oprerator
+  int param1 = 0;
+  int16_t param3 = 9999;  // =0 could invoke parameter changes. & -1 gives later errors
@@ -35,4 +35,6 @@ bool CamParser::parseN(Print * stream, byte paramCount, int16_t p[]) {
-  if(camop=='C'){ 
-    if(p[1]>=100) EXSensorCAM::CAMBaseVpin=p[1];
-    if(p[1]<4) EXSensorCAM::CAMBaseVpin=CAMVPINS[p[1]];
-    DIAG(F("CAM base Vpin: %c %d "),p[0],EXSensorCAM::CAMBaseVpin);
+  if (camop == 'C') {
+    if (p[1] >= 100)
+      EXSensorCAM::CAMBaseVpin = p[1];
+    if (p[1] < 4)
+      EXSensorCAM::CAMBaseVpin = CAMVPINS[p[1]];
+    DIAG(F("CAM base Vpin: %c %d "), p[0], EXSensorCAM::CAMBaseVpin);
@@ -41,7 +43,7 @@ bool CamParser::parseN(Print * stream, byte paramCount, int16_t p[]) {
-  if (camop<100) {               //switch CAM# if p[1] dictates
-    if(p[1]>=100 && p[1]<400) {  //limits to CAM# 1 to 3 for now
-      vpin=CAMVPINS[p[1]/100];
-      EXSensorCAM::CAMBaseVpin=vpin;     
-      DIAG(F("switching to CAM %d baseVpin:%d"),p[1]/100,vpin); 
-      p[1]=p[1]%100;             //strip off CAM #
-    } 
+  if (camop < 100) {                  // switch CAM# if p[1] dictates
+    if (p[1] >= 100 && p[1] < 400) {  // limits to CAM# 1 to 3 for now
+      vpin = CAMVPINS[p[1] / 100];
+      EXSensorCAM::CAMBaseVpin = vpin;
+      DIAG(F("switching to CAM %d baseVpin:%d"), p[1] / 100, vpin);
+      p[1] = p[1] % 100;  // strip off CAM #
+    }
@@ -49 +51,15 @@ bool CamParser::parseN(Print * stream, byte paramCount, int16_t p[]) {
-  if (EXSensorCAM::CAMBaseVpin==0) return false; // no cam defined 
+  if (EXSensorCAM::CAMBaseVpin == 0)
+    return false;  // no cam defined
+
+  // send UPPER case to sensorCAM to flag binary data from a DCCEX-CS parser
+  switch (paramCount) {
+    case 1:  //<N ver> produces '^'
+      if ((p[0] == ve) || (p[0] == ver) || (p[0] == 'V'))
+        camop = '^';
+      if (STRCHR_P((const char*)F("EFGMQRVW^"), camop) == nullptr)
+        return false;
+      if (camop == 'Q')
+        param3 = 10;  //<NQ> for activation state of all 10 banks of sensors
+      if (camop == 'F')
+        camop = ']';  //<NF> for Reset/Finish webCAM.
+      break;          // F Coded as ']' else conflicts with <Nf %%>
@@ -51,13 +67,4 @@ bool CamParser::parseN(Print * stream, byte paramCount, int16_t p[]) {
-  
-      // send UPPER case to sensorCAM to flag binary data from a DCCEX-CS parser  
-  switch(paramCount) {    
-    case 1:                          //<N ver> produces '^'
-      if((p[0] == ve) || (p[0] == ver) || (p[0] == 'V')) camop='^'; 
-      if (STRCHR_P((const char *)F("EFGMQRVW^"),camop) == nullptr) return false;
-      if (camop=='Q') param3=10;     //<NQ> for activation state of all 10 banks of sensors
-      if (camop=='F') camop=']';     //<NF> for Reset/Finish webCAM.
-      break;    // F Coded as ']' else conflicts with <Nf %%>
-    
-    case 2:                          //<N camop p1>  
-      if (STRCHR_P((const char *)F("ABFILMNOPQRSTUV"),camop)==nullptr) return false;
-      param1=p[1];
+    case 2:  //<N camop p1>
+      if (STRCHR_P((const char*)F("ABFILMNOPQRSTUV"), camop) == nullptr)
+        return false;
+      param1 = p[1];
@@ -65,7 +72,9 @@ bool CamParser::parseN(Print * stream, byte paramCount, int16_t p[]) {
-    
-    case 3:              //<N vpin rowY colx > or <N cmd p1 p2>
-      camop=p[0];
-      if (p[0]>=100) {   //vpin - i.e. NOT 'A' through 'Z'
-        if (p[1]>236 || p[1]<0) return false;     //row
-        if (p[2]>316 || p[2]<0) return false;     //column
-        camop=0x80;      // special 'a' case for IO_SensorCAM
+
+    case 3:  //<N vpin rowY colx > or <N cmd p1 p2>
+      camop = p[0];
+      if (p[0] >= 100) {  // vpin - i.e. NOT 'A' through 'Z'
+        if (p[1] > 236 || p[1] < 0)
+          return false;  // row
+        if (p[2] > 316 || p[2] < 0)
+          return false;  // column
+        camop = 0x80;    // special 'a' case for IO_SensorCAM
@@ -73,2 +82,3 @@ bool CamParser::parseN(Print * stream, byte paramCount, int16_t p[]) {
-      }else if (STRCHR_P((const char *)F("IJMNT"),camop) == nullptr) return false; 
-      param1 = p[1];  
+      } else if (STRCHR_P((const char*)F("IJMNT"), camop) == nullptr)
+        return false;
+      param1 = p[1];
@@ -77,10 +87,14 @@ bool CamParser::parseN(Print * stream, byte paramCount, int16_t p[]) {
-    
-    case 4:          //<N a id row col> 
-      if (camop!='A') return false;          //must start with 'a' 
-      if (p[3]>316 || p[3]<0) return false;
-      if (p[2]>236 || p[2]<0) return false;
-      if (p[1]>97 || p[1]<0) return false;   //treat as bsNo.
-      vpin = vpin + (p[1]/10)*8 + p[1]%10;   //translate p[1]
-      camop=0x80;    // special 'a' case for IO_SensorCAM
-      param1=p[2];   // row
-      param3=p[3];   // col
+
+    case 4:  //<N a id row col>
+      if (camop != 'A')
+        return false;  // must start with 'a'
+      if (p[3] > 316 || p[3] < 0)
+        return false;
+      if (p[2] > 236 || p[2] < 0)
+        return false;
+      if (p[1] > 97 || p[1] < 0)
+        return false;                             // treat as bsNo.
+      vpin = vpin + (p[1] / 10) * 8 + p[1] % 10;  // translate p[1]
+      camop = 0x80;                               // special 'a' case for IO_SensorCAM
+      param1 = p[2];                              // row
+      param3 = p[3];                              // col
@@ -92,2 +106,2 @@ bool CamParser::parseN(Print * stream, byte paramCount, int16_t p[]) {
-  DIAG(F("CamParser: %d %c %d %d"),vpin,camop,param1,param3);
-  IODevice::writeAnalogue(vpin,param1,camop,param3);
+  DIAG(F("CamParser: %d %c %d %d"), vpin, camop, param1, param3);
+  IODevice::writeAnalogue(vpin, param1, camop, param3);
diff --git a/CamParser.h b/CamParser.h
index ad1b7e6..f9cf35d 100644
--- a/CamParser.h
+++ b/CamParser.h
@@ -7,2 +7,2 @@ class CamParser {
-   public:
-   static bool parseN(Print * stream, byte paramCount, int16_t p[]);
+ public:
+  static bool parseN(Print* stream, byte paramCount, int16_t p[]);
@@ -11 +10,0 @@ class CamParser {
-
diff --git a/CommandDistributor.cpp b/CommandDistributor.cpp
index cdfbe2d..45c0109 100644
--- a/CommandDistributor.cpp
+++ b/CommandDistributor.cpp
@@ -39,2 +39,2 @@ int8_t lastclockrate;
-
-#if WIFI_ON || ETHERNET_ON || defined(SERIAL1_COMMANDS) || defined(SERIAL2_COMMANDS) || defined(SERIAL3_COMMANDS) || defined(SERIAL4_COMMANDS) || defined(SERIAL5_COMMANDS) || defined(SERIAL6_COMMANDS)
+#if WIFI_ON || ETHERNET_ON || defined(SERIAL1_COMMANDS) || defined(SERIAL2_COMMANDS) || defined(SERIAL3_COMMANDS) || defined(SERIAL4_COMMANDS) || \
+    defined(SERIAL5_COMMANDS) || defined(SERIAL6_COMMANDS)
@@ -42,2 +42,3 @@ int8_t lastclockrate;
-StringBuffer * CommandDistributor::broadcastBufferWriter=new StringBuffer();
-template<typename... Targs> void CommandDistributor::broadcastReply(clientType type, Targs... msg){
+StringBuffer* CommandDistributor::broadcastBufferWriter = new StringBuffer();
+template <typename... Targs>
+void CommandDistributor::broadcastReply(clientType type, Targs... msg) {
@@ -50,2 +51,3 @@ template<typename... Targs> void CommandDistributor::broadcastReply(clientType t
-template<typename... Targs> void CommandDistributor::broadcastReply(clientType type, Targs... msg){
-  (void)type; //shut up compiler warning
+template <typename... Targs>
+void CommandDistributor::broadcastReply(clientType type, Targs... msg) {
+  (void)type;  // shut up compiler warning
@@ -54 +56 @@ template<typename... Targs> void CommandDistributor::broadcastReply(clientType t
-#endif 
+#endif
@@ -57,4 +59,4 @@ template<typename... Targs> void CommandDistributor::broadcastReply(clientType t
-  // wifi or ethernet ring streams with multiple client types
-  RingStream *  CommandDistributor::ring=0;
-  CommandDistributor::clientType  CommandDistributor::clients[8]={
-    NONE_TYPE,NONE_TYPE,NONE_TYPE,NONE_TYPE,NONE_TYPE,NONE_TYPE,NONE_TYPE,NONE_TYPE};
+// wifi or ethernet ring streams with multiple client types
+RingStream* CommandDistributor::ring = 0;
+CommandDistributor::clientType CommandDistributor::clients[8] = {NONE_TYPE, NONE_TYPE, NONE_TYPE, NONE_TYPE,
+                                                                 NONE_TYPE, NONE_TYPE, NONE_TYPE, NONE_TYPE};
@@ -64 +66 @@ template<typename... Targs> void CommandDistributor::broadcastReply(clientType t
-void  CommandDistributor::parse(byte clientId,byte * buffer, RingStream * stream) {
+void CommandDistributor::parse(byte clientId, byte* buffer, RingStream* stream) {
@@ -66,2 +68,2 @@ void  CommandDistributor::parse(byte clientId,byte * buffer, RingStream * stream
-    DIAG(F("Parse C=%d T=%d B=%s"),clientId, clients[clientId], buffer);
-  ring=stream;
+    DIAG(F("Parse C=%d T=%d B=%s"), clientId, clients[clientId], buffer);
+  ring = stream;
@@ -76 +78 @@ void  CommandDistributor::parse(byte clientId,byte * buffer, RingStream * stream
-      clients[clientId]=COMMAND_TYPE;
+      clients[clientId] = COMMAND_TYPE;
@@ -78 +80 @@ void  CommandDistributor::parse(byte clientId,byte * buffer, RingStream * stream
-      clients[clientId]=WITHROTTLE_TYPE;
+      clients[clientId] = WITHROTTLE_TYPE;
@@ -92 +94 @@ void  CommandDistributor::parse(byte clientId,byte * buffer, RingStream * stream
-  if (ring->peekTargetMark()!=RingStream::NO_CLIENT) {
+  if (ring->peekTargetMark() != RingStream::NO_CLIENT) {
@@ -98 +100 @@ void  CommandDistributor::parse(byte clientId,byte * buffer, RingStream * stream
-      DIAG(F("OUTBOUND FULL processing cmd:%s"),buffer);
+      DIAG(F("OUTBOUND FULL processing cmd:%s"), buffer);
@@ -101 +103 @@ void  CommandDistributor::parse(byte clientId,byte * buffer, RingStream * stream
-    DIAG(F("CD parse: was alredy committed")); //XXX Could have been committed by broadcastClient?!
+    DIAG(F("CD parse: was alredy committed"));  // XXX Could have been committed by broadcastClient?!
@@ -106,3 +108,5 @@ void CommandDistributor::forget(byte clientId) {
-  if (clients[clientId]==WITHROTTLE_TYPE) WiThrottle::forget(clientId);
-  clients[clientId]=NONE_TYPE;
-  if (virtualLCDClient==clientId) virtualLCDClient=RingStream::NO_CLIENT;
+  if (clients[clientId] == WITHROTTLE_TYPE)
+    WiThrottle::forget(clientId);
+  clients[clientId] = NONE_TYPE;
+  if (virtualLCDClient == clientId)
+    virtualLCDClient = RingStream::NO_CLIENT;
@@ -110 +114 @@ void CommandDistributor::forget(byte clientId) {
-#endif 
+#endif
@@ -112 +116 @@ void CommandDistributor::forget(byte clientId) {
-// This will not be called on a uno 
+// This will not be called on a uno
@@ -114 +117,0 @@ void CommandDistributor::broadcastToClients(clientType type) {
-
@@ -116 +119 @@ void CommandDistributor::broadcastToClients(clientType type) {
-  (void)rememberClient; // shut up compiler warning
+  (void)rememberClient;  // shut up compiler warning
@@ -119 +122,2 @@ void CommandDistributor::broadcastToClients(clientType type) {
-  if (type==COMMAND_TYPE) SerialManager::broadcast(broadcastBufferWriter->getString());
+  if (type == COMMAND_TYPE)
+    SerialManager::broadcast(broadcastBufferWriter->getString());
@@ -127 +131 @@ void CommandDistributor::broadcastToClients(clientType type) {
-      //DIAG(F("CD precommit client %d"), rememberClient);
+      // DIAG(F("CD precommit client %d"), rememberClient);
@@ -131,7 +135,7 @@ void CommandDistributor::broadcastToClients(clientType type) {
-    for (byte clientId=0; clientId<sizeof(clients); clientId++) {
-      if (clients[clientId]==type)  {
-	//DIAG(F("CD mark client %d"), clientId);
-	ring->mark(clientId);
-	ring->print(broadcastBufferWriter->getString());
-	//DIAG(F("CD commit client %d"), clientId);
-	ring->commit();
+    for (byte clientId = 0; clientId < sizeof(clients); clientId++) {
+      if (clients[clientId] == type) {
+        // DIAG(F("CD mark client %d"), clientId);
+        ring->mark(clientId);
+        ring->print(broadcastBufferWriter->getString());
+        // DIAG(F("CD commit client %d"), clientId);
+        ring->commit();
@@ -143 +147 @@ void CommandDistributor::broadcastToClients(clientType type) {
-      //DIAG(F("CD postmark client %d"), rememberClient);
+      // DIAG(F("CD postmark client %d"), rememberClient);
@@ -150,3 +154,3 @@ void CommandDistributor::broadcastToClients(clientType type) {
-// Public broadcast functions below 
-void  CommandDistributor::broadcastSensor(int16_t id, bool on ) {
-  broadcastReply(COMMAND_TYPE, F("<%c %d>\n"), on?'Q':'q', id);
+// Public broadcast functions below
+void CommandDistributor::broadcastSensor(int16_t id, bool on) {
+  broadcastReply(COMMAND_TYPE, F("<%c %d>\n"), on ? 'Q' : 'q', id);
@@ -155 +159 @@ void  CommandDistributor::broadcastSensor(int16_t id, bool on ) {
-void  CommandDistributor::broadcastTurnout(int16_t id, bool isClosed ) {
+void CommandDistributor::broadcastTurnout(int16_t id, bool isClosed) {
@@ -159 +163 @@ void  CommandDistributor::broadcastTurnout(int16_t id, bool isClosed ) {
-  broadcastReply(COMMAND_TYPE, F("<H %d %d>\n"),id, !isClosed);
+  broadcastReply(COMMAND_TYPE, F("<H %d %d>\n"), id, !isClosed);
@@ -161 +165 @@ void  CommandDistributor::broadcastTurnout(int16_t id, bool isClosed ) {
-  broadcastReply(WITHROTTLE_TYPE, F("PTA%c%d\n"), isClosed?'2':'4', id);
+  broadcastReply(WITHROTTLE_TYPE, F("PTA%c%d\n"), isClosed ? '2' : '4', id);
@@ -169 +173 @@ void CommandDistributor::broadcastTurntable(int16_t id, uint8_t position, bool m
-void  CommandDistributor::broadcastClockTime(int16_t time, int8_t rate) {
+void CommandDistributor::broadcastClockTime(int16_t time, int8_t rate) {
@@ -174 +178 @@ void  CommandDistributor::broadcastClockTime(int16_t time, int8_t rate) {
-  broadcastReply(COMMAND_TYPE, F("<jC %d %d>\n"),time, rate);
+  broadcastReply(COMMAND_TYPE, F("<jC %d %d>\n"), time, rate);
@@ -176 +180 @@ void  CommandDistributor::broadcastClockTime(int16_t time, int8_t rate) {
-  broadcastReply(WITHROTTLE_TYPE, F("PFT%l<;>%d\n"), (int32_t)time*60, rate);
+  broadcastReply(WITHROTTLE_TYPE, F("PFT%l<;>%d\n"), (int32_t)time * 60, rate);
@@ -184,2 +188 @@ void CommandDistributor::setClockTime(int16_t clocktime, int8_t clockrate, byte
-  switch (opt)
-  {
+  switch (opt) {
@@ -187,3 +190,3 @@ void CommandDistributor::setClockTime(int16_t clocktime, int8_t clockrate, byte
-      if (clocktime != lastclocktime){
-        // CAH. DIAG removed because LCD does it anyway. 
-        LCD(6,F("Clk Time:%d Sp %d"), clocktime, clockrate);
+      if (clocktime != lastclocktime) {
+        // CAH. DIAG removed because LCD does it anyway.
+        LCD(6, F("Clk Time:%d Sp %d"), clocktime, clockrate);
@@ -191 +194 @@ void CommandDistributor::setClockTime(int16_t clocktime, int8_t clockrate, byte
-        RMFT2::clockEvent(clocktime,1);
+        RMFT2::clockEvent(clocktime, 1);
@@ -203 +205,0 @@ void CommandDistributor::setClockTime(int16_t clocktime, int8_t clockrate, byte
- 
@@ -210,3 +212,3 @@ int16_t CommandDistributor::retClockTime() {
-void  CommandDistributor::broadcastLoco(byte slot) {
-  DCC::LOCO * sp=&DCC::speedTable[slot];
-  broadcastReply(COMMAND_TYPE, F("<l %d %d %d %l>\n"), sp->loco,slot,sp->speedCode,sp->functions);
+void CommandDistributor::broadcastLoco(byte slot) {
+  DCC::LOCO* sp = &DCC::speedTable[slot];
+  broadcastReply(COMMAND_TYPE, F("<l %d %d %d %l>\n"), sp->loco, slot, sp->speedCode, sp->functions);
@@ -216 +218 @@ void  CommandDistributor::broadcastLoco(byte slot) {
-    bool direction = (sp->speedCode & 0x80) !=0; // true for forward
+    bool direction = (sp->speedCode & 0x80) != 0;  // true for forward
@@ -218 +220 @@ void  CommandDistributor::broadcastLoco(byte slot) {
-    if (speed == 1) { // emergency stop
+    if (speed == 1) {  // emergency stop
@@ -220,3 +222,3 @@ void  CommandDistributor::broadcastLoco(byte slot) {
-	rampingmode = 1;
-	Serial2.print("R1: 0\r\n");
-	Serial2.print("R2: 0\r\n");
+        rampingmode = 1;
+        Serial2.print("R1: 0\r\n");
+        Serial2.print("R2: 0\r\n");
@@ -228,3 +230,3 @@ void  CommandDistributor::broadcastLoco(byte slot) {
-	speed = (speed - 1) * 1625 / 100;
-	speed = speed * (direction ? 1 : -1);
-	// speed is here -2047 to 2047
+        speed = (speed - 1) * 1625 / 100;
+        speed = speed * (direction ? 1 : -1);
+        // speed is here -2047 to 2047
@@ -233,3 +235,3 @@ void  CommandDistributor::broadcastLoco(byte slot) {
-	rampingmode = 2;
-	Serial2.print("R1: 2047\r\n");
-	Serial2.print("R2: 2047\r\n");
+        rampingmode = 2;
+        Serial2.print("R1: 2047\r\n");
+        Serial2.print("R2: 2047\r\n");
@@ -251,2 +253,2 @@ void  CommandDistributor::broadcastLoco(byte slot) {
-void  CommandDistributor::broadcastForgetLoco(int16_t loco) {
-  broadcastReply(COMMAND_TYPE, F("<l %d 0 1 0>\n<- %d>\n"), loco,loco);
+void CommandDistributor::broadcastForgetLoco(int16_t loco) {
+  broadcastReply(COMMAND_TYPE, F("<l %d 0 1 0>\n<- %d>\n"), loco, loco);
@@ -255 +257 @@ void  CommandDistributor::broadcastForgetLoco(int16_t loco) {
-void  CommandDistributor::broadcastPower() {
+void CommandDistributor::broadcastPower() {
@@ -257 +259 @@ void  CommandDistributor::broadcastPower() {
-  for(byte t=0; t<TrackManager::MAX_TRACKS; t++)
+  for (byte t = 0; t < TrackManager::MAX_TRACKS; t++)
@@ -259 +261 @@ void  CommandDistributor::broadcastPower() {
-      broadcastReply(COMMAND_TYPE, F("<p%s>\n"),pstr);
+      broadcastReply(COMMAND_TYPE, F("<p%s>\n"), pstr);
@@ -261,4 +263,4 @@ void  CommandDistributor::broadcastPower() {
-  byte trackcount=0;
-  byte oncount=0;
-  byte offcount=0;
-  for(byte t=0; t<TrackManager::MAX_TRACKS; t++) {
+  byte trackcount = 0;
+  byte oncount = 0;
+  byte offcount = 0;
+  for (byte t = 0; t < TrackManager::MAX_TRACKS; t++) {
@@ -269 +271 @@ void  CommandDistributor::broadcastPower() {
-	oncount++;
+        oncount++;
@@ -271 +273 @@ void  CommandDistributor::broadcastPower() {
-	offcount++;
+        offcount++;
@@ -274 +276 @@ void  CommandDistributor::broadcastPower() {
-  //DIAG(F("t=%d on=%d off=%d"), trackcount, oncount, offcount);
+  // DIAG(F("t=%d on=%d off=%d"), trackcount, oncount, offcount);
@@ -276,2 +278,2 @@ void  CommandDistributor::broadcastPower() {
-  char state='2';
-  if (oncount==0 || offcount == trackcount)
+  char state = '2';
+  if (oncount == 0 || offcount == trackcount)
@@ -284 +286 @@ void  CommandDistributor::broadcastPower() {
-    broadcastReply(COMMAND_TYPE, F("<p%c>\n"),state);
+    broadcastReply(COMMAND_TYPE, F("<p%c>\n"), state);
@@ -287,5 +289,5 @@ void  CommandDistributor::broadcastPower() {
-  bool main=TrackManager::getMainPower()==POWERMODE::ON;
-  bool prog=TrackManager::getProgPower()==POWERMODE::ON;
-  bool join=TrackManager::isJoined();
-  //DIAG(F("m=%d p=%d j=%d"), main, prog, join);
-  const FSH * reason=F("");
+  bool main = TrackManager::getMainPower() == POWERMODE::ON;
+  bool prog = TrackManager::getProgPower() == POWERMODE::ON;
+  bool join = TrackManager::isJoined();
+  // DIAG(F("m=%d p=%d j=%d"), main, prog, join);
+  const FSH* reason = F("");
@@ -293,2 +295,2 @@ void  CommandDistributor::broadcastPower() {
-    reason = F(" JOIN"); // with space at start so we can append without space
-    broadcastReply(COMMAND_TYPE, F("<p1%S>\n"),reason);
+    reason = F(" JOIN");  // with space at start so we can append without space
+    broadcastReply(COMMAND_TYPE, F("<p1%S>\n"), reason);
@@ -297 +299 @@ void  CommandDistributor::broadcastPower() {
-      //reason = F("MAIN");
+      // reason = F("MAIN");
@@ -301 +303 @@ void  CommandDistributor::broadcastPower() {
-      //reason = F("PROG");
+      // reason = F("PROG");
@@ -307 +309 @@ void  CommandDistributor::broadcastPower() {
-  broadcastReply(WITHROTTLE_TYPE, F("PPA%c\n"), main?'1': state);
+  broadcastReply(WITHROTTLE_TYPE, F("PPA%c\n"), main ? '1' : state);
@@ -310 +312 @@ void  CommandDistributor::broadcastPower() {
-  LCD(2,F("Power %S%S"),state=='1'?F("On"): ( state=='0'? F("Off") : F("SC") ),reason);
+  LCD(2, F("Power %S%S"), state == '1' ? F("On") : (state == '0' ? F("Off") : F("SC")), reason);
@@ -313,2 +315,2 @@ void  CommandDistributor::broadcastPower() {
-void CommandDistributor::broadcastRaw(clientType type, char * msg) {
-  broadcastReply(type, F("%s"),msg);
+void CommandDistributor::broadcastRaw(clientType type, char* msg) {
+  broadcastReply(type, F("%s"), msg);
@@ -317,3 +319,3 @@ void CommandDistributor::broadcastRaw(clientType type, char * msg) {
-void CommandDistributor::broadcastMessage(char * message) {
-  broadcastReply(COMMAND_TYPE, F("<m \"%s\">\n"),message);
-  broadcastReply(WITHROTTLE_TYPE, F("Hm%s\n"),message);
+void CommandDistributor::broadcastMessage(char* message) {
+  broadcastReply(COMMAND_TYPE, F("<m \"%s\">\n"), message);
+  broadcastReply(WITHROTTLE_TYPE, F("Hm%s\n"), message);
@@ -322 +324 @@ void CommandDistributor::broadcastMessage(char * message) {
-void CommandDistributor::broadcastTrackState(const FSH* format, byte trackLetter, const FSH *modename, int16_t dcAddr) {
+void CommandDistributor::broadcastTrackState(const FSH* format, byte trackLetter, const FSH* modename, int16_t dcAddr) {
@@ -326,2 +328,2 @@ void CommandDistributor::broadcastTrackState(const FSH* format, byte trackLetter
-void  CommandDistributor::broadcastRouteState(uint16_t routeId, byte state ) {
-  broadcastReply(COMMAND_TYPE, F("<jB %d %d>\n"),routeId,state);
+void CommandDistributor::broadcastRouteState(uint16_t routeId, byte state) {
+  broadcastReply(COMMAND_TYPE, F("<jB %d %d>\n"), routeId, state);
@@ -330,2 +332,2 @@ void  CommandDistributor::broadcastRouteState(uint16_t routeId, byte state ) {
-void  CommandDistributor::broadcastRouteCaption(uint16_t routeId, const FSH* caption ) {
-  broadcastReply(COMMAND_TYPE, F("<jB %d \"%S\">\n"),routeId,caption);
+void CommandDistributor::broadcastRouteCaption(uint16_t routeId, const FSH* caption) {
+  broadcastReply(COMMAND_TYPE, F("<jB %d \"%S\">\n"), routeId, caption);
@@ -334,5 +336,5 @@ void  CommandDistributor::broadcastRouteCaption(uint16_t routeId, const FSH* cap
-Print * CommandDistributor::getVirtualLCDSerial(byte screen, byte row) {
-  Print * stream=virtualLCDSerial;
-  #ifdef  CD_HANDLE_RING
-  rememberVLCDClient=RingStream::NO_CLIENT;
-  if (!stream && virtualLCDClient!=RingStream::NO_CLIENT) {
+Print* CommandDistributor::getVirtualLCDSerial(byte screen, byte row) {
+  Print* stream = virtualLCDSerial;
+#ifdef CD_HANDLE_RING
+  rememberVLCDClient = RingStream::NO_CLIENT;
+  if (!stream && virtualLCDClient != RingStream::NO_CLIENT) {
@@ -345,2 +347,2 @@ Print * CommandDistributor::getVirtualLCDSerial(byte screen, byte row) {
-    ring->mark(virtualLCDClient);   
-    stream=ring; 
+    ring->mark(virtualLCDClient);
+    stream = ring;
@@ -348,3 +350,4 @@ Print * CommandDistributor::getVirtualLCDSerial(byte screen, byte row) {
-  #endif
-  if (stream) StringFormatter::send(stream,F("<@ %d %d \""), screen,row);
-  return stream;  
+#endif
+  if (stream)
+    StringFormatter::send(stream, F("<@ %d %d \""), screen, row);
+  return stream;
@@ -354,3 +357,3 @@ void CommandDistributor::commitVirtualLCDSerial() {
-  #ifdef  CD_HANDLE_RING
-  if (virtualLCDClient!=RingStream::NO_CLIENT) {
-    StringFormatter::send(ring,F("\">\n"));
+#ifdef CD_HANDLE_RING
+  if (virtualLCDClient != RingStream::NO_CLIENT) {
+    StringFormatter::send(ring, F("\">\n"));
@@ -358,5 +361,6 @@ void CommandDistributor::commitVirtualLCDSerial() {
-    if (rememberVLCDClient!=RingStream::NO_CLIENT) ring->mark(rememberVLCDClient);
-    return;  
-   }
-  #endif
-  StringFormatter::send(virtualLCDSerial,F("\">\n"));  
+    if (rememberVLCDClient != RingStream::NO_CLIENT)
+      ring->mark(rememberVLCDClient);
+    return;
+  }
+#endif
+  StringFormatter::send(virtualLCDSerial, F("\">\n"));
@@ -365,10 +369,10 @@ void CommandDistributor::commitVirtualLCDSerial() {
-void CommandDistributor::setVirtualLCDSerial(Print * stream) {
-  #ifdef  CD_HANDLE_RING
-  virtualLCDClient=RingStream::NO_CLIENT;
-  if (stream && stream->availableForWrite()==RingStream::THIS_IS_A_RINGSTREAM) {
-     virtualLCDClient=((RingStream *) stream)->peekTargetMark();
-     virtualLCDSerial=nullptr;
-     return;
-  }      
-    #endif
-  virtualLCDSerial=stream;
+void CommandDistributor::setVirtualLCDSerial(Print* stream) {
+#ifdef CD_HANDLE_RING
+  virtualLCDClient = RingStream::NO_CLIENT;
+  if (stream && stream->availableForWrite() == RingStream::THIS_IS_A_RINGSTREAM) {
+    virtualLCDClient = ((RingStream*)stream)->peekTargetMark();
+    virtualLCDSerial = nullptr;
+    return;
+  }
+#endif
+  virtualLCDSerial = stream;
@@ -377,3 +381,3 @@ void CommandDistributor::setVirtualLCDSerial(Print * stream) {
-Print* CommandDistributor::virtualLCDSerial=&USB_SERIAL;
-byte CommandDistributor::virtualLCDClient=0xFF;
-byte CommandDistributor::rememberVLCDClient=0;
+Print* CommandDistributor::virtualLCDSerial = &USB_SERIAL;
+byte CommandDistributor::virtualLCDClient = 0xFF;
+byte CommandDistributor::rememberVLCDClient = 0;
diff --git a/CommandDistributor.h b/CommandDistributor.h
index d86b87f..3efb8fd 100644
--- a/CommandDistributor.h
+++ b/CommandDistributor.h
@@ -6 +6 @@
- * 
+ *
@@ -32,4 +32,4 @@
-#if WIFI_ON | ETHERNET_ON 
-  // Command Distributor must handle a RingStream of clients
-  #define CD_HANDLE_RING
-#endif 
+#if WIFI_ON | ETHERNET_ON
+// Command Distributor must handle a RingStream of clients
+#define CD_HANDLE_RING
+#endif
@@ -38,3 +38,4 @@ class CommandDistributor {
-public:
-  enum clientType: byte {NONE_TYPE,COMMAND_TYPE,WITHROTTLE_TYPE};
-private:
+ public:
+  enum clientType : byte { NONE_TYPE, COMMAND_TYPE, WITHROTTLE_TYPE };
+
+ private:
@@ -42,7 +43,7 @@ private:
-  static StringBuffer * broadcastBufferWriter;
-  #ifdef CD_HANDLE_RING
-    static RingStream * ring;
-    static clientType clients[8];
-  #endif
-public :
-  static void parse(byte clientId,byte* buffer, RingStream * ring);
+  static StringBuffer* broadcastBufferWriter;
+#ifdef CD_HANDLE_RING
+  static RingStream* ring;
+  static clientType clients[8];
+#endif
+ public:
+  static void parse(byte clientId, byte* buffer, RingStream* ring);
@@ -58,3 +59,4 @@ public :
-  static void broadcastRaw(clientType type,char * msg);
-  static void broadcastTrackState(const FSH* format,byte trackLetter, const FSH* modename, int16_t dcAddr);
-  template<typename... Targs> static void broadcastReply(clientType type, Targs... msg);
+  static void broadcastRaw(clientType type, char* msg);
+  static void broadcastTrackState(const FSH* format, byte trackLetter, const FSH* modename, int16_t dcAddr);
+  template <typename... Targs>
+  static void broadcastReply(clientType type, Targs... msg);
@@ -62,4 +64,4 @@ public :
-  static void broadcastRouteState(uint16_t routeId,byte state);
-  static void broadcastRouteCaption(uint16_t routeId,const FSH * caption);
-  static void broadcastMessage(char * message);
-  
+  static void broadcastRouteState(uint16_t routeId, byte state);
+  static void broadcastRouteCaption(uint16_t routeId, const FSH* caption);
+  static void broadcastMessage(char* message);
+
@@ -67 +69 @@ public :
-  static Print * getVirtualLCDSerial(byte screen, byte row);
+  static Print* getVirtualLCDSerial(byte screen, byte row);
@@ -69,5 +71,6 @@ public :
-  static void setVirtualLCDSerial(Print * stream); 
-  private:
-    static Print * virtualLCDSerial;
-    static byte virtualLCDClient;
-    static byte rememberVLCDClient;
+  static void setVirtualLCDSerial(Print* stream);
+
+ private:
+  static Print* virtualLCDSerial;
+  static byte virtualLCDClient;
+  static byte rememberVLCDClient;
diff --git a/DCC.cpp b/DCC.cpp
index a5eafec..6bef63e 100644
--- a/DCC.cpp
+++ b/DCC.cpp
@@ -54,5 +54,5 @@
-const byte FN_GROUP_1=0x01;
-const byte FN_GROUP_2=0x02;
-const byte FN_GROUP_3=0x04;
-const byte FN_GROUP_4=0x08;
-const byte FN_GROUP_5=0x10;
+const byte FN_GROUP_1 = 0x01;
+const byte FN_GROUP_2 = 0x02;
+const byte FN_GROUP_3 = 0x04;
+const byte FN_GROUP_4 = 0x08;
+const byte FN_GROUP_5 = 0x10;
@@ -60,2 +60,2 @@ const byte FN_GROUP_5=0x10;
-FSH* DCC::shieldName=NULL;
-byte DCC::globalSpeedsteps=128;
+FSH* DCC::shieldName = NULL;
+byte DCC::globalSpeedsteps = 128;
@@ -64 +64 @@ void DCC::begin() {
-  StringFormatter::send(&USB_SERIAL,F("<iDCC-EX V-%S / %S / %S G-%S>\n"), F(VERSION), F(ARDUINO_TYPE), shieldName, F(GITHUB_SHA));
+  StringFormatter::send(&USB_SERIAL, F("<iDCC-EX V-%S / %S / %S G-%S>\n"), F(VERSION), F(ARDUINO_TYPE), shieldName, F(GITHUB_SHA));
@@ -67 +67 @@ void DCC::begin() {
-  (void)EEPROM; // tell compiler not to warn this is unused
+  (void)EEPROM;  // tell compiler not to warn this is unused
@@ -75,3 +75,2 @@ void DCC::begin() {
-
-void DCC::setThrottle( uint16_t cab, uint8_t tSpeed, bool tDirection)  {
-  byte speedCode = (tSpeed & 0x7F)  + tDirection * 128;
+void DCC::setThrottle(uint16_t cab, uint8_t tSpeed, bool tDirection) {
+  byte speedCode = (tSpeed & 0x7F) + tDirection * 128;
@@ -79 +78 @@ void DCC::setThrottle( uint16_t cab, uint8_t tSpeed, bool tDirection)  {
-  TrackManager::setDCSignal(cab,speedCode); // in case this is a dcc track on this addr
+  TrackManager::setDCSignal(cab, speedCode);  // in case this is a dcc track on this addr
@@ -81 +80 @@ void DCC::setThrottle( uint16_t cab, uint8_t tSpeed, bool tDirection)  {
-  updateLocoReminder(cab, speedCode );
+  updateLocoReminder(cab, speedCode);
@@ -84,2 +83 @@ void DCC::setThrottle( uint16_t cab, uint8_t tSpeed, bool tDirection)  {
-void DCC::setThrottle2( uint16_t cab, byte speedCode)  {
-
+void DCC::setThrottle2(uint16_t cab, byte speedCode) {
@@ -91 +89 @@ void DCC::setThrottle2( uint16_t cab, byte speedCode)  {
-    b[nB++] = highByte(cab) | 0xC0;    // convert train number into a two-byte address
+    b[nB++] = highByte(cab) | 0xC0;  // convert train number into a two-byte address
@@ -95 +92,0 @@ void DCC::setThrottle2( uint16_t cab, byte speedCode)  {
-
@@ -100 +97 @@ void DCC::setThrottle2( uint16_t cab, byte speedCode)  {
-    if (speed128 == 0 || speed128 == 1) { // stop or emergency stop
+    if (speed128 == 0 || speed128 == 1) {  // stop or emergency stop
@@ -103,7 +100,7 @@ void DCC::setThrottle2( uint16_t cab, byte speedCode)  {
-      speed28= (speed128*10+36)/46;                 // convert 2-127 to 1-28
-/*
-      if (globalSpeedsteps <= 14)                   // Don't want to do 14 steps, to get F0 there is ugly
-        code28 = (speed28+3)/2 | (Value of F0);     // convert 1-28 to DCC 14 step speed code
-      else
-*/
-      code28 = (speed28+3)/2 | ( (speed28 & 1) ? 0 : 0b00010000 ); // convert 1-28 to DCC 28 step speed code
+      speed28 = (speed128 * 10 + 36) / 46;                            // convert 2-127 to 1-28
+                                                                      /*
+                                                                            if (globalSpeedsteps <= 14)                   // Don't want to do 14 steps, to get F0 there is ugly
+                                                                              code28 = (speed28+3)/2 | (Value of F0);     // convert 1-28 to DCC 14 step speed code
+                                                                            else
+                                                                      */
+      code28 = (speed28 + 3) / 2 | ((speed28 & 1) ? 0 : 0b00010000);  // convert 1-28 to DCC 28 step speed code
@@ -115,4 +112 @@ void DCC::setThrottle2( uint16_t cab, byte speedCode)  {
-  } else { // 128 speedsteps
-
-    b[nB++] = SET_SPEED;                      // 128-step speed control byte
-    b[nB++] = speedCode; // for encoding see setThrottle
+  } else {  // 128 speedsteps
@@ -119,0 +114,2 @@ void DCC::setThrottle2( uint16_t cab, byte speedCode)  {
+    b[nB++] = SET_SPEED;  // 128-step speed control byte
+    b[nB++] = speedCode;  // for encoding see setThrottle
@@ -131 +127 @@ void DCC::setFunctionInternal(int cab, byte byte1, byte byte2, byte count) {
-    b[nB++] = highByte(cab) | 0xC0;    // convert train number into a two-byte address
+    b[nB++] = highByte(cab) | 0xC0;  // convert train number into a two-byte address
@@ -133 +129,2 @@ void DCC::setFunctionInternal(int cab, byte byte1, byte byte2, byte count) {
-  if (byte1!=0) b[nB++] = byte1;
+  if (byte1 != 0)
+    b[nB++] = byte1;
@@ -142,2 +139,3 @@ int8_t DCC::getThrottleSpeed(int cab) {
-  int reg=lookupSpeedTable(cab);
-  if (reg<0) return -1;
+  int reg = lookupSpeedTable(cab);
+  if (reg < 0)
+    return -1;
@@ -150,2 +148,2 @@ uint8_t DCC::getThrottleSpeedByte(int cab) {
-  int reg=lookupSpeedTable(cab);
-  if (reg<0)
+  int reg = lookupSpeedTable(cab);
+  if (reg < 0)
@@ -162,3 +160,3 @@ uint8_t DCC::getThrottleFrequency(int cab) {
-  int reg=lookupSpeedTable(cab);
-  if (reg<0)
-    return 0; // use default frequency
+  int reg = lookupSpeedTable(cab);
+  if (reg < 0)
+    return 0;  // use default frequency
@@ -166,2 +164,2 @@ uint8_t DCC::getThrottleFrequency(int cab) {
-  uint8_t res = (uint8_t)(speedTable[reg].functions >>29);
-  //DIAG(F("Speed table %d functions %l shifted %d"), reg, speedTable[reg].functions, res);
+  uint8_t res = (uint8_t)(speedTable[reg].functions >> 29);
+  // DIAG(F("Speed table %d functions %l shifted %d"), reg, speedTable[reg].functions, res);
@@ -175,3 +173,4 @@ bool DCC::getThrottleDirection(int cab) {
-  int reg=lookupSpeedTable(cab);
-  if (reg<0) return true;
-  return (speedTable[reg].speedCode & 0x80) !=0;
+  int reg = lookupSpeedTable(cab);
+  if (reg < 0)
+    return true;
+  return (speedTable[reg].speedCode & 0x80) != 0;
@@ -181,6 +180,8 @@ bool DCC::getThrottleDirection(int cab) {
-bool DCC::setFn( int cab, int16_t functionNumber, bool on) {
-  if (cab<=0 ) return false;
-  if (functionNumber < 0) return false;
-
-  if (functionNumber>28) {
-    //non reminding advanced binary bit set
+bool DCC::setFn(int cab, int16_t functionNumber, bool on) {
+  if (cab <= 0)
+    return false;
+  if (functionNumber < 0)
+    return false;
+
+  if (functionNumber > 28) {
+    // non reminding advanced binary bit set
@@ -190 +191 @@ bool DCC::setFn( int cab, int16_t functionNumber, bool on) {
-      b[nB++] = highByte(cab) | 0xC0;    // convert train number into a two-byte address
+      b[nB++] = highByte(cab) | 0xC0;  // convert train number into a two-byte address
@@ -193,7 +194,6 @@ bool DCC::setFn( int cab, int16_t functionNumber, bool on) {
-       b[nB++] = 0b11011101;   // Binary State Control Instruction short form
-       b[nB++] = functionNumber | (on ? 0x80 : 0);
-    }
-    else  {
-       b[nB++] = 0b11000000;   // Binary State Control Instruction long form
-       b[nB++] = (functionNumber & 0x7F) | (on ? 0x80 : 0);  // low order bits and state flag
-       b[nB++] = functionNumber >>7 ;  // high order bits
+      b[nB++] = 0b11011101;  // Binary State Control Instruction short form
+      b[nB++] = functionNumber | (on ? 0x80 : 0);
+    } else {
+      b[nB++] = 0b11000000;                                 // Binary State Control Instruction long form
+      b[nB++] = (functionNumber & 0x7F) | (on ? 0x80 : 0);  // low order bits and state flag
+      b[nB++] = functionNumber >> 7;                        // high order bits
@@ -209 +209 @@ bool DCC::setFn( int cab, int16_t functionNumber, bool on) {
-  
+
@@ -211 +211,2 @@ bool DCC::setFn( int cab, int16_t functionNumber, bool on) {
-  if (reg<0) return false;
+  if (reg < 0)
+    return false;
@@ -215,2 +216,2 @@ bool DCC::setFn( int cab, int16_t functionNumber, bool on) {
-  uint32_t previous=speedTable[reg].functions;
-  uint32_t funcmask = (1UL<<functionNumber);
+  uint32_t previous = speedTable[reg].functions;
+  uint32_t funcmask = (1UL << functionNumber);
@@ -218 +219 @@ bool DCC::setFn( int cab, int16_t functionNumber, bool on) {
-      speedTable[reg].functions |= funcmask;
+    speedTable[reg].functions |= funcmask;
@@ -220 +221 @@ bool DCC::setFn( int cab, int16_t functionNumber, bool on) {
-      speedTable[reg].functions &= ~funcmask;
+    speedTable[reg].functions &= ~funcmask;
@@ -231,4 +232,5 @@ bool DCC::setFn( int cab, int16_t functionNumber, bool on) {
-void DCC::changeFn( int cab, int16_t functionNumber) {
-  auto currentValue=getFn(cab,functionNumber);
-  if (currentValue<0) return;  // function not valid for change  
-  setFn(cab,functionNumber, currentValue?false:true);
+void DCC::changeFn(int cab, int16_t functionNumber) {
+  auto currentValue = getFn(cab, functionNumber);
+  if (currentValue < 0)
+    return;  // function not valid for change
+  setFn(cab, functionNumber, currentValue ? false : true);
@@ -239,2 +241,2 @@ void DCC::changeFn( int cab, int16_t functionNumber) {
-int8_t DCC::getFn( int cab, int16_t functionNumber) {
-  if (cab<=0 || functionNumber>31)
+int8_t DCC::getFn(int cab, int16_t functionNumber) {
+  if (cab <= 0 || functionNumber > 31)
@@ -243 +245 @@ int8_t DCC::getFn( int cab, int16_t functionNumber) {
-  if (reg<0)
+  if (reg < 0)
@@ -246,2 +248,2 @@ int8_t DCC::getFn( int cab, int16_t functionNumber) {
-  unsigned long funcmask = (1UL<<functionNumber);
-  return  (speedTable[reg].functions & funcmask)? 1 : 0;
+  unsigned long funcmask = (1UL << functionNumber);
+  return (speedTable[reg].functions & funcmask) ? 1 : 0;
@@ -252 +254 @@ int8_t DCC::getFn( int cab, int16_t functionNumber) {
-void DCC::updateGroupflags(byte & flags, int16_t functionNumber) {
+void DCC::updateGroupflags(byte& flags, int16_t functionNumber) {
@@ -254,5 +256,10 @@ void DCC::updateGroupflags(byte & flags, int16_t functionNumber) {
-  if (functionNumber<=4)       groupMask=FN_GROUP_1;
-  else if (functionNumber<=8)  groupMask=FN_GROUP_2;
-  else if (functionNumber<=12) groupMask=FN_GROUP_3;
-  else if (functionNumber<=20) groupMask=FN_GROUP_4;
-  else                         groupMask=FN_GROUP_5;
+  if (functionNumber <= 4)
+    groupMask = FN_GROUP_1;
+  else if (functionNumber <= 8)
+    groupMask = FN_GROUP_2;
+  else if (functionNumber <= 12)
+    groupMask = FN_GROUP_3;
+  else if (functionNumber <= 20)
+    groupMask = FN_GROUP_4;
+  else
+    groupMask = FN_GROUP_5;
@@ -263 +270,2 @@ uint32_t DCC::getFunctionMap(int cab) {
-  if (cab<=0) return 0;  // unknown pretend all functions off
+  if (cab <= 0)
+    return 0;  // unknown pretend all functions off
@@ -265 +273 @@ uint32_t DCC::getFunctionMap(int cab) {
-  return (reg<0)?0:speedTable[reg].functions;
+  return (reg < 0) ? 0 : speedTable[reg].functions;
@@ -269,10 +277,15 @@ uint32_t DCC::getFunctionMap(int cab) {
-void DCC::setDCFreq(int cab,byte freq) {
-  if (cab==0 || freq>3) return;
-  auto reg=lookupSpeedTable(cab,true);
-  // drop and replace F29,30,31 (top 3 bits) 
-  auto newFunctions=speedTable[reg].functions & 0x1FFFFFFFUL;
-  if (freq==1)      newFunctions |= (1UL<<29); // F29
-  else if (freq==2) newFunctions |= (1UL<<30); // F30
-  else if (freq==3) newFunctions |= (1UL<<31); // F31
-  if (newFunctions==speedTable[reg].functions) return; // no change 
-  speedTable[reg].functions=newFunctions;
+void DCC::setDCFreq(int cab, byte freq) {
+  if (cab == 0 || freq > 3)
+    return;
+  auto reg = lookupSpeedTable(cab, true);
+  // drop and replace F29,30,31 (top 3 bits)
+  auto newFunctions = speedTable[reg].functions & 0x1FFFFFFFUL;
+  if (freq == 1)
+    newFunctions |= (1UL << 29);  // F29
+  else if (freq == 2)
+    newFunctions |= (1UL << 30);  // F30
+  else if (freq == 3)
+    newFunctions |= (1UL << 31);  // F31
+  if (newFunctions == speedTable[reg].functions)
+    return;  // no change
+  speedTable[reg].functions = newFunctions;
@@ -283,9 +296,9 @@ void DCC::setAccessory(int address, byte port, bool gate, byte onoff /*= 2*/) {
-  // onoff is tristate:
-  // 0  => send off packet
-  // 1  => send on packet
-  // >1 => send both on and off packets.
-
-  // An accessory has an address, 4 ports and 2 gates (coils) each. That's how
-  // the initial decoders were orgnized and that influenced how the DCC
-  // standard was made.
-  #ifdef DIAG_IO
+// onoff is tristate:
+// 0  => send off packet
+// 1  => send on packet
+// >1 => send both on and off packets.
+
+// An accessory has an address, 4 ports and 2 gates (coils) each. That's how
+// the initial decoders were orgnized and that influenced how the DCC
+// standard was made.
+#ifdef DIAG_IO
@@ -293 +306 @@ void DCC::setAccessory(int address, byte port, bool gate, byte onoff /*= 2*/) {
-  #endif
+#endif
@@ -295 +308 @@ void DCC::setAccessory(int address, byte port, bool gate, byte onoff /*= 2*/) {
-  if(address != (address & 511))
+  if (address != (address & 511))
@@ -297 +310 @@ void DCC::setAccessory(int address, byte port, bool gate, byte onoff /*= 2*/) {
-  if(port != (port & 3))
+  if (port != (port & 3))
@@ -306 +319 @@ void DCC::setAccessory(int address, byte port, bool gate, byte onoff /*= 2*/) {
-    DCCWaveform::mainTrack.schedulePacket(b, 2, 3);      // Repeat on packet three times
+    DCCWaveform::mainTrack.schedulePacket(b, 2, 3);  // Repeat on packet three times
@@ -308 +321 @@ void DCC::setAccessory(int address, byte port, bool gate, byte onoff /*= 2*/) {
-    RMFT2::activateEvent(address<<2|port,gate);
+    RMFT2::activateEvent(address << 2 | port, gate);
@@ -312,2 +325,2 @@ void DCC::setAccessory(int address, byte port, bool gate, byte onoff /*= 2*/) {
-    b[1] &= ~0x08; // set C to 0
-    DCCWaveform::mainTrack.schedulePacket(b, 2, 3);      // Repeat off packet three times
+    b[1] &= ~0x08;                                   // set C to 0
+    DCCWaveform::mainTrack.schedulePacket(b, 2, 3);  // Repeat off packet three times
@@ -317,0 +331 @@ bool DCC::setExtendedAccessory(int16_t address, int16_t value, byte repeats) {
+  /* From https://www.nmra.org/sites/default/files/s-9.2.1_2012_07.pdf
@@ -319 +333,3 @@ bool DCC::setExtendedAccessory(int16_t address, int16_t value, byte repeats) {
-/* From https://www.nmra.org/sites/default/files/s-9.2.1_2012_07.pdf
+  The Extended Accessory Decoder Control Packet is included for the purpose of transmitting aspect control to signal
+  decoders or data bytes to more complex accessory decoders. Each signal head can display one aspect at a time.
+  {preamble} 0 10AAAAAA 0 0AAA0AA1 0 000XXXXX 0 EEEEEEEE 1
@@ -321,3 +337,3 @@ bool DCC::setExtendedAccessory(int16_t address, int16_t value, byte repeats) {
-The Extended Accessory Decoder Control Packet is included for the purpose of transmitting aspect control to signal 
-decoders or data bytes to more complex accessory decoders. Each signal head can display one aspect at a time. 
-{preamble} 0 10AAAAAA 0 0AAA0AA1 0 000XXXXX 0 EEEEEEEE 1
+  XXXXX is for a single head. A value of 00000 for XXXXX indicates the absolute stop aspect. All other aspects
+  represented by the values for XXXXX are determined by the signaling system used and the prototype being
+  modeled.
@@ -325,3 +341 @@ decoders or data bytes to more complex accessory decoders. Each signal head can
-XXXXX is for a single head. A value of 00000 for XXXXX indicates the absolute stop aspect. All other aspects 
-represented by the values for XXXXX are determined by the signaling system used and the prototype being 
-modeled.
+  From https://normen.railcommunity.de/RCN-213.pdf:
@@ -329 +343,2 @@ modeled.
-From https://normen.railcommunity.de/RCN-213.pdf:
+  More information is in RCN-213 about how the address bits are organized.
+  preamble -0- 1 0 A7 A6 A5 A4 A3 A2 -0- 0 ^A10 ^A9 ^A8 0 A1 A0 1 -0- ....
@@ -331,2 +346 @@ From https://normen.railcommunity.de/RCN-213.pdf:
-More information is in RCN-213 about how the address bits are organized.
-preamble -0- 1 0 A7 A6 A5 A4 A3 A2 -0- 0 ^A10 ^A9 ^A8 0 A1 A0 1 -0- ....
+  Thus in byte packet form the format is 10AAAAAA, 0AAA0AA1, 000XXXXX
@@ -334 +348,3 @@ preamble -0- 1 0 A7 A6 A5 A4 A3 A2 -0- 0 ^A10 ^A9 ^A8 0 A1 A0 1 -0- ....
-Thus in byte packet form the format is 10AAAAAA, 0AAA0AA1, 000XXXXX
+  Die Adresse fï¿½r den ersten erweiterten Zubehï¿½rdecoder ist wie bei den einfachen
+  Zubehï¿½rdecodern die Adresse 4 = 1000-0001 0111-0001 . Diese Adresse wird in
+  Anwenderdialogen als Adresse 1 dargestellt.
@@ -336,3 +352,2 @@ Thus in byte packet form the format is 10AAAAAA, 0AAA0AA1, 000XXXXX
-Die Adresse fï¿½r den ersten erweiterten Zubehï¿½rdecoder ist wie bei den einfachen
-Zubehï¿½rdecodern die Adresse 4 = 1000-0001 0111-0001 . Diese Adresse wird in
-Anwenderdialogen als Adresse 1 dargestellt.
+  This means that the first address shown to the user as "1" is mapped
+  to internal address 4.
@@ -340,2 +355,6 @@ Anwenderdialogen als Adresse 1 dargestellt.
-This means that the first address shown to the user as "1" is mapped
-to internal address 4.
+  Note that the Basic accessory format mentions "By convention these
+  bits (bits 4-6 of the second data byte) are in ones complement" but
+  this note is absent from the advanced packet description. The
+  english translation does not mention that the address format for
+  the advanced packet follows the one for the basic packet but
+  according to the RCN-213 this is the case.
@@ -343,6 +362,7 @@ to internal address 4.
-Note that the Basic accessory format mentions "By convention these
-bits (bits 4-6 of the second data byte) are in ones complement" but
-this note is absent from the advanced packet description. The
-english translation does not mention that the address format for
-the advanced packet follows the one for the basic packet but
-according to the RCN-213 this is the case.
+  We allow for addresses from -3 to 2047-3 as that allows to address the
+  whole range of the 11 bits sent to track.
+  */
+  if ((address > 2044) || (address < -3))
+    return false;  // 2047-3, 11 bits but offset 3
+  if (value != (value & 0x1F))
+    return false;  // 5 bits
@@ -350,7 +370 @@ according to the RCN-213 this is the case.
-We allow for addresses from -3 to 2047-3 as that allows to address the
-whole range of the 11 bits sent to track.
-*/
-  if ((address > 2044) || (address < -3)) return false; // 2047-3, 11 bits but offset 3
-  if (value != (value & 0x1F)) return false;            // 5 bits
-
-  address+=3;                        // +3 offset according to RCN-213
+  address += 3;  // +3 offset according to RCN-213
@@ -358,6 +372,6 @@ whole range of the 11 bits sent to track.
-  b[0]= 0x80                         // bits always on
-    | ((address>>2) & 0x3F);         // shift out 2, mask out used bits
-  b[1]= 0x01                         // bits always on
-    | (((~(address>>8)) & 0x07)<<4)  // shift out 8, invert, mask 3 bits, shift up 4
-    | ((address & 0x03)<<1);         // mask 2 bits, shift up 1
-  b[2]=value;
+  b[0] = 0x80                                 // bits always on
+         | ((address >> 2) & 0x3F);           // shift out 2, mask out used bits
+  b[1] = 0x01                                 // bits always on
+         | (((~(address >> 8)) & 0x07) << 4)  // shift out 8, invert, mask 3 bits, shift up 4
+         | ((address & 0x03) << 1);           // mask 2 bits, shift up 1
+  b[2] = value;
@@ -372 +386 @@ whole range of the 11 bits sent to track.
-void DCC::writeCVByteMain(int cab, int cv, byte bValue)  {
+void DCC::writeCVByteMain(int cab, int cv, byte bValue) {
@@ -376 +390 @@ void DCC::writeCVByteMain(int cab, int cv, byte bValue)  {
-    b[nB++] = highByte(cab) | 0xC0;    // convert train number into a two-byte address
+    b[nB++] = highByte(cab) | 0xC0;  // convert train number into a two-byte address
@@ -379 +393 @@ void DCC::writeCVByteMain(int cab, int cv, byte bValue)  {
-  b[nB++] = cv1(WRITE_BYTE_MAIN, cv); // any CV>1023 will become modulus(1024) due to bit-mask of 0x03
+  b[nB++] = cv1(WRITE_BYTE_MAIN, cv);  // any CV>1023 will become modulus(1024) due to bit-mask of 0x03
@@ -390 +404 @@ void DCC::writeCVByteMain(int cab, int cv, byte bValue)  {
-void DCC::writeCVBitMain(int cab, int cv, byte bNum, bool bValue)  {
+void DCC::writeCVBitMain(int cab, int cv, byte bNum, bool bValue) {
@@ -397 +411 @@ void DCC::writeCVBitMain(int cab, int cv, byte bNum, bool bValue)  {
-    b[nB++] = highByte(cab) | 0xC0;    // convert train number into a two-byte address
+    b[nB++] = highByte(cab) | 0xC0;  // convert train number into a two-byte address
@@ -400 +414 @@ void DCC::writeCVBitMain(int cab, int cv, byte bNum, bool bValue)  {
-  b[nB++] = cv1(WRITE_BIT_MAIN, cv); // any CV>1023 will become modulus(1024) due to bit-mask of 0x03
+  b[nB++] = cv1(WRITE_BIT_MAIN, cv);  // any CV>1023 will become modulus(1024) due to bit-mask of 0x03
@@ -412,5 +426,3 @@ const ackOp FLASH WRITE_BIT0_PROG[] = {
-     BASELINE,
-     W0,WACK,
-     V0, WACK,  // validate bit is 0
-     ITC1,      // if acked, callback(1)
-     CALLFAIL  // callback (-1)
+    BASELINE, W0, WACK, V0, WACK,  // validate bit is 0
+    ITC1,                          // if acked, callback(1)
+    CALLFAIL                       // callback (-1)
@@ -419,5 +431,3 @@ const ackOp FLASH WRITE_BIT1_PROG[] = {
-     BASELINE,
-     W1,WACK,
-     V1, WACK,  // validate bit is 1
-     ITC1,      // if acked, callback(1)
-     CALLFAIL  // callback (-1)
+    BASELINE, W1, WACK, V1, WACK,  // validate bit is 1
+    ITC1,                          // if acked, callback(1)
+    CALLFAIL                       // callback (-1)
@@ -427,6 +437,5 @@ const ackOp FLASH VERIFY_BIT0_PROG[] = {
-     BASELINE,
-     V0, WACK,  // validate bit is 0
-     ITC0,      // if acked, callback(0)
-     V1, WACK,  // validate bit is 1
-     ITC1,
-     CALLFAIL  // callback (-1)
+    BASELINE, V0,   WACK,  // validate bit is 0
+    ITC0,                  // if acked, callback(0)
+    V1,       WACK,        // validate bit is 1
+    ITC1,
+    CALLFAIL  // callback (-1)
@@ -435,6 +444,4 @@ const ackOp FLASH VERIFY_BIT1_PROG[] = {
-     BASELINE,
-     V1, WACK,  // validate bit is 1
-     ITC1,      // if acked, callback(1)
-     V0, WACK,
-     ITC0,
-     CALLFAIL  // callback (-1)
+    BASELINE, V1,   WACK,  // validate bit is 1
+    ITC1,                  // if acked, callback(1)
+    V0,       WACK, ITC0,
+    CALLFAIL  // callback (-1)
@@ -444,180 +451,5 @@ const ackOp FLASH READ_BIT_PROG[] = {
-     BASELINE,
-     V1, WACK,  // validate bit is 1
-     ITC1,      // if acked, callback(1)
-     V0, WACK,  // validate bit is zero
-     ITC0,      // if acked callback 0
-     CALLFAIL       // bit not readable
-     };
-
-const ackOp FLASH WRITE_BYTE_PROG[] = {
-      BASELINE,
-      WB,WACK,ITC1,    // Write and callback(1) if ACK
-      // handle decoders that dont ack a write
-      VB,WACK,ITC1,    // validate byte and callback(1) if correct
-      CALLFAIL        // callback (-1)
-      };
-
-const ackOp FLASH VERIFY_BYTE_PROG[] = {
-      BASELINE,
-      BIV,         // ackManagerByte initial value
-      VB,WACK,     // validate byte
-      ITCB,       // if ok callback value	
-      STARTMERGE,    //clear bit and byte values ready for merge pass
-      // each bit is validated against 0 and the result inverted in MERGE
-      // this is because there tend to be more zeros in cv values than ones.
-      // There is no need for one validation as entire byte is validated at the end
-      V0, WACK, MERGE,        // read and merge first tested bit (7)
-      ITSKIP,                 // do small excursion if there was no ack
-        SETBIT,(ackOp)7,
-        V1, WACK, NAKFAIL,    // test if there is an ack on the inverse of this bit (7)
-        SETBIT,(ackOp)6,      // and abort whole test if not else continue with bit (6)
-      SKIPTARGET,
-      V0, WACK, MERGE,        // read and merge second tested bit (6)
-      V0, WACK, MERGE,        // read and merge third  tested bit (5) ...
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      VB, WACK, ITCBV,  // verify merged byte and return it if acked ok - with retry report
-      CALLFAIL };
-
-
-const ackOp FLASH READ_CV_PROG[] = {
-      BASELINE,
-      STARTMERGE,    //clear bit and byte values ready for merge pass
-      // each bit is validated against 0 and the result inverted in MERGE
-      // this is because there tend to be more zeros in cv values than ones.
-      // There is no need for one validation as entire byte is validated at the end
-      V0, WACK, MERGE,        // read and merge first tested bit (7)
-      ITSKIP,                 // do small excursion if there was no ack
-        SETBIT,(ackOp)7,
-        V1, WACK, NAKFAIL,    // test if there is an ack on the inverse of this bit (7)
-        SETBIT,(ackOp)6,      // and abort whole test if not else continue with bit (6)
-      SKIPTARGET,
-      V0, WACK, MERGE,        // read and merge second tested bit (6)
-      V0, WACK, MERGE,        // read and merge third  tested bit (5) ...
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      VB, WACK, ITCB,  // verify merged byte and return it if acked ok
-      CALLFAIL };          // verification failed
-
-
-const ackOp FLASH LOCO_ID_PROG[] = {
-      BASELINE,
-      // first check cv20 for extended addressing
-      SETCV, (ackOp)20,     // CV 19 is extended
-      SETBYTE, (ackOp)0,
-      VB, WACK, ITSKIP,     // skip past extended section if cv20 is zero
-      // read cv20 and 19 and merge 
-      STARTMERGE,           // Setup to read cv 20
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      VB, WACK, NAKSKIP, // bad read of cv20, assume its 0 
-      STASHLOCOID,   // keep cv 20 until we have cv19 as well.
-      SETCV, (ackOp)19, 
-      STARTMERGE,           // Setup to read cv 19
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      VB, WACK, NAKFAIL,  // cant recover if cv 19 unreadable
-      COMBINE1920,  // Combile byte with stash and callback
-// end of advanced 20,19 check
-      SKIPTARGET,
-      SETCV, (ackOp)19,     // CV 19 is consist setting
-      SETBYTE, (ackOp)0,
-      VB, WACK, ITSKIP,     // ignore consist if cv19 is zero (no consist)
-      SETBYTE, (ackOp)128,
-      VB, WACK, ITSKIP,     // ignore consist if cv19 is 128 (no consist, direction bit set)
-      STARTMERGE,           // Setup to read cv 19
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      VB, WACK, ITCB7,  // return 7 bits only, No_ACK means CV19 not supported so ignore it
-
-      SKIPTARGET,     // continue here if CV 19 is zero or fails all validation
-      SETCV,(ackOp)29,
-      SETBIT,(ackOp)5,
-      V0, WACK, ITSKIP,  // Skip to SKIPTARGET if bit 5 of CV29 is zero
-
-      // Long locoid
-      SETCV, (ackOp)17,       // CV 17 is part of locoid
-      STARTMERGE,
-      V0, WACK, MERGE,  // read and merge bit 1 etc
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      VB, WACK, NAKFAIL,  // verify merged byte and return -1 it if not acked ok
-      STASHLOCOID,         // keep stashed cv 17 for later
-      // Read 2nd part from CV 18
-      SETCV, (ackOp)18,
-      STARTMERGE,
-      V0, WACK, MERGE,  // read and merge bit 1 etc
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      VB, WACK, NAKFAIL,  // verify merged byte and return -1 it if not acked ok
-      COMBINELOCOID,        // Combile byte with stash to make long locoid and callback
-
-      // ITSKIP Skips to here if CV 29 bit 5 was zero. so read CV 1 and return that
-      SKIPTARGET,
-      SETCV, (ackOp)1,
-      STARTMERGE,
-      SETBIT, (ackOp)6,  // skip over first bit as we know its a zero
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      V0, WACK, MERGE,
-      VB, WACK, ITCB,  // verify merged byte and callback
-      CALLFAIL
-      };
-
-const ackOp FLASH SHORT_LOCO_ID_PROG[] = {
-      BASELINE,
-      // Clear consist CV 19,20
-      SETCV,(ackOp)20,
-      SETBYTE, (ackOp)0,
-      WB,WACK,     // ignore dedcoder without cv20 support
-      SETCV,(ackOp)19,
-      SETBYTE, (ackOp)0,
-      WB,WACK,     // ignore dedcoder without cv19 support
-      // Turn off long address flag
-      SETCV,(ackOp)29,
-      SETBIT,(ackOp)5,
-      W0,WACK,
-      V0,WACK,NAKFAIL,
-      SETCV, (ackOp)1,
-      SETBYTEL,   // low byte of word
-      WB,WACK,ITC1,   // If ACK, we are done - callback(1) means Ok
-      VB,WACK,ITC1,   // Some decoders do not ack and need verify
-      CALLFAIL
+    BASELINE, V1,   WACK,  // validate bit is 1
+    ITC1,                  // if acked, callback(1)
+    V0,       WACK,        // validate bit is zero
+    ITC0,                  // if acked callback 0
+    CALLFAIL               // bit not readable
@@ -626,11 +458,5 @@ const ackOp FLASH SHORT_LOCO_ID_PROG[] = {
-// for CONSIST_ID_PROG the 20,19 values are already calculated
-const ackOp FLASH CONSIST_ID_PROG[] = {
-      BASELINE,
-      SETCV,(ackOp)20,
-      SETBYTEH,    // high byte to CV 20
-      WB,WACK,     // ignore dedcoder without cv20 support
-      SETCV,(ackOp)19,
-      SETBYTEL,   // low byte of word
-      WB,WACK,ITC1,   // If ACK, we are done - callback(1) means Ok
-      VB,WACK,ITC1,   // Some decoders do not ack and need verify
-      CALLFAIL
+const ackOp FLASH WRITE_BYTE_PROG[] = {
+    BASELINE, WB, WACK, ITC1,  // Write and callback(1) if ACK
+    // handle decoders that dont ack a write
+    VB, WACK, ITC1,  // validate byte and callback(1) if correct
+    CALLFAIL         // callback (-1)
@@ -639,30 +465,86 @@ const ackOp FLASH CONSIST_ID_PROG[] = {
-const ackOp FLASH LONG_LOCO_ID_PROG[] = {
-      BASELINE,
-      // Clear consist CV 19,20
-      SETCV,(ackOp)20,
-      SETBYTE, (ackOp)0,
-      WB,WACK,     // ignore dedcoder without cv20 support
-      SETCV,(ackOp)19,
-      SETBYTE, (ackOp)0,
-      WB,WACK,     // ignore decoder without cv19 support
-      // Turn on long address flag cv29 bit 5
-      SETCV,(ackOp)29,
-      SETBIT,(ackOp)5,
-      W1,WACK,
-      V1,WACK,NAKFAIL,
-      // Store high byte of address in cv 17
-      SETCV, (ackOp)17,
-      SETBYTEH, // high byte of word
-      WB,WACK,      // do write
-      ITSKIP,       // if ACK, jump to SKIPTARGET
-        VB,WACK,    // try verify instead
-        ITSKIP,     // if ACK, jump to SKIPTARGET
-          CALLFAIL, // if still here, fail
-      SKIPTARGET,
-      // store
-      SETCV, (ackOp)18,
-      SETBYTEL,   // low byte of word
-      WB,WACK,ITC1,   // If ACK, we are done - callback(1) means Ok
-      VB,WACK,ITC1,   // Some decoders do not ack and need verify
-      CALLFAIL
-};
+const ackOp FLASH VERIFY_BYTE_PROG[] = {BASELINE,
+                                        BIV,         // ackManagerByte initial value
+                                        VB, WACK,    // validate byte
+                                        ITCB,        // if ok callback value
+                                        STARTMERGE,  // clear bit and byte values ready for merge pass
+                                        // each bit is validated against 0 and the result inverted in MERGE
+                                        // this is because there tend to be more zeros in cv values than ones.
+                                        // There is no need for one validation as entire byte is validated at the end
+                                        V0, WACK, MERGE,                      // read and merge first tested bit (7)
+                                        ITSKIP,                               // do small excursion if there was no ack
+                                        SETBIT, (ackOp)7, V1, WACK, NAKFAIL,  // test if there is an ack on the inverse of this bit (7)
+                                        SETBIT, (ackOp)6,                     // and abort whole test if not else continue with bit (6)
+                                        SKIPTARGET, V0, WACK, MERGE,          // read and merge second tested bit (6)
+                                        V0, WACK, MERGE,                      // read and merge third  tested bit (5) ...
+                                        V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, VB, WACK,
+                                        ITCBV,  // verify merged byte and return it if acked ok - with retry report
+                                        CALLFAIL};
+
+const ackOp FLASH READ_CV_PROG[] = {BASELINE,
+                                    STARTMERGE,  // clear bit and byte values ready for merge pass
+                                    // each bit is validated against 0 and the result inverted in MERGE
+                                    // this is because there tend to be more zeros in cv values than ones.
+                                    // There is no need for one validation as entire byte is validated at the end
+                                    V0, WACK, MERGE,                      // read and merge first tested bit (7)
+                                    ITSKIP,                               // do small excursion if there was no ack
+                                    SETBIT, (ackOp)7, V1, WACK, NAKFAIL,  // test if there is an ack on the inverse of this bit (7)
+                                    SETBIT, (ackOp)6,                     // and abort whole test if not else continue with bit (6)
+                                    SKIPTARGET, V0, WACK, MERGE,          // read and merge second tested bit (6)
+                                    V0, WACK, MERGE,                      // read and merge third  tested bit (5) ...
+                                    V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, VB, WACK,
+                                    ITCB,       // verify merged byte and return it if acked ok
+                                    CALLFAIL};  // verification failed
+
+const ackOp FLASH LOCO_ID_PROG[] = {BASELINE,
+                                    // first check cv20 for extended addressing
+                                    SETCV, (ackOp)20,                     // CV 19 is extended
+                                    SETBYTE, (ackOp)0, VB, WACK, ITSKIP,  // skip past extended section if cv20 is zero
+                                    // read cv20 and 19 and merge
+                                    STARTMERGE,  // Setup to read cv 20
+                                    V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK,
+                                    MERGE, V0, WACK, MERGE, VB, WACK, NAKSKIP,  // bad read of cv20, assume its 0
+                                    STASHLOCOID,                                // keep cv 20 until we have cv19 as well.
+                                    SETCV, (ackOp)19,
+                                    STARTMERGE,  // Setup to read cv 19
+                                    V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK,
+                                    MERGE, V0, WACK, MERGE, VB, WACK, NAKFAIL,  // cant recover if cv 19 unreadable
+                                    COMBINE1920,                                // Combile byte with stash and callback
+                                                                                // end of advanced 20,19 check
+                                    SKIPTARGET, SETCV, (ackOp)19,               // CV 19 is consist setting
+                                    SETBYTE, (ackOp)0, VB, WACK, ITSKIP,        // ignore consist if cv19 is zero (no consist)
+                                    SETBYTE, (ackOp)128, VB, WACK, ITSKIP,      // ignore consist if cv19 is 128 (no consist, direction bit set)
+                                    STARTMERGE,                                 // Setup to read cv 19
+                                    V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK,
+                                    MERGE, V0, WACK, MERGE, VB, WACK, ITCB7,  // return 7 bits only, No_ACK means CV19 not supported so ignore it
+
+                                    SKIPTARGET,                                            // continue here if CV 19 is zero or fails all validation
+                                    SETCV, (ackOp)29, SETBIT, (ackOp)5, V0, WACK, ITSKIP,  // Skip to SKIPTARGET if bit 5 of CV29 is zero
+
+                                    // Long locoid
+                                    SETCV, (ackOp)17,             // CV 17 is part of locoid
+                                    STARTMERGE, V0, WACK, MERGE,  // read and merge bit 1 etc
+                                    V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK,
+                                    MERGE, VB, WACK, NAKFAIL,  // verify merged byte and return -1 it if not acked ok
+                                    STASHLOCOID,               // keep stashed cv 17 for later
+                                    // Read 2nd part from CV 18
+                                    SETCV, (ackOp)18, STARTMERGE, V0, WACK, MERGE,  // read and merge bit 1 etc
+                                    V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK,
+                                    MERGE, VB, WACK, NAKFAIL,  // verify merged byte and return -1 it if not acked ok
+                                    COMBINELOCOID,             // Combile byte with stash to make long locoid and callback
+
+                                    // ITSKIP Skips to here if CV 29 bit 5 was zero. so read CV 1 and return that
+                                    SKIPTARGET, SETCV, (ackOp)1, STARTMERGE, SETBIT, (ackOp)6,  // skip over first bit as we know its a zero
+                                    V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK, MERGE, V0, WACK,
+                                    MERGE, VB, WACK, ITCB,  // verify merged byte and callback
+                                    CALLFAIL};
+
+const ackOp FLASH SHORT_LOCO_ID_PROG[] = {BASELINE,
+                                          // Clear consist CV 19,20
+                                          SETCV, (ackOp)20, SETBYTE, (ackOp)0, WB, WACK,  // ignore dedcoder without cv20 support
+                                          SETCV, (ackOp)19, SETBYTE, (ackOp)0, WB, WACK,  // ignore dedcoder without cv19 support
+                                          // Turn off long address flag
+                                          SETCV, (ackOp)29, SETBIT, (ackOp)5, W0, WACK, V0, WACK, NAKFAIL, SETCV, (ackOp)1,
+                                          SETBYTEL,        // low byte of word
+                                          WB, WACK, ITC1,  // If ACK, we are done - callback(1) means Ok
+                                          VB, WACK, ITC1,  // Some decoders do not ack and need verify
+                                          CALLFAIL};
@@ -670,7 +552,41 @@ const ackOp FLASH LONG_LOCO_ID_PROG[] = {
-void  DCC::writeCVByte(int16_t cv, byte byteValue, ACK_CALLBACK callback)  {
-  DCCACK::Setup(cv, byteValue,  WRITE_BYTE_PROG, callback);
-}
-
-void DCC::writeCVBit(int16_t cv, byte bitNum, bool bitValue, ACK_CALLBACK callback)  {
-  if (bitNum >= 8) callback(-1);
-  else DCCACK::Setup(cv, bitNum, bitValue?WRITE_BIT1_PROG:WRITE_BIT0_PROG, callback);
+// for CONSIST_ID_PROG the 20,19 values are already calculated
+const ackOp FLASH CONSIST_ID_PROG[] = {BASELINE, SETCV,     (ackOp)20,
+                                       SETBYTEH,        // high byte to CV 20
+                                       WB,       WACK,  // ignore dedcoder without cv20 support
+                                       SETCV,    (ackOp)19,
+                                       SETBYTEL,                   // low byte of word
+                                       WB,       WACK,      ITC1,  // If ACK, we are done - callback(1) means Ok
+                                       VB,       WACK,      ITC1,  // Some decoders do not ack and need verify
+                                       CALLFAIL};
+
+const ackOp FLASH LONG_LOCO_ID_PROG[] = {BASELINE,
+                                         // Clear consist CV 19,20
+                                         SETCV, (ackOp)20, SETBYTE, (ackOp)0, WB, WACK,  // ignore dedcoder without cv20 support
+                                         SETCV, (ackOp)19, SETBYTE, (ackOp)0, WB, WACK,  // ignore decoder without cv19 support
+                                         // Turn on long address flag cv29 bit 5
+                                         SETCV, (ackOp)29, SETBIT, (ackOp)5, W1, WACK, V1, WACK, NAKFAIL,
+                                         // Store high byte of address in cv 17
+                                         SETCV, (ackOp)17,
+                                         SETBYTEH,  // high byte of word
+                                         WB, WACK,  // do write
+                                         ITSKIP,    // if ACK, jump to SKIPTARGET
+                                         VB, WACK,  // try verify instead
+                                         ITSKIP,    // if ACK, jump to SKIPTARGET
+                                         CALLFAIL,  // if still here, fail
+                                         SKIPTARGET,
+                                         // store
+                                         SETCV, (ackOp)18,
+                                         SETBYTEL,        // low byte of word
+                                         WB, WACK, ITC1,  // If ACK, we are done - callback(1) means Ok
+                                         VB, WACK, ITC1,  // Some decoders do not ack and need verify
+                                         CALLFAIL};
+
+void DCC::writeCVByte(int16_t cv, byte byteValue, ACK_CALLBACK callback) {
+  DCCACK::Setup(cv, byteValue, WRITE_BYTE_PROG, callback);
+}
+
+void DCC::writeCVBit(int16_t cv, byte bitNum, bool bitValue, ACK_CALLBACK callback) {
+  if (bitNum >= 8)
+    callback(-1);
+  else
+    DCCACK::Setup(cv, bitNum, bitValue ? WRITE_BIT1_PROG : WRITE_BIT0_PROG, callback);
@@ -679,2 +595,2 @@ void DCC::writeCVBit(int16_t cv, byte bitNum, bool bitValue, ACK_CALLBACK callba
-void  DCC::verifyCVByte(int16_t cv, byte byteValue, ACK_CALLBACK callback)  {
-  DCCACK::Setup(cv, byteValue,  VERIFY_BYTE_PROG, callback);
+void DCC::verifyCVByte(int16_t cv, byte byteValue, ACK_CALLBACK callback) {
+  DCCACK::Setup(cv, byteValue, VERIFY_BYTE_PROG, callback);
@@ -683,3 +599,5 @@ void  DCC::verifyCVByte(int16_t cv, byte byteValue, ACK_CALLBACK callback)  {
-void DCC::verifyCVBit(int16_t cv, byte bitNum, bool bitValue, ACK_CALLBACK callback)  {
-  if (bitNum >= 8) callback(-1);
-  else DCCACK::Setup(cv, bitNum, bitValue?VERIFY_BIT1_PROG:VERIFY_BIT0_PROG, callback);
+void DCC::verifyCVBit(int16_t cv, byte bitNum, bool bitValue, ACK_CALLBACK callback) {
+  if (bitNum >= 8)
+    callback(-1);
+  else
+    DCCACK::Setup(cv, bitNum, bitValue ? VERIFY_BIT1_PROG : VERIFY_BIT0_PROG, callback);
@@ -688,4 +606,5 @@ void DCC::verifyCVBit(int16_t cv, byte bitNum, bool bitValue, ACK_CALLBACK callb
-
-void DCC::readCVBit(int16_t cv, byte bitNum, ACK_CALLBACK callback)  {
-  if (bitNum >= 8) callback(-1);
-  else DCCACK::Setup(cv, bitNum,READ_BIT_PROG, callback);
+void DCC::readCVBit(int16_t cv, byte bitNum, ACK_CALLBACK callback) {
+  if (bitNum >= 8)
+    callback(-1);
+  else
+    DCCACK::Setup(cv, bitNum, READ_BIT_PROG, callback);
@@ -694,2 +613,2 @@ void DCC::readCVBit(int16_t cv, byte bitNum, ACK_CALLBACK callback)  {
-void DCC::readCV(int16_t cv, ACK_CALLBACK callback)  {
-  DCCACK::Setup(cv, 0,READ_CV_PROG, callback);
+void DCC::readCV(int16_t cv, ACK_CALLBACK callback) {
+  DCCACK::Setup(cv, 0, READ_CV_PROG, callback);
@@ -699 +618 @@ void DCC::getLocoId(ACK_CALLBACK callback) {
-  DCCACK::Setup(0,0, LOCO_ID_PROG, callback);
+  DCCACK::Setup(0, 0, LOCO_ID_PROG, callback);
@@ -702,2 +621,2 @@ void DCC::getLocoId(ACK_CALLBACK callback) {
-void DCC::setLocoId(int id,ACK_CALLBACK callback) {
-  if (id<1 || id>10239) { //0x27FF according to standard
+void DCC::setLocoId(int id, ACK_CALLBACK callback) {
+  if (id < 1 || id > 10239) {  // 0x27FF according to standard
@@ -707,2 +626,2 @@ void DCC::setLocoId(int id,ACK_CALLBACK callback) {
-  if (id<=HIGHEST_SHORT_ADDR)
-      DCCACK::Setup(id, SHORT_LOCO_ID_PROG, callback);
+  if (id <= HIGHEST_SHORT_ADDR)
+    DCCACK::Setup(id, SHORT_LOCO_ID_PROG, callback);
@@ -710 +629 @@ void DCC::setLocoId(int id,ACK_CALLBACK callback) {
-      DCCACK::Setup(id | 0xc000,LONG_LOCO_ID_PROG, callback);
+    DCCACK::Setup(id | 0xc000, LONG_LOCO_ID_PROG, callback);
@@ -713,2 +632,2 @@ void DCC::setLocoId(int id,ACK_CALLBACK callback) {
-void DCC::setConsistId(int id,bool reverse,ACK_CALLBACK callback) {
-  if (id<0 || id>10239) { //0x27FF according to standard
+void DCC::setConsistId(int id, bool reverse, ACK_CALLBACK callback) {
+  if (id < 0 || id > 10239) {  // 0x27FF according to standard
@@ -721,7 +640,6 @@ void DCC::setConsistId(int id,bool reverse,ACK_CALLBACK callback) {
-  if (id<=HIGHEST_SHORT_ADDR) {
-    cv19=id;
-    cv20=0;
-  }
-  else {
-    cv20=id/100;
-    cv19=id%100;
+  if (id <= HIGHEST_SHORT_ADDR) {
+    cv19 = id;
+    cv20 = 0;
+  } else {
+    cv20 = id / 100;
+    cv19 = id % 100;
@@ -729,2 +647,3 @@ void DCC::setConsistId(int id,bool reverse,ACK_CALLBACK callback) {
-  if (reverse) cv19|=0x80;
-  DCCACK::Setup((cv20<<8)|cv19, CONSIST_ID_PROG, callback);
+  if (reverse)
+    cv19 |= 0x80;
+  DCCACK::Setup((cv20 << 8) | cv19, CONSIST_ID_PROG, callback);
@@ -734,5 +653,5 @@ void DCC::forgetLoco(int cab) {  // removes any speed reminders for this loco
-  setThrottle2(cab,1); // ESTOP this loco if still on track
-  int reg=lookupSpeedTable(cab, false);
-  if (reg>=0) {
-    speedTable[reg].loco=0;
-    setThrottle2(cab,1); // ESTOP if this loco still on track
+  setThrottle2(cab, 1);          // ESTOP this loco if still on track
+  int reg = lookupSpeedTable(cab, false);
+  if (reg >= 0) {
+    speedTable[reg].loco = 0;
+    setThrottle2(cab, 1);  // ESTOP if this loco still on track
@@ -743,4 +662,5 @@ void DCC::forgetAllLocos() {  // removes all speed reminders
-  setThrottle2(0,1); // ESTOP all locos still on track
-  for (int i=0;i<MAX_LOCOS;i++) {
-    if (speedTable[i].loco) CommandDistributor::broadcastForgetLoco(speedTable[i].loco);
-    speedTable[i].loco=0;
+  setThrottle2(0, 1);         // ESTOP all locos still on track
+  for (int i = 0; i < MAX_LOCOS; i++) {
+    if (speedTable[i].loco)
+      CommandDistributor::broadcastForgetLoco(speedTable[i].loco);
+    speedTable[i].loco = 0;
@@ -750 +670 @@ void DCC::forgetAllLocos() {  // removes all speed reminders
-byte DCC::loopStatus=0;
+byte DCC::loopStatus = 0;
@@ -752,2 +672,2 @@ byte DCC::loopStatus=0;
-void DCC::loop()  {
-  TrackManager::loop(); // power overload checks
+void DCC::loop() {
+  TrackManager::loop();  // power overload checks
@@ -759 +679,2 @@ void DCC::issueReminders() {
-  if (!DCCWaveform::mainTrack.isReminderWindowOpen()) return;
+  if (!DCCWaveform::mainTrack.isReminderWindowOpen())
+    return;
@@ -761,2 +682,3 @@ void DCC::issueReminders() {
-  int reg = lastLocoReminder+1;
-  if (reg > highestUsedReg) reg = 0;  // Go to start of table
+  int reg = lastLocoReminder + 1;
+  if (reg > highestUsedReg)
+    reg = 0;  // Go to start of table
@@ -772,3 +694,3 @@ bool DCC::issueReminder(int reg) {
-  unsigned long functions=speedTable[reg].functions;
-  int loco=speedTable[reg].loco;
-  byte flags=speedTable[reg].groupFlags;
+  unsigned long functions = speedTable[reg].functions;
+  int loco = speedTable[reg].loco;
+  byte flags = speedTable[reg].groupFlags;
@@ -777 +699 @@ bool DCC::issueReminder(int reg) {
-        case 0:
+    case 0:
@@ -779,4 +701,4 @@ bool DCC::issueReminder(int reg) {
-         setThrottle2(loco, speedTable[reg].speedCode);
-         break;
-       case 1: // remind function group 1 (F0-F4)
-          if (flags & FN_GROUP_1)
+      setThrottle2(loco, speedTable[reg].speedCode);
+      break;
+    case 1:  // remind function group 1 (F0-F4)
+      if (flags & FN_GROUP_1)
@@ -784 +706 @@ bool DCC::issueReminder(int reg) {
-	    setFunctionInternal(loco,0, 128 | ((functions>>1)& 0x0F) | ((functions & 0x01)<<4),0); // 100D DDDD
+        setFunctionInternal(loco, 0, 128 | ((functions >> 1) & 0x0F) | ((functions & 0x01) << 4), 0);  // 100D DDDD
@@ -786,2 +708,2 @@ bool DCC::issueReminder(int reg) {
-	    setFunctionInternal(loco,0, 128 | ((functions>>1)& 0x0F) | ((functions & 0x01)<<4),2);
-          flags&= ~FN_GROUP_1;  // dont send them again
+        setFunctionInternal(loco, 0, 128 | ((functions >> 1) & 0x0F) | ((functions & 0x01) << 4), 2);
+      flags &= ~FN_GROUP_1;  // dont send them again
@@ -789,3 +711,3 @@ bool DCC::issueReminder(int reg) {
-          break;
-       case 2: // remind function group 2 F5-F8
-          if (flags & FN_GROUP_2)
+      break;
+    case 2:  // remind function group 2 F5-F8
+      if (flags & FN_GROUP_2)
@@ -793 +715 @@ bool DCC::issueReminder(int reg) {
-  	    setFunctionInternal(loco,0, 176 | ((functions>>5)& 0x0F),0);                           // 1011 DDDD
+        setFunctionInternal(loco, 0, 176 | ((functions >> 5) & 0x0F), 0);  // 1011 DDDD
@@ -795,2 +717,2 @@ bool DCC::issueReminder(int reg) {
-	    setFunctionInternal(loco,0, 176 | ((functions>>5)& 0x0F),2);
-          flags&= ~FN_GROUP_2;  // dont send them again
+        setFunctionInternal(loco, 0, 176 | ((functions >> 5) & 0x0F), 2);
+      flags &= ~FN_GROUP_2;  // dont send them again
@@ -798,3 +720,3 @@ bool DCC::issueReminder(int reg) {
-          break;
-       case 3: // remind function group 3 F9-F12
-          if (flags & FN_GROUP_3)
+      break;
+    case 3:  // remind function group 3 F9-F12
+      if (flags & FN_GROUP_3)
@@ -802 +724 @@ bool DCC::issueReminder(int reg) {
-	    setFunctionInternal(loco,0, 160 | ((functions>>9)& 0x0F),0);                           // 1010 DDDD
+        setFunctionInternal(loco, 0, 160 | ((functions >> 9) & 0x0F), 0);  // 1010 DDDD
@@ -804,2 +726,2 @@ bool DCC::issueReminder(int reg) {
-	    setFunctionInternal(loco,0, 160 | ((functions>>9)& 0x0F),2);
-          flags&= ~FN_GROUP_3;  // dont send them again
+        setFunctionInternal(loco, 0, 160 | ((functions >> 9) & 0x0F), 2);
+      flags &= ~FN_GROUP_3;  // dont send them again
@@ -807,22 +729,20 @@ bool DCC::issueReminder(int reg) {
-          break;
-       case 4: // remind function group 4 F13-F20
-          if (flags & FN_GROUP_4)
-	    setFunctionInternal(loco,222, ((functions>>13)& 0xFF),2);
-          flags&= ~FN_GROUP_4;  // dont send them again
-          break;
-       case 5: // remind function group 5 F21-F28
-          if (flags & FN_GROUP_5)
-	    setFunctionInternal(loco,223, ((functions>>21)& 0xFF),2);
-          flags&= ~FN_GROUP_5;  // dont send them again
-          break;
-      }
-      loopStatus++;
-      // if we reach status 6 then this loco is done so
-      // reset status to 0 for next loco and return true so caller
-      // moves on to next loco.
-      if (loopStatus>5) loopStatus=0;
-      return loopStatus==0;
-    }
-
-
-
+      break;
+    case 4:  // remind function group 4 F13-F20
+      if (flags & FN_GROUP_4)
+        setFunctionInternal(loco, 222, ((functions >> 13) & 0xFF), 2);
+      flags &= ~FN_GROUP_4;  // dont send them again
+      break;
+    case 5:  // remind function group 5 F21-F28
+      if (flags & FN_GROUP_5)
+        setFunctionInternal(loco, 223, ((functions >> 21) & 0xFF), 2);
+      flags &= ~FN_GROUP_5;  // dont send them again
+      break;
+  }
+  loopStatus++;
+  // if we reach status 6 then this loco is done so
+  // reset status to 0 for next loco and return true so caller
+  // moves on to next loco.
+  if (loopStatus > 5)
+    loopStatus = 0;
+  return loopStatus == 0;
+}
@@ -832 +752 @@ bool DCC::issueReminder(int reg) {
-byte DCC::cv1(byte opcode, int cv)  {
+byte DCC::cv1(byte opcode, int cv) {
@@ -836 +756 @@ byte DCC::cv1(byte opcode, int cv)  {
-byte DCC::cv2(int cv)  {
+byte DCC::cv2(int cv) {
@@ -846,2 +766,4 @@ int DCC::lookupSpeedTable(int locoId, bool autoCreate) {
-    if (speedTable[reg].loco == locoId) break;
-    if (speedTable[reg].loco == 0 && firstEmpty == MAX_LOCOS) firstEmpty = reg;
+    if (speedTable[reg].loco == locoId)
+      break;
+    if (speedTable[reg].loco == 0 && firstEmpty == MAX_LOCOS)
+      firstEmpty = reg;
@@ -851,2 +773,4 @@ int DCC::lookupSpeedTable(int locoId, bool autoCreate) {
-  if (reg== MAX_LOCOS && !autoCreate) return -1; 
-  if (reg == MAX_LOCOS) reg = firstEmpty;
+  if (reg == MAX_LOCOS && !autoCreate)
+    return -1;
+  if (reg == MAX_LOCOS)
+    reg = firstEmpty;
@@ -857,5 +781,5 @@ int DCC::lookupSpeedTable(int locoId, bool autoCreate) {
-  if (reg==firstEmpty){
-        speedTable[reg].loco = locoId;
-        speedTable[reg].speedCode=128;  // default direction forward
-        speedTable[reg].groupFlags=0;
-        speedTable[reg].functions=0;
+  if (reg == firstEmpty) {
+    speedTable[reg].loco = locoId;
+    speedTable[reg].speedCode = 128;  // default direction forward
+    speedTable[reg].groupFlags = 0;
+    speedTable[reg].functions = 0;
@@ -863 +787,2 @@ int DCC::lookupSpeedTable(int locoId, bool autoCreate) {
-  if (reg > highestUsedReg) highestUsedReg = reg;
+  if (reg > highestUsedReg)
+    highestUsedReg = reg;
@@ -867,13 +792,13 @@ int DCC::lookupSpeedTable(int locoId, bool autoCreate) {
-void  DCC::updateLocoReminder(int loco, byte speedCode) {
-
-  if (loco==0) {
-     // broadcast stop/estop but dont change direction
-     for (int reg = 0; reg <= highestUsedReg; reg++) {
-       if (speedTable[reg].loco==0) continue;
-       byte newspeed=(speedTable[reg].speedCode & 0x80) |  (speedCode & 0x7f);
-       if (speedTable[reg].speedCode != newspeed) {
-         speedTable[reg].speedCode = newspeed;
-         CommandDistributor::broadcastLoco(reg);
-       }
-     }
-     return;
+void DCC::updateLocoReminder(int loco, byte speedCode) {
+  if (loco == 0) {
+    // broadcast stop/estop but dont change direction
+    for (int reg = 0; reg <= highestUsedReg; reg++) {
+      if (speedTable[reg].loco == 0)
+        continue;
+      byte newspeed = (speedTable[reg].speedCode & 0x80) | (speedCode & 0x7f);
+      if (speedTable[reg].speedCode != newspeed) {
+        speedTable[reg].speedCode = newspeed;
+        CommandDistributor::broadcastLoco(reg);
+      }
+    }
+    return;
@@ -883,2 +808,2 @@ void  DCC::updateLocoReminder(int loco, byte speedCode) {
-  int reg=lookupSpeedTable(loco);
-  if (reg>=0 && speedTable[reg].speedCode!=speedCode) {
+  int reg = lookupSpeedTable(loco);
+  if (reg >= 0 && speedTable[reg].speedCode != speedCode) {
@@ -894,13 +819,10 @@ int DCC::highestUsedReg = 0;
-
-void DCC::displayCabList(Print * stream) {
-
-    int used=0;
-    for (int reg = 0; reg <= highestUsedReg; reg++) {
-       if (speedTable[reg].loco>0) {
-        used ++;
-        StringFormatter::send(stream,F("cab=%d, speed=%d, dir=%c \n"),
-           speedTable[reg].loco,  speedTable[reg].speedCode & 0x7f,(speedTable[reg].speedCode & 0x80) ? 'F':'R');
-       }
-     }
-     StringFormatter::send(stream,F("Used=%d, max=%d\n"),used,MAX_LOCOS);
-
+void DCC::displayCabList(Print* stream) {
+  int used = 0;
+  for (int reg = 0; reg <= highestUsedReg; reg++) {
+    if (speedTable[reg].loco > 0) {
+      used++;
+      StringFormatter::send(stream, F("cab=%d, speed=%d, dir=%c \n"), speedTable[reg].loco, speedTable[reg].speedCode & 0x7f,
+                            (speedTable[reg].speedCode & 0x80) ? 'F' : 'R');
+    }
+  }
+  StringFormatter::send(stream, F("Used=%d, max=%d\n"), used, MAX_LOCOS);
diff --git a/DCC.h b/DCC.h
index 38c1952..6447de2 100644
--- a/DCC.h
+++ b/DCC.h
@@ -8 +8 @@
- *  
+ *
@@ -42 +41,0 @@ const uint16_t LONG_ADDR_MARKER = 0x4000;
-
@@ -51,5 +50,4 @@ const byte MAX_LOCOS = 30;
-class DCC
-{
-public:
-  static inline void setShieldName(const FSH * motorShieldName) {
-    shieldName=(FSH *)motorShieldName;
+class DCC {
+ public:
+  static inline void setShieldName(const FSH* motorShieldName) {
+    shieldName = (FSH*)motorShieldName;
@@ -73,2 +71,2 @@ public:
-  static void setDCFreq(int cab,byte freq);
-  static void updateGroupflags(byte &flags, int16_t functionNumber);
+  static void setDCFreq(int cab, byte freq);
+  static void updateGroupflags(byte& flags, int16_t functionNumber);
@@ -76,3 +74,3 @@ public:
-  static bool setExtendedAccessory(int16_t address, int16_t value, byte repeats=3);
-  static bool writeTextPacket(byte *b, int nBytes);
-  
+  static bool setExtendedAccessory(int16_t address, int16_t value, byte repeats = 3);
+  static bool writeTextPacket(byte* b, int nBytes);
+
@@ -81 +79 @@ public:
-  static void readCVBit(int16_t cv, byte bitNum, ACK_CALLBACK callback); // -1 for error
+  static void readCVBit(int16_t cv, byte bitNum, ACK_CALLBACK callback);  // -1 for error
@@ -88,2 +86,2 @@ public:
-  static void setLocoId(int id,ACK_CALLBACK callback);
-  static void setConsistId(int id,bool reverse,ACK_CALLBACK callback);
+  static void setLocoId(int id, ACK_CALLBACK callback);
+  static void setConsistId(int id, bool reverse, ACK_CALLBACK callback);
@@ -91,4 +89,4 @@ public:
-  static void forgetLoco(int cab); // removes any speed reminders for this loco
-  static void forgetAllLocos();    // removes all speed reminders
-  static void displayCabList(Print *stream);
-  static FSH *getMotorShieldName();
+  static void forgetLoco(int cab);  // removes any speed reminders for this loco
+  static void forgetAllLocos();     // removes all speed reminders
+  static void displayCabList(Print* stream);
+  static FSH* getMotorShieldName();
@@ -98,3 +96,2 @@ public:
-  
-  struct LOCO
-  {
+
+  struct LOCO {
@@ -106,6 +103,6 @@ public:
- static LOCO speedTable[MAX_LOCOS];
- static int lookupSpeedTable(int locoId, bool autoCreate=true);
- static byte cv1(byte opcode, int cv);
- static byte cv2(int cv);
- 
-private:
+  static LOCO speedTable[MAX_LOCOS];
+  static int lookupSpeedTable(int locoId, bool autoCreate = true);
+  static byte cv1(byte opcode, int cv);
+  static byte cv2(int cv);
+
+ private:
@@ -119 +116 @@ private:
-  static FSH *shieldName;
+  static FSH* shieldName;
@@ -125 +121,0 @@ private:
-  
diff --git a/DCCACK.cpp b/DCCACK.cpp
index 7a43cd1..f139b11 100644
--- a/DCCACK.cpp
+++ b/DCCACK.cpp
@@ -8 +8 @@
- *  
+ *
@@ -30,22 +30,21 @@
-unsigned long DCCACK::minAckPulseDuration = 2000; // micros
-unsigned long DCCACK::maxAckPulseDuration = 20000; // micros
-  
-MotorDriver *  DCCACK::progDriver=NULL;
-ackOp  const *  DCCACK::ackManagerProg;
-ackOp  const *  DCCACK::ackManagerProgStart;
-byte   DCCACK::ackManagerByte;
-byte   DCCACK::ackManagerByteVerify;
-byte   DCCACK::ackManagerStash;
-int    DCCACK::ackManagerWord;
-byte   DCCACK::ackManagerRetry;
-byte   DCCACK::ackRetry = 2;
-int16_t  DCCACK::ackRetrySum;
-int16_t  DCCACK::ackRetryPSum;
-int    DCCACK::ackManagerCv;
-byte   DCCACK::ackManagerBitNum;
-bool   DCCACK::ackReceived;
-bool   DCCACK::ackManagerRejoin;
-volatile uint8_t DCCACK::numAckGaps=0;
-volatile uint8_t DCCACK::numAckSamples=0;
-uint8_t DCCACK::trailingEdgeCounter=0;
-
+unsigned long DCCACK::minAckPulseDuration = 2000;   // micros
+unsigned long DCCACK::maxAckPulseDuration = 20000;  // micros
+
+MotorDriver* DCCACK::progDriver = NULL;
+ackOp const* DCCACK::ackManagerProg;
+ackOp const* DCCACK::ackManagerProgStart;
+byte DCCACK::ackManagerByte;
+byte DCCACK::ackManagerByteVerify;
+byte DCCACK::ackManagerStash;
+int DCCACK::ackManagerWord;
+byte DCCACK::ackManagerRetry;
+byte DCCACK::ackRetry = 2;
+int16_t DCCACK::ackRetrySum;
+int16_t DCCACK::ackRetryPSum;
+int DCCACK::ackManagerCv;
+byte DCCACK::ackManagerBitNum;
+bool DCCACK::ackReceived;
+bool DCCACK::ackManagerRejoin;
+volatile uint8_t DCCACK::numAckGaps = 0;
+volatile uint8_t DCCACK::numAckSamples = 0;
+uint8_t DCCACK::trailingEdgeCounter = 0;
@@ -54,12 +53,11 @@ unsigned long DCCACK::ackPulseDuration;  // micros
-unsigned long DCCACK::ackPulseStart; // micros
- volatile bool DCCACK::ackDetected;
- unsigned long DCCACK::ackCheckStart; // millis
- volatile bool DCCACK::ackPending;
-  bool   DCCACK::autoPowerOff;
-   int  DCCACK::ackThreshold; 
-   int  DCCACK::ackLimitmA = 50;
-     int DCCACK::ackMaxCurrent;
-      unsigned int DCCACK::ackCheckDuration; // millis       
-    
-    
-CALLBACK_STATE DCCACK::callbackState=READY;
+unsigned long DCCACK::ackPulseStart;     // micros
+volatile bool DCCACK::ackDetected;
+unsigned long DCCACK::ackCheckStart;  // millis
+volatile bool DCCACK::ackPending;
+bool DCCACK::autoPowerOff;
+int DCCACK::ackThreshold;
+int DCCACK::ackLimitmA = 50;
+int DCCACK::ackMaxCurrent;
+unsigned int DCCACK::ackCheckDuration;  // millis
+
+CALLBACK_STATE DCCACK::callbackState = READY;
@@ -69 +67 @@ ACK_CALLBACK DCCACK::ackManagerCallback;
-void  DCCACK::Setup(int cv, byte byteValueOrBitnum, ackOp const program[], ACK_CALLBACK callback) {
+void DCCACK::Setup(int cv, byte byteValueOrBitnum, ackOp const program[], ACK_CALLBACK callback) {
@@ -74,2 +72,2 @@ void  DCCACK::Setup(int cv, byte byteValueOrBitnum, ackOp const program[], ACK_C
-  ackManagerRejoin=TrackManager::isJoined();
-  //DIAG(F("Joined is %d"), ackManagerRejoin);
+  ackManagerRejoin = TrackManager::isJoined();
+  // DIAG(F("Joined is %d"), ackManagerRejoin);
@@ -81,3 +79,3 @@ void  DCCACK::Setup(int cv, byte byteValueOrBitnum, ackOp const program[], ACK_C
-  progDriver=TrackManager::getProgDriver();
-  //DIAG(F("Progdriver is %d"), progDriver);
-  if (progDriver==NULL) {
+  progDriver = TrackManager::getProgDriver();
+  // DIAG(F("Progdriver is %d"), progDriver);
+  if (progDriver == NULL) {
@@ -88 +86 @@ void  DCCACK::Setup(int cv, byte byteValueOrBitnum, ackOp const program[], ACK_C
-    callback(-3); // we dont have a prog track!
+    callback(-3);  // we dont have a prog track!
@@ -93 +91 @@ void  DCCACK::Setup(int cv, byte byteValueOrBitnum, ackOp const program[], ACK_C
-    callback(-2); // our prog track cant measure current
+    callback(-2);  // our prog track cant measure current
@@ -97,6 +95,7 @@ void  DCCACK::Setup(int cv, byte byteValueOrBitnum, ackOp const program[], ACK_C
-   autoPowerOff=false;
-   if (progDriver->getPower() == POWERMODE::OFF) {
-        autoPowerOff=true;  // power off afterwards
-        if (Diag::ACK) DIAG(F("Auto Prog power on"));
-        progDriver->setPower(POWERMODE::ON);
-	
+  autoPowerOff = false;
+  if (progDriver->getPower() == POWERMODE::OFF) {
+    autoPowerOff = true;  // power off afterwards
+    if (Diag::ACK)
+      DIAG(F("Auto Prog power on"));
+    progDriver->setPower(POWERMODE::ON);
+
@@ -105 +104 @@ void  DCCACK::Setup(int cv, byte byteValueOrBitnum, ackOp const program[], ACK_C
-	  DCCWaveform::mainTrack.setPowerMode(POWERMODE::ON);
+    DCCWaveform::mainTrack.setPowerMode(POWERMODE::ON);
@@ -108,2 +107 @@ void  DCCACK::Setup(int cv, byte byteValueOrBitnum, ackOp const program[], ACK_C
-      }
-
+  }
@@ -117 +115 @@ void  DCCACK::Setup(int cv, byte byteValueOrBitnum, ackOp const program[], ACK_C
-  ackManagerBitNum=byteValueOrBitnum;
+  ackManagerBitNum = byteValueOrBitnum;
@@ -121,2 +119,2 @@ void  DCCACK::Setup(int cv, byte byteValueOrBitnum, ackOp const program[], ACK_C
-void  DCCACK::Setup(int wordval, ackOp const program[], ACK_CALLBACK callback) {
-  ackManagerWord=wordval;
+void DCCACK::Setup(int wordval, ackOp const program[], ACK_CALLBACK callback) {
+  ackManagerWord = wordval;
@@ -124 +122 @@ void  DCCACK::Setup(int wordval, ackOp const program[], ACK_CALLBACK callback) {
-  }
+}
@@ -126 +124 @@ void  DCCACK::Setup(int wordval, ackOp const program[], ACK_CALLBACK callback) {
-const byte RESET_MIN=8;  // tuning of reset counter before sending message
+const byte RESET_MIN = 8;  // tuning of reset counter before sending message
@@ -133 +131 @@ bool DCCACK::checkResets(uint8_t numResets) {
-// (yes I know I could have subclassed the main track but...) 
+// (yes I know I could have subclassed the main track but...)
@@ -136,6 +134,5 @@ void DCCACK::setAckBaseline() {
-      int baseline=progDriver->getCurrentRaw();
-      ackThreshold= baseline + progDriver->mA2raw(ackLimitmA);
-      if (Diag::ACK) DIAG(F("ACK baseline=%d/%dmA Threshold=%d/%dmA Duration between %lus and %lus"),
-			  baseline,progDriver->raw2mA(baseline),
-			  ackThreshold,progDriver->raw2mA(ackThreshold),
-                          minAckPulseDuration, maxAckPulseDuration);
+  int baseline = progDriver->getCurrentRaw();
+  ackThreshold = baseline + progDriver->mA2raw(ackLimitmA);
+  if (Diag::ACK)
+    DIAG(F("ACK baseline=%d/%dmA Threshold=%d/%dmA Duration between %lus and %lus"), baseline, progDriver->raw2mA(baseline), ackThreshold,
+         progDriver->raw2mA(ackThreshold), minAckPulseDuration, maxAckPulseDuration);
@@ -145,8 +142,8 @@ void DCCACK::setAckPending() {
-      ackMaxCurrent=0;
-      ackPulseStart=0;
-      ackPulseDuration=0;
-      ackDetected=false;
-      ackCheckStart=millis();
-      numAckSamples=0;
-      numAckGaps=0;
-      ackPending=true;  // interrupt routines will now take note
+  ackMaxCurrent = 0;
+  ackPulseStart = 0;
+  ackPulseDuration = 0;
+  ackDetected = false;
+  ackCheckStart = millis();
+  numAckSamples = 0;
+  numAckGaps = 0;
+  ackPending = true;  // interrupt routines will now take note
@@ -156,5 +153,8 @@ byte DCCACK::getAck() {
-      if (ackPending) return (2);  // still waiting
-      if (Diag::ACK) DIAG(F("%S after %dmS max=%d/%dmA pulse=%luS samples=%d gaps=%d"),ackDetected?F("ACK"):F("NO-ACK"), ackCheckDuration,
-			  ackMaxCurrent,progDriver->raw2mA(ackMaxCurrent), ackPulseDuration, numAckSamples, numAckGaps);
-      if (ackDetected) return (1); // Yes we had an ack
-      return(0);  // pending set off but not detected means no ACK.   
+  if (ackPending)
+    return (2);  // still waiting
+  if (Diag::ACK)
+    DIAG(F("%S after %dmS max=%d/%dmA pulse=%luS samples=%d gaps=%d"), ackDetected ? F("ACK") : F("NO-ACK"), ackCheckDuration, ackMaxCurrent,
+         progDriver->raw2mA(ackMaxCurrent), ackPulseDuration, numAckSamples, numAckGaps);
+  if (ackDetected)
+    return (1);  // Yes we had an ack
+  return (0);    // pending set off but not detected means no ACK.
@@ -166 +166 @@ void DCCACK::loop() {
-    byte opcode=GETFLASH(ackManagerProg);
+    byte opcode = GETFLASH(ackManagerProg);
@@ -173,37 +173,6 @@ void DCCACK::loop() {
-          if (progDriver->getPower()==POWERMODE::OVERLOAD) return;
-      	  if (checkResets(autoPowerOff || ackManagerRejoin  ? 20 : 3)) return;
-          setAckBaseline();
-          callbackState=AFTER_READ;
-          break;
-      case W0:    // write 0 bit
-      case W1:    // write 1 bit
-            {
-	      if (checkResets(RESET_MIN)) return;
-              if (Diag::ACK) DIAG(F("W%d cv=%d bit=%d"),opcode==W1, ackManagerCv,ackManagerBitNum);
-              byte instruction = WRITE_BIT | (opcode==W1 ? BIT_ON : BIT_OFF) | ackManagerBitNum;
-              byte message[] = {DCC::cv1(BIT_MANIPULATE, ackManagerCv), DCC::cv2(ackManagerCv), instruction };
-              DCCWaveform::progTrack.schedulePacket(message, sizeof(message), PROG_REPEATS);
-              setAckPending();
-             callbackState=AFTER_WRITE;
-         }
-            break;
-
-      case WB:   // write byte
-            {
-	      if (checkResets( RESET_MIN)) return;
-              if (Diag::ACK) DIAG(F("WB cv=%d value=%d"),ackManagerCv,ackManagerByte);
-              byte message[] = {DCC::cv1(WRITE_BYTE, ackManagerCv), DCC::cv2(ackManagerCv), ackManagerByte};
-              DCCWaveform::progTrack.schedulePacket(message, sizeof(message), PROG_REPEATS);
-              setAckPending();
-              callbackState=AFTER_WRITE;
-            }
-            break;
-
-      case   VB:     // Issue validate Byte packet
-        {
-	  if (checkResets( RESET_MIN)) return;
-          if (Diag::ACK) DIAG(F("VB cv=%d value=%d"),ackManagerCv,ackManagerByte);
-          byte message[] = { DCC::cv1(VERIFY_BYTE, ackManagerCv), DCC::cv2(ackManagerCv), ackManagerByte};
-          DCCWaveform::progTrack.schedulePacket(message, sizeof(message), PROG_REPEATS);
-          setAckPending();
-        }
+        if (progDriver->getPower() == POWERMODE::OVERLOAD)
+          return;
+        if (checkResets(autoPowerOff || ackManagerRejoin ? 20 : 3))
+          return;
+        setAckBaseline();
+        callbackState = AFTER_READ;
@@ -210,0 +180,36 @@ void DCCACK::loop() {
+      case W0:  // write 0 bit
+      case W1:  // write 1 bit
+      {
+        if (checkResets(RESET_MIN))
+          return;
+        if (Diag::ACK)
+          DIAG(F("W%d cv=%d bit=%d"), opcode == W1, ackManagerCv, ackManagerBitNum);
+        byte instruction = WRITE_BIT | (opcode == W1 ? BIT_ON : BIT_OFF) | ackManagerBitNum;
+        byte message[] = {DCC::cv1(BIT_MANIPULATE, ackManagerCv), DCC::cv2(ackManagerCv), instruction};
+        DCCWaveform::progTrack.schedulePacket(message, sizeof(message), PROG_REPEATS);
+        setAckPending();
+        callbackState = AFTER_WRITE;
+      } break;
+
+      case WB:  // write byte
+      {
+        if (checkResets(RESET_MIN))
+          return;
+        if (Diag::ACK)
+          DIAG(F("WB cv=%d value=%d"), ackManagerCv, ackManagerByte);
+        byte message[] = {DCC::cv1(WRITE_BYTE, ackManagerCv), DCC::cv2(ackManagerCv), ackManagerByte};
+        DCCWaveform::progTrack.schedulePacket(message, sizeof(message), PROG_REPEATS);
+        setAckPending();
+        callbackState = AFTER_WRITE;
+      } break;
+
+      case VB:  // Issue validate Byte packet
+      {
+        if (checkResets(RESET_MIN))
+          return;
+        if (Diag::ACK)
+          DIAG(F("VB cv=%d value=%d"), ackManagerCv, ackManagerByte);
+        byte message[] = {DCC::cv1(VERIFY_BYTE, ackManagerCv), DCC::cv2(ackManagerCv), ackManagerByte};
+        DCCWaveform::progTrack.schedulePacket(message, sizeof(message), PROG_REPEATS);
+        setAckPending();
+      } break;
@@ -213,8 +218,27 @@ void DCCACK::loop() {
-      case V1:      // Issue validate bit=0 or bit=1  packet
-        {
-	  if (checkResets(RESET_MIN)) return;
-          if (Diag::ACK) DIAG(F("V%d cv=%d bit=%d"),opcode==V1, ackManagerCv,ackManagerBitNum);
-          byte instruction = VERIFY_BIT | (opcode==V0?BIT_OFF:BIT_ON) | ackManagerBitNum;
-          byte message[] = {DCC::cv1(BIT_MANIPULATE, ackManagerCv), DCC::cv2(ackManagerCv), instruction };
-          DCCWaveform::progTrack.schedulePacket(message, sizeof(message), PROG_REPEATS);
-          setAckPending();
+      case V1:  // Issue validate bit=0 or bit=1  packet
+      {
+        if (checkResets(RESET_MIN))
+          return;
+        if (Diag::ACK)
+          DIAG(F("V%d cv=%d bit=%d"), opcode == V1, ackManagerCv, ackManagerBitNum);
+        byte instruction = VERIFY_BIT | (opcode == V0 ? BIT_OFF : BIT_ON) | ackManagerBitNum;
+        byte message[] = {DCC::cv1(BIT_MANIPULATE, ackManagerCv), DCC::cv2(ackManagerCv), instruction};
+        DCCWaveform::progTrack.schedulePacket(message, sizeof(message), PROG_REPEATS);
+        setAckPending();
+      } break;
+
+      case WACK:  // wait for ack (or absence of ack)
+      {
+        byte ackState = 2;  // keep polling
+
+        ackState = getAck();
+        if (ackState == 2)
+          return;  // keep polling
+        ackReceived = ackState == 1;
+        break;  // we have a genuine ACK result
+      }
+      case ITC0:
+      case ITC1:  // If True Callback(0 or 1)  (if prevous WACK got an ACK)
+        if (ackReceived) {
+          callback(opcode == ITC0 ? 0 : 1);
+          return;
@@ -224,11 +248 @@ void DCCACK::loop() {
-      case WACK:   // wait for ack (or absence of ack)
-         {
-          byte ackState=2; // keep polling
-
-          ackState=getAck();
-          if (ackState==2) return; // keep polling
-          ackReceived=ackState==1;
-          break;  // we have a genuine ACK result
-         }
-     case ITC0:
-     case ITC1:   // If True Callback(0 or 1)  (if prevous WACK got an ACK)
+      case ITCB:  // If True callback(byte)
@@ -236,3 +250,3 @@ void DCCACK::loop() {
-            callback(opcode==ITC0?0:1);
-            return;
-          }
+          callback(ackManagerByte);
+          return;
+        }
@@ -241,15 +255,5 @@ void DCCACK::loop() {
-      case ITCB:   // If True callback(byte)
-          if (ackReceived) {
-            callback(ackManagerByte);
-            return;
-          }
-        break;
-		
-      case ITCBV:   // If True callback(byte) - Verify
-          if (ackReceived) {
-            if (ackManagerByte == ackManagerByteVerify) {
-               ackRetrySum ++;
-               LCD(1, F("v %d %d Sum=%d"), ackManagerCv, ackManagerByte, ackRetrySum);
-            }
-            callback(ackManagerByte);
-            return;
+      case ITCBV:  // If True callback(byte) - Verify
+        if (ackReceived) {
+          if (ackManagerByte == ackManagerByteVerify) {
+            ackRetrySum++;
+            LCD(1, F("v %d %d Sum=%d"), ackManagerCv, ackManagerByte, ackRetrySum);
@@ -256,0 +261,3 @@ void DCCACK::loop() {
+          callback(ackManagerByte);
+          return;
+        }
@@ -258,6 +265,6 @@ void DCCACK::loop() {
-		
-      case ITCB7:   // If True callback(byte & 0x7F)
-          if (ackReceived) {
-            callback(ackManagerByte & 0x7F);
-            return;
-          }
+
+      case ITCB7:  // If True callback(byte & 0x7F)
+        if (ackReceived) {
+          callback(ackManagerByte & 0x7F);
+          return;
+        }
@@ -266,5 +273,5 @@ void DCCACK::loop() {
-      case NAKFAIL:   // If nack callback(-1)
-          if (!ackReceived) {
-            callback(-1);
-            return;
-          }
+      case NAKFAIL:  // If nack callback(-1)
+        if (!ackReceived) {
+          callback(-1);
+          return;
+        }
@@ -274,2 +281,2 @@ void DCCACK::loop() {
-           callback(-1);
-           return;
+        callback(-1);
+        return;
@@ -277,3 +284,3 @@ void DCCACK::loop() {
-      case BIV:     // ackManagerByte initial value
-           ackManagerByte = ackManagerByteVerify;
-           break;
+      case BIV:  // ackManagerByte initial value
+        ackManagerByte = ackManagerByteVerify;
+        break;
@@ -282,3 +289,3 @@ void DCCACK::loop() {
-           ackManagerBitNum=7;
-           ackManagerByte=0;
-          break;
+        ackManagerBitNum = 7;
+        ackManagerByte = 0;
+        break;
@@ -287,5 +294,6 @@ void DCCACK::loop() {
-          ackManagerByte <<= 1;
-          // ackReceived means bit is zero.
-          if (!ackReceived) ackManagerByte |= 1;
-          ackManagerBitNum--;
-          break;
+        ackManagerByte <<= 1;
+        // ackReceived means bit is zero.
+        if (!ackReceived)
+          ackManagerByte |= 1;
+        ackManagerBitNum--;
+        break;
@@ -294,13 +302,3 @@ void DCCACK::loop() {
-          ackManagerProg++;
-          ackManagerBitNum=GETFLASH(ackManagerProg);
-          break;
-
-     case SETCV:
-          ackManagerProg++;
-          ackManagerCv=GETFLASH(ackManagerProg);
-          break;
-
-     case SETBYTE:
-          ackManagerProg++;
-          ackManagerByte=GETFLASH(ackManagerProg);
-          break;
+        ackManagerProg++;
+        ackManagerBitNum = GETFLASH(ackManagerProg);
+        break;
@@ -308,3 +306,4 @@ void DCCACK::loop() {
-    case SETBYTEH:
-          ackManagerByte=highByte(ackManagerWord);
-          break;
+      case SETCV:
+        ackManagerProg++;
+        ackManagerCv = GETFLASH(ackManagerProg);
+        break;
@@ -312,3 +311,4 @@ void DCCACK::loop() {
-    case SETBYTEL:
-          ackManagerByte=lowByte(ackManagerWord);
-          break;
+      case SETBYTE:
+        ackManagerProg++;
+        ackManagerByte = GETFLASH(ackManagerProg);
+        break;
@@ -316,3 +316,3 @@ void DCCACK::loop() {
-     case STASHLOCOID:
-          ackManagerStash=ackManagerByte;  // stash value from CV17
-          break;
+      case SETBYTEH:
+        ackManagerByte = highByte(ackManagerWord);
+        break;
@@ -320,4 +320,3 @@ void DCCACK::loop() {
-     case COMBINELOCOID:
-          // ackManagerStash is  cv17, ackManagerByte is CV 18
-          callback( LONG_ADDR_MARKER | ( ackManagerByte + ((ackManagerStash - 192) << 8)));
-          return;
+      case SETBYTEL:
+        ackManagerByte = lowByte(ackManagerWord);
+        break;
@@ -325,7 +324,3 @@ void DCCACK::loop() {
-     case COMBINE1920:
-          // ackManagerStash is  cv20, ackManagerByte is CV 19
-          // This will not be called if cv20==0
-          ackManagerByte &= 0x7F;  // ignore direction marker
-          ackManagerByte %=100;    // take last 2 decimal digits 
-          callback( ackManagerStash*100+ackManagerByte);
-          return;
+      case STASHLOCOID:
+        ackManagerStash = ackManagerByte;  // stash value from CV17
+        break;
@@ -333,7 +328,15 @@ void DCCACK::loop() {
-     case ITSKIP:
-          if (!ackReceived) break;
-          // SKIP opcodes until SKIPTARGET found
-          while (opcode!=SKIPTARGET) {
-            ackManagerProg++;
-            opcode=GETFLASH(ackManagerProg);
-          }
+      case COMBINELOCOID:
+        // ackManagerStash is  cv17, ackManagerByte is CV 18
+        callback(LONG_ADDR_MARKER | (ackManagerByte + ((ackManagerStash - 192) << 8)));
+        return;
+
+      case COMBINE1920:
+        // ackManagerStash is  cv20, ackManagerByte is CV 19
+        // This will not be called if cv20==0
+        ackManagerByte &= 0x7F;  // ignore direction marker
+        ackManagerByte %= 100;   // take last 2 decimal digits
+        callback(ackManagerStash * 100 + ackManagerByte);
+        return;
+
+      case ITSKIP:
+        if (!ackReceived)
@@ -340,0 +344,6 @@ void DCCACK::loop() {
+        // SKIP opcodes until SKIPTARGET found
+        while (opcode != SKIPTARGET) {
+          ackManagerProg++;
+          opcode = GETFLASH(ackManagerProg);
+        }
+        break;
@@ -342,9 +351,2 @@ void DCCACK::loop() {
-     case NAKSKIP:
-          if (ackReceived) break;
-          // SKIP opcodes until SKIPTARGET found
-          while (opcode!=SKIPTARGET) {
-            ackManagerProg++;
-            opcode=GETFLASH(ackManagerProg);
-          }
-          break;
-     case SKIPTARGET:
+      case NAKSKIP:
+        if (ackReceived)
@@ -352,4 +354,12 @@ void DCCACK::loop() {
-     default:
-          DIAG(F("!! ackOp %d FAULT!!"),opcode);
-          callback( -1);
-          return;
+        // SKIP opcodes until SKIPTARGET found
+        while (opcode != SKIPTARGET) {
+          ackManagerProg++;
+          opcode = GETFLASH(ackManagerProg);
+        }
+        break;
+      case SKIPTARGET:
+        break;
+      default:
+        DIAG(F("!! ackOp %d FAULT!!"), opcode);
+        callback(-1);
+        return;
@@ -357 +367 @@ void DCCACK::loop() {
-      }  // end of switch
+    }  // end of switch
@@ -363,8 +373,8 @@ void DCCACK::callback(int value) {
-    // check for automatic retry
-    if (value == -1 && ackManagerRetry > 0) {
-      ackRetrySum ++;
-      LCD(0, F("Retry %d %d Sum=%d"), ackManagerCv, ackManagerRetry, ackRetrySum);
-      ackManagerRetry --;
-      ackManagerProg = ackManagerProgStart;
-      return;
-    }
+  // check for automatic retry
+  if (value == -1 && ackManagerRetry > 0) {
+    ackRetrySum++;
+    LCD(0, F("Retry %d %d Sum=%d"), ackManagerCv, ackManagerRetry, ackRetrySum);
+    ackManagerRetry--;
+    ackManagerProg = ackManagerProgStart;
+    return;
+  }
@@ -372,15 +382,31 @@ void DCCACK::callback(int value) {
-    static unsigned long callbackStart;
-    // We are about to leave programming mode
-    // Rule 1: If we have written to a decoder we must maintain power for 100mS
-    // Rule 2: If we are re-joining the main track we must power off for 30mS
-
-    switch (callbackState) {
-      case AFTER_READ:
-         if (ackManagerRejoin && !autoPowerOff) {
-                progDriver->setPower(POWERMODE::OFF);
-                callbackStart=millis();
-                callbackState=WAITING_30;
-                if (Diag::ACK) DIAG(F("OFF 30mS"));
-        } else {
-               callbackState=READY;
-        }
+  static unsigned long callbackStart;
+  // We are about to leave programming mode
+  // Rule 1: If we have written to a decoder we must maintain power for 100mS
+  // Rule 2: If we are re-joining the main track we must power off for 30mS
+
+  switch (callbackState) {
+    case AFTER_READ:
+      if (ackManagerRejoin && !autoPowerOff) {
+        progDriver->setPower(POWERMODE::OFF);
+        callbackStart = millis();
+        callbackState = WAITING_30;
+        if (Diag::ACK)
+          DIAG(F("OFF 30mS"));
+      } else {
+        callbackState = READY;
+      }
+      break;
+
+    case AFTER_WRITE:  // first attempt to callback after a write operation
+      if (!ackManagerRejoin && !autoPowerOff) {
+        callbackState = READY;
+        break;
+      }  // lines 906-910 added. avoid wait after write. use 1 PROG
+      callbackStart = millis();
+      callbackState = WAITING_100;
+      if (Diag::ACK)
+        DIAG(F("Stable 100mS"));
+      break;
+
+    case WAITING_100:  // waiting for 100mS
+      if (millis() - callbackStart < 100)
@@ -387,0 +414,14 @@ void DCCACK::callback(int value) {
+      // stable after power maintained for 100mS
+
+      // If we are going to power off anyway, it doesnt matter
+      // but if we will keep the power on, we must off it for 30mS
+      if (autoPowerOff)
+        callbackState = READY;
+      else {  // Need to cycle power off and on
+        progDriver->setPower(POWERMODE::OFF);
+        callbackStart = millis();
+        callbackState = WAITING_30;
+        if (Diag::ACK)
+          DIAG(F("OFF 30mS"));
+      }
+      break;
@@ -389,47 +429,25 @@ void DCCACK::callback(int value) {
-      case AFTER_WRITE:  // first attempt to callback after a write operation
-	    if (!ackManagerRejoin && !autoPowerOff) {
-               callbackState=READY;
-               break;
-            }                              // lines 906-910 added. avoid wait after write. use 1 PROG
-            callbackStart=millis();
-            callbackState=WAITING_100;
-            if (Diag::ACK) DIAG(F("Stable 100mS"));
-            break;
-
-       case WAITING_100:  // waiting for 100mS
-            if (millis()-callbackStart < 100) break;
-            // stable after power maintained for 100mS
-
-            // If we are going to power off anyway, it doesnt matter
-            // but if we will keep the power on, we must off it for 30mS
-            if (autoPowerOff) callbackState=READY;
-            else { // Need to cycle power off and on
-                progDriver->setPower(POWERMODE::OFF);
-                callbackStart=millis();
-                callbackState=WAITING_30;
-                if (Diag::ACK) DIAG(F("OFF 30mS"));
-            }
-            break;
-
-        case WAITING_30:  // waiting for 30mS with power off
-            if (millis()-callbackStart < 30) break;
-            //power has been off for 30mS
-            progDriver->setPower(POWERMODE::ON);
-            callbackState=READY;
-            break;
-
-       case READY:  // ready after read, or write after power delay and off period.
-            // power off if we powered it on
-           if (autoPowerOff) {
-              if (Diag::ACK) DIAG(F("Auto Prog power off"));
-              progDriver->setPower(POWERMODE::OFF);
-              /* TODO 
-	      if (MotorDriver::commonFaultPin)
-		DCCWaveform::mainTrack.setPowerMode(POWERMODE::OFF);
-        **/
-           }
-          // Restore <1 JOIN> to state before BASELINE
-          if (ackManagerRejoin) {
-              TrackManager::setJoin(true);
-              if (Diag::ACK) DIAG(F("Auto JOIN"));
-          }
+    case WAITING_30:  // waiting for 30mS with power off
+      if (millis() - callbackStart < 30)
+        break;
+      // power has been off for 30mS
+      progDriver->setPower(POWERMODE::ON);
+      callbackState = READY;
+      break;
+
+    case READY:  // ready after read, or write after power delay and off period.
+                 // power off if we powered it on
+      if (autoPowerOff) {
+        if (Diag::ACK)
+          DIAG(F("Auto Prog power off"));
+        progDriver->setPower(POWERMODE::OFF);
+        /* TODO
+  if (MotorDriver::commonFaultPin)
+DCCWaveform::mainTrack.setPowerMode(POWERMODE::OFF);
+  **/
+      }
+      // Restore <1 JOIN> to state before BASELINE
+      if (ackManagerRejoin) {
+        TrackManager::setJoin(true);
+        if (Diag::ACK)
+          DIAG(F("Auto JOIN"));
+      }
@@ -437,4 +455,5 @@ void DCCACK::callback(int value) {
-          ackManagerProg=NULL;  // no more steps to execute
-          if (Diag::ACK) DIAG(F("Callback(%d)"),value);
-          (ackManagerCallback)( value);
-    }
+      ackManagerProg = NULL;  // no more steps to execute
+      if (Diag::ACK)
+        DIAG(F("Callback(%d)"), value);
+      (ackManagerCallback)(value);
+  }
@@ -445,30 +464,14 @@ void DCCACK::checkAck(byte sentResetsSincePacket) {
-    if (!ackPending) return; 
-    // This function operates in interrupt() time so must be fast and can't DIAG 
-    if (sentResetsSincePacket > 6) {  //ACK timeout
-        ackCheckDuration=millis()-ackCheckStart;
-        ackPending = false;
-        return; 
-    }
-      
-    int current=progDriver->getCurrentRaw(true); // true means "from interrupt"
-    numAckSamples++;
-    if (current > ackMaxCurrent) ackMaxCurrent=current;
-    // An ACK is a pulse lasting between minAckPulseDuration and maxAckPulseDuration uSecs (refer @haba)
-        
-    if (current>ackThreshold) {
-       if (trailingEdgeCounter > 0) {
-	 numAckGaps++;
-	 trailingEdgeCounter = 0;
-       }
-       if (ackPulseStart==0) ackPulseStart=micros();    // leading edge of pulse detected
-       return;
-    }
-    
-    // not in pulse
-    if (ackPulseStart==0) return; // keep waiting for leading edge 
-    
-    // if we reach to this point, we have
-    // detected trailing edge of pulse
-    if (trailingEdgeCounter == 0) {
-      ackPulseDuration=micros()-ackPulseStart;
-    }
+  if (!ackPending)
+    return;
+  // This function operates in interrupt() time so must be fast and can't DIAG
+  if (sentResetsSincePacket > 6) {  // ACK timeout
+    ackCheckDuration = millis() - ackCheckStart;
+    ackPending = false;
+    return;
+  }
+
+  int current = progDriver->getCurrentRaw(true);  // true means "from interrupt"
+  numAckSamples++;
+  if (current > ackMaxCurrent)
+    ackMaxCurrent = current;
+  // An ACK is a pulse lasting between minAckPulseDuration and maxAckPulseDuration uSecs (refer @haba)
@@ -476,6 +479,4 @@ void DCCACK::checkAck(byte sentResetsSincePacket) {
-    // but we do not trust it yet and return (which will force another
-    // measurement) and first the third time around with low current
-    // the ack detection will be finalized. 
-    if (trailingEdgeCounter < 2) {
-      trailingEdgeCounter++;
-      return;
+  if (current > ackThreshold) {
+    if (trailingEdgeCounter > 0) {
+      numAckGaps++;
+      trailingEdgeCounter = 0;
@@ -483,10 +484,32 @@ void DCCACK::checkAck(byte sentResetsSincePacket) {
-    trailingEdgeCounter = 0;
-
-    if (ackPulseDuration>=minAckPulseDuration && ackPulseDuration<=maxAckPulseDuration) {
-        ackCheckDuration=millis()-ackCheckStart;
-        ackDetected=true;
-        ackPending=false;
-        DCCWaveform::progTrack.clearRepeats();  // shortcut remaining repeat packets 
-        return;  // we have a genuine ACK result
-    }      
-    ackPulseStart=0;  // We have detected a too-short or too-long pulse so ignore and wait for next leading edge 
+    if (ackPulseStart == 0)
+      ackPulseStart = micros();  // leading edge of pulse detected
+    return;
+  }
+
+  // not in pulse
+  if (ackPulseStart == 0)
+    return;  // keep waiting for leading edge
+
+  // if we reach to this point, we have
+  // detected trailing edge of pulse
+  if (trailingEdgeCounter == 0) {
+    ackPulseDuration = micros() - ackPulseStart;
+  }
+
+  // but we do not trust it yet and return (which will force another
+  // measurement) and first the third time around with low current
+  // the ack detection will be finalized.
+  if (trailingEdgeCounter < 2) {
+    trailingEdgeCounter++;
+    return;
+  }
+  trailingEdgeCounter = 0;
+
+  if (ackPulseDuration >= minAckPulseDuration && ackPulseDuration <= maxAckPulseDuration) {
+    ackCheckDuration = millis() - ackCheckStart;
+    ackDetected = true;
+    ackPending = false;
+    DCCWaveform::progTrack.clearRepeats();  // shortcut remaining repeat packets
+    return;                                 // we have a genuine ACK result
+  }
+  ackPulseStart = 0;  // We have detected a too-short or too-long pulse so ignore and wait for next leading edge
diff --git a/DCCACK.h b/DCCACK.h
index c50dbbd..c327cd3 100644
--- a/DCCACK.h
+++ b/DCCACK.h
@@ -8 +8 @@
- *  
+ *
@@ -31,3 +31,2 @@ typedef void (*ACK_CALLBACK)(int16_t result);
-enum ackOp : byte
-{           // Program opcodes for the ack Manager
-  BASELINE, // ensure enough resets sent before starting and obtain baseline current
+enum ackOp : byte {  // Program opcodes for the ack Manager
+  BASELINE,          // ensure enough resets sent before starting and obtain baseline current
@@ -35,27 +34,27 @@ enum ackOp : byte
-  W1,               // issue write bit (0..1) packet
-  WB,               // issue write byte packet
-  VB,               // Issue validate Byte packet
-  V0,               // Issue validate bit=0 packet
-  V1,               // issue validate bit=1 packlet
-  WACK,             // wait for ack (or absence of ack)
-  ITC1,             // If True Callback(1)  (if prevous WACK got an ACK)
-  ITC0,             // If True callback(0);
-  ITCB,             // If True callback(byte)
-  ITCBV,            // If True callback(byte) - end of Verify Byte
-  ITCB7,            // If True callback(byte &0x7F)
-  NAKFAIL,          // if false callback(-1)
-  CALLFAIL,         // callback(-1)
-  BIV,              // Set ackManagerByte to initial value for Verify retry
-  STARTMERGE,       // Clear bit and byte settings ready for merge pass
-  MERGE,            // Merge previous wack response with byte value and decrement bit number (use for readimng CV bytes)
-  SETBIT,           // sets bit number to next prog byte
-  SETCV,            // sets cv number to next prog byte
-  SETBYTE,          // sets current byte to next prog byte
-  SETBYTEH,         // sets current byte to word high byte
-  SETBYTEL,         // sets current byte to word low byte
-  STASHLOCOID,      // keeps current byte value for later
-  COMBINELOCOID,    // combines current value with stashed value and returns it
-  ITSKIP,           // skip to SKIPTARGET if ack true
-  NAKSKIP,          // skip to SKIPTARGET if ack false
-  COMBINE1920,      // combine cvs 19 and 20 and callback
-  SKIPTARGET = 0xFF // jump to target
+  W1,                // issue write bit (0..1) packet
+  WB,                // issue write byte packet
+  VB,                // Issue validate Byte packet
+  V0,                // Issue validate bit=0 packet
+  V1,                // issue validate bit=1 packlet
+  WACK,              // wait for ack (or absence of ack)
+  ITC1,              // If True Callback(1)  (if prevous WACK got an ACK)
+  ITC0,              // If True callback(0);
+  ITCB,              // If True callback(byte)
+  ITCBV,             // If True callback(byte) - end of Verify Byte
+  ITCB7,             // If True callback(byte &0x7F)
+  NAKFAIL,           // if false callback(-1)
+  CALLFAIL,          // callback(-1)
+  BIV,               // Set ackManagerByte to initial value for Verify retry
+  STARTMERGE,        // Clear bit and byte settings ready for merge pass
+  MERGE,             // Merge previous wack response with byte value and decrement bit number (use for readimng CV bytes)
+  SETBIT,            // sets bit number to next prog byte
+  SETCV,             // sets cv number to next prog byte
+  SETBYTE,           // sets current byte to next prog byte
+  SETBYTEH,          // sets current byte to word high byte
+  SETBYTEL,          // sets current byte to word low byte
+  STASHLOCOID,       // keeps current byte value for later
+  COMBINELOCOID,     // combines current value with stashed value and returns it
+  ITSKIP,            // skip to SKIPTARGET if ack true
+  NAKSKIP,           // skip to SKIPTARGET if ack false
+  COMBINE1920,       // combine cvs 19 and 20 and callback
+  SKIPTARGET = 0xFF  // jump to target
@@ -64,9 +63 @@ enum ackOp : byte
-enum   CALLBACK_STATE : byte {
-
-  AFTER_READ,   // Start callback sequence after something was read from the decoder  
-  AFTER_WRITE,  // Start callback sequence after something was written to the decoder  
-  WAITING_100,        // Waiting for 100mS of stable power 
-  WAITING_30,         // waiting to 30ms of power off gap. 
-  READY,              // Ready to complete callback  
-  }; 
-
+enum CALLBACK_STATE : byte {
@@ -73,0 +65,6 @@ enum   CALLBACK_STATE : byte {
+  AFTER_READ,   // Start callback sequence after something was read from the decoder
+  AFTER_WRITE,  // Start callback sequence after something was written to the decoder
+  WAITING_100,  // Waiting for 100mS of stable power
+  WAITING_30,   // waiting to 30ms of power off gap.
+  READY,        // Ready to complete callback
+};
@@ -76,12 +73,12 @@ class DCCACK {
-  public:
-    static byte getAck();               //prog track only 0=NACK, 1=ACK 2=keep waiting
-    static void checkAck(byte sentResetsSincePacket); // Interrupt time ack checker
-    static inline void setAckLimit(int mA) {
-	ackLimitmA = mA;
-    }
-    static inline void setMinAckPulseDuration(unsigned long i) {
-	minAckPulseDuration = i;
-    }
-    static inline void setMaxAckPulseDuration(unsigned long i) {
-	maxAckPulseDuration = i;
-    }
+ public:
+  static byte getAck();                              // prog track only 0=NACK, 1=ACK 2=keep waiting
+  static void checkAck(byte sentResetsSincePacket);  // Interrupt time ack checker
+  static inline void setAckLimit(int mA) {
+    ackLimitmA = mA;
+  }
+  static inline void setMinAckPulseDuration(unsigned long i) {
+    minAckPulseDuration = i;
+  }
+  static inline void setMaxAckPulseDuration(unsigned long i) {
+    maxAckPulseDuration = i;
+  }
@@ -89,4 +86,6 @@ class DCCACK {
-    static void  Setup(int cv, byte byteValueOrBitnum, ackOp const program[], ACK_CALLBACK callback);
-    static void  Setup(int wordval, ackOp const program[], ACK_CALLBACK callback);
-    static void loop();
-    static bool isActive() { return ackManagerProg!=NULL;}
+  static void Setup(int cv, byte byteValueOrBitnum, ackOp const program[], ACK_CALLBACK callback);
+  static void Setup(int wordval, ackOp const program[], ACK_CALLBACK callback);
+  static void loop();
+  static bool isActive() {
+    return ackManagerProg != NULL;
+  }
@@ -99,0 +99,13 @@ class DCCACK {
+ private:
+  static const byte SET_SPEED = 0x3f;
+  static const byte WRITE_BYTE = 0x7C;
+  static const byte VERIFY_BYTE = 0x74;
+  static const byte BIT_MANIPULATE = 0x78;
+  static const byte WRITE_BIT = 0xF0;
+  static const byte VERIFY_BIT = 0xE0;
+  static const byte BIT_ON = 0x08;
+  static const byte BIT_OFF = 0x00;
+
+  static void setAckBaseline();
+  static void setAckPending();
+  static void callback(int value);
@@ -101,19 +113 @@ class DCCACK {
-  private:
-    static const byte SET_SPEED = 0x3f;
-    static const byte WRITE_BYTE = 0x7C;
-    static const byte VERIFY_BYTE = 0x74;
-    static const byte BIT_MANIPULATE = 0x78;
-    static const byte WRITE_BIT = 0xF0;
-    static const byte VERIFY_BIT = 0xE0;
-    static const byte BIT_ON = 0x08;
-    static const byte BIT_OFF = 0x00;
- 
-    static void setAckBaseline();
-    static void setAckPending();  
-    static void callback(int value);
-    
-    static const int PROG_REPEATS = 8; // repeats of programming commands (some decoders need at least 8 to be reliable)
-    
-    // ACK management (Prog track only)  
-    static void checkAck();
-    static bool checkResets(uint8_t numResets);
+  static const int PROG_REPEATS = 8;  // repeats of programming commands (some decoders need at least 8 to be reliable)
@@ -121,10 +115,3 @@ class DCCACK {
-    static volatile bool ackPending;
-    static volatile bool ackDetected;
-    static int  ackThreshold; 
-    static int  ackLimitmA;
-    static int ackMaxCurrent;
-    static unsigned long ackCheckStart; // millis
-    static unsigned int ackCheckDuration; // millis       
-    
-    static unsigned long ackPulseDuration;  // micros
-    static unsigned long ackPulseStart; // micros
+  // ACK management (Prog track only)
+  static void checkAck();
+  static bool checkResets(uint8_t numResets);
@@ -132,23 +119,7 @@ class DCCACK {
-    static unsigned long minAckPulseDuration ; // micros
-    static unsigned long maxAckPulseDuration ; // micros
-    static MotorDriver* progDriver;
-    static volatile uint8_t numAckGaps;
-    static volatile uint8_t numAckSamples;
-    static uint8_t trailingEdgeCounter;
-    static ackOp  const *  ackManagerProg;
-static ackOp  const *  ackManagerProgStart;
-static byte   ackManagerByte;
-static byte   ackManagerByteVerify;
-static byte   ackManagerStash;
-static int    ackManagerWord;
-static byte   ackManagerRetry;
-static byte   ackRetry;
-static int16_t ackRetrySum;
-static int16_t  ackRetryPSum;
-static int    ackManagerCv;
-static byte   ackManagerBitNum;
-static bool   ackReceived;
-static bool   ackManagerRejoin;
-static bool   autoPowerOff;
-static CALLBACK_STATE callbackState;
-static ACK_CALLBACK ackManagerCallback;
+  static volatile bool ackPending;
+  static volatile bool ackDetected;
+  static int ackThreshold;
+  static int ackLimitmA;
+  static int ackMaxCurrent;
+  static unsigned long ackCheckStart;    // millis
+  static unsigned int ackCheckDuration;  // millis
@@ -155,0 +127,2 @@ static ACK_CALLBACK ackManagerCallback;
+  static unsigned long ackPulseDuration;  // micros
+  static unsigned long ackPulseStart;     // micros
@@ -156,0 +130,23 @@ static ACK_CALLBACK ackManagerCallback;
+  static unsigned long minAckPulseDuration;  // micros
+  static unsigned long maxAckPulseDuration;  // micros
+  static MotorDriver* progDriver;
+  static volatile uint8_t numAckGaps;
+  static volatile uint8_t numAckSamples;
+  static uint8_t trailingEdgeCounter;
+  static ackOp const* ackManagerProg;
+  static ackOp const* ackManagerProgStart;
+  static byte ackManagerByte;
+  static byte ackManagerByteVerify;
+  static byte ackManagerStash;
+  static int ackManagerWord;
+  static byte ackManagerRetry;
+  static byte ackRetry;
+  static int16_t ackRetrySum;
+  static int16_t ackRetryPSum;
+  static int ackManagerCv;
+  static byte ackManagerBitNum;
+  static bool ackReceived;
+  static bool ackManagerRejoin;
+  static bool autoPowerOff;
+  static CALLBACK_STATE callbackState;
+  static ACK_CALLBACK ackManagerCallback;
diff --git a/DCCEX.h b/DCCEX.h
index 3aa7b7a..aafa452 100644
--- a/DCCEX.h
+++ b/DCCEX.h
@@ -6 +6 @@
- *  
+ *
@@ -24 +24 @@
-// If there were any #ifdefs required they are much better handled in here.  
+// If there were any #ifdefs required they are much better handled in here.
@@ -51 +51 @@
-#include "DCCTimer.h"    
+#include "DCCTimer.h"
@@ -54 +54 @@
-    
+
diff --git a/DCCEXParser.cpp b/DCCEXParser.cpp
index 6bec5fb..2757290 100644
--- a/DCCEXParser.cpp
+++ b/DCCEXParser.cpp
@@ -12 +12 @@
- *  
+ *
@@ -71 +71 @@ Once a new OPCODE is decided upon, update this list.
-  m, message to throttles broadcast 
+  m, message to throttles broadcast
@@ -74 +74 @@ Once a new OPCODE is decided upon, update this list.
-  N, Reserved for Sensorcam 
+  N, Reserved for Sensorcam
@@ -95 +95 @@ Once a new OPCODE is decided upon, update this list.
-  y, 
+  y,
@@ -101 +100,0 @@ Once a new OPCODE is decided upon, update this list.
-#include "StringFormatter.h"
@@ -102,0 +102,3 @@ Once a new OPCODE is decided upon, update this list.
+
+#include "CamParser.h"
+#include "CommandDistributor.h"
@@ -103,0 +106 @@ Once a new OPCODE is decided upon, update this list.
+#include "DCCTimer.h"
@@ -105 +108,5 @@ Once a new OPCODE is decided upon, update this list.
-#include "Turnouts.h"
+#include "DIAG.h"
+#include "EEStore.h"
+#include "EXRAIL2.h"
+#include "GITHUB_SHA.h"
+#include "KeywordHasher.h"
@@ -108,6 +115 @@ Once a new OPCODE is decided upon, update this list.
-#include "GITHUB_SHA.h"
-#include "version.h"
-#include "defines.h"
-#include "CommandDistributor.h"
-#include "EEStore.h"
-#include "DIAG.h"
+#include "StringFormatter.h"
@@ -115,2 +117 @@ Once a new OPCODE is decided upon, update this list.
-#include "DCCTimer.h"
-#include "EXRAIL2.h"
+#include "Turnouts.h"
@@ -117,0 +119 @@ Once a new OPCODE is decided upon, update this list.
+#include "defines.h"
@@ -119,2 +120,0 @@ Once a new OPCODE is decided upon, update this list.
-#include "KeywordHasher.h"
-#include "CamParser.h"
@@ -126,7 +126,8 @@ Once a new OPCODE is decided upon, update this list.
-// flashlist requires a far pointer for high flash access. 
-#define SENDFLASHLIST(stream,flashList)                 \
-    for (int16_t i=0;;i+=sizeof(flashList[0])) {                            \
-        int16_t value=GETHIGHFLASHW(flashList,i);       \
-        if (value==INT16_MAX) break;                            \
-        StringFormatter::send(stream,F(" %d"),value);	\
-    }                                   
+// flashlist requires a far pointer for high flash access.
+#define SENDFLASHLIST(stream, flashList)            \
+  for (int16_t i = 0;; i += sizeof(flashList[0])) { \
+    int16_t value = GETHIGHFLASHW(flashList, i);    \
+    if (value == INT16_MAX)                         \
+      break;                                        \
+    StringFormatter::send(stream, F(" %d"), value); \
+  }
@@ -136,3 +137,3 @@ bool DCCEXParser::stashBusy;
-Print *DCCEXParser::stashStream = NULL;
-RingStream *DCCEXParser::stashRingStream = NULL;
-byte DCCEXParser::stashTarget=0;
+Print* DCCEXParser::stashStream = NULL;
+RingStream* DCCEXParser::stashRingStream = NULL;
+byte DCCEXParser::stashTarget = 0;
@@ -145,0 +147,24 @@ byte DCCEXParser::stashTarget=0;
+int16_t DCCEXParser::splitValues(int16_t result[MAX_COMMAND_PARAMS], byte* cmd, bool usehex) {
+  byte state = 1;
+  byte parameterCount = 0;
+  int16_t runningValue = 0;
+  byte* remainingCmd = cmd + 1;  // skips the opcode
+  bool signNegative = false;
+
+  // clear all parameters in case not enough found
+  for (int16_t i = 0; i < MAX_COMMAND_PARAMS; i++) result[i] = 0;
+
+  while (parameterCount < MAX_COMMAND_PARAMS) {
+    byte hot = *remainingCmd;
+    switch (state) {
+      case 1:  // skipping spaces before a param
+        if (hot == ' ')
+          break;
+        if (hot == '\0')
+          return -1;
+        if (hot == '>') {
+          *remainingCmd = '\0';  // terminate the cmd string with 0 instead of '>'
+          return parameterCount;
+        }
+        state = 2;
+        continue;
@@ -147,31 +172 @@ byte DCCEXParser::stashTarget=0;
-int16_t DCCEXParser::splitValues(int16_t result[MAX_COMMAND_PARAMS], byte *cmd, bool usehex)
-{
-    byte state = 1;
-    byte parameterCount = 0;
-    int16_t runningValue = 0;
-    byte *remainingCmd = cmd + 1; // skips the opcode
-    bool signNegative = false;
-
-    // clear all parameters in case not enough found
-    for (int16_t i = 0; i < MAX_COMMAND_PARAMS; i++)
-        result[i] = 0;
-
-    while (parameterCount < MAX_COMMAND_PARAMS)
-    {
-        byte hot = *remainingCmd;
-        switch (state)
-        {
-
-        case 1: // skipping spaces before a param
-            if (hot == ' ')
-                break;
-            if (hot == '\0')
-	      return -1;
-	    if (hot == '>') {
-	      *remainingCmd = '\0';  // terminate the cmd string with 0 instead of '>'
-	      return parameterCount;
-	    }
-            state = 2;
-            continue;
-
-        case 2: // checking sign or quoted string
+      case 2:  // checking sign or quoted string
@@ -179,13 +174,13 @@ int16_t DCCEXParser::splitValues(int16_t result[MAX_COMMAND_PARAMS], byte *cmd,
-	    if (hot == '"') {
-	      // this inserts an extra parameter 0x7777 in front
-	      // of each string parameter as a marker that can
-	      // be checked that a string parameter follows
-	      // This clashes of course with the real value
-	      // 0x7777 which we hope is used seldom
-	      result[parameterCount] = (int16_t)0x7777;
-	      parameterCount++;
-	      result[parameterCount] = (int16_t)(remainingCmd - cmd + 1);
-	      parameterCount++;
-	      state = 4;
-	      break;
-	    }
+        if (hot == '"') {
+          // this inserts an extra parameter 0x7777 in front
+          // of each string parameter as a marker that can
+          // be checked that a string parameter follows
+          // This clashes of course with the real value
+          // 0x7777 which we hope is used seldom
+          result[parameterCount] = (int16_t)0x7777;
+          parameterCount++;
+          result[parameterCount] = (int16_t)(remainingCmd - cmd + 1);
+          parameterCount++;
+          state = 4;
+          break;
+        }
@@ -193,30 +188,29 @@ int16_t DCCEXParser::splitValues(int16_t result[MAX_COMMAND_PARAMS], byte *cmd,
-            signNegative = false;
-            runningValue = 0;
-            state = 3;
-            if (hot != '-')
-                continue;
-            signNegative = true;
-            break;
-        case 3: // building a parameter
-            if (hot >= '0' && hot <= '9')
-            {
-                runningValue = (usehex?16:10) * runningValue + (hot - '0');
-                break;
-            }
-            if (hot >= 'a' && hot <= 'z') hot=hot-'a'+'A'; // uppercase a..z
-            if (usehex && hot>='A' && hot<='F') {
-                // treat A..F as hex not keyword
-                runningValue = 16 * runningValue + (hot - 'A' + 10);
-                break;
-            }
-            if (hot=='_' || (hot >= 'A' && hot <= 'Z'))
-            {
-                // Since JMRI got modified to send keywords in some rare cases, we need this
-                // Super Kluge to turn keywords into a hash value that can be recognised later
-                runningValue = ((runningValue << 5) + runningValue) ^ hot;
-                break;
-            }
-            result[parameterCount] = runningValue * (signNegative ? -1 : 1);
-            parameterCount++;
-            state = 1;
-            continue;
+        signNegative = false;
+        runningValue = 0;
+        state = 3;
+        if (hot != '-')
+          continue;
+        signNegative = true;
+        break;
+      case 3:  // building a parameter
+        if (hot >= '0' && hot <= '9') {
+          runningValue = (usehex ? 16 : 10) * runningValue + (hot - '0');
+          break;
+        }
+        if (hot >= 'a' && hot <= 'z')
+          hot = hot - 'a' + 'A';  // uppercase a..z
+        if (usehex && hot >= 'A' && hot <= 'F') {
+          // treat A..F as hex not keyword
+          runningValue = 16 * runningValue + (hot - 'A' + 10);
+          break;
+        }
+        if (hot == '_' || (hot >= 'A' && hot <= 'Z')) {
+          // Since JMRI got modified to send keywords in some rare cases, we need this
+          // Super Kluge to turn keywords into a hash value that can be recognised later
+          runningValue = ((runningValue << 5) + runningValue) ^ hot;
+          break;
+        }
+        result[parameterCount] = runningValue * (signNegative ? -1 : 1);
+        parameterCount++;
+        state = 1;
+        continue;
@@ -224,9 +218,6 @@ int16_t DCCEXParser::splitValues(int16_t result[MAX_COMMAND_PARAMS], byte *cmd,
-	case 4: // skipover text
-	  if (hot == '\0')        // We did run to end of buffer without finding the "
-	    return -1;
-	  if (hot == '"') {
-	    *remainingCmd = '\0'; // overwrite " in command buffer with the end-of-string
-	    state = 1;
-	  }
-	  break;
-#endif
+      case 4:             // skipover text
+        if (hot == '\0')  // We did run to end of buffer without finding the "
+          return -1;
+        if (hot == '"') {
+          *remainingCmd = '\0';  // overwrite " in command buffer with the end-of-string
+          state = 1;
@@ -234 +225,2 @@ int16_t DCCEXParser::splitValues(int16_t result[MAX_COMMAND_PARAMS], byte *cmd,
-        remainingCmd++;
+        break;
+#endif
@@ -236 +228,3 @@ int16_t DCCEXParser::splitValues(int16_t result[MAX_COMMAND_PARAMS], byte *cmd,
-    return parameterCount;
+    remainingCmd++;
+  }
+  return parameterCount;
@@ -239 +233 @@ int16_t DCCEXParser::splitValues(int16_t result[MAX_COMMAND_PARAMS], byte *cmd,
-extern __attribute__((weak))  void myFilter(Print * stream, byte & opcode, byte & paramCount, int16_t p[]);
+extern __attribute__((weak)) void myFilter(Print* stream, byte& opcode, byte& paramCount, int16_t p[]);
@@ -245,3 +239,2 @@ AT_COMMAND_CALLBACK DCCEXParser::atCommandCallback = 0;
-void DCCEXParser::setFilter(FILTER_CALLBACK filter)
-{
-    filterCallback = filter;
+void DCCEXParser::setFilter(FILTER_CALLBACK filter) {
+  filterCallback = filter;
@@ -249,3 +242,2 @@ void DCCEXParser::setFilter(FILTER_CALLBACK filter)
-void DCCEXParser::setRMFTFilter(FILTER_CALLBACK filter)
-{
-    filterRMFTCallback = filter;
+void DCCEXParser::setRMFTFilter(FILTER_CALLBACK filter) {
+  filterRMFTCallback = filter;
@@ -253,3 +245,2 @@ void DCCEXParser::setRMFTFilter(FILTER_CALLBACK filter)
-void DCCEXParser::setAtCommandCallback(AT_COMMAND_CALLBACK callback)
-{
-    atCommandCallback = callback;
+void DCCEXParser::setAtCommandCallback(AT_COMMAND_CALLBACK callback) {
+  atCommandCallback = callback;
@@ -258,7 +249,7 @@ void DCCEXParser::setAtCommandCallback(AT_COMMAND_CALLBACK callback)
-// Parse an F() string 
-void DCCEXParser::parse(const FSH * cmd) {
-      DIAG(F("SETUP(\"%S\")"),cmd);
-      int size=STRLEN_P((char *)cmd)+1; 
-      char buffer[size];
-      STRCPY_P(buffer,(char *)cmd);
-      parse(&USB_SERIAL,(byte *)buffer,NULL);
+// Parse an F() string
+void DCCEXParser::parse(const FSH* cmd) {
+  DIAG(F("SETUP(\"%S\")"), cmd);
+  int size = STRLEN_P((char*)cmd) + 1;
+  char buffer[size];
+  STRCPY_P(buffer, (char*)cmd);
+  parse(&USB_SERIAL, (byte*)buffer, NULL);
@@ -269 +260 @@ void DCCEXParser::parse(const FSH * cmd) {
-void DCCEXParser::parse(Print *stream,  byte *com,  RingStream *ringStream) {
+void DCCEXParser::parse(Print* stream, byte* com, RingStream* ringStream) {
@@ -273 +264 @@ void DCCEXParser::parse(Print *stream,  byte *com,  RingStream *ringStream) {
-  byte *cForLater = NULL;
+  byte* cForLater = NULL;
@@ -275 +266 @@ void DCCEXParser::parse(Print *stream,  byte *com,  RingStream *ringStream) {
-  for (byte *c=com; c[0] != '\0'; c++) {
+  for (byte* c = com; c[0] != '\0'; c++) {
@@ -278 +269 @@ void DCCEXParser::parse(Print *stream,  byte *com,  RingStream *ringStream) {
-      found=false;
+      found = false;
@@ -281 +272,2 @@ void DCCEXParser::parse(Print *stream,  byte *com,  RingStream *ringStream) {
-      if (cForLater) parseOne(stream, cForLater, ringStream);
+      if (cForLater)
+        parseOne(stream, cForLater, ringStream);
@@ -285 +277,2 @@ void DCCEXParser::parse(Print *stream,  byte *com,  RingStream *ringStream) {
-  if (cForLater) parseOne(stream, cForLater, ringStream);
+  if (cForLater)
+    parseOne(stream, cForLater, ringStream);
@@ -288,2 +281 @@ void DCCEXParser::parse(Print *stream,  byte *com,  RingStream *ringStream) {
-void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-{
+void DCCEXParser::parseOne(Print* stream, byte* com, RingStream* ringStream) {
@@ -291 +283 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    (void)ringStream;
+  (void)ringStream;
@@ -294 +286 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    (void)EEPROM; // tell compiler not to warn this is unused
+  (void)EEPROM;  // tell compiler not to warn this is unused
@@ -296,21 +288,19 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    byte params = 0;
-    if (Diag::CMD)
-        DIAG(F("PARSING:%s"), com);
-    int16_t p[MAX_COMMAND_PARAMS];
-    while (com[0] == '<' || com[0] == ' ')
-        com++; // strip off any number of < or spaces
-    byte opcode = com[0];
-    int16_t splitnum = splitValues(p, com, opcode=='M' || opcode=='P');
-    if (splitnum < 0 || splitnum >= MAX_COMMAND_PARAMS) // if arguments are broken, leave but via printing <X>
-      goto out;
-    // Because of check above we are now inside byte size
-    params = splitnum;
-
-    if (filterCallback)
-        filterCallback(stream, opcode, params, p);
-    if (filterRMFTCallback && opcode!='\0')
-        filterRMFTCallback(stream, opcode, params, p);
-
-    // Functions return from this switch if complete, break from switch implies error <X> to send
-    switch (opcode)
-    {
+  byte params = 0;
+  if (Diag::CMD)
+    DIAG(F("PARSING:%s"), com);
+  int16_t p[MAX_COMMAND_PARAMS];
+  while (com[0] == '<' || com[0] == ' ') com++;  // strip off any number of < or spaces
+  byte opcode = com[0];
+  int16_t splitnum = splitValues(p, com, opcode == 'M' || opcode == 'P');
+  if (splitnum < 0 || splitnum >= MAX_COMMAND_PARAMS)  // if arguments are broken, leave but via printing <X>
+    goto out;
+  // Because of check above we are now inside byte size
+  params = splitnum;
+
+  if (filterCallback)
+    filterCallback(stream, opcode, params, p);
+  if (filterRMFTCallback && opcode != '\0')
+    filterRMFTCallback(stream, opcode, params, p);
+
+  // Functions return from this switch if complete, break from switch implies error <X> to send
+  switch (opcode) {
@@ -318,2 +308,2 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-        return; // filterCallback asked us to ignore
-    case 't':   // THROTTLE <t [REGISTER] CAB SPEED DIRECTION>
+      return;  // filterCallback asked us to ignore
+    case 't':  // THROTTLE <t [REGISTER] CAB SPEED DIRECTION>
@@ -321,12 +311,12 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-        int16_t cab;
-        int16_t tspeed;
-        int16_t direction;
-
-        if (params==1) {  // <t cab>  display state
-	  int16_t slot=DCC::lookupSpeedTable(p[0],false);
-	  if (slot>=0)
-	    CommandDistributor::broadcastLoco(slot);
-	  else // send dummy state speed 0 fwd no functions.
-            StringFormatter::send(stream,F("<l %d -1 128 0>\n"),p[0]);
-	  return;
-        }
+      int16_t cab;
+      int16_t tspeed;
+      int16_t direction;
+
+      if (params == 1) {  // <t cab>  display state
+        int16_t slot = DCC::lookupSpeedTable(p[0], false);
+        if (slot >= 0)
+          CommandDistributor::broadcastLoco(slot);
+        else  // send dummy state speed 0 fwd no functions.
+          StringFormatter::send(stream, F("<l %d -1 128 0>\n"), p[0]);
+        return;
+      }
@@ -334,15 +324,11 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-        if (params == 4)
-        { // <t REGISTER CAB SPEED DIRECTION>
-	    // ignore register p[0]
-            cab = p[1];
-            tspeed = p[2];
-            direction = p[3];
-        }
-        else if (params == 3)
-        { // <t CAB SPEED DIRECTION>
-            cab = p[0];
-            tspeed = p[1];
-            direction = p[2];
-        }
-        else
-            break;
+      if (params == 4) {  // <t REGISTER CAB SPEED DIRECTION>
+                          // ignore register p[0]
+        cab = p[1];
+        tspeed = p[2];
+        direction = p[3];
+      } else if (params == 3) {  // <t CAB SPEED DIRECTION>
+        cab = p[0];
+        tspeed = p[1];
+        direction = p[2];
+      } else
+        break;
@@ -350,22 +336,22 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-        // Convert DCC-EX protocol speed steps where
-        // -1=emergency stop, 0-126 as speeds
-        // to DCC 0=stop, 1= emergency stop, 2-127 speeds
-        if (tspeed > 126 || tspeed < -1)
-            break; // invalid JMRI speed code
-        if (tspeed < 0)
-            tspeed = 1; // emergency stop DCC speed
-        else if (tspeed > 0)
-            tspeed++; // map 1-126 -> 2-127
-        if (cab == 0 && tspeed > 1)
-            break; // ignore broadcasts of speed>1
-
-        if (direction < 0 || direction > 1)
-            break; // invalid direction code
-	if (cab > 10239 || cab < 0)
-	    break; // beyond DCC range
-
-        DCC::setThrottle(cab, tspeed, direction);
-        if (params == 4) // send obsolete format T response
-            StringFormatter::send(stream, F("<T %d %d %d>\n"), p[0], p[2], p[3]);
-        // speed change will be broadcast anyway in new <l > format
-        return;
+      // Convert DCC-EX protocol speed steps where
+      // -1=emergency stop, 0-126 as speeds
+      // to DCC 0=stop, 1= emergency stop, 2-127 speeds
+      if (tspeed > 126 || tspeed < -1)
+        break;  // invalid JMRI speed code
+      if (tspeed < 0)
+        tspeed = 1;  // emergency stop DCC speed
+      else if (tspeed > 0)
+        tspeed++;  // map 1-126 -> 2-127
+      if (cab == 0 && tspeed > 1)
+        break;  // ignore broadcasts of speed>1
+
+      if (direction < 0 || direction > 1)
+        break;  // invalid direction code
+      if (cab > 10239 || cab < 0)
+        break;  // beyond DCC range
+
+      DCC::setThrottle(cab, tspeed, direction);
+      if (params == 4)  // send obsolete format T response
+        StringFormatter::send(stream, F("<T %d %d %d>\n"), p[0], p[2], p[3]);
+      // speed change will be broadcast anyway in new <l > format
+      return;
@@ -373,4 +359,4 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case 'f': // FUNCTION <f CAB BYTE1 [BYTE2]>
-        if (parsef(stream, params, p))
-            return;
-        break;
+    case 'f':  // FUNCTION <f CAB BYTE1 [BYTE2]>
+      if (parsef(stream, params, p))
+        return;
+      break;
@@ -378,35 +364,33 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case 'a': // ACCESSORY <a ADDRESS SUBADDRESS ACTIVATE [ONOFF]> or <a LINEARADDRESS ACTIVATE>
-        { 
-          int address;
-          byte subaddress;
-          byte activep;
-          byte onoff;
-          if (params==2) { // <a LINEARADDRESS ACTIVATE>
-              address=(p[0] - 1) / 4 + 1;
-              subaddress=(p[0] - 1)  % 4;
-              activep=1;
-              onoff=2; // send both
-          }
-          else if (params==3) { // <a ADDRESS SUBADDRESS ACTIVATE>
-              address=p[0];
-              subaddress=p[1];
-              activep=2;
-              onoff=2; // send both
-          }
-          else if (params==4) { // <a ADDRESS SUBADDRESS ACTIVATE ONOFF>
-              address=p[0];
-              subaddress=p[1];
-              activep=2;
-	      if ((p[3] < 0) || (p[3] > 1))        // invalid onoff    0|1
-		break;
-              onoff=p[3];
-          }
-          else break; // invalid no of parameters
-          
-          if (
-	      ((address & 0x01FF) != address)      // invalid address (limit 9 bits)
-           || ((subaddress & 0x03) != subaddress)  // invalid subaddress (limit 2 bits)
-           || (p[activep] > 1) || (p[activep] < 0) // invalid activate 0|1
-	      ) break;
-          // Honour the configuration option (config.h) which allows the <a> command to be reversed
-	  // Because of earlier confusion we need to do the same thing under both defines
+    case 'a':  // ACCESSORY <a ADDRESS SUBADDRESS ACTIVATE [ONOFF]> or <a LINEARADDRESS ACTIVATE>
+    {
+      int address;
+      byte subaddress;
+      byte activep;
+      byte onoff;
+      if (params == 2) {  // <a LINEARADDRESS ACTIVATE>
+        address = (p[0] - 1) / 4 + 1;
+        subaddress = (p[0] - 1) % 4;
+        activep = 1;
+        onoff = 2;               // send both
+      } else if (params == 3) {  // <a ADDRESS SUBADDRESS ACTIVATE>
+        address = p[0];
+        subaddress = p[1];
+        activep = 2;
+        onoff = 2;               // send both
+      } else if (params == 4) {  // <a ADDRESS SUBADDRESS ACTIVATE ONOFF>
+        address = p[0];
+        subaddress = p[1];
+        activep = 2;
+        if ((p[3] < 0) || (p[3] > 1))  // invalid onoff    0|1
+          break;
+        onoff = p[3];
+      } else
+        break;  // invalid no of parameters
+
+      if (((address & 0x01FF) != address)          // invalid address (limit 9 bits)
+          || ((subaddress & 0x03) != subaddress)   // invalid subaddress (limit 2 bits)
+          || (p[activep] > 1) || (p[activep] < 0)  // invalid activate 0|1
+      )
+        break;
+      // Honour the configuration option (config.h) which allows the <a> command to be reversed
+      // Because of earlier confusion we need to do the same thing under both defines
@@ -414 +398 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-          DCC::setAccessory(address, subaddress,p[activep]==0,onoff);
+      DCC::setAccessory(address, subaddress, p[activep] == 0, onoff);
@@ -416 +400 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-          DCC::setAccessory(address, subaddress,p[activep]==1,onoff);
+      DCC::setAccessory(address, subaddress, p[activep] == 1, onoff);
@@ -418 +402,8 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-        }
+    }
+      return;
+
+    case 'A':  // EXTENDED ACCESSORY <A address value>
+      // Note: if this happens to match a defined EXRAIL
+      // DCCX_SIGNAL, then EXRAIL will have intercepted
+      // this command alrerady.
+      if (params == 2 && DCC::setExtendedAccessory(p[0], p[1]))
@@ -420,12 +411,6 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    
-    case 'A': // EXTENDED ACCESSORY <A address value> 
-        // Note: if this happens to match a defined EXRAIL 
-        // DCCX_SIGNAL, then EXRAIL will have intercepted
-        // this command alrerady.   
-        if (params==2 && DCC::setExtendedAccessory(p[0],p[1])) return;
-        break;
-     
-    case 'T': // TURNOUT  <T ...>
-        if (parseT(stream, params, p))
-            return;
-        break;
+      break;
+
+    case 'T':  // TURNOUT  <T ...>
+      if (parseT(stream, params, p))
+        return;
+      break;
@@ -435,24 +420 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-        if (p[0]==0) break;
-        {  
-          VPIN vpin=p[0]>0 ? p[0]:-p[0];
-          bool setON=p[0]>0;
-          if (params==1) {  // <o [-]vpin> 
-            IODevice::write(vpin,setON);
-            return;
-          }
-          if (params==2) {  // <o [-]vpin count> 
-            IODevice::writeRange(vpin,setON,p[1]);
-            return;
-          }
-          if (params==4 || params==5) { // <z [-]vpin r g b [count]>
-             auto count=p[4]?p[4]:1;  
-             if (p[1]<0 || p[1]>0xFF) break;  
-            if (p[2]<0 || p[2]>0xFF) break;  
-            if (p[3]<0 || p[3]>0xFF) break;  
-            // strange parameter mangling... see IO_NeoPixel.h NeoPixel::_writeAnalogue
-            int colour_RG=(p[1]<<8)  | p[2];
-            uint16_t colour_B=p[3];
-            IODevice::writeAnalogueRange(vpin,colour_RG,setON,colour_B,count);
-            return;
-            }
-        }
+      if (p[0] == 0)
@@ -460,8 +422,6 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-#endif        
-
-  case 'z':  // direct pin manipulation
-        if (p[0]==0) break; 
-        if (params==1) {  // <z vpin | -vpin> 
-            if (p[0]>0) IODevice::write(p[0],HIGH);
-            else IODevice::write(-p[0],LOW);
-            return;
+      {
+        VPIN vpin = p[0] > 0 ? p[0] : -p[0];
+        bool setON = p[0] > 0;
+        if (params == 1) {  // <o [-]vpin>
+          IODevice::write(vpin, setON);
+          return;
@@ -469,4 +429,3 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-        if (params>=2 && params<=4) { // <z vpin analog profile duration> 
-            // unused params default to 0           
-            IODevice::writeAnalogue(p[0],p[1],p[2],p[3]);
-            return;
+        if (params == 2) {  // <o [-]vpin count>
+          IODevice::writeRange(vpin, setON, p[1]);
+          return;
@@ -474 +433,17 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-        break; 
+        if (params == 4 || params == 5) {  // <z [-]vpin r g b [count]>
+          auto count = p[4] ? p[4] : 1;
+          if (p[1] < 0 || p[1] > 0xFF)
+            break;
+          if (p[2] < 0 || p[2] > 0xFF)
+            break;
+          if (p[3] < 0 || p[3] > 0xFF)
+            break;
+          // strange parameter mangling... see IO_NeoPixel.h NeoPixel::_writeAnalogue
+          int colour_RG = (p[1] << 8) | p[2];
+          uint16_t colour_B = p[3];
+          IODevice::writeAnalogueRange(vpin, colour_RG, setON, colour_B, count);
+          return;
+        }
+      }
+      break;
+#endif
@@ -476,3 +451,2 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case 'Z': // OUTPUT <Z ...>
-        if (parseZ(stream, params, p))
-            return;
+    case 'z':  // direct pin manipulation
+      if (p[0] == 0)
@@ -479,0 +454,13 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
+      if (params == 1) {  // <z vpin | -vpin>
+        if (p[0] > 0)
+          IODevice::write(p[0], HIGH);
+        else
+          IODevice::write(-p[0], LOW);
+        return;
+      }
+      if (params >= 2 && params <= 4) {  // <z vpin analog profile duration>
+        // unused params default to 0
+        IODevice::writeAnalogue(p[0], p[1], p[2], p[3]);
+        return;
+      }
+      break;
@@ -481,4 +468,9 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case 'S': // SENSOR <S ...>
-        if (parseS(stream, params, p))
-            return;
-        break;
+    case 'Z':  // OUTPUT <Z ...>
+      if (parseZ(stream, params, p))
+        return;
+      break;
+
+    case 'S':  // SENSOR <S ...>
+      if (parseS(stream, params, p))
+        return;
+      break;
@@ -487 +479 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case 'w': // WRITE CV on MAIN <w CAB CV VALUE>
+    case 'w':  // WRITE CV on MAIN <w CAB CV VALUE>
@@ -489 +481 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-	break;
+        break;
@@ -493 +485 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case 'b': // WRITE CV BIT ON MAIN <b CAB CV BIT VALUE>
+    case 'b':  // WRITE CV BIT ON MAIN <b CAB CV BIT VALUE>
@@ -495 +487 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-	break;
+        break;
@@ -500 +492 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case 'M': // WRITE TRANSPARENT DCC PACKET MAIN <M REG X1 ... X9>
+    case 'M':  // WRITE TRANSPARENT DCC PACKET MAIN <M REG X1 ... X9>
@@ -502 +494 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case 'P': // WRITE TRANSPARENT DCC PACKET PROG <P REG X1 ... X9>
+    case 'P':  // WRITE TRANSPARENT DCC PACKET PROG <P REG X1 ... X9>
@@ -504,11 +496,12 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-        // NOTE: this command was parsed in HEX instead of decimal
-        params--; // drop REG
-        if (params<1) break;
-	if (params > MAX_PACKET_SIZE) break;
-        {
-          byte packet[params];
-          for (int i=0;i<params;i++) {
-            packet[i]=(byte)p[i+1];
-            if (Diag::CMD) DIAG(F("packet[%d]=%d (0x%x)"), i, packet[i], packet[i]);
-          }
-          (opcode=='M'?DCCWaveform::mainTrack:DCCWaveform::progTrack).schedulePacket(packet,params,3);  
+               // NOTE: this command was parsed in HEX instead of decimal
+      params--;  // drop REG
+      if (params < 1)
+        break;
+      if (params > MAX_PACKET_SIZE)
+        break;
+      {
+        byte packet[params];
+        for (int i = 0; i < params; i++) {
+          packet[i] = (byte)p[i + 1];
+          if (Diag::CMD)
+            DIAG(F("packet[%d]=%d (0x%x)"), i, packet[i], packet[i]);
@@ -516,2 +509,4 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-        return;
-        
+        (opcode == 'M' ? DCCWaveform::mainTrack : DCCWaveform::progTrack).schedulePacket(packet, params, 3);
+      }
+      return;
+
@@ -519 +514,17 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case 'W': // WRITE CV ON PROG <W CV VALUE CALLBACKNUM CALLBACKSUB>
+    case 'W':  // WRITE CV ON PROG <W CV VALUE CALLBACKNUM CALLBACKSUB>
+      if (!stashCallback(stream, p, ringStream))
+        break;
+      if (params == 1)  // <W id> Write new loco id (clearing consist and managing short/long)
+        DCC::setLocoId(p[0], callback_Wloco);
+      else if (params == 4)  // WRITE CV ON PROG <W CV VALUE [CALLBACKNUM] [CALLBACKSUB]>
+        DCC::writeCVByte(p[0], p[1], callback_W4);
+      else if ((params == 2 || params == 3) && p[0] == "CONSIST"_hk) {
+        DCC::setConsistId(p[1], p[2] == "REVERSE"_hk, callback_Wconsist);
+      } else if (params == 2)  // WRITE CV ON PROG <W CV VALUE>
+        DCC::writeCVByte(p[0], p[1], callback_W);
+      else
+        break;
+      return;
+
+    case 'V':             // VERIFY CV ON PROG <V CV VALUE> <V CV BIT 0|1>
+      if (params == 2) {  // <V CV VALUE>
@@ -521,12 +532,8 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-	    break;
-        if (params == 1) // <W id> Write new loco id (clearing consist and managing short/long)
-            DCC::setLocoId(p[0],callback_Wloco);
-        else if (params == 4)  // WRITE CV ON PROG <W CV VALUE [CALLBACKNUM] [CALLBACKSUB]>
-            DCC::writeCVByte(p[0], p[1], callback_W4);
-        else if ((params==2 || params==3 ) && p[0]=="CONSIST"_hk ) {
-            DCC::setConsistId(p[1],p[2]=="REVERSE"_hk,callback_Wconsist);
-        }    
-        else if (params == 2)  // WRITE CV ON PROG <W CV VALUE>
-            DCC::writeCVByte(p[0], p[1], callback_W);
-	else
-            break;
+          break;
+        DCC::verifyCVByte(p[0], p[1], callback_Vbyte);
+        return;
+      }
+      if (params == 3) {
+        if (!stashCallback(stream, p, ringStream))
+          break;
+        DCC::verifyCVBit(p[0], p[1], p[2], callback_Vbit);
@@ -533,0 +541,2 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
+      }
+      break;
@@ -535,15 +544,2 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case 'V': // VERIFY CV ON PROG <V CV VALUE> <V CV BIT 0|1>
-        if (params == 2)
-        { // <V CV VALUE>
-            if (!stashCallback(stream, p, ringStream))
-                break;
-            DCC::verifyCVByte(p[0], p[1], callback_Vbyte);
-            return;
-        }
-        if (params == 3)
-        {
-            if (!stashCallback(stream, p, ringStream))
-                break;
-            DCC::verifyCVBit(p[0], p[1], p[2], callback_Vbit);
-            return;
-        }
+    case 'B':  // WRITE CV BIT ON PROG  <B CV BIT VALUE CALLBACKNUM CALLBACKSUB> or <B CV BIT VALUE>
+      if (params != 3 && params != 5)
@@ -550,0 +547,4 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
+      if (!stashCallback(stream, p, ringStream))
+        break;
+      DCC::writeCVBit(p[0], p[1], p[2], callback_B);
+      return;
@@ -552,3 +552,14 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case 'B': // WRITE CV BIT ON PROG  <B CV BIT VALUE CALLBACKNUM CALLBACKSUB> or <B CV BIT VALUE>
-        if (params != 3 && params != 5)
-	  break;
+    case 'R':             // READ CV ON PROG
+      if (params == 1) {  // <R CV> -- uses verify callback
+        if (!stashCallback(stream, p, ringStream))
+          break;
+        DCC::verifyCVByte(p[0], 0, callback_Vbyte);
+        return;
+      }
+      if (params == 3) {  // <R CV CALLBACKNUM CALLBACKSUB>
+        if (!stashCallback(stream, p, ringStream))
+          break;
+        DCC::readCV(p[0], callback_R);
+        return;
+      }
+      if (params == 0) {  // <R> New read loco id
@@ -556,2 +567,2 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-	  break;
-        DCC::writeCVBit(p[0], p[1], p[2], callback_B);
+          break;
+        DCC::getLocoId(callback_Rloco);
@@ -558,0 +570,3 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
+      }
+      break;
+#endif
@@ -560,14 +574,10 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case 'R': // READ CV ON PROG
-        if (params == 1)
-        { // <R CV> -- uses verify callback
-            if (!stashCallback(stream, p, ringStream))
-                break;
-            DCC::verifyCVByte(p[0], 0, callback_Vbyte);
-            return;
-        }
-        if (params == 3)
-        { // <R CV CALLBACKNUM CALLBACKSUB>
-            if (!stashCallback(stream, p, ringStream))
-                break;
-            DCC::readCV(p[0], callback_R);
-            return;
+    case '1':  // POWERON <1   [MAIN|PROG|JOIN]>
+    {
+      if (params > 1)
+        break;
+      if (params == 0) {  // All
+        TrackManager::setTrackPower(TRACK_ALL, POWERMODE::ON);
+      }
+      if (params == 1) {
+        if (p[0] == "MAIN"_hk) {  // <1 MAIN>
+          TrackManager::setTrackPower(TRACK_MODE_MAIN, POWERMODE::ON);
@@ -575,6 +585,7 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-        if (params == 0)
-        { // <R> New read loco id
-            if (!stashCallback(stream, p, ringStream))
-                break;
-            DCC::getLocoId(callback_Rloco);
-            return;
+#ifndef DISABLE_PROG
+        else if (p[0] == "JOIN"_hk) {  // <1 JOIN>
+          TrackManager::setJoin(true);
+          TrackManager::setTrackPower(TRACK_MODE_MAIN | TRACK_MODE_PROG, POWERMODE::ON);
+        } else if (p[0] == "PROG"_hk) {  // <1 PROG>
+          TrackManager::setJoin(false);
+          TrackManager::setTrackPower(TRACK_MODE_PROG, POWERMODE::ON);
@@ -582 +592,0 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-        break;
@@ -583,0 +594,8 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
+        else if (p[0] >= "A"_hk && p[0] <= "H"_hk) {  // <1 A-H>
+          byte t = (p[0] - 'A');
+          TrackManager::setTrackPower(POWERMODE::ON, t);
+          // StringFormatter::send(stream, F("<p1 %c>\n"), t+'A');
+        } else
+          break;  // will reply <X>
+      }
+      // TrackManager::streamTrackState(NULL,t);
@@ -585,44 +603,16 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case '1': // POWERON <1   [MAIN|PROG|JOIN]>
-        {
-	  if (params > 1) break;
-	  if (params==0) { // All
-	    TrackManager::setTrackPower(TRACK_ALL, POWERMODE::ON);
-	  }
-	  if (params==1) {
-	    if (p[0]=="MAIN"_hk) { // <1 MAIN>
-	      TrackManager::setTrackPower(TRACK_MODE_MAIN, POWERMODE::ON);
-            }
-#ifndef DISABLE_PROG
-            else if (p[0] == "JOIN"_hk) {  // <1 JOIN>
-	      TrackManager::setJoin(true);
-	      TrackManager::setTrackPower(TRACK_MODE_MAIN|TRACK_MODE_PROG, POWERMODE::ON);
-            }
-            else if (p[0]=="PROG"_hk) { // <1 PROG>
-	      TrackManager::setJoin(false);
-	      TrackManager::setTrackPower(TRACK_MODE_PROG, POWERMODE::ON);
-            }
-#endif
-            else if (p[0] >= "A"_hk && p[0] <= "H"_hk) { // <1 A-H>
-	      byte t = (p[0] - 'A');
-	      TrackManager::setTrackPower(POWERMODE::ON, t);
-	      //StringFormatter::send(stream, F("<p1 %c>\n"), t+'A');
-            }
-	    else break; // will reply <X>
-	  }
-	  //TrackManager::streamTrackState(NULL,t);
-          
-	  return;
-	}
-            
-    case '0': // POWEROFF <0 [MAIN | PROG] >
-        {
-	  if (params > 1) break;
-	  if (params==0) { // All
-	    TrackManager::setJoin(false);
-	    TrackManager::setTrackPower(TRACK_ALL, POWERMODE::OFF);
-	  }
-	  if (params==1) {
-	    if (p[0]=="MAIN"_hk) { // <0 MAIN>
-	      TrackManager::setJoin(false);
-	      TrackManager::setTrackPower(TRACK_MODE_MAIN, POWERMODE::OFF);
-	    }
+      return;
+    }
+
+    case '0':  // POWEROFF <0 [MAIN | PROG] >
+    {
+      if (params > 1)
+        break;
+      if (params == 0) {  // All
+        TrackManager::setJoin(false);
+        TrackManager::setTrackPower(TRACK_ALL, POWERMODE::OFF);
+      }
+      if (params == 1) {
+        if (p[0] == "MAIN"_hk) {  // <0 MAIN>
+          TrackManager::setJoin(false);
+          TrackManager::setTrackPower(TRACK_MODE_MAIN, POWERMODE::OFF);
+        }
@@ -630 +620 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-            else if (p[0]=="PROG"_hk) { // <0 PROG>
+        else if (p[0] == "PROG"_hk) {  // <0 PROG>
@@ -632,3 +622,3 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-	      TrackManager::progTrackBoosted=false;  // Prog track boost mode will not outlive prog track off
-	      TrackManager::setTrackPower(TRACK_MODE_PROG, POWERMODE::OFF);
-            }
+          TrackManager::progTrackBoosted = false;  // Prog track boost mode will not outlive prog track off
+          TrackManager::setTrackPower(TRACK_MODE_PROG, POWERMODE::OFF);
+        }
@@ -636,14 +626,14 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-	    else if (p[0] >= "A"_hk && p[0] <= "H"_hk) { // <1 A-H>
-	      byte t = (p[0] - 'A');
-	      TrackManager::setJoin(false);
-	      TrackManager::setTrackPower(POWERMODE::OFF, t);
-	      //StringFormatter::send(stream, F("<p0 %c>\n"), t+'A');
-	    }
-	    else break; // will reply <X>
-	  }
-	  return;
-	}
-
-    case '!': // ESTOP ALL  <!>
-        DCC::setThrottle(0,1,1); // this broadcasts speed 1(estop) and sets all reminders to speed 1.
-        return;
+        else if (p[0] >= "A"_hk && p[0] <= "H"_hk) {  // <1 A-H>
+          byte t = (p[0] - 'A');
+          TrackManager::setJoin(false);
+          TrackManager::setTrackPower(POWERMODE::OFF, t);
+          // StringFormatter::send(stream, F("<p0 %c>\n"), t+'A');
+        } else
+          break;  // will reply <X>
+      }
+      return;
+    }
+
+    case '!':                     // ESTOP ALL  <!>
+      DCC::setThrottle(0, 1, 1);  // this broadcasts speed 1(estop) and sets all reminders to speed 1.
+      return;
@@ -652,5 +642,6 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case 'c': // SEND METER RESPONSES <c>
-        // No longer useful because of multiple tracks See <JG> and <JI>
-        if (params>0) break;
-        TrackManager::reportObsoleteCurrent(stream);
-        return;
+    case 'c':  // SEND METER RESPONSES <c>
+      // No longer useful because of multiple tracks See <JG> and <JI>
+      if (params > 0)
+        break;
+      TrackManager::reportObsoleteCurrent(stream);
+      return;
@@ -658,3 +649,3 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case 'Q': // SENSORS <Q>
-        Sensor::printAll(stream);
-        return;
+    case 'Q':  // SENSORS <Q>
+      Sensor::printAll(stream);
+      return;
@@ -662,6 +653,6 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case 's': // STATUS <s>
-        StringFormatter::send(stream, F("<iDCC-EX V-%S / %S / %S G-%S>\n"), F(VERSION), F(ARDUINO_TYPE), DCC::getMotorShieldName(), F(GITHUB_SHA));
-        CommandDistributor::broadcastPower(); // <s> is the only "get power status" command we have
-        Turnout::printAll(stream); //send all Turnout states
-        Sensor::printAll(stream);  //send all Sensor  states
-        return;       
+    case 's':  // STATUS <s>
+      StringFormatter::send(stream, F("<iDCC-EX V-%S / %S / %S G-%S>\n"), F(VERSION), F(ARDUINO_TYPE), DCC::getMotorShieldName(), F(GITHUB_SHA));
+      CommandDistributor::broadcastPower();  // <s> is the only "get power status" command we have
+      Turnout::printAll(stream);             // send all Turnout states
+      Sensor::printAll(stream);              // send all Sensor  states
+      return;
@@ -670,4 +661,5 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case 'E': // STORE EPROM <E>
-        EEStore::store();
-        StringFormatter::send(stream, F("<e %d %d %d>\n"), EEStore::eeStore->data.nTurnouts, EEStore::eeStore->data.nSensors, EEStore::eeStore->data.nOutputs);
-        return;
+    case 'E':  // STORE EPROM <E>
+      EEStore::store();
+      StringFormatter::send(stream, F("<e %d %d %d>\n"), EEStore::eeStore->data.nTurnouts, EEStore::eeStore->data.nSensors,
+                            EEStore::eeStore->data.nOutputs);
+      return;
@@ -675,4 +667,4 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case 'e': // CLEAR EPROM <e>
-        EEStore::clear();
-        StringFormatter::send(stream, F("<O>\n"));
-        return;
+    case 'e':  // CLEAR EPROM <e>
+      EEStore::clear();
+      StringFormatter::send(stream, F("<O>\n"));
+      return;
@@ -680,4 +672,4 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case ' ': // < >
-        StringFormatter::send(stream, F("\n"));
-        return;
-    case 'C': // CONFIG <C [params]>
+    case ' ':  // < >
+      StringFormatter::send(stream, F("\n"));
+      return;
+    case 'C':  // CONFIG <C [params]>
@@ -687,7 +679,7 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-      if (p[0] == "WIFI"_hk) { 	// <C WIFI SSID PASSWORD>
-	if (params != 5)        // the 5 params 0 to 4 are (kinda): WIFI_hk 0x7777 &SSID 0x7777 &PASSWORD
-	  break;
-	if (p[1] == 0x7777 && p[3] == 0x7777) {
-	  WifiESP::setup((const char*)(com + p[2]), (const char*)(com + p[4]), WIFI_HOSTNAME, IP_PORT, WIFI_CHANNEL, WIFI_FORCE_AP);
-	}
-	return;
+      if (p[0] == "WIFI"_hk) {  // <C WIFI SSID PASSWORD>
+        if (params != 5)        // the 5 params 0 to 4 are (kinda): WIFI_hk 0x7777 &SSID 0x7777 &PASSWORD
+          break;
+        if (p[1] == 0x7777 && p[3] == 0x7777) {
+          WifiESP::setup((const char*)(com + p[2]), (const char*)(com + p[4]), WIFI_HOSTNAME, IP_PORT, WIFI_CHANNEL, WIFI_FORCE_AP);
+        }
+        return;
@@ -696 +688 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-#endif //ESP32
+#endif  // ESP32
@@ -698 +690 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-	return;
+        return;
@@ -701,4 +693,4 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case 'D': // DIAG <D [params]>
-        if (parseD(stream, params, p))
-            return;
-        break;
+    case 'D':  // DIAG <D [params]>
+      if (parseD(stream, params, p))
+        return;
+      break;
@@ -706,3 +698,11 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case '=': // TRACK MANAGER CONTROL <= [params]>
-        if (TrackManager::parseEqualSign(stream, params, p))
-            return;
+    case '=':  // TRACK MANAGER CONTROL <= [params]>
+      if (TrackManager::parseEqualSign(stream, params, p))
+        return;
+      break;
+
+    case '#':  // NUMBER OF LOCOSLOTS <#>
+      StringFormatter::send(stream, F("<# %d>\n"), MAX_LOCOS);
+      return;
+
+    case '-':  // Forget Loco <- [cab]>
+      if (params > 1 || p[0] < 0)
@@ -709,0 +710,5 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
+      if (p[0] == 0)
+        DCC::forgetAllLocos();
+      else
+        DCC::forgetLoco(p[0]);
+      return;
@@ -711,2 +716,8 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case '#': // NUMBER OF LOCOSLOTS <#>
-        StringFormatter::send(stream, F("<# %d>\n"), MAX_LOCOS);
+    case 'F':  // New command to call the new Loco Function API <F cab func 1|0>
+      if (params != 3)
+        break;
+
+      if (p[1] == "DCFREQ"_hk) {  // <F cab DCFREQ 0..3>
+        if (p[2] < 0 || p[2] > 3)
+          break;
+        DCC::setDCFreq(p[0], p[2]);
@@ -713,0 +725 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
+      }
@@ -715,4 +727,3 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case '-': // Forget Loco <- [cab]>
-        if (params > 1 || p[0]<0) break;
-        if (p[0]==0) DCC::forgetAllLocos();
-        else  DCC::forgetLoco(p[0]);
+      if (Diag::CMD)
+        DIAG(F("Setting loco %d F%d %S"), p[0], p[1], p[2] ? F("ON") : F("OFF"));
+      if (DCC::setFn(p[0], p[1], p[2] == 1))
@@ -719,0 +731 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
+      break;
@@ -721,8 +733,9 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case 'F': // New command to call the new Loco Function API <F cab func 1|0>
-        if(params!=3) break; 
-        
-        if (p[1]=="DCFREQ"_hk) { // <F cab DCFREQ 0..3>
-          if (p[2]<0 || p[2]>3) break;
-          DCC::setDCFreq(p[0],p[2]);
-          return;    
-        }
+#if WIFI_ON
+    case '+':  // Complex Wifi interface command (not usual parse)
+      if (atCommandCallback && !ringStream) {
+        TrackManager::setPower(POWERMODE::OFF);
+        atCommandCallback((HardwareSerial*)stream, com);
+        return;
+      }
+      break;
+#endif
@@ -730,4 +743,15 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-        if (Diag::CMD)
-            DIAG(F("Setting loco %d F%d %S"), p[0], p[1], p[2] ? F("ON") : F("OFF"));
-        if (DCC::setFn(p[0], p[1], p[2] == 1)) return;
-	break;
+    case 'J':  // throttle info access
+    {
+      if ((params < 1) | (params > 3))
+        break;  // <J>
+      // if ((params<1) | (params>2)) break; // <J>
+      int16_t id = (params == 2) ? p[1] : 0;
+      switch (p[0]) {
+        case "C"_hk:          // <JC mmmm nn> sets time and speed
+          if (params == 1) {  // <JC> returns latest time
+            int16_t x = CommandDistributor::retClockTime();
+            StringFormatter::send(stream, F("<jC %d>\n"), x);
+            return;
+          }
+          CommandDistributor::setClockTime(p[1], p[2], 1);
+          return;
@@ -735,5 +759,4 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-#if WIFI_ON
-    case '+': // Complex Wifi interface command (not usual parse)
-        if (atCommandCallback && !ringStream) {
-          TrackManager::setPower(POWERMODE::OFF);
-          atCommandCallback((HardwareSerial *)stream,com);
+        case "G"_hk:  // <JG> current gauge limits
+          if (params > 1)
+            break;
+          TrackManager::reportGauges(stream);  // <g limit...limit>
@@ -741,42 +764,22 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-        }
-        break;
-#endif 
-
-    case 'J' : // throttle info access
-        {
-            if ((params<1) | (params>3)) break; // <J>
-            //if ((params<1) | (params>2)) break; // <J>
-            int16_t id=(params==2)?p[1]:0;
-            switch(p[0]) {
-                case "C"_hk: // <JC mmmm nn> sets time and speed
-                    if (params==1) { // <JC> returns latest time
-                        int16_t x = CommandDistributor::retClockTime();
-                        StringFormatter::send(stream, F("<jC %d>\n"), x);
-                        return;
-                    }
-                    CommandDistributor::setClockTime(p[1], p[2], 1);
-                    return;
-                
-                case "G"_hk: // <JG> current gauge limits
-                    if (params>1) break;
-                    TrackManager::reportGauges(stream);   // <g limit...limit>     
-                    return;
-                
-                case "I"_hk: // <JI> current values
-                    if (params>1) break;
-                    TrackManager::reportCurrent(stream);   // <g limit...limit>     
-                    return;
-
-                case "A"_hk: // <JA> intercepted by EXRAIL// <JA> returns automations/routes
-                    if (params!=1) break; // <JA>
-                    StringFormatter::send(stream, F("<jA>\n"));
-                    return;
- 
-                case "M"_hk: // <JM> intercepted by EXRAIL
-                    if (params>1) break; // invalid cant do
-                    // <JM> requests stash size so say none.
-                    StringFormatter::send(stream,F("<jM 0>\n")); 
-                    return;
- 
-            case "R"_hk: // <JR> returns rosters 
-                StringFormatter::send(stream, F("<jR"));
+
+        case "I"_hk:  // <JI> current values
+          if (params > 1)
+            break;
+          TrackManager::reportCurrent(stream);  // <g limit...limit>
+          return;
+
+        case "A"_hk:  // <JA> intercepted by EXRAIL// <JA> returns automations/routes
+          if (params != 1)
+            break;  // <JA>
+          StringFormatter::send(stream, F("<jA>\n"));
+          return;
+
+        case "M"_hk:  // <JM> intercepted by EXRAIL
+          if (params > 1)
+            break;  // invalid cant do
+          // <JM> requests stash size so say none.
+          StringFormatter::send(stream, F("<jM 0>\n"));
+          return;
+
+        case "R"_hk:  // <JR> returns rosters
+          StringFormatter::send(stream, F("<jR"));
@@ -784,29 +787,31 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-                if (params==1) {
-                    SENDFLASHLIST(stream,RMFT2::rosterIdList)
-                }
-                else {
-                    auto rosterName= RMFT2::getRosterName(id);
-                    if (!rosterName) rosterName=F("");
-
-                    auto functionNames= RMFT2::getRosterFunctions(id);
-                    if (!functionNames) functionNames=RMFT2::getRosterFunctions(0);
-                    if (!functionNames) functionNames=F("");
-                    StringFormatter::send(stream,F(" %d \"%S\" \"%S\""), 
-					                            id, rosterName, functionNames);
-                }
-#endif          
-                StringFormatter::send(stream, F(">\n"));      
-                return; 
-            case "T"_hk: // <JT> returns turnout list 
-                StringFormatter::send(stream, F("<jT"));
-                if (params==1) { // <JT>
-                    for ( Turnout * t=Turnout::first(); t; t=t->next()) { 
-                        if (t->isHidden()) continue;          
-                        StringFormatter::send(stream, F(" %d"),t->getId());
-                    }
-                }
-                else { // <JT id>
-                    Turnout * t=Turnout::get(id);
-                    if (!t || t->isHidden()) StringFormatter::send(stream, F(" %d X"),id);
-                    else {
-		      const FSH *tdesc = NULL;
+          if (params == 1) {
+            SENDFLASHLIST(stream, RMFT2::rosterIdList)
+          } else {
+            auto rosterName = RMFT2::getRosterName(id);
+            if (!rosterName)
+              rosterName = F("");
+
+            auto functionNames = RMFT2::getRosterFunctions(id);
+            if (!functionNames)
+              functionNames = RMFT2::getRosterFunctions(0);
+            if (!functionNames)
+              functionNames = F("");
+            StringFormatter::send(stream, F(" %d \"%S\" \"%S\""), id, rosterName, functionNames);
+          }
+#endif
+          StringFormatter::send(stream, F(">\n"));
+          return;
+        case "T"_hk:  // <JT> returns turnout list
+          StringFormatter::send(stream, F("<jT"));
+          if (params == 1) {  // <JT>
+            for (Turnout* t = Turnout::first(); t; t = t->next()) {
+              if (t->isHidden())
+                continue;
+              StringFormatter::send(stream, F(" %d"), t->getId());
+            }
+          } else {  // <JT id>
+            Turnout* t = Turnout::get(id);
+            if (!t || t->isHidden())
+              StringFormatter::send(stream, F(" %d X"), id);
+            else {
+              const FSH* tdesc = NULL;
@@ -814 +819 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-		      tdesc = RMFT2::getTurnoutDescription(id);
+              tdesc = RMFT2::getTurnoutDescription(id);
@@ -816,9 +821,7 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-		      if (tdesc == NULL)
-			tdesc = F("");
-		      StringFormatter::send(stream, F(" %d %c \"%S\""),
-					    id,t->isThrown()?'T':'C',
-					    tdesc);
-		    }
-                }
-                StringFormatter::send(stream, F(">\n"));
-                return;
+              if (tdesc == NULL)
+                tdesc = F("");
+              StringFormatter::send(stream, F(" %d %c \"%S\""), id, t->isThrown() ? 'T' : 'C', tdesc);
+            }
+          }
+          StringFormatter::send(stream, F(">\n"));
+          return;
@@ -827,17 +830,18 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-            case "O"_hk: // <JO returns turntable list
-                StringFormatter::send(stream, F("<jO"));
-                if (params==1) { // <JO>
-                    for (Turntable * tto=Turntable::first(); tto; tto=tto->next()) { 
-                        if (tto->isHidden()) continue;          
-                        StringFormatter::send(stream, F(" %d"),tto->getId());
-                    }
-                    StringFormatter::send(stream, F(">\n"));
-                } else {    // <JO id>
-                    Turntable *tto=Turntable::get(id);
-                    if (!tto || tto->isHidden()) {
-                        StringFormatter::send(stream, F(" %d X>\n"), id);
-                    } else {
-                        uint8_t pos = tto->getPosition();
-                        uint8_t type = tto->isEXTT();
-                        uint8_t posCount = tto->getPositionCount();
-                        const FSH *todesc = NULL;
+        case "O"_hk:  // <JO returns turntable list
+          StringFormatter::send(stream, F("<jO"));
+          if (params == 1) {  // <JO>
+            for (Turntable* tto = Turntable::first(); tto; tto = tto->next()) {
+              if (tto->isHidden())
+                continue;
+              StringFormatter::send(stream, F(" %d"), tto->getId());
+            }
+            StringFormatter::send(stream, F(">\n"));
+          } else {  // <JO id>
+            Turntable* tto = Turntable::get(id);
+            if (!tto || tto->isHidden()) {
+              StringFormatter::send(stream, F(" %d X>\n"), id);
+            } else {
+              uint8_t pos = tto->getPosition();
+              uint8_t type = tto->isEXTT();
+              uint8_t posCount = tto->getPositionCount();
+              const FSH* todesc = NULL;
@@ -845 +849 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-                        todesc = RMFT2::getTurntableDescription(id);
+              todesc = RMFT2::getTurntableDescription(id);
@@ -847,16 +851,17 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-                        if (todesc == NULL) todesc = F("");
-                        StringFormatter::send(stream, F(" %d %d %d %d \"%S\">\n"), id, type, pos, posCount, todesc);
-                    }
-                }
-                return;
-            case "P"_hk: // <JP id> returns turntable position list for the turntable id
-                if (params==2) { // <JP id>
-                    Turntable *tto=Turntable::get(id);
-                    if (!tto || tto->isHidden()) {
-                        StringFormatter::send(stream, F(" %d X>\n"), id);
-                    } else {
-                        uint8_t posCount = tto->getPositionCount();
-                        const FSH *tpdesc = NULL;
-                        for (uint8_t p = 0; p < posCount; p++) {
-                            StringFormatter::send(stream, F("<jP"));
-                            int16_t angle = tto->getPositionAngle(p);
+              if (todesc == NULL)
+                todesc = F("");
+              StringFormatter::send(stream, F(" %d %d %d %d \"%S\">\n"), id, type, pos, posCount, todesc);
+            }
+          }
+          return;
+        case "P"_hk:          // <JP id> returns turntable position list for the turntable id
+          if (params == 2) {  // <JP id>
+            Turntable* tto = Turntable::get(id);
+            if (!tto || tto->isHidden()) {
+              StringFormatter::send(stream, F(" %d X>\n"), id);
+            } else {
+              uint8_t posCount = tto->getPositionCount();
+              const FSH* tpdesc = NULL;
+              for (uint8_t p = 0; p < posCount; p++) {
+                StringFormatter::send(stream, F("<jP"));
+                int16_t angle = tto->getPositionAngle(p);
@@ -864 +869 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-                            tpdesc = RMFT2::getTurntablePositionDescription(id, p);
+                tpdesc = RMFT2::getTurntablePositionDescription(id, p);
@@ -866,9 +871,10 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-                            if (tpdesc == NULL) tpdesc = F("");
-                            StringFormatter::send(stream, F(" %d %d %d \"%S\""), id, p, angle, tpdesc);
-                            StringFormatter::send(stream, F(">\n"));
-                        }
-                    }
-                } else {
-                    StringFormatter::send(stream, F("<jP X>\n"));
-                }
-                return;
+                if (tpdesc == NULL)
+                  tpdesc = F("");
+                StringFormatter::send(stream, F(" %d %d %d \"%S\""), id, p, angle, tpdesc);
+                StringFormatter::send(stream, F(">\n"));
+              }
+            }
+          } else {
+            StringFormatter::send(stream, F("<jP X>\n"));
+          }
+          return;
@@ -876,4 +882,5 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-            default: break;    
-            }  // switch(p[1])
-        break; // case J
-        }
+        default:
+          break;
+      }  // switch(p[1])
+      break;  // case J
+    }
@@ -883,4 +890,4 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case 'I': // TURNTABLE  <I ...>
-        if (parseI(stream, params, p))
-            return;
-        break;
+    case 'I':  // TURNTABLE  <I ...>
+      if (parseI(stream, params, p))
+        return;
+      break;
@@ -889,3 +896,4 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case 'N': // <N  commands for SensorCam
-        if (CamParser::parseN(stream,params,p)) return;
-        break;
+    case 'N':  // <N  commands for SensorCam
+      if (CamParser::parseN(stream, params, p))
+        return;
+      break;
@@ -893,3 +901,3 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case '/': // implemented in EXRAIL parser
-    case 'L': // LCC interface implemented in EXRAIL parser
-        break; // Will <X> if not intercepted by EXRAIL 
+    case '/':  // implemented in EXRAIL parser
+    case 'L':  // LCC interface implemented in EXRAIL parser
+      break;   // Will <X> if not intercepted by EXRAIL
@@ -898,6 +906,5 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    case '@': // JMRI saying "give me virtual LCD msgs"
-        CommandDistributor::setVirtualLCDSerial(stream);
-        StringFormatter::send(stream,
-            F("<@ 0 0 \"DCC-EX v" VERSION "\">\n"
-               "<@ 0 1 \"Lic GPLv3\">\n"));
-        return; 
+    case '@':  // JMRI saying "give me virtual LCD msgs"
+      CommandDistributor::setVirtualLCDSerial(stream);
+      StringFormatter::send(stream, F("<@ 0 0 \"DCC-EX v" VERSION "\">\n"
+                                      "<@ 0 1 \"Lic GPLv3\">\n"));
+      return;
@@ -905 +912 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    default: //anything else will diagnose and drop out to <X>
+    default:  // anything else will diagnose and drop out to <X>
@@ -908,2 +915 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-        for (int i = 0; i < params; i++)
-            DIAG(F("p[%d]=%d (0x%x)"), i, p[i], p[i]);
+        for (int i = 0; i < params; i++) DIAG(F("p[%d]=%d (0x%x)"), i, p[i], p[i]);
@@ -911 +917 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-	DIAG(F("Unprintable %x"), opcode);
+        DIAG(F("Unprintable %x"), opcode);
@@ -915 +921 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-    } // end of opcode switch
+  }  // end of opcode switch
@@ -917,2 +923,2 @@ void DCCEXParser::parseOne(Print *stream, byte *com, RingStream * ringStream)
-out:// Any fallout here sends an <X>
-    StringFormatter::send(stream, F("<X>\n"));
+out:  // Any fallout here sends an <X>
+  StringFormatter::send(stream, F("<X>\n"));
@@ -921,4 +927,3 @@ out:// Any fallout here sends an <X>
-bool DCCEXParser::parseZ(Print *stream, int16_t params, int16_t p[])
-{
-
-    switch (params)
+bool DCCEXParser::parseZ(Print* stream, int16_t params, int16_t p[]) {
+  switch (params) {
+    case 2:  // <Z ID ACTIVATE>
@@ -926,8 +931,5 @@ bool DCCEXParser::parseZ(Print *stream, int16_t params, int16_t p[])
-    
-    case 2: // <Z ID ACTIVATE>
-    {
-        Output *o = Output::get(p[0]);
-        if (o == NULL)
-            return false;
-        o->activate(p[1]);
-        StringFormatter::send(stream, F("<Y %d %d>\n"), p[0], p[1]);
+      Output* o = Output::get(p[0]);
+      if (o == NULL)
+        return false;
+      o->activate(p[1]);
+      StringFormatter::send(stream, F("<Y %d %d>\n"), p[0], p[1]);
@@ -935 +937 @@ bool DCCEXParser::parseZ(Print *stream, int16_t params, int16_t p[])
-        return true;
+      return true;
@@ -937,7 +939,7 @@ bool DCCEXParser::parseZ(Print *stream, int16_t params, int16_t p[])
-    case 3: // <Z ID PIN IFLAG>
-        if (p[0] < 0 || p[2] < 0 || p[2] > 7 )
-	        return false;
-        if (!Output::create(p[0], p[1], p[2], 1))
-          return false;
-        StringFormatter::send(stream, F("<O>\n"));
-        return true;
+    case 3:  // <Z ID PIN IFLAG>
+      if (p[0] < 0 || p[2] < 0 || p[2] > 7)
+        return false;
+      if (!Output::create(p[0], p[1], p[2], 1))
+        return false;
+      StringFormatter::send(stream, F("<O>\n"));
+      return true;
@@ -945,5 +947,5 @@ bool DCCEXParser::parseZ(Print *stream, int16_t params, int16_t p[])
-    case 1: // <Z ID>
-        if (!Output::remove(p[0]))
-          return false;
-        StringFormatter::send(stream, F("<O>\n"));
-        return true;
+    case 1:  // <Z ID>
+      if (!Output::remove(p[0]))
+        return false;
+      StringFormatter::send(stream, F("<O>\n"));
+      return true;
@@ -951 +953 @@ bool DCCEXParser::parseZ(Print *stream, int16_t params, int16_t p[])
-    case 0: // <Z> list Output definitions
+    case 0:  // <Z> list Output definitions
@@ -953,7 +955,6 @@ bool DCCEXParser::parseZ(Print *stream, int16_t params, int16_t p[])
-        bool gotone = false;
-        for (Output *tt = Output::firstOutput; tt != NULL; tt = tt->nextOutput)
-        {
-            gotone = true;
-            StringFormatter::send(stream, F("<Y %d %d %d %d>\n"), tt->data.id, tt->data.pin, tt->data.flags, tt->data.active);
-        }
-        return gotone;
+      bool gotone = false;
+      for (Output* tt = Output::firstOutput; tt != NULL; tt = tt->nextOutput) {
+        gotone = true;
+        StringFormatter::send(stream, F("<Y %d %d %d %d>\n"), tt->data.id, tt->data.pin, tt->data.flags, tt->data.active);
+      }
+      return gotone;
@@ -962,2 +963,2 @@ bool DCCEXParser::parseZ(Print *stream, int16_t params, int16_t p[])
-        return false;
-    }
+      return false;
+  }
@@ -967,2 +968 @@ bool DCCEXParser::parseZ(Print *stream, int16_t params, int16_t p[])
-bool DCCEXParser::parsef(Print *stream, int16_t params, int16_t p[])
-{
+bool DCCEXParser::parsef(Print* stream, int16_t params, int16_t p[]) {
@@ -972,2 +972,2 @@ bool DCCEXParser::parsef(Print *stream, int16_t params, int16_t p[])
-    byte instructionField = p[1] & 0xE0;   // 1110 0000
-    if (instructionField == 0x80) {        // 1000 0000 Function group 1
+    byte instructionField = p[1] & 0xE0;  // 1110 0000
+    if (instructionField == 0x80) {       // 1000 0000 Function group 1
@@ -977,3 +977,3 @@ bool DCCEXParser::parsef(Print *stream, int16_t params, int16_t p[])
-    } else if (instructionField == 0xA0) { // 1010 0000 Function group 2
-      if (p[1] & 0x10)                     // 0001 0000 Bit selects F5toF8 / F9toF12
-	return (funcmap(p[0], p[1], 5, 8));
+    } else if (instructionField == 0xA0) {  // 1010 0000 Function group 2
+      if (p[1] & 0x10)                      // 0001 0000 Bit selects F5toF8 / F9toF12
+        return (funcmap(p[0], p[1], 5, 8));
@@ -981,2 +981,2 @@ bool DCCEXParser::parsef(Print *stream, int16_t params, int16_t p[])
-	return (funcmap(p[0], p[1], 9, 12));
-    } 
+        return (funcmap(p[0], p[1], 9, 12));
+    }
@@ -989 +989 @@ bool DCCEXParser::parsef(Print *stream, int16_t params, int16_t p[])
-    } 
+    }
@@ -991 +991 @@ bool DCCEXParser::parsef(Print *stream, int16_t params, int16_t p[])
-  (void)stream; // NO RESPONSE
+  (void)stream;  // NO RESPONSE
@@ -995,2 +995 @@ bool DCCEXParser::parsef(Print *stream, int16_t params, int16_t p[])
-bool DCCEXParser::funcmap(int16_t cab, byte value, byte fstart, byte fstop)
-{
+bool DCCEXParser::funcmap(int16_t cab, byte value, byte fstart, byte fstop) {
@@ -998 +997,2 @@ bool DCCEXParser::funcmap(int16_t cab, byte value, byte fstart, byte fstop)
-    if (! DCC::setFn(cab, i, value & 1)) return false;
+    if (!DCC::setFn(cab, i, value & 1))
+      return false;
@@ -1005,6 +1005,4 @@ bool DCCEXParser::funcmap(int16_t cab, byte value, byte fstart, byte fstop)
-bool DCCEXParser::parseT(Print *stream, int16_t params, int16_t p[])
-{
-    switch (params)
-    {
-    case 0: // <T>  list turnout definitions
-        return Turnout::printAll(stream); // will <X> if none found
+bool DCCEXParser::parseT(Print* stream, int16_t params, int16_t p[]) {
+  switch (params) {
+    case 0:                              // <T>  list turnout definitions
+      return Turnout::printAll(stream);  // will <X> if none found
@@ -1012,30 +1010,24 @@ bool DCCEXParser::parseT(Print *stream, int16_t params, int16_t p[])
-    case 1: // <T id>  delete turnout
-        if (!Turnout::remove(p[0]))
-            return false;
-        StringFormatter::send(stream, F("<O>\n"));
-        return true;
-
-    case 2: // <T id 0|1|T|C> 
-        {
-          bool state = false;
-          switch (p[1]) {
-            // Turnout messages use 1=throw, 0=close.
-            case 0:
-            case "C"_hk:
-              state = true;
-              break;
-            case 1:
-            case "T"_hk:
-              state= false;
-              break;
-            case "X"_hk:
-	    {
-              Turnout *tt = Turnout::get(p[0]);
-              if (tt) {
-                tt->print(stream);
-                return true;
-              }
-              return false;
-	    }
-            default: // Invalid parameter
-	      return false;
+    case 1:  // <T id>  delete turnout
+      if (!Turnout::remove(p[0]))
+        return false;
+      StringFormatter::send(stream, F("<O>\n"));
+      return true;
+
+    case 2:  // <T id 0|1|T|C>
+    {
+      bool state = false;
+      switch (p[1]) {
+        // Turnout messages use 1=throw, 0=close.
+        case 0:
+        case "C"_hk:
+          state = true;
+          break;
+        case 1:
+        case "T"_hk:
+          state = false;
+          break;
+        case "X"_hk: {
+          Turnout* tt = Turnout::get(p[0]);
+          if (tt) {
+            tt->print(stream);
+            return true;
@@ -1043,2 +1035 @@ bool DCCEXParser::parseT(Print *stream, int16_t params, int16_t p[])
-          if (!Turnout::setClosed(p[0], state)) return false;
-          return true;
+          return false;
@@ -1045,0 +1037,7 @@ bool DCCEXParser::parseT(Print *stream, int16_t params, int16_t p[])
+        default:  // Invalid parameter
+          return false;
+      }
+      if (!Turnout::setClosed(p[0], state))
+        return false;
+      return true;
+    }
@@ -1047,2 +1045,2 @@ bool DCCEXParser::parseT(Print *stream, int16_t params, int16_t p[])
-    default: // Anything else is some kind of turnout create function.
-      if (params == 6 && p[1] == "SERVO"_hk) { // <T id SERVO n n n n>
+    default:                                    // Anything else is some kind of turnout create function.
+      if (params == 6 && p[1] == "SERVO"_hk) {  // <T id SERVO n n n n>
@@ -1051,5 +1049,4 @@ bool DCCEXParser::parseT(Print *stream, int16_t params, int16_t p[])
-      } else 
-      if (params == 3 && p[1] == "VPIN"_hk) { // <T id VPIN n>
-        if (!VpinTurnout::create(p[0], p[2])) return false;
-      } else 
-      if (params >= 3 && p[1] == "DCC"_hk) {
+      } else if (params == 3 && p[1] == "VPIN"_hk) {  // <T id VPIN n>
+        if (!VpinTurnout::create(p[0], p[2]))
+          return false;
+      } else if (params >= 3 && p[1] == "DCC"_hk) {
@@ -1057,3 +1054,4 @@ bool DCCEXParser::parseT(Print *stream, int16_t params, int16_t p[])
-        if (params==4 && p[2]>=0 && p[2]<512 && p[3]>=0 && p[3]<4) { // <T id DCC n m>
-          if (!DCCTurnout::create(p[0], p[2], p[3])) return false;
-        } else if (params==3 && p[2]>0 && p[2]<=512*4) { // <T id DCC nn>, 1<=nn<=2048
+        if (params == 4 && p[2] >= 0 && p[2] < 512 && p[3] >= 0 && p[3] < 4) {  // <T id DCC n m>
+          if (!DCCTurnout::create(p[0], p[2], p[3]))
+            return false;
+        } else if (params == 3 && p[2] > 0 && p[2] <= 512 * 4) {  // <T id DCC nn>, 1<=nn<=2048
@@ -1061 +1059,2 @@ bool DCCEXParser::parseT(Print *stream, int16_t params, int16_t p[])
-          if (!DCCTurnout::create(p[0], (p[2]-1)/4+1, (p[2]-1)%4)) return false;
+          if (!DCCTurnout::create(p[0], (p[2] - 1) / 4 + 1, (p[2] - 1) % 4))
+            return false;
@@ -1064,4 +1063,4 @@ bool DCCEXParser::parseT(Print *stream, int16_t params, int16_t p[])
-      } else 
-      if (params==3) { // legacy <T id addr subadd> for DCC accessory
-        if (p[1]>=0 && p[1]<512 && p[2]>=0 && p[2]<4) {
-          if (!DCCTurnout::create(p[0], p[1], p[2])) return false;
+      } else if (params == 3) {  // legacy <T id addr subadd> for DCC accessory
+        if (p[1] >= 0 && p[1] < 512 && p[2] >= 0 && p[2] < 4) {
+          if (!DCCTurnout::create(p[0], p[1], p[2]))
+            return false;
@@ -1070,4 +1069,3 @@ bool DCCEXParser::parseT(Print *stream, int16_t params, int16_t p[])
-      } 
-      else 
-      if (params==4) { // legacy <T id n n n> for Servo
-        if (!ServoTurnout::create(p[0], (VPIN)p[1], (uint16_t)p[2], (uint16_t)p[3], 1)) return false;
+      } else if (params == 4) {  // legacy <T id n n n> for Servo
+        if (!ServoTurnout::create(p[0], (VPIN)p[1], (uint16_t)p[2], (uint16_t)p[3], 1))
+          return false;
@@ -1079 +1077 @@ bool DCCEXParser::parseT(Print *stream, int16_t params, int16_t p[])
-    }
+  }
@@ -1082,10 +1080,7 @@ bool DCCEXParser::parseT(Print *stream, int16_t params, int16_t p[])
-bool DCCEXParser::parseS(Print *stream, int16_t params, int16_t p[])
-{
-
-    switch (params)
-    {
-    case 3: // <S id pin pullup>  create sensor. pullUp indicator (0=LOW/1=HIGH)
-        if (!Sensor::create(p[0], p[1], p[2]))
-          return false;
-        StringFormatter::send(stream, F("<O>\n"));
-        return true;
+bool DCCEXParser::parseS(Print* stream, int16_t params, int16_t p[]) {
+  switch (params) {
+    case 3:  // <S id pin pullup>  create sensor. pullUp indicator (0=LOW/1=HIGH)
+      if (!Sensor::create(p[0], p[1], p[2]))
+        return false;
+      StringFormatter::send(stream, F("<O>\n"));
+      return true;
@@ -1093,5 +1088,5 @@ bool DCCEXParser::parseS(Print *stream, int16_t params, int16_t p[])
-    case 1: // S id> remove sensor
-        if (!Sensor::remove(p[0]))
-          return false;
-        StringFormatter::send(stream, F("<O>\n"));
-        return true;
+    case 1:  // S id> remove sensor
+      if (!Sensor::remove(p[0]))
+        return false;
+      StringFormatter::send(stream, F("<O>\n"));
+      return true;
@@ -1099 +1094 @@ bool DCCEXParser::parseS(Print *stream, int16_t params, int16_t p[])
-    case 0: // <S> list sensor definitions
+    case 0:  // <S> list sensor definitions
@@ -1102,3 +1097,2 @@ bool DCCEXParser::parseS(Print *stream, int16_t params, int16_t p[])
-      for (Sensor *tt = Sensor::firstSensor; tt != NULL; tt = tt->nextSensor)
-      {
-          StringFormatter::send(stream, F("<Q %d %d %d>\n"), tt->data.snum, tt->data.pin, tt->data.pullUp);
+      for (Sensor* tt = Sensor::firstSensor; tt != NULL; tt = tt->nextSensor) {
+        StringFormatter::send(stream, F("<Q %d %d %d>\n"), tt->data.snum, tt->data.pin, tt->data.pullUp);
@@ -1108,4 +1102,4 @@ bool DCCEXParser::parseS(Print *stream, int16_t params, int16_t p[])
-    default: // invalid number of arguments
-        break;
-    }
-    return false;
+    default:  // invalid number of arguments
+      break;
+  }
+  return false;
@@ -1114,6 +1108,5 @@ bool DCCEXParser::parseS(Print *stream, int16_t params, int16_t p[])
-bool DCCEXParser::parseC(Print *stream, int16_t params, int16_t p[]) {
-    (void)stream; // arg not used, maybe later?
-    if (params == 0)
-        return false;
-    switch (p[0])
-    {
+bool DCCEXParser::parseC(Print* stream, int16_t params, int16_t p[]) {
+  (void)stream;  // arg not used, maybe later?
+  if (params == 0)
+    return false;
+  switch (p[0]) {
@@ -1122,2 +1115,2 @@ bool DCCEXParser::parseC(Print *stream, int16_t params, int16_t p[]) {
-        TrackManager::progTrackBoosted=true;
-	    return true;
+      TrackManager::progTrackBoosted = true;
+      return true;
@@ -1126,2 +1119,2 @@ bool DCCEXParser::parseC(Print *stream, int16_t params, int16_t p[]) {
-        DCCTimer::reset();
-        break; // and <X> if we didnt restart
+      DCCTimer::reset();
+      break;  // and <X> if we didnt restart
@@ -1129,3 +1122,3 @@ bool DCCEXParser::parseC(Print *stream, int16_t params, int16_t p[]) {
-        DCC::setGlobalSpeedsteps(28);
-	DIAG(F("28 Speedsteps"));
-        return true;
+      DCC::setGlobalSpeedsteps(28);
+      DIAG(F("28 Speedsteps"));
+      return true;
@@ -1134,3 +1127,3 @@ bool DCCEXParser::parseC(Print *stream, int16_t params, int16_t p[]) {
-        DCC::setGlobalSpeedsteps(128);
-	DIAG(F("128 Speedsteps"));
-        return true;
+      DCC::setGlobalSpeedsteps(128);
+      DIAG(F("128 Speedsteps"));
+      return true;
@@ -1138,24 +1131,23 @@ bool DCCEXParser::parseC(Print *stream, int16_t params, int16_t p[]) {
-    case "RAILCOM"_hk:
-        {   // <C RAILCOM ON|OFF|DEBUG >
-            if (params<2) return false;
-            bool on=false;
-            bool debug=false;
-            switch (p[1]) {
-                case "ON"_hk:
-                case 1:
-                    on=true;
-                    break;
-                case "DEBUG"_hk:
-                    on=true;
-                    debug=true;
-                    break;
-                case "OFF"_hk:
-                case 0:
-                     break;
-                default:
-                 return false;
-            }              
-        DIAG(F("Railcom %S")
-            ,DCCWaveform::setRailcom(on,debug)?F("ON"):F("OFF"));
-        return true;     
-        }
+    case "RAILCOM"_hk: {  // <C RAILCOM ON|OFF|DEBUG >
+      if (params < 2)
+        return false;
+      bool on = false;
+      bool debug = false;
+      switch (p[1]) {
+        case "ON"_hk:
+        case 1:
+          on = true;
+          break;
+        case "DEBUG"_hk:
+          on = true;
+          debug = true;
+          break;
+        case "OFF"_hk:
+        case 0:
+          break;
+        default:
+          return false;
+      }
+      DIAG(F("Railcom %S"), DCCWaveform::setRailcom(on, debug) ? F("ON") : F("OFF"));
+      return true;
+    }
@@ -1164,31 +1156,32 @@ bool DCCEXParser::parseC(Print *stream, int16_t params, int16_t p[]) {
-    case "ACK"_hk: // <D ACK ON/OFF> <D ACK [LIMIT|MIN|MAX|RETRY] Value>
-	if (params >= 3) {
-            long duration;
-	    if (p[1] == "LIMIT"_hk) {
-	      DCCACK::setAckLimit(p[2]);
-	      LCD(1, F("Ack Limit=%dmA"), p[2]);       // <D ACK LIMIT 42>
-	    } else if (p[1] == "MIN"_hk) {
-	      if (params == 4 && p[3] == "MS"_hk)
-		duration = p[2] * 1000L;
-	      else
-		duration = p[2];
-	      DCCACK::setMinAckPulseDuration(duration);
-	      LCD(0, F("Ack Min=%lus"), duration);     // <D ACK MIN 1500>
-	    } else if (p[1] == "MAX"_hk) {
-	      if (params == 4 && p[3] == "MS"_hk)      // <D ACK MAX 80 MS>
-		duration = p[2] * 1000L;
-	      else
-		duration = p[2];
-	      DCCACK::setMaxAckPulseDuration(duration);
-	      LCD(0, F("Ack Max=%lus"), duration);     // <D ACK MAX 9000>
-	    } else if (p[1] == "RETRY"_hk) {
-	      if (p[2] >255) p[2]=3;
-	      LCD(0, F("Ack Retry=%d Sum=%d"), p[2], DCCACK::setAckRetry(p[2]));  //   <D ACK RETRY 2>
-	    }
-	} else {
-      bool onOff = (params > 0) && (p[1] == 1 || p[1] == "ON"_hk); // dont care if other stuff or missing... just means off
-    
-	  DIAG(F("Ack diag %S"), onOff ? F("on") : F("off"));
-	  Diag::ACK = onOff;
-	}
-        return true;
+    case "ACK"_hk:  // <D ACK ON/OFF> <D ACK [LIMIT|MIN|MAX|RETRY] Value>
+      if (params >= 3) {
+        long duration;
+        if (p[1] == "LIMIT"_hk) {
+          DCCACK::setAckLimit(p[2]);
+          LCD(1, F("Ack Limit=%dmA"), p[2]);  // <D ACK LIMIT 42>
+        } else if (p[1] == "MIN"_hk) {
+          if (params == 4 && p[3] == "MS"_hk)
+            duration = p[2] * 1000L;
+          else
+            duration = p[2];
+          DCCACK::setMinAckPulseDuration(duration);
+          LCD(0, F("Ack Min=%lus"), duration);  // <D ACK MIN 1500>
+        } else if (p[1] == "MAX"_hk) {
+          if (params == 4 && p[3] == "MS"_hk)  // <D ACK MAX 80 MS>
+            duration = p[2] * 1000L;
+          else
+            duration = p[2];
+          DCCACK::setMaxAckPulseDuration(duration);
+          LCD(0, F("Ack Max=%lus"), duration);  // <D ACK MAX 9000>
+        } else if (p[1] == "RETRY"_hk) {
+          if (p[2] > 255)
+            p[2] = 3;
+          LCD(0, F("Ack Retry=%d Sum=%d"), p[2], DCCACK::setAckRetry(p[2]));  //   <D ACK RETRY 2>
+        }
+      } else {
+        bool onOff = (params > 0) && (p[1] == 1 || p[1] == "ON"_hk);  // dont care if other stuff or missing... just means off
+
+        DIAG(F("Ack diag %S"), onOff ? F("on") : F("off"));
+        Diag::ACK = onOff;
+      }
+      return true;
@@ -1196 +1189 @@ bool DCCEXParser::parseC(Print *stream, int16_t params, int16_t p[]) {
-    default: // invalid/unknown
+    default:  // invalid/unknown
@@ -1198,2 +1191,2 @@ bool DCCEXParser::parseC(Print *stream, int16_t params, int16_t p[]) {
-    }
-    return false;
+  }
+  return false;
@@ -1202,10 +1195,8 @@ bool DCCEXParser::parseC(Print *stream, int16_t params, int16_t p[]) {
-bool DCCEXParser::parseD(Print *stream, int16_t params, int16_t p[])
-{
-    if (params == 0)
-        return false;
-    bool onOff = (params > 0) && (p[1] == 1 || p[1] == "ON"_hk); // dont care if other stuff or missing... just means off
-    switch (p[0])
-    {
-    case "CABS"_hk: // <D CABS>
-        DCC::displayCabList(stream);
-        return true;
+bool DCCEXParser::parseD(Print* stream, int16_t params, int16_t p[]) {
+  if (params == 0)
+    return false;
+  bool onOff = (params > 0) && (p[1] == 1 || p[1] == "ON"_hk);  // dont care if other stuff or missing... just means off
+  switch (p[0]) {
+    case "CABS"_hk:  // <D CABS>
+      DCC::displayCabList(stream);
+      return true;
@@ -1213,3 +1204,3 @@ bool DCCEXParser::parseD(Print *stream, int16_t params, int16_t p[])
-    case "RAM"_hk: // <D RAM>
-        DIAG(F("Free memory=%d"), DCCTimer::getMinimumFreeMemory());
-        return true;
+    case "RAM"_hk:  // <D RAM>
+      DIAG(F("Free memory=%d"), DCCTimer::getMinimumFreeMemory());
+      return true;
@@ -1217,3 +1208,3 @@ bool DCCEXParser::parseD(Print *stream, int16_t params, int16_t p[])
-    case "CMD"_hk: // <D CMD ON/OFF>
-        Diag::CMD = onOff;
-        return true;
+    case "CMD"_hk:  // <D CMD ON/OFF>
+      Diag::CMD = onOff;
+      return true;
@@ -1222,3 +1213,3 @@ bool DCCEXParser::parseD(Print *stream, int16_t params, int16_t p[])
-    case "WIFI"_hk: // <D WIFI ON/OFF>
-        Diag::WIFI = onOff;
-        return true;
+    case "WIFI"_hk:  // <D WIFI ON/OFF>
+      Diag::WIFI = onOff;
+      return true;
@@ -1226,3 +1217,3 @@ bool DCCEXParser::parseD(Print *stream, int16_t params, int16_t p[])
-    case "ETHERNET"_hk: // <D ETHERNET ON/OFF>
-        Diag::ETHERNET = onOff;
-        return true;
+    case "ETHERNET"_hk:  // <D ETHERNET ON/OFF>
+      Diag::ETHERNET = onOff;
+      return true;
@@ -1230,3 +1221,3 @@ bool DCCEXParser::parseD(Print *stream, int16_t params, int16_t p[])
-    case "WIT"_hk: // <D WIT ON/OFF>
-        Diag::WITHROTTLE = onOff;
-        return true;
+    case "WIT"_hk:  // <D WIT ON/OFF>
+      Diag::WITHROTTLE = onOff;
+      return true;
@@ -1234,3 +1225,3 @@ bool DCCEXParser::parseD(Print *stream, int16_t params, int16_t p[])
-    case "LCN"_hk: // <D LCN ON/OFF>
-        Diag::LCN = onOff;
-        return true;
+    case "LCN"_hk:  // <D LCN ON/OFF>
+      Diag::LCN = onOff;
+      return true;
@@ -1239,4 +1230,4 @@ bool DCCEXParser::parseD(Print *stream, int16_t params, int16_t p[])
-    case "EEPROM"_hk: // <D EEPROM NumEntries>
-	if (params >= 2)
-	    EEStore::dump(p[1]);
-	return true;
+    case "EEPROM"_hk:  // <D EEPROM NumEntries>
+      if (params >= 2)
+        EEStore::dump(p[1]);
+      return true;
@@ -1247,2 +1238,2 @@ bool DCCEXParser::parseD(Print *stream, int16_t params, int16_t p[])
-        IODevice::writeAnalogue(p[1], p[2], params>3 ? p[3] : 0);
-        return true;
+      IODevice::writeAnalogue(p[1], p[2], params > 3 ? p[3] : 0);
+      return true;
@@ -1250,3 +1241,3 @@ bool DCCEXParser::parseD(Print *stream, int16_t params, int16_t p[])
-    case "ANIN"_hk:   // <D ANIN vpin>  Display analogue input value
-        DIAG(F("VPIN=%u value=%d"), p[1], IODevice::readAnalogue(p[1]));
-        return true;
+    case "ANIN"_hk:  // <D ANIN vpin>  Display analogue input value
+      DIAG(F("VPIN=%u value=%d"), p[1], IODevice::readAnalogue(p[1]));
+      return true;
@@ -1255,6 +1246,6 @@ bool DCCEXParser::parseD(Print *stream, int16_t params, int16_t p[])
-    case "HAL"_hk: 
-        if (p[1] == "SHOW"_hk) 
-          IODevice::DumpAll();
-        else if (p[1] == "RESET"_hk)
-          IODevice::reset();
-        return true;
+    case "HAL"_hk:
+      if (p[1] == "SHOW"_hk)
+        IODevice::DumpAll();
+      else if (p[1] == "RESET"_hk)
+        IODevice::reset();
+      return true;
@@ -1263,3 +1254,3 @@ bool DCCEXParser::parseD(Print *stream, int16_t params, int16_t p[])
-    case "TT"_hk:     // <D TT vpin steps activity>
-        IODevice::writeAnalogue(p[1], p[2], params>3 ? p[3] : 0);
-        return true;
+    case "TT"_hk:  // <D TT vpin steps activity>
+      IODevice::writeAnalogue(p[1], p[2], params > 3 ? p[3] : 0);
+      return true;
@@ -1267,4 +1258,4 @@ bool DCCEXParser::parseD(Print *stream, int16_t params, int16_t p[])
-    default: // invalid/unknown
-        return parseC(stream, params, p);
-    }
-    return false;
+    default:  // invalid/unknown
+      return parseC(stream, params, p);
+  }
+  return false;
@@ -1283,3 +1274,6 @@ bool DCCEXParser::parseD(Print *stream, int16_t params, int16_t p[])
-bool DCCEXParser::parseI(Print *stream, int16_t params, int16_t p[])
-{
-    switch (params)
+bool DCCEXParser::parseI(Print* stream, int16_t params, int16_t p[]) {
+  switch (params) {
+    case 0:  // <I> list turntable objects
+      return Turntable::printAll(stream);
+
+    case 1:  // <I id> broadcast type and current position
@@ -1287,74 +1281,72 @@ bool DCCEXParser::parseI(Print *stream, int16_t params, int16_t p[])
-    case 0: // <I> list turntable objects
-        return Turntable::printAll(stream);
-
-    case 1: // <I id> broadcast type and current position
-        {    
-            Turntable *tto = Turntable::get(p[0]);
-            if (tto) {
-                bool type = tto->isEXTT();
-                uint8_t position = tto->getPosition();
-                StringFormatter::send(stream, F("<I %d %d>\n"), type, position);
-            } else {
-                return false;
-            }
-        }
-        return true;
-    
-    case 2: // <I id position> - rotate a DCC turntable
-        {
-            Turntable *tto = Turntable::get(p[0]);
-            if (tto && !tto->isEXTT()) {
-                if (!tto->setPosition(p[0], p[1])) return false;
-            } else {
-                return false;
-            }
-        }
-        return true;
-
-    case 3: // <I id position activity> | <I id DCC home> - rotate to position for EX-Turntable or create DCC turntable
-        {
-            Turntable *tto = Turntable::get(p[0]);
-            if (p[1] == "DCC"_hk) {
-                if (tto || p[2] < 0 || p[2] > 3600) return false;
-                if (!DCCTurntable::create(p[0])) return false;
-                Turntable *tto = Turntable::get(p[0]);
-                tto->addPosition(0, 0, p[2]);
-                StringFormatter::send(stream, F("<I>\n"));
-            } else {
-                if (!tto) return false;
-                if (!tto->isEXTT()) return false;
-                if (!tto->setPosition(p[0], p[1], p[2])) return false;
-            }
-        }
-        return true;
-    
-    case 4: // <I id EXTT vpin home> create an EXTT turntable
-        {
-            Turntable *tto = Turntable::get(p[0]);
-            if (p[1] == "EXTT"_hk) {
-                if (tto || p[3] < 0 || p[3] > 3600) return false;
-                if (!EXTTTurntable::create(p[0], (VPIN)p[2])) return false;
-                Turntable *tto = Turntable::get(p[0]);
-                tto->addPosition(0, 0, p[3]);
-                StringFormatter::send(stream, F("<I>\n"));
-            } else {
-                return false;
-            }
-        }
-        return true;
-    
-    case 5: // <I id ADD position value angle> add a position
-        {
-            Turntable *tto = Turntable::get(p[0]);
-            if (p[1] == "ADD"_hk) {
-                // tto must exist, no more than 48 positions, angle 0 - 3600
-                if (!tto || p[2] > 48 || p[4] < 0 || p[4] > 3600) return false;
-                tto->addPosition(p[2], p[3], p[4]);
-                StringFormatter::send(stream, F("<I>\n"));
-            } else {
-                return false;
-            }
-        }
-        return true;
-    
-    default:    // Anything else is invalid
+      Turntable* tto = Turntable::get(p[0]);
+      if (tto) {
+        bool type = tto->isEXTT();
+        uint8_t position = tto->getPosition();
+        StringFormatter::send(stream, F("<I %d %d>\n"), type, position);
+      } else {
+        return false;
+      }
+    }
+      return true;
+
+    case 2:  // <I id position> - rotate a DCC turntable
+    {
+      Turntable* tto = Turntable::get(p[0]);
+      if (tto && !tto->isEXTT()) {
+        if (!tto->setPosition(p[0], p[1]))
+          return false;
+      } else {
+        return false;
+      }
+    }
+      return true;
+
+    case 3:  // <I id position activity> | <I id DCC home> - rotate to position for EX-Turntable or create DCC turntable
+    {
+      Turntable* tto = Turntable::get(p[0]);
+      if (p[1] == "DCC"_hk) {
+        if (tto || p[2] < 0 || p[2] > 3600)
+          return false;
+        if (!DCCTurntable::create(p[0]))
+          return false;
+        Turntable* tto = Turntable::get(p[0]);
+        tto->addPosition(0, 0, p[2]);
+        StringFormatter::send(stream, F("<I>\n"));
+      } else {
+        if (!tto)
+          return false;
+        if (!tto->isEXTT())
+          return false;
+        if (!tto->setPosition(p[0], p[1], p[2]))
+          return false;
+      }
+    }
+      return true;
+
+    case 4:  // <I id EXTT vpin home> create an EXTT turntable
+    {
+      Turntable* tto = Turntable::get(p[0]);
+      if (p[1] == "EXTT"_hk) {
+        if (tto || p[3] < 0 || p[3] > 3600)
+          return false;
+        if (!EXTTTurntable::create(p[0], (VPIN)p[2]))
+          return false;
+        Turntable* tto = Turntable::get(p[0]);
+        tto->addPosition(0, 0, p[3]);
+        StringFormatter::send(stream, F("<I>\n"));
+      } else {
+        return false;
+      }
+    }
+      return true;
+
+    case 5:  // <I id ADD position value angle> add a position
+    {
+      Turntable* tto = Turntable::get(p[0]);
+      if (p[1] == "ADD"_hk) {
+        // tto must exist, no more than 48 positions, angle 0 - 3600
+        if (!tto || p[2] > 48 || p[4] < 0 || p[4] > 3600)
+          return false;
+        tto->addPosition(p[2], p[3], p[4]);
+        StringFormatter::send(stream, F("<I>\n"));
+      } else {
@@ -1361,0 +1354 @@ bool DCCEXParser::parseI(Print *stream, int16_t params, int16_t p[])
+      }
@@ -1362,0 +1356,5 @@ bool DCCEXParser::parseI(Print *stream, int16_t params, int16_t p[])
+      return true;
+
+    default:  // Anything else is invalid
+      return false;
+  }
@@ -1367,10 +1365,10 @@ bool DCCEXParser::parseI(Print *stream, int16_t params, int16_t p[])
-bool DCCEXParser::stashCallback(Print *stream, int16_t p[MAX_COMMAND_PARAMS], RingStream * ringStream)
-{
-    if (stashBusy )
-        return false;
-    stashBusy = true;
-    stashStream = stream;
-    stashRingStream=ringStream;
-    if (ringStream) stashTarget= ringStream->peekTargetMark();
-    memcpy(stashP, p, MAX_COMMAND_PARAMS * sizeof(p[0]));
-    return true;
+bool DCCEXParser::stashCallback(Print* stream, int16_t p[MAX_COMMAND_PARAMS], RingStream* ringStream) {
+  if (stashBusy)
+    return false;
+  stashBusy = true;
+  stashStream = stream;
+  stashRingStream = ringStream;
+  if (ringStream)
+    stashTarget = ringStream->peekTargetMark();
+  memcpy(stashP, p, MAX_COMMAND_PARAMS * sizeof(p[0]));
+  return true;
@@ -1379,6 +1377,6 @@ bool DCCEXParser::stashCallback(Print *stream, int16_t p[MAX_COMMAND_PARAMS], Ri
-Print * DCCEXParser::getAsyncReplyStream() {
-       if (stashRingStream) {
-           stashRingStream->mark(stashTarget);
-           return stashRingStream;
-       }
-       return stashStream;
+Print* DCCEXParser::getAsyncReplyStream() {
+  if (stashRingStream) {
+    stashRingStream->mark(stashTarget);
+    return stashRingStream;
+  }
+  return stashStream;
@@ -1388,2 +1386,3 @@ void DCCEXParser::commitAsyncReplyStream() {
-     if (stashRingStream) stashRingStream->commit();
-     stashBusy = false;
+  if (stashRingStream)
+    stashRingStream->commit();
+  stashBusy = false;
@@ -1392,5 +1391,3 @@ void DCCEXParser::commitAsyncReplyStream() {
-void DCCEXParser::callback_W(int16_t result)
-{
-    StringFormatter::send(getAsyncReplyStream(),
-          F("<r %d %d>\n"), stashP[0], result == 1 ? stashP[1] : -1);
-    commitAsyncReplyStream();
+void DCCEXParser::callback_W(int16_t result) {
+  StringFormatter::send(getAsyncReplyStream(), F("<r %d %d>\n"), stashP[0], result == 1 ? stashP[1] : -1);
+  commitAsyncReplyStream();
@@ -1399,5 +1396,3 @@ void DCCEXParser::callback_W(int16_t result)
-void DCCEXParser::callback_W4(int16_t result)
-{
-    StringFormatter::send(getAsyncReplyStream(),
-	  F("<r%d|%d|%d %d>\n"), stashP[2], stashP[3], stashP[0], result == 1 ? stashP[1] : -1);
-    commitAsyncReplyStream();
+void DCCEXParser::callback_W4(int16_t result) {
+  StringFormatter::send(getAsyncReplyStream(), F("<r%d|%d|%d %d>\n"), stashP[2], stashP[3], stashP[0], result == 1 ? stashP[1] : -1);
+  commitAsyncReplyStream();
@@ -1406,5 +1401,3 @@ void DCCEXParser::callback_W4(int16_t result)
-void DCCEXParser::callback_B(int16_t result)
-{
-    StringFormatter::send(getAsyncReplyStream(), 
-          F("<r%d|%d|%d %d %d>\n"), stashP[3], stashP[4], stashP[0], stashP[1], result == 1 ? stashP[2] : -1);
-    commitAsyncReplyStream();
+void DCCEXParser::callback_B(int16_t result) {
+  StringFormatter::send(getAsyncReplyStream(), F("<r%d|%d|%d %d %d>\n"), stashP[3], stashP[4], stashP[0], stashP[1], result == 1 ? stashP[2] : -1);
+  commitAsyncReplyStream();
@@ -1412,4 +1405,3 @@ void DCCEXParser::callback_B(int16_t result)
-void DCCEXParser::callback_Vbit(int16_t result)
-{
-    StringFormatter::send(getAsyncReplyStream(), F("<v %d %d %d>\n"), stashP[0], stashP[1], result);
-    commitAsyncReplyStream();
+void DCCEXParser::callback_Vbit(int16_t result) {
+  StringFormatter::send(getAsyncReplyStream(), F("<v %d %d %d>\n"), stashP[0], stashP[1], result);
+  commitAsyncReplyStream();
@@ -1417,4 +1409,3 @@ void DCCEXParser::callback_Vbit(int16_t result)
-void DCCEXParser::callback_Vbyte(int16_t result)
-{
-    StringFormatter::send(getAsyncReplyStream(), F("<v %d %d>\n"), stashP[0], result);
-    commitAsyncReplyStream();
+void DCCEXParser::callback_Vbyte(int16_t result) {
+  StringFormatter::send(getAsyncReplyStream(), F("<v %d %d>\n"), stashP[0], result);
+  commitAsyncReplyStream();
@@ -1423,4 +1414,3 @@ void DCCEXParser::callback_Vbyte(int16_t result)
-void DCCEXParser::callback_R(int16_t result)
-{
-    StringFormatter::send(getAsyncReplyStream(), F("<r%d|%d|%d %d>\n"), stashP[1], stashP[2], stashP[0], result);
-    commitAsyncReplyStream();
+void DCCEXParser::callback_R(int16_t result) {
+  StringFormatter::send(getAsyncReplyStream(), F("<r%d|%d|%d %d>\n"), stashP[1], stashP[2], stashP[0], result);
+  commitAsyncReplyStream();
@@ -1430,3 +1420,3 @@ void DCCEXParser::callback_Rloco(int16_t result) {
-  const FSH * detail;
-  if (result<=0) {
-    detail=F("<r %d>\n");
+  const FSH* detail;
+  if (result <= 0) {
+    detail = F("<r %d>\n");
@@ -1434 +1424 @@ void DCCEXParser::callback_Rloco(int16_t result) {
-    bool longAddr=result & LONG_ADDR_MARKER;        //long addr
+    bool longAddr = result & LONG_ADDR_MARKER;  // long addr
@@ -1436 +1426 @@ void DCCEXParser::callback_Rloco(int16_t result) {
-      result = result^LONG_ADDR_MARKER;
+      result = result ^ LONG_ADDR_MARKER;
@@ -1438 +1428 @@ void DCCEXParser::callback_Rloco(int16_t result) {
-      detail=F("<r LONG %d UNSUPPORTED>\n");
+      detail = F("<r LONG %d UNSUPPORTED>\n");
@@ -1440 +1430 @@ void DCCEXParser::callback_Rloco(int16_t result) {
-      detail=F("<r %d>\n");
+      detail = F("<r %d>\n");
@@ -1446,5 +1436,5 @@ void DCCEXParser::callback_Rloco(int16_t result) {
-void DCCEXParser::callback_Wloco(int16_t result)
-{
-    if (result==1) result=stashP[0]; // pick up original requested id from command
-    StringFormatter::send(getAsyncReplyStream(), F("<w %d>\n"), result);
-    commitAsyncReplyStream();
+void DCCEXParser::callback_Wloco(int16_t result) {
+  if (result == 1)
+    result = stashP[0];  // pick up original requested id from command
+  StringFormatter::send(getAsyncReplyStream(), F("<w %d>\n"), result);
+  commitAsyncReplyStream();
@@ -1453,6 +1443,5 @@ void DCCEXParser::callback_Wloco(int16_t result)
-void DCCEXParser::callback_Wconsist(int16_t result)
-{
-    if (result==1) result=stashP[1]; // pick up original requested id from command
-    StringFormatter::send(getAsyncReplyStream(), F("<w CONSIST %d%S>\n"),
-     result, stashP[2]=="REVERSE"_hk ? F(" REVERSE") : F(""));
-    commitAsyncReplyStream();
+void DCCEXParser::callback_Wconsist(int16_t result) {
+  if (result == 1)
+    result = stashP[1];  // pick up original requested id from command
+  StringFormatter::send(getAsyncReplyStream(), F("<w CONSIST %d%S>\n"), result, stashP[2] == "REVERSE"_hk ? F(" REVERSE") : F(""));
+  commitAsyncReplyStream();
diff --git a/DCCEXParser.h b/DCCEXParser.h
index b9d56ea..2004f08 100644
--- a/DCCEXParser.h
+++ b/DCCEXParser.h
@@ -6 +6 @@
- *  
+ *
@@ -29,2 +29,15 @@
-typedef void (*FILTER_CALLBACK)(Print * stream, byte & opcode, byte & paramCount, int16_t p[]);
-typedef void (*AT_COMMAND_CALLBACK)(HardwareSerial * stream,const byte * command);
+typedef void (*FILTER_CALLBACK)(Print* stream, byte& opcode, byte& paramCount, int16_t p[]);
+typedef void (*AT_COMMAND_CALLBACK)(HardwareSerial* stream, const byte* command);
+
+struct DCCEXParser {
+        static void parse(Print* stream, byte* command, RingStream* ringStream);
+        static void parse(const FSH* cmd);
+        static void parseOne(Print* stream, byte* command, RingStream* ringStream);
+        static void setFilter(FILTER_CALLBACK filter);
+        static void setRMFTFilter(FILTER_CALLBACK filter);
+        static void setAtCommandCallback(AT_COMMAND_CALLBACK filter);
+        static const int MAX_COMMAND_PARAMS = 10;  // Must not exceed this
+
+ private:
+  static const int16_t MAX_BUFFER = 50;  // longest command sent in
+  static int16_t splitValues(int16_t result[MAX_COMMAND_PARAMS], byte* command, bool usehex);
@@ -32,22 +45,7 @@ typedef void (*AT_COMMAND_CALLBACK)(HardwareSerial * stream,const byte * command
-struct DCCEXParser
-{
-   
-   static void parse(Print * stream,  byte * command,  RingStream * ringStream);
-   static void parse(const FSH * cmd);
-   static void parseOne(Print * stream,  byte * command,  RingStream * ringStream);
-   static void setFilter(FILTER_CALLBACK filter);
-   static void setRMFTFilter(FILTER_CALLBACK filter);
-   static void setAtCommandCallback(AT_COMMAND_CALLBACK filter);
-   static const int MAX_COMMAND_PARAMS=10;  // Must not exceed this
- 
-   private:
-  
-    static const int16_t MAX_BUFFER=50;  // longest command sent in
-    static int16_t splitValues( int16_t result[MAX_COMMAND_PARAMS], byte * command, bool usehex);
-     
-    static bool parseT(Print * stream, int16_t params, int16_t p[]);
-    static bool parseZ(Print * stream, int16_t params, int16_t p[]);
-    static bool parseS(Print * stream, int16_t params, int16_t p[]);
-    static bool parsef(Print * stream, int16_t params, int16_t p[]);
-    static bool parseC(Print * stream, int16_t params, int16_t p[]);
-    static bool parseD(Print * stream, int16_t params, int16_t p[]);
+    static bool parseT(Print* stream, int16_t params, int16_t p[]);
+    static bool parseZ(Print* stream, int16_t params, int16_t p[]);
+    static bool parseS(Print* stream, int16_t 
+      params, int16_t    p  []);
+    static bool parsef(Print* stream, int16_t params, int16_t p[]);
+  static bool parseC(Print* stream, int16_t params, int16_t p[]);
+  static bool parseD(Print* stream, int16_t params, int16_t p[]);
@@ -55 +53 @@ struct DCCEXParser
-    static bool parseI(Print * stream, int16_t params, int16_t p[]);
+  static bool parseI(Print*   stream, int16_t params, int16_t p[]);
@@ -58,2 +56,2 @@ struct DCCEXParser
-    static Print * getAsyncReplyStream();
-    static void commitAsyncReplyStream();
+  static    Print* getAsyncReplyStream();
+  static void commitAsyncReplyStream();
@@ -61,21 +59,4 @@ struct DCCEXParser
-    static bool stashBusy;
-    static byte stashTarget;
-    static Print * stashStream;
-    static RingStream * stashRingStream;
-    
-    static int16_t stashP[MAX_COMMAND_PARAMS];
-    static bool stashCallback(Print * stream, int16_t p[MAX_COMMAND_PARAMS], RingStream * ringStream);
-    static void callback_W(int16_t result);
-    static void callback_W4(int16_t result);
-    static void callback_B(int16_t result);        
-    static void callback_R(int16_t result);
-    static void callback_Rloco(int16_t result);
-    static void callback_Wloco(int16_t result);
-    static void callback_Wconsist(int16_t result);
-    static void callback_Vbit(int16_t result);
-    static void callback_Vbyte(int16_t result);
-    static FILTER_CALLBACK  filterCallback;
-    static FILTER_CALLBACK  filterRMFTCallback;
-    static AT_COMMAND_CALLBACK  atCommandCallback;
-    static bool funcmap(int16_t cab, byte value, byte fstart, byte fstop);
-    static void sendFlashList(Print * stream,const int16_t flashList[]);
+  static bool stashBusy;
+  static byte stashTarget;
+  static Print* stashStream;
+  static RingStream* stashRingStream;
@@ -82,0 +64,16 @@ struct DCCEXParser
+  static int16_t stashP[MAX_COMMAND_PARAMS];
+  static bool stashCallback(Print* stream, int16_t p[MAX_COMMAND_PARAMS], RingStream* ringStream);
+  static void callback_W(int16_t result);
+  static void callback_W4( int16_t result);
+  static void callback_B(int16_t result);
+  static void callback_R( int16_t result);
+  static void callback_Rloco(int16_t result);
+  static void callback_Wloco( int16_t result);
+  static void callback_Wconsist(int16_t result);
+  static void callback_Vbit (int16_t result);
+  static void callback_Vbyte(int16_t result) ;
+  static FILTER_CALLBACK filterCallback;
+  static FILTER_CALLBACK filterRMFTCallback ;
+  static AT_COMMAND_CALLBACK atCommandCallback ;
+  static bool funcmap(int16_t cab, byte value, byte fstart, byte fstop );
+  static void sendFlashList(Print* stream, const int16_t flashList[] );
diff --git a/DCCRMT.cpp b/DCCRMT.cpp
index 24a6e00..74fbd83 100644
--- a/DCCRMT.cpp
+++ b/DCCRMT.cpp
@@ -3 +3 @@
- *  
+ *
@@ -44 +44 @@
-#include "DCCWaveform.h" // for MAX_PACKET_SIZE
+#include "DCCWaveform.h"  // for MAX_PACKET_SIZE
@@ -61 +61 @@ static const byte RMT_CHAN_PER_DCC_CHAN = 2;
-#define DATA_LEN(X) ((X)*9+1)
+#define DATA_LEN(X) ((X) * 9 + 1)
@@ -63 +63 @@ static const byte RMT_CHAN_PER_DCC_CHAN = 2;
-#if ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(4,2,0)
+#if ESP_IDF_VERSION < ESP_IDF_VERSION_VAL(4, 2, 0)
@@ -68 +68 @@ void setDCCBit1(rmt_item32_t* item) {
-  item->level0    = 1;
+  item->level0 = 1;
@@ -70 +70 @@ void setDCCBit1(rmt_item32_t* item) {
-  item->level1    = 0;
+  item->level1 = 0;
@@ -75 +75 @@ void setDCCBit0(rmt_item32_t* item) {
-  item->level0    = 1;
+  item->level0 = 1;
@@ -77 +77 @@ void setDCCBit0(rmt_item32_t* item) {
-  item->level1    = 0;
+  item->level1 = 0;
@@ -83,4 +83,4 @@ void setDCCBit0Long(rmt_item32_t* item) {
-  item->level0    = 1;
-  item->duration0 = DCC_0_HALFPERIOD + DCC_0_HALFPERIOD/10;
-  item->level1    = 0;
-  item->duration1 = DCC_0_HALFPERIOD + DCC_0_HALFPERIOD/10;
+  item->level0 = 1;
+  item->duration0 = DCC_0_HALFPERIOD + DCC_0_HALFPERIOD / 10;
+  item->level1 = 0;
+  item->duration1 = DCC_0_HALFPERIOD + DCC_0_HALFPERIOD / 10;
@@ -97 +97 @@ void setEOT(rmt_item32_t* item) {
-RMTChannel *channelHandle[8] = { 0 };
+RMTChannel* channelHandle[8] = {0};
@@ -99,3 +99,4 @@ RMTChannel *channelHandle[8] = { 0 };
-void IRAM_ATTR interrupt(rmt_channel_t channel, void *t) {
-  RMTChannel *tt = channelHandle[channel];
-  if (tt) tt->RMTinterrupt();
+void IRAM_ATTR interrupt(rmt_channel_t channel, void* t) {
+  RMTChannel* tt = channelHandle[channel];
+  if (tt)
+    tt->RMTinterrupt();
@@ -126,2 +127,2 @@ RMTChannel::RMTChannel(pinpair pins, bool isMain) {
-    static_assert (DATA_LEN(MAX_PACKET_SIZE+1) + PREAMBLE_BITS_MAIN + 2 <= RMT_CHAN_PER_DCC_CHAN * SOC_RMT_MEM_WORDS_PER_CHANNEL,
-		  "Number of DCC packet bits greater than ESP32 RMT memory available");
+    static_assert(DATA_LEN(MAX_PACKET_SIZE + 1) + PREAMBLE_BITS_MAIN + 2 <= RMT_CHAN_PER_DCC_CHAN * SOC_RMT_MEM_WORDS_PER_CHANNEL,
+                  "Number of DCC packet bits greater than ESP32 RMT memory available");
@@ -129 +130 @@ RMTChannel::RMTChannel(pinpair pins, bool isMain) {
-    ch = RMT_CHAN_PER_DCC_CHAN; // number == offset
+    ch = RMT_CHAN_PER_DCC_CHAN;  // number == offset
@@ -131,2 +132,2 @@ RMTChannel::RMTChannel(pinpair pins, bool isMain) {
-    static_assert (DATA_LEN(MAX_PACKET_SIZE+1) + PREAMBLE_BITS_PROG + 2 <= RMT_CHAN_PER_DCC_CHAN * SOC_RMT_MEM_WORDS_PER_CHANNEL,
-		   "Number of DCC packet bits greater than ESP32 RMT memory available");
+    static_assert(DATA_LEN(MAX_PACKET_SIZE + 1) + PREAMBLE_BITS_PROG + 2 <= RMT_CHAN_PER_DCC_CHAN * SOC_RMT_MEM_WORDS_PER_CHANNEL,
+                  "Number of DCC packet bits greater than ESP32 RMT memory available");
@@ -134 +135 @@ RMTChannel::RMTChannel(pinpair pins, bool isMain) {
-    
+
@@ -136,4 +137,3 @@ RMTChannel::RMTChannel(pinpair pins, bool isMain) {
-  preambleLen = plen+2; // plen 1 bits, one 0 bit and one EOF marker
-  preamble = (rmt_item32_t*)malloc(preambleLen*sizeof(rmt_item32_t));
-  for (byte n=0; n<plen; n++)
-    setDCCBit1(preamble + n);      // preamble bits
+  preambleLen = plen + 2;  // plen 1 bits, one 0 bit and one EOF marker
+  preamble = (rmt_item32_t*)malloc(preambleLen * sizeof(rmt_item32_t));
+  for (byte n = 0; n < plen; n++) setDCCBit1(preamble + n);  // preamble bits
@@ -141 +141 @@ RMTChannel::RMTChannel(pinpair pins, bool isMain) {
-  setDCCBit0Long(preamble + plen); // start of packet 0 bit long version
+  setDCCBit0Long(preamble + plen);  // start of packet 0 bit long version
@@ -143 +143 @@ RMTChannel::RMTChannel(pinpair pins, bool isMain) {
-  setDCCBit0(preamble + plen);     // start of packet 0 bit normal version
+  setDCCBit0(preamble + plen);  // start of packet 0 bit normal version
@@ -145 +145 @@ RMTChannel::RMTChannel(pinpair pins, bool isMain) {
-  setEOT(preamble + plen + 1);     // EOT marker
+  setEOT(preamble + plen + 1);  // EOT marker
@@ -149 +149 @@ RMTChannel::RMTChannel(pinpair pins, bool isMain) {
-  idle = (rmt_item32_t*)malloc(idleLen*sizeof(rmt_item32_t));
+  idle = (rmt_item32_t*)malloc(idleLen * sizeof(rmt_item32_t));
@@ -151 +151 @@ RMTChannel::RMTChannel(pinpair pins, bool isMain) {
-    for (byte n=0; n<8; n++)   // 0 to 7
+    for (byte n = 0; n < 8; n++)  // 0 to 7
@@ -153 +153 @@ RMTChannel::RMTChannel(pinpair pins, bool isMain) {
-    for (byte n=8; n<18; n++)  // 8, 9 to 16, 17
+    for (byte n = 8; n < 18; n++)  // 8, 9 to 16, 17
@@ -155 +155 @@ RMTChannel::RMTChannel(pinpair pins, bool isMain) {
-    for (byte n=18; n<26; n++) // 18 to 25
+    for (byte n = 18; n < 26; n++)  // 18 to 25
@@ -158 +158 @@ RMTChannel::RMTChannel(pinpair pins, bool isMain) {
-    for (byte n=0; n<26; n++)  // all zero
+    for (byte n = 0; n < 26; n++)  // all zero
@@ -161,2 +161,2 @@ RMTChannel::RMTChannel(pinpair pins, bool isMain) {
-  setDCCBit1(idle + 26);     // end bit
-  setEOT(idle + 27);         // EOT marker
+  setDCCBit1(idle + 26);  // end bit
+  setEOT(idle + 27);      // EOT marker
@@ -165,2 +165,2 @@ RMTChannel::RMTChannel(pinpair pins, bool isMain) {
-  maxDataLen = DATA_LEN(MAX_PACKET_SIZE+1);  // plus checksum
-  data = (rmt_item32_t*)malloc(maxDataLen*sizeof(rmt_item32_t));
+  maxDataLen = DATA_LEN(MAX_PACKET_SIZE + 1);  // plus checksum
+  data = (rmt_item32_t*)malloc(maxDataLen * sizeof(rmt_item32_t));
@@ -179 +179 @@ RMTChannel::RMTChannel(pinpair pins, bool isMain) {
-  
+
@@ -181 +181 @@ RMTChannel::RMTChannel(pinpair pins, bool isMain) {
-  ESP_ERROR_CHECK(rmt_driver_install(config.channel, 0, ESP_INTR_FLAG_LOWMED|ESP_INTR_FLAG_SHARED));
+  ESP_ERROR_CHECK(rmt_driver_install(config.channel, 0, ESP_INTR_FLAG_LOWMED | ESP_INTR_FLAG_SHARED));
@@ -186 +186 @@ RMTChannel::RMTChannel(pinpair pins, bool isMain) {
-  channelHandle[channel] = this; // used by interrupt
+  channelHandle[channel] = this;  // used by interrupt
@@ -194 +194 @@ RMTChannel::RMTChannel(pinpair pins, bool isMain) {
-  //rmt_write_items(channel, preamble, preambleLen, false);
+  // rmt_write_items(channel, preamble, preambleLen, false);
@@ -201 +201 @@ void RMTChannel::RMTprefill() {
-  rmt_fill_tx_items(channel, idle, idleLen, preambleLen-1);
+  rmt_fill_tx_items(channel, idle, idleLen, preambleLen - 1);
@@ -206,8 +206,8 @@ const byte transmitMask[] = {0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01};
-int RMTChannel::RMTfillData(const byte buffer[], byte byteCount, byte repeatCount=0) {
-  //int RMTChannel::RMTfillData(dccPacket packet) {
-  // dataReady: Signals to then interrupt routine. It is set when
-  // we have data in the channel buffer which can be copied out
-  // to the HW. dataRepeat on the other hand signals back to
-  // the caller of this function if the data has been sent enough
-  // times (0 to 3 means 1 to 4 times in total).
-  if (dataRepeat > 0) // we have still old work to do
+int RMTChannel::RMTfillData(const byte buffer[], byte byteCount, byte repeatCount = 0) {
+  // int RMTChannel::RMTfillData(dccPacket packet) {
+  //  dataReady: Signals to then interrupt routine. It is set when
+  //  we have data in the channel buffer which can be copied out
+  //  to the HW. dataRepeat on the other hand signals back to
+  //  the caller of this function if the data has been sent enough
+  //  times (0 to 3 means 1 to 4 times in total).
+  if (dataRepeat > 0)  // we have still old work to do
@@ -215 +215 @@ int RMTChannel::RMTfillData(const byte buffer[], byte byteCount, byte repeatCoun
-  if (dataReady == true) // the packet is not copied out yet
+  if (dataReady == true)  // the packet is not copied out yet
@@ -219 +219 @@ int RMTChannel::RMTfillData(const byte buffer[], byte byteCount, byte repeatCoun
-    return -1;                          // something very broken, can not convert packet
+    return -1;  // something very broken, can not convert packet
@@ -224,2 +224,2 @@ int RMTChannel::RMTfillData(const byte buffer[], byte byteCount, byte repeatCoun
-  for(byte n=0; n<byteCount; n++) {
-    for(byte bit=0; bit<8; bit++) {
+  for (byte n = 0; n < byteCount; n++) {
+    for (byte bit = 0; bit < 8; bit++) {
@@ -227 +227 @@ int RMTChannel::RMTfillData(const byte buffer[], byte byteCount, byte repeatCoun
-	setDCCBit1(data + bitcounter++);
+        setDCCBit1(data + bitcounter++);
@@ -229 +229 @@ int RMTChannel::RMTfillData(const byte buffer[], byte byteCount, byte repeatCoun
-	setDCCBit0(data + bitcounter++);
+        setDCCBit0(data + bitcounter++);
@@ -231 +231 @@ int RMTChannel::RMTfillData(const byte buffer[], byte byteCount, byte repeatCoun
-    setDCCBit0(data + bitcounter++); // zero at end of each byte
+    setDCCBit0(data + bitcounter++);  // zero at end of each byte
@@ -233,2 +233,2 @@ int RMTChannel::RMTfillData(const byte buffer[], byte byteCount, byte repeatCoun
-  setDCCBit1(data + bitcounter-1);     // overwrite previous zero bit with one bit
-  setEOT(data + bitcounter++);         // EOT marker
+  setDCCBit1(data + bitcounter - 1);  // overwrite previous zero bit with one bit
+  setEOT(data + bitcounter++);        // EOT marker
@@ -236 +236 @@ int RMTChannel::RMTfillData(const byte buffer[], byte byteCount, byte repeatCoun
-  noInterrupts();                      // keep dataReady and dataRepeat consistnet to each other
+  noInterrupts();  // keep dataReady and dataRepeat consistnet to each other
@@ -238 +238 @@ int RMTChannel::RMTfillData(const byte buffer[], byte byteCount, byte repeatCoun
-  dataRepeat = repeatCount+1;         // repeatCount of 0 means send once
+  dataRepeat = repeatCount + 1;  // repeatCount of 0 means send once
@@ -244,2 +244,2 @@ void IRAM_ATTR RMTChannel::RMTinterrupt() {
-  //no rmt_tx_start(channel,true) as we run in loop mode
-  //preamble is always loaded at beginning of buffer
+  // no rmt_tx_start(channel,true) as we run in loop mode
+  // preamble is always loaded at beginning of buffer
@@ -247,3 +247,3 @@ void IRAM_ATTR RMTChannel::RMTinterrupt() {
-  if (!dataReady && dataRepeat == 0) { // we did run empty
-    rmt_fill_tx_items(channel, idle, idleLen, preambleLen-1);
-    return; // nothing to do about that
+  if (!dataReady && dataRepeat == 0) {  // we did run empty
+    rmt_fill_tx_items(channel, idle, idleLen, preambleLen - 1);
+    return;  // nothing to do about that
@@ -253,2 +253,2 @@ void IRAM_ATTR RMTChannel::RMTinterrupt() {
-  if (dataReady) {            // if we have new data, fill while preamble is running
-    rmt_fill_tx_items(channel, data, dataLen, preambleLen-1);
+  if (dataReady) {  // if we have new data, fill while preamble is running
+    rmt_fill_tx_items(channel, data, dataLen, preambleLen - 1);
@@ -256 +256 @@ void IRAM_ATTR RMTChannel::RMTinterrupt() {
-    if (dataRepeat == 0)       // all data should go out at least once
+    if (dataRepeat == 0)  // all data should go out at least once
@@ -259 +259 @@ void IRAM_ATTR RMTChannel::RMTinterrupt() {
-  if (dataRepeat > 0)         // if a repeat count was specified, work on that
+  if (dataRepeat > 0)  // if a repeat count was specified, work on that
@@ -270,3 +270,5 @@ bool RMTChannel::addPin(byte pin, bool inverted) {
-  if (err != ESP_OK) return false;
-  gpio_matrix_out(gpioNum, RMT_SIG_OUT0_IDX+channel, inverted, 0);
-  if (err != ESP_OK) return false;
+  if (err != ESP_OK)
+    return false;
+  gpio_matrix_out(gpioNum, RMT_SIG_OUT0_IDX + channel, inverted, 0);
+  if (err != ESP_OK)
+    return false;
@@ -278 +280 @@ bool RMTChannel::addPin(pinpair pins) {
-#endif //ESP32
+#endif  // ESP32
diff --git a/DCCRMT.h b/DCCRMT.h
index 3a20027..803516e 100644
--- a/DCCRMT.h
+++ b/DCCRMT.h
@@ -3 +3 @@
- *  
+ *
@@ -26 +26 @@
-#include "MotorDriver.h" // for class pinpair
+#include "MotorDriver.h"  // for class pinpair
@@ -30,2 +30,2 @@
-#define DCC_1_HALFPERIOD 58  //4640 // 1 / 80000000 * 4640 = 58us
-#define DCC_0_HALFPERIOD 100 //8000
+#define DCC_1_HALFPERIOD 58   // 4640 // 1 / 80000000 * 4640 = 58us
+#define DCC_0_HALFPERIOD 100  // 8000
@@ -36 +36 @@ class RMTChannel {
-  bool addPin(byte pin, bool inverted=0);
+  bool addPin(byte pin, bool inverted = 0);
@@ -40 +40 @@ class RMTChannel {
-  //int RMTfillData(dccPacket packet);
+  // int RMTfillData(dccPacket packet);
@@ -43 +43 @@ class RMTChannel {
-    if (dataRepeat > 0) // we have still old work to do
+    if (dataRepeat > 0)  // we have still old work to do
@@ -48 +48 @@ class RMTChannel {
-    while(1) { // do nothing and wait for interrupt clearing dataReady to happen
+    while (1) {  // do nothing and wait for interrupt clearing dataReady to happen
@@ -50 +50 @@ class RMTChannel {
-	break;
+        break;
@@ -53,2 +53,4 @@ class RMTChannel {
-  inline uint32_t packetCount() { return packetCounter; };
-  
+  inline uint32_t packetCount() {
+    return packetCounter;
+  };
+
@@ -56 +57,0 @@ class RMTChannel {
-    
@@ -60 +61 @@ class RMTChannel {
-  rmt_item32_t *idle;
+  rmt_item32_t* idle;
@@ -62 +63 @@ class RMTChannel {
-  rmt_item32_t *preamble;
+  rmt_item32_t* preamble;
@@ -64 +65 @@ class RMTChannel {
-  rmt_item32_t *data;
+  rmt_item32_t* data;
@@ -68,2 +69,2 @@ class RMTChannel {
-  // flags 
-  volatile bool dataReady = false;    // do we have real data available or send idle
+  // flags
+  volatile bool dataReady = false;  // do we have real data available or send idle
@@ -72 +73 @@ class RMTChannel {
-#endif //ESP32
+#endif  // ESP32
diff --git a/DCCTimer.h b/DCCTimer.h
index c3fcaf1..9570cdc 100644
--- a/DCCTimer.h
+++ b/DCCTimer.h
@@ -7 +7 @@
- *  
+ *
@@ -24 +24 @@
-/* There are several different implementations of this class which the compiler will select 
+/* There are several different implementations of this class which the compiler will select
@@ -29,3 +29,3 @@
- *  All timer access comes through this class so that it can be compiled for 
- *  various hardware CPU types. 
- *  
+ *  All timer access comes through this class so that it can be compiled for
+ *  various hardware CPU types.
+ *
@@ -33,3 +33,3 @@
- *  The DCCWaveform class generates the signals to the motor shield  
- *  based on this timer. 
- *  
+ *  The DCCWaveform class generates the signals to the motor shield
+ *  based on this timer.
+ *
@@ -39,5 +39,5 @@
- *  achieved by setting the duty cycle of the NEXT clock interrupt to 0% or 100% depending on 
- *  the required pin state. (see setPWM())  
- *  This is more accurate than the software interrupt but at the expense of 
- *  limiting the choice of available pins. 
- *  Fortunately, a standard motor shield on a Mega uses pins that qualify for PWM... 
+ *  achieved by setting the duty cycle of the NEXT clock interrupt to 0% or 100% depending on
+ *  the required pin state. (see setPWM())
+ *  This is more accurate than the software interrupt but at the expense of
+ *  limiting the choice of available pins.
+ *  Fortunately, a standard motor shield on a Mega uses pins that qualify for PWM...
@@ -45 +45 @@
- *  
+ *
@@ -49 +49 @@
- *  
+ *
@@ -59 +59 @@ class DCCTimer {
-  public:
+ public:
@@ -74,14 +74,15 @@ class DCCTimer {
-// Update low ram level.  Allow for extra bytes to be specified
-// by estimation or inspection, that may be used by other 
-// called subroutines.  Must be called with interrupts disabled.
-// 
-// Although __brkval may go up and down as heap memory is allocated
-// and freed, this function records only the worst case encountered.
-// So even if all of the heap is freed, the reported minimum free 
-// memory will not increase.
-//
-  static void inline updateMinimumFreeMemoryISR(unsigned char extraBytes=0)
-    __attribute__((always_inline)) {
-    int spare = freeMemory()-extraBytes;
-    if (spare < 0) spare = 0;
-    if (spare < minimum_free_memory) minimum_free_memory = spare;
+  // Update low ram level.  Allow for extra bytes to be specified
+  // by estimation or inspection, that may be used by other
+  // called subroutines.  Must be called with interrupts disabled.
+  //
+  // Although __brkval may go up and down as heap memory is allocated
+  // and freed, this function records only the worst case encountered.
+  // So even if all of the heap is freed, the reported minimum free
+  // memory will not increase.
+  //
+  static void inline updateMinimumFreeMemoryISR(unsigned char extraBytes = 0) __attribute__((always_inline)) {
+    int spare = freeMemory() - extraBytes;
+    if (spare < 0)
+      spare = 0;
+    if (spare < minimum_free_memory)
+      minimum_free_memory = spare;
@@ -90 +91 @@ class DCCTimer {
-  static int  getMinimumFreeMemory();
+  static int getMinimumFreeMemory();
@@ -92,2 +93,2 @@ class DCCTimer {
-  
-private:
+
+ private:
@@ -97,3 +98,3 @@ private:
-  static const int DCC_SIGNAL_TIME=58;  // this is the 58uS DCC 1-bit waveform half-cycle 
-#if defined(ARDUINO_ARCH_STM32)  // TODO: PMA temporary hack - assumes 100Mhz F_CPU as STM32 can change frequency
-  static const long CLOCK_CYCLES=(100000000L / 1000000 * DCC_SIGNAL_TIME) >>1;
+  static const int DCC_SIGNAL_TIME = 58;  // this is the 58uS DCC 1-bit waveform half-cycle
+#if defined(ARDUINO_ARCH_STM32)           // TODO: PMA temporary hack - assumes 100Mhz F_CPU as STM32 can change frequency
+  static const long CLOCK_CYCLES = (100000000L / 1000000 * DCC_SIGNAL_TIME) >> 1;
@@ -101 +102 @@ private:
-  static const long CLOCK_CYCLES=(F_CPU / 1000000 * DCC_SIGNAL_TIME) >>1;
+  static const long CLOCK_CYCLES = (F_CPU / 1000000 * DCC_SIGNAL_TIME) >> 1;
@@ -103 +103,0 @@ private:
-
@@ -114 +114 @@ class ADCee {
-public:
+ public:
@@ -128 +128 @@ public:
-  static int read(uint8_t pin, bool fromISR=false);
+  static int read(uint8_t pin, bool fromISR = false);
@@ -131 +131,2 @@ public:
-private:
+
+ private:
@@ -135 +136 @@ private:
-  #if defined (ARDUINO_ARCH_STM32)
+#if defined(ARDUINO_ARCH_STM32)
@@ -138,2 +139,2 @@ private:
-  static uint32_t * analogchans;        // Array of channel numbers to be scanned
-  static ADC_TypeDef * * adcchans;      // Array to capture which ADC is each input channel on
+  static uint32_t* analogchans;   // Array of channel numbers to be scanned
+  static ADC_TypeDef** adcchans;  // Array to capture which ADC is each input channel on
@@ -146 +147 @@ private:
-  static int *analogvals;
+  static int* analogvals;
@@ -149 +150 @@ private:
-  };
+};
diff --git a/DCCTimerAVR.cpp b/DCCTimerAVR.cpp
index 5f828d7..203d42b 100644
--- a/DCCTimerAVR.cpp
+++ b/DCCTimerAVR.cpp
@@ -8 +8 @@
- *  
+ *
@@ -29 +29 @@
-#include <avr/boot.h> 
+#include <avr/boot.h>
@@ -36 +36 @@
-INTERRUPT_CALLBACK interruptHandler=0;
+INTERRUPT_CALLBACK interruptHandler = 0;
@@ -38 +38 @@ INTERRUPT_CALLBACK interruptHandler=0;
-  // Arduino nano, uno, mega etc
+// Arduino nano, uno, mega etc
@@ -40,6 +40,6 @@ INTERRUPT_CALLBACK interruptHandler=0;
-    #define TIMER1_A_PIN   11
-    #define TIMER1_B_PIN   12
-    #define TIMER1_C_PIN   13
-    #define TIMER2_A_PIN   10
-    #define TIMER2_B_PIN   9
-    
+#define TIMER1_A_PIN 11
+#define TIMER1_B_PIN 12
+#define TIMER1_C_PIN 13
+#define TIMER2_A_PIN 10
+#define TIMER2_B_PIN 9
+
@@ -47,2 +47,2 @@ INTERRUPT_CALLBACK interruptHandler=0;
-   #define TIMER1_A_PIN   9
-   #define TIMER1_B_PIN   10
+#define TIMER1_A_PIN 9
+#define TIMER1_B_PIN 10
@@ -52,10 +52,9 @@ void DCCTimer::begin(INTERRUPT_CALLBACK callback) {
-    interruptHandler=callback;
-    noInterrupts();
-    TCCR1A = 0;
-    ICR1 = CLOCK_CYCLES;
-    TCNT1 = 0;   
-    TCCR1B = _BV(WGM13) | _BV(CS10);     // Mode 8, clock select 1
-    TIMSK1 = _BV(TOIE1); // Enable Software interrupt
-    interrupts();
-  }
-
+  interruptHandler = callback;
+  noInterrupts();
+  TCCR1A = 0;
+  ICR1 = CLOCK_CYCLES;
+  TCNT1 = 0;
+  TCCR1B = _BV(WGM13) | _BV(CS10);  // Mode 8, clock select 1
+  TIMSK1 = _BV(TOIE1);              // Enable Software interrupt
+  interrupts();
+}
@@ -64,2 +63,2 @@ void DCCTimer::startRailcomTimer(byte brakePin) {
-  /* The Railcom timer is started in such a way that it 
-     - First triggers 28uS after the last TIMER1 tick. 
+  /* The Railcom timer is started in such a way that it
+     - First triggers 28uS after the last TIMER1 tick.
@@ -68 +67 @@ void DCCTimer::startRailcomTimer(byte brakePin) {
-     - Sets the Railcom pin high at first tick, 
+     - Sets the Railcom pin high at first tick,
@@ -70,2 +69,2 @@ void DCCTimer::startRailcomTimer(byte brakePin) {
-        
-     - Cycles at 436uS so the second tick is the 
+
+     - Cycles at 436uS so the second tick is the
@@ -73,2 +72,2 @@ void DCCTimer::startRailcomTimer(byte brakePin) {
-        
-     - Waveform code is responsible for altering the PWM 
+
+     - Waveform code is responsible for altering the PWM
@@ -77 +76 @@ void DCCTimer::startRailcomTimer(byte brakePin) {
-    
+
@@ -79,3 +78,3 @@ void DCCTimer::startRailcomTimer(byte brakePin) {
-  (void) brakePin; // Ignored... works on pin 9 only 
-  const int cutoutDuration = 430; // Desired interval in microseconds
-  
+  (void)brakePin;                  // Ignored... works on pin 9 only
+  const int cutoutDuration = 430;  // Desired interval in microseconds
+
@@ -83,8 +82,7 @@ void DCCTimer::startRailcomTimer(byte brakePin) {
-  TCCR2A = 0; // Clear Timer2 control register A
-  TCCR2B = 0; // Clear Timer2 control register B
-  TCNT2 = 0;  // Initialize Timer2 counter value to 0
-   // Configure Phase and Frequency Correct PWM mode
-   TCCR2A =  (1 << COM2B1); // enable pwm on pin 9
-   TCCR2A |= (1 << WGM20);
-  
-   
+  TCCR2A = 0;  // Clear Timer2 control register A
+  TCCR2B = 0;  // Clear Timer2 control register B
+  TCNT2 = 0;   // Initialize Timer2 counter value to 0
+  // Configure Phase and Frequency Correct PWM mode
+  TCCR2A = (1 << COM2B1);  // enable pwm on pin 9
+  TCCR2A |= (1 << WGM20);
+
@@ -92 +90 @@ void DCCTimer::startRailcomTimer(byte brakePin) {
-  TCCR2B = (1 << CS21) | (1 << CS20); // 32 prescaler
+  TCCR2B = (1 << CS21) | (1 << CS20);  // 32 prescaler
@@ -98 +96 @@ void DCCTimer::startRailcomTimer(byte brakePin) {
-  OCR2B = OCR2A+1;  // set duty cycle to 100%= OCR2A)
+  OCR2B = OCR2A + 1;  // set duty cycle to 100%= OCR2A)
@@ -104,5 +102,5 @@ void DCCTimer::startRailcomTimer(byte brakePin) {
- // Previous TIMER1 Tick was at rising end-of-packet bit
- // Cutout starts half way through first preamble
- // that is 2.5 * 58uS later.
- // TCNT1 ticks 8 times / microsecond
- // auto microsendsToFirstRailcomTick=(58+58+29)-(TCNT1/8);
+  // Previous TIMER1 Tick was at rising end-of-packet bit
+  // Cutout starts half way through first preamble
+  // that is 2.5 * 58uS later.
+  // TCNT1 ticks 8 times / microsecond
+  // auto microsendsToFirstRailcomTick=(58+58+29)-(TCNT1/8);
@@ -111 +109 @@ void DCCTimer::startRailcomTimer(byte brakePin) {
-  // CHris's NOTE: 
+  // CHris's NOTE:
@@ -113 +111 @@ void DCCTimer::startRailcomTimer(byte brakePin) {
-  // it does seems to get a good answer. 
+  // it does seems to get a good answer.
@@ -115 +113 @@ void DCCTimer::startRailcomTimer(byte brakePin) {
-  TCNT2=193 + (ICR1 - TCNT1)/8;
+  TCNT2 = 193 + (ICR1 - TCNT1) / 8;
@@ -119 +117 @@ void DCCTimer::ackRailcomTimer() {
-  OCR2B= 0x00;  // brake pin pwm duty cycle 0 at next tick
+  OCR2B = 0x00;  // brake pin pwm duty cycle 0 at next tick
@@ -122 +119,0 @@ void DCCTimer::ackRailcomTimer() {
-
@@ -124 +121,3 @@ void DCCTimer::ackRailcomTimer() {
-  ISR(TIMER1_OVF_vect){ interruptHandler(); }
+ISR(TIMER1_OVF_vect) {
+  interruptHandler();
+}
@@ -127,8 +126,7 @@ void DCCTimer::ackRailcomTimer() {
-  bool DCCTimer::isPWMPin(byte pin) {
-       return pin==TIMER1_A_PIN 
-           || pin==TIMER1_B_PIN
-       #ifdef TIMER1_C_PIN 
-           || pin==TIMER1_C_PIN
-       #endif       
-       ;
-  }
+bool DCCTimer::isPWMPin(byte pin) {
+  return pin == TIMER1_A_PIN || pin == TIMER1_B_PIN
+#ifdef TIMER1_C_PIN
+         || pin == TIMER1_C_PIN
+#endif
+      ;
+}
@@ -136,16 +134,15 @@ void DCCTimer::ackRailcomTimer() {
- void DCCTimer::setPWM(byte pin, bool high) {
-    if (pin==TIMER1_A_PIN) {
-      TCCR1A |= _BV(COM1A1);
-      OCR1A= high?1024:0;
-    }
-    else if (pin==TIMER1_B_PIN) { 
-      TCCR1A |= _BV(COM1B1);
-      OCR1B= high?1024:0;
-    }
- #ifdef TIMER1_C_PIN 
-    else if (pin==TIMER1_C_PIN) { 
-      TCCR1A |= _BV(COM1C1);
-      OCR1C= high?1024:0;
-    }
- #endif       
- }
+void DCCTimer::setPWM(byte pin, bool high) {
+  if (pin == TIMER1_A_PIN) {
+    TCCR1A |= _BV(COM1A1);
+    OCR1A = high ? 1024 : 0;
+  } else if (pin == TIMER1_B_PIN) {
+    TCCR1A |= _BV(COM1B1);
+    OCR1B = high ? 1024 : 0;
+  }
+#ifdef TIMER1_C_PIN
+  else if (pin == TIMER1_C_PIN) {
+    TCCR1A |= _BV(COM1C1);
+    OCR1C = high ? 1024 : 0;
+  }
+#endif
+}
@@ -154 +151 @@ void DCCTimer::clearPWM() {
-  TCCR1A= 0;
+  TCCR1A = 0;
@@ -157,9 +154,6 @@ void DCCTimer::clearPWM() {
-  void DCCTimer::getSimulatedMacAddress(byte mac[6]) {
-    for (byte i=0; i<6; i++) {
-      // take the fist 3 and last 3 of the serial.
-      // the first 5 of 8 are at 0x0E to 0x013
-      // the last  3 of 8 are at 0x15 to 0x017
-      mac[i]=boot_signature_byte_get(0x0E + i + (i>2? 4 : 0));
-    }
-    mac[0] &= 0xFE;
-    mac[0] |= 0x02;
+void DCCTimer::getSimulatedMacAddress(byte mac[6]) {
+  for (byte i = 0; i < 6; i++) {
+    // take the fist 3 and last 3 of the serial.
+    // the first 5 of 8 are at 0x0E to 0x013
+    // the last  3 of 8 are at 0x15 to 0x017
+    mac[i] = boot_signature_byte_get(0x0E + i + (i > 2 ? 4 : 0));
@@ -166,0 +161,3 @@ void DCCTimer::clearPWM() {
+  mac[0] &= 0xFE;
+  mac[0] |= 0x02;
+}
@@ -167,0 +165 @@ void DCCTimer::clearPWM() {
+volatile int DCCTimer::minimum_free_memory = __INT_MAX__;
@@ -169,3 +167 @@ void DCCTimer::clearPWM() {
-volatile int DCCTimer::minimum_free_memory=__INT_MAX__;
-
-// Return low memory value... 
+// Return low memory value...
@@ -173 +169 @@ int DCCTimer::getMinimumFreeMemory() {
-  noInterrupts(); // Disable interrupts to get volatile value 
+  noInterrupts();  // Disable interrupts to get volatile value
@@ -179,2 +175,2 @@ int DCCTimer::getMinimumFreeMemory() {
-extern char *__brkval;
-extern char *__malloc_heap_start;
+extern char* __brkval;
+extern char* __malloc_heap_start;
@@ -190 +186 @@ void DCCTimer::reset() {
-  wdt_enable( WDTO_250MS); // set Arduino watchdog timer for 250ms 
+  wdt_enable(WDTO_250MS);  // set Arduino watchdog timer for 250ms
@@ -192 +187,0 @@ void DCCTimer::reset() {
-
@@ -200,6 +195,6 @@ void DCCTimer::DCCEXanalogWriteFrequencyInternal(uint8_t pin, uint32_t fbits) {
-      (void)fbits;
-      (void) pin;
-      // Not worth doin something here as:
-      // If we are on pin 9 or 10 we are on Timer1 and we can not touch Timer1 as that is our DCC source.
-      // If we are on pin 5 or 6 we are on Timer 0 ad we can not touch Timer0 as that is millis() etc.
-      // We are most likely not on pin 3 or 11 as no known motor shield has that as brake.
+  (void)fbits;
+  (void)pin;
+  // Not worth doin something here as:
+  // If we are on pin 9 or 10 we are on Timer1 and we can not touch Timer1 as that is our DCC source.
+  // If we are on pin 5 or 6 we are on Timer 0 ad we can not touch Timer0 as that is millis() etc.
+  // We are most likely not on pin 3 or 11 as no known motor shield has that as brake.
@@ -215 +210 @@ void DCCTimer::DCCEXanalogWriteFrequencyInternal(uint8_t pin, uint32_t fbits) {
-  if (pin == 9 || pin == 10) { // timer 2 is different
+  if (pin == 9 || pin == 10) {  // timer 2 is different
@@ -228 +223 @@ void DCCTimer::DCCEXanalogWriteFrequencyInternal(uint8_t pin, uint32_t fbits) {
-    else //  fbits == 0
+    else  //  fbits == 0
@@ -231,2 +226,2 @@ void DCCTimer::DCCEXanalogWriteFrequencyInternal(uint8_t pin, uint32_t fbits) {
-    TCCR2A = (TCCR2A & B11111100) | abits; // set WGM0 and WGM1
-    TCCR2B = (TCCR2B & B11110000) | bbits; // set WGM2 and 3 bits of prescaler
+    TCCR2A = (TCCR2A & B11111100) | abits;  // set WGM0 and WGM1
+    TCCR2B = (TCCR2B & B11110000) | bbits;  // set WGM2 and 3 bits of prescaler
@@ -235 +230 @@ void DCCTimer::DCCEXanalogWriteFrequencyInternal(uint8_t pin, uint32_t fbits) {
-  } else { // not timer 9 or 10
+  } else {  // not timer 9 or 10
@@ -248,19 +243,19 @@ void DCCTimer::DCCEXanalogWriteFrequencyInternal(uint8_t pin, uint32_t fbits) {
-      // case 9 and 10 taken care of above by if()
-    case 6:
-    case 7:
-    case 8:
-      // Timer4
-      TCCR4A = (TCCR4A & B11111100) | abits; // set WGM0 and WGM1
-      TCCR4B = (TCCR4B & B11100000) | bbits; // set WGM2 and WGM3 and divisor
-      //DIAG(F("Timer 4 A=%x B=%x"), TCCR4A, TCCR4B);
-      break;
-    case 46:
-    case 45:
-    case 44:
-      // Timer5
-      TCCR5A = (TCCR5A & B11111100) | abits; // set WGM0 and WGM1
-      TCCR5B = (TCCR5B & B11100000) | bbits; // set WGM2 and WGM3 and divisor
-      //DIAG(F("Timer 5 A=%x B=%x"), TCCR5A, TCCR5B);
-      break;
-    default:
-      break;
+        // case 9 and 10 taken care of above by if()
+      case 6:
+      case 7:
+      case 8:
+        // Timer4
+        TCCR4A = (TCCR4A & B11111100) | abits;  // set WGM0 and WGM1
+        TCCR4B = (TCCR4B & B11100000) | bbits;  // set WGM2 and WGM3 and divisor
+        // DIAG(F("Timer 4 A=%x B=%x"), TCCR4A, TCCR4B);
+        break;
+      case 46:
+      case 45:
+      case 44:
+        // Timer5
+        TCCR5A = (TCCR5A & B11111100) | abits;  // set WGM0 and WGM1
+        TCCR5B = (TCCR5B & B11100000) | bbits;  // set WGM2 and WGM3 and divisor
+        // DIAG(F("Timer 5 A=%x B=%x"), TCCR5A, TCCR5B);
+        break;
+      default:
+        break;
@@ -279 +274 @@ uint8_t ADCee::highestPin = 0;
-int * ADCee::analogvals = NULL;
+int* ADCee::analogvals = NULL;
@@ -296 +291 @@ int ADCee::init(uint8_t pin) {
-    analogvals = (int *)calloc(NUM_ADC_INPUTS, sizeof(int));
+    analogvals = (int*)calloc(NUM_ADC_INPUTS, sizeof(int));
@@ -298,2 +293,3 @@ int ADCee::init(uint8_t pin) {
-  usedpins |= (1<<id);
-  if (id > highestPin) highestPin = id;
+  usedpins |= (1 << id);
+  if (id > highestPin)
+    highestPin = id;
@@ -310 +306 @@ int ADCee::read(uint8_t pin, bool fromISR) {
-  if ((usedpins & (1<<id) ) == 0)
+  if ((usedpins & (1 << id)) == 0)
@@ -314 +310,2 @@ int ADCee::read(uint8_t pin, bool fromISR) {
-  if (!fromISR) noInterrupts();
+  if (!fromISR)
+    noInterrupts();
@@ -316 +313,2 @@ int ADCee::read(uint8_t pin, bool fromISR) {
-  if (!fromISR) interrupts();
+  if (!fromISR)
+    interrupts();
@@ -323 +321 @@ int ADCee::read(uint8_t pin, bool fromISR) {
-#pragma GCC optimize ("-O3")
+#pragma GCC optimize("-O3")
@@ -325,2 +323,2 @@ void ADCee::scan() {
-  static byte id = 0;       // id and mask are the same thing but it is faster to
-  static uint16_t mask = 1; // increment and shift instead to calculate mask from id
+  static byte id = 0;        // id and mask are the same thing but it is faster to
+  static uint16_t mask = 1;  // increment and shift instead to calculate mask from id
@@ -333 +331 @@ void ADCee::scan() {
-      return; // no result, continue to wait
+      return;  // no result, continue to wait
@@ -335 +333 @@ void ADCee::scan() {
-    low = ADCL; //must read low before high
+    low = ADCL;  // must read low before high
@@ -341 +339,2 @@ void ADCee::scan() {
-    if (id == 1) TrackManager::track[1]->setBrake(0);
+    if (id == 1)
+      TrackManager::track[1]->setBrake(0);
@@ -352 +351 @@ void ADCee::scan() {
-    if (usedpins == 0) // otherwise we would loop forever
+    if (usedpins == 0)  // otherwise we would loop forever
@@ -356,2 +355,2 @@ void ADCee::scan() {
-      if (mask  & usedpins) {
-	// start new ADC aquire on id
+      if (mask & usedpins) {
+        // start new ADC aquire on id
@@ -359,6 +358,6 @@ void ADCee::scan() {
-	if (ADCusesHighPort) { // if we ever have started to use high pins)
-	  if (id > 7)          // if we use a high ADC pin
-	    bitSet(ADCSRB, MUX5); // set MUX5 bit
-	  else
-	    bitClear(ADCSRB, MUX5);
-	}
+        if (ADCusesHighPort) {     // if we ever have started to use high pins)
+          if (id > 7)              // if we use a high ADC pin
+            bitSet(ADCSRB, MUX5);  // set MUX5 bit
+          else
+            bitClear(ADCSRB, MUX5);
+        }
@@ -366,2 +365,2 @@ void ADCee::scan() {
-	ADMUX=(1<<REFS0)|(id & 0x07); //select AVCC as reference and set MUX
-	bitSet(ADCSRA,ADSC); // start conversion
+        ADMUX = (1 << REFS0) | (id & 0x07);  // select AVCC as reference and set MUX
+        bitSet(ADCSRA, ADSC);                // start conversion
@@ -369 +368,2 @@ void ADCee::scan() {
-	if (id == 1) TrackManager::track[1]->setBrake(1);
+        if (id == 1)
+          TrackManager::track[1]->setBrake(1);
@@ -371,2 +371,2 @@ void ADCee::scan() {
-	waiting = true;
-	return;
+        waiting = true;
+        return;
@@ -377,2 +377,2 @@ void ADCee::scan() {
-      	id = 0;
-	      mask = 1;
+        id = 0;
+        mask = 1;
@@ -389,3 +389,3 @@ void ADCee::begin() {
-  ADMUX=(1<<REFS0); //select AVCC as reference. We set MUX later
-  ADCSRA = (1<<ADEN)|(1 << ADPS2); // ADPS2 means divisor 32 and 16Mhz/32=500kHz.
-  //bitSet(ADCSRA, ADSC); //do not start the ADC yet. Done when we have set the MUX
+  ADMUX = (1 << REFS0);                 // select AVCC as reference. We set MUX later
+  ADCSRA = (1 << ADEN) | (1 << ADPS2);  // ADPS2 means divisor 32 and 16Mhz/32=500kHz.
+  // bitSet(ADCSRA, ADSC); //do not start the ADC yet. Done when we have set the MUX
diff --git a/DCCTimerESP.cpp b/DCCTimerESP.cpp
index afbd2da..5c85fd5 100644
--- a/DCCTimerESP.cpp
+++ b/DCCTimerESP.cpp
@@ -5 +5 @@
- *  
+ *
@@ -28 +28 @@
-INTERRUPT_CALLBACK interruptHandler=0;
+INTERRUPT_CALLBACK interruptHandler = 0;
@@ -31 +31 @@ void DCCTimer::begin(INTERRUPT_CALLBACK callback) {
-  interruptHandler=callback;
+  interruptHandler = callback;
@@ -54 +54 @@ void IRAM_ATTR DCCTimer::clearPWM() {
-void   DCCTimer::getSimulatedMacAddress(byte mac[6]) {
+void DCCTimer::getSimulatedMacAddress(byte mac[6]) {
@@ -63 +63 @@ void   DCCTimer::getSimulatedMacAddress(byte mac[6]) {
-volatile int DCCTimer::minimum_free_memory=__INT_MAX__;
+volatile int DCCTimer::minimum_free_memory = __INT_MAX__;
@@ -65 +65 @@ volatile int DCCTimer::minimum_free_memory=__INT_MAX__;
-// Return low memory value... 
+// Return low memory value...
@@ -67 +67 @@ int DCCTimer::getMinimumFreeMemory() {
-  noInterrupts(); // Disable interrupts to get volatile value 
+  noInterrupts();  // Disable interrupts to get volatile value
@@ -87 +87,2 @@ int DCCTimer::freeMemory() {
-#error "DCC-EX does not support compiling with IDF version 5.0 or later. Downgrade your ESP32 library to a version that contains IDF version 4. Arduino ESP32 library 3.0.0 is too new. Downgrade to one of 2.0.9 to 2.0.17"
+#error \
+    "DCC-EX does not support compiling with IDF version 5.0 or later. Downgrade your ESP32 library to a version that contains IDF version 4. Arduino ESP32 library 3.0.0 is too new. Downgrade to one of 2.0.9 to 2.0.17"
@@ -97,2 +98,2 @@ int DCCTimer::freeMemory() {
-#define ADC_INPUT_MAX_VALUE 4095 // 12 bit ADC
-#define pinToADC1Channel(X) (adc1_channel_t)(((X) > 35) ? (X)-36 : (X)-28)
+#define ADC_INPUT_MAX_VALUE 4095  // 12 bit ADC
+#define pinToADC1Channel(X) (adc1_channel_t)(((X) > 35) ? (X) - 36 : (X) - 28)
@@ -102 +103 @@ int IRAM_ATTR local_adc1_get_raw(int channel) {
-  SENS.sar_meas_start1.sar1_en_pad = (1 << channel); // only one channel is selected
+  SENS.sar_meas_start1.sar1_en_pad = (1 << channel);  // only one channel is selected
@@ -112 +113 @@ int IRAM_ATTR local_adc1_get_raw(int channel) {
-INTERRUPT_CALLBACK interruptHandler=0;
+INTERRUPT_CALLBACK interruptHandler = 0;
@@ -122,2 +123,2 @@ void DCCTimer::begin(INTERRUPT_CALLBACK callback) {
-  hw_timer_t *timer = NULL;
-  timer = timerBegin(0, 2, true); // prescaler can be 2 to 65536 so choose 2
+  hw_timer_t* timer = NULL;
+  timer = timerBegin(0, 2, true);  // prescaler can be 2 to 65536 so choose 2
@@ -125 +126 @@ void DCCTimer::begin(INTERRUPT_CALLBACK callback) {
-  timerAlarmWrite(timer, CLOCK_CYCLES / 6, true); // divide by prescaler*3 (Clockbase is 80Mhz and not F_CPU 240Mhz)
+  timerAlarmWrite(timer, CLOCK_CYCLES / 6, true);  // divide by prescaler*3 (Clockbase is 80Mhz and not F_CPU 240Mhz)
@@ -139 +140 @@ void IRAM_ATTR DCCTimer::clearPWM() {
-void   DCCTimer::getSimulatedMacAddress(byte mac[6]) {
+void DCCTimer::getSimulatedMacAddress(byte mac[6]) {
@@ -148 +149 @@ void   DCCTimer::getSimulatedMacAddress(byte mac[6]) {
-volatile int DCCTimer::minimum_free_memory=__INT_MAX__;
+volatile int DCCTimer::minimum_free_memory = __INT_MAX__;
@@ -150 +151 @@ volatile int DCCTimer::minimum_free_memory=__INT_MAX__;
-// Return low memory value... 
+// Return low memory value...
@@ -152 +153 @@ int DCCTimer::getMinimumFreeMemory() {
-  noInterrupts(); // Disable interrupts to get volatile value 
+  noInterrupts();  // Disable interrupts to get volatile value
@@ -163 +164 @@ void DCCTimer::reset() {
-   ESP.restart();
+  ESP.restart();
@@ -169,4 +170,4 @@ void DCCTimer::DCCEXanalogWriteFrequency(uint8_t pin, uint32_t f) {
-/*
-  else if (f == 7) // not used on ESP32
-    DCCTimer::DCCEXanalogWriteFrequencyInternal(pin, 62500);
-*/
+  /*
+    else if (f == 7) // not used on ESP32
+      DCCTimer::DCCEXanalogWriteFrequencyInternal(pin, 62500);
+  */
@@ -189 +190 @@ void DCCTimer::DCCEXanalogWriteFrequency(uint8_t pin, uint32_t f) {
-#define LEDC_CHANNELS           (SOC_LEDC_CHANNEL_NUM<<1)
+#define LEDC_CHANNELS (SOC_LEDC_CHANNEL_NUM << 1)
@@ -191 +192 @@ void DCCTimer::DCCEXanalogWriteFrequency(uint8_t pin, uint32_t f) {
-#define LEDC_CHANNELS           (SOC_LEDC_CHANNEL_NUM)
+#define LEDC_CHANNELS (SOC_LEDC_CHANNEL_NUM)
@@ -194 +195 @@ void DCCTimer::DCCEXanalogWriteFrequency(uint8_t pin, uint32_t f) {
-static int8_t pin_to_channel[SOC_GPIO_PIN_COUNT] = { 0 };
+static int8_t pin_to_channel[SOC_GPIO_PIN_COUNT] = {0};
@@ -212,16 +213,3 @@ static byte LEDCToMux[] = {
-  LEDC_HS_SIG_OUT0_IDX,
-  LEDC_HS_SIG_OUT1_IDX,
-  LEDC_HS_SIG_OUT2_IDX,
-  LEDC_HS_SIG_OUT3_IDX,
-  LEDC_HS_SIG_OUT4_IDX,
-  LEDC_HS_SIG_OUT5_IDX,
-  LEDC_HS_SIG_OUT6_IDX,
-  LEDC_HS_SIG_OUT7_IDX,
-  LEDC_LS_SIG_OUT0_IDX,
-  LEDC_LS_SIG_OUT1_IDX,
-  LEDC_LS_SIG_OUT2_IDX,
-  LEDC_LS_SIG_OUT3_IDX,
-  LEDC_LS_SIG_OUT4_IDX,
-  LEDC_LS_SIG_OUT5_IDX,
-  LEDC_LS_SIG_OUT6_IDX,
-  LEDC_LS_SIG_OUT7_IDX,
+    LEDC_HS_SIG_OUT0_IDX, LEDC_HS_SIG_OUT1_IDX, LEDC_HS_SIG_OUT2_IDX, LEDC_HS_SIG_OUT3_IDX, LEDC_HS_SIG_OUT4_IDX, LEDC_HS_SIG_OUT5_IDX,
+    LEDC_HS_SIG_OUT6_IDX, LEDC_HS_SIG_OUT7_IDX, LEDC_LS_SIG_OUT0_IDX, LEDC_LS_SIG_OUT1_IDX, LEDC_LS_SIG_OUT2_IDX, LEDC_LS_SIG_OUT3_IDX,
+    LEDC_LS_SIG_OUT4_IDX, LEDC_LS_SIG_OUT5_IDX, LEDC_LS_SIG_OUT6_IDX, LEDC_LS_SIG_OUT7_IDX,
@@ -233 +221 @@ void DCCTimer::DCCEXledcAttachPin(uint8_t pin, int8_t channel, bool inverted) {
-  if (inverted) // we attach again but with inversion
+  if (inverted)  // we attach again but with inversion
@@ -241 +229 @@ void DCCTimer::DCCEXanalogCopyChannel(int8_t frompin, int8_t topin) {
-  if (frompin<0)
+  if (frompin < 0)
@@ -243 +231 @@ void DCCTimer::DCCEXanalogCopyChannel(int8_t frompin, int8_t topin) {
-  if (topin<0) {
+  if (topin < 0) {
@@ -247 +235 @@ void DCCTimer::DCCEXanalogCopyChannel(int8_t frompin, int8_t topin) {
-  int channel = pin_to_channel[frompin]; // after abs(frompin)
+  int channel = pin_to_channel[frompin];  // after abs(frompin)
@@ -260,2 +248,2 @@ void DCCTimer::DCCEXanalogWrite(uint8_t pin, int value, bool invert) {
-          log_e("No more PWM channels available! All %u already used", LEDC_CHANNELS);
-          return;
+        log_e("No more PWM channels available! All %u already used", LEDC_CHANNELS);
+        return;
@@ -264,12 +252,12 @@ void DCCTimer::DCCEXanalogWrite(uint8_t pin, int value, bool invert) {
-      for (search_channel=LEDC_CHANNELS-1; search_channel >=cnt_channel; search_channel -= 2) {
-	bool chanused = false;
-	for (n=0; n < SOC_GPIO_PIN_COUNT; n++) {
-	  if (pin_to_channel[n] == search_channel) { // current search_channel used
-	    chanused = true;
-	    break;
-	  }
-	}
-	if (chanused)
-	  continue;
-	if (n == SOC_GPIO_PIN_COUNT) // current search_channel unused
-	  break;
+      for (search_channel = LEDC_CHANNELS - 1; search_channel >= cnt_channel; search_channel -= 2) {
+        bool chanused = false;
+        for (n = 0; n < SOC_GPIO_PIN_COUNT; n++) {
+          if (pin_to_channel[n] == search_channel) {  // current search_channel used
+            chanused = true;
+            break;
+          }
+        }
+        if (chanused)
+          continue;
+        if (n == SOC_GPIO_PIN_COUNT)  // current search_channel unused
+          break;
@@ -278,2 +266,2 @@ void DCCTimer::DCCEXanalogWrite(uint8_t pin, int value, bool invert) {
-	pin_to_channel[pin] = search_channel;
-	DIAG(F("Pin %d assigned to search channel %d"), pin, search_channel);
+        pin_to_channel[pin] = search_channel;
+        DIAG(F("Pin %d assigned to search channel %d"), pin, search_channel);
@@ -281,3 +269,3 @@ void DCCTimer::DCCEXanalogWrite(uint8_t pin, int value, bool invert) {
-	pin_to_channel[pin] = --cnt_channel; // This sets 15, 13, ...
-	DIAG(F("Pin %d assigned to new channel %d"), pin, cnt_channel);
-	--cnt_channel;                       // Now we are at 14, 12, ...
+        pin_to_channel[pin] = --cnt_channel;  // This sets 15, 13, ...
+        DIAG(F("Pin %d assigned to new channel %d"), pin, cnt_channel);
+        --cnt_channel;  // Now we are at 14, 12, ...
@@ -308 +296 @@ int ADCee::init(uint8_t pin) {
-  adc1_config_channel_atten(pinToADC1Channel(pin),ADC_ATTEN_11db);
+  adc1_config_channel_atten(pinToADC1Channel(pin), ADC_ATTEN_11db);
@@ -310 +298 @@ int ADCee::init(uint8_t pin) {
-  adc1_config_channel_atten(pinToADC1Channel(pin),ADC_ATTEN_DB_11);
+  adc1_config_channel_atten(pinToADC1Channel(pin), ADC_ATTEN_DB_11);
@@ -331,2 +319,2 @@ void ADCee::begin() {
-#endif //IDF v4
-#endif //ESP32
+#endif  // IDF v4
+#endif  // ESP32
diff --git a/DCCTimerMEGAAVR.cpp b/DCCTimerMEGAAVR.cpp
index 845e188..c20bdf4 100644
--- a/DCCTimerMEGAAVR.cpp
+++ b/DCCTimerMEGAAVR.cpp
@@ -9 +9 @@
- *  
+ *
@@ -26 +25,0 @@
-
@@ -28,3 +27,3 @@
- *  All timer access comes through this class so that it can be compiled for 
- *  various hardware CPU types. 
- *  
+ *  All timer access comes through this class so that it can be compiled for
+ *  various hardware CPU types.
+ *
@@ -32,3 +31,3 @@
- *  The DCCWaveform class generates the signals to the motor shield  
- *  based on this timer. 
- *  
+ *  The DCCWaveform class generates the signals to the motor shield
+ *  based on this timer.
+ *
@@ -38,5 +37,5 @@
- *  achieved by setting the duty cycle of the NEXT clock interrupt to 0% or 100% depending on 
- *  the required pin state. (see setPWM())  
- *  This is more accurate than the software interrupt but at the expense of 
- *  limiting the choice of available pins. 
- *  Fortunately, a standard motor shield on a Mega uses pins that qualify for PWM... 
+ *  achieved by setting the duty cycle of the NEXT clock interrupt to 0% or 100% depending on
+ *  the required pin state. (see setPWM())
+ *  This is more accurate than the software interrupt but at the expense of
+ *  limiting the choice of available pins.
+ *  Fortunately, a standard motor shield on a Mega uses pins that qualify for PWM...
@@ -44 +43 @@
- *  
+ *
@@ -48 +47 @@
- *  
+ *
@@ -58,18 +57,3 @@
-INTERRUPT_CALLBACK interruptHandler=0;
-extern char *__brkval;
-extern char *__malloc_heap_start;
-
-  
-  void DCCTimer::begin(INTERRUPT_CALLBACK callback) {
-    interruptHandler=callback;
-    noInterrupts(); 
-    ADC0.CTRLC = (ADC0.CTRLC & 0b00110000) | 0b01000011;  // speed up analogRead sample time   
-    TCB0.CTRLB = TCB_CNTMODE_INT_gc & ~TCB_CCMPEN_bm; // timer compare mode with output disabled
-    TCB0.CTRLA = TCB_CLKSEL_CLKDIV2_gc; //   8 MHz ~ 0.125 us      
-    TCB0.CCMP =  CLOCK_CYCLES -1;  // 1 tick less for timer reset
-    TCB0.INTFLAGS = TCB_CAPT_bm; // clear interrupt request flag
-    TCB0.INTCTRL = TCB_CAPT_bm;  // Enable the interrupt
-    TCB0.CNT = 0;
-    TCB0.CTRLA |= TCB_ENABLE_bm;  // start
-    interrupts();
-  }
+INTERRUPT_CALLBACK interruptHandler = 0;
+extern char* __brkval;
+extern char* __malloc_heap_start;
@@ -77,5 +61,19 @@ extern char *__malloc_heap_start;
-  // ISR called by timer interrupt every 58uS
-  ISR(TCB0_INT_vect){
-    TCB0.INTFLAGS = TCB_CAPT_bm; // Clear interrupt request flag
-    interruptHandler();
-  }
+void DCCTimer::begin(INTERRUPT_CALLBACK callback) {
+  interruptHandler = callback;
+  noInterrupts();
+  ADC0.CTRLC = (ADC0.CTRLC & 0b00110000) | 0b01000011;  // speed up analogRead sample time
+  TCB0.CTRLB = TCB_CNTMODE_INT_gc & ~TCB_CCMPEN_bm;     // timer compare mode with output disabled
+  TCB0.CTRLA = TCB_CLKSEL_CLKDIV2_gc;                   //   8 MHz ~ 0.125 us
+  TCB0.CCMP = CLOCK_CYCLES - 1;                         // 1 tick less for timer reset
+  TCB0.INTFLAGS = TCB_CAPT_bm;                          // clear interrupt request flag
+  TCB0.INTCTRL = TCB_CAPT_bm;                           // Enable the interrupt
+  TCB0.CNT = 0;
+  TCB0.CTRLA |= TCB_ENABLE_bm;  // start
+  interrupts();
+}
+
+// ISR called by timer interrupt every 58uS
+ISR(TCB0_INT_vect) {
+  TCB0.INTFLAGS = TCB_CAPT_bm;  // Clear interrupt request flag
+  interruptHandler();
+}
@@ -85 +83 @@ void DCCTimer::startRailcomTimer(byte brakePin) {
-  (void) brakePin; 
+  (void)brakePin;
@@ -92,4 +90,4 @@ void DCCTimer::ackRailcomTimer() {
-  bool DCCTimer::isPWMPin(byte pin) {
-       (void) pin; 
-       return false;  // TODO what are the relevant pins? 
-  }
+bool DCCTimer::isPWMPin(byte pin) {
+  (void)pin;
+  return false;  // TODO what are the relevant pins?
+}
@@ -97,5 +95,5 @@ void DCCTimer::ackRailcomTimer() {
- void DCCTimer::setPWM(byte pin, bool high) {
-    (void) pin;
-    (void) high;
-    // TODO what are the relevant pins?
- }
+void DCCTimer::setPWM(byte pin, bool high) {
+  (void)pin;
+  (void)high;
+  // TODO what are the relevant pins?
+}
@@ -104 +102 @@ void DCCTimer::clearPWM() {
-    // Do nothing unless we implent HA
+  // Do nothing unless we implent HA
@@ -107,5 +105,5 @@ void DCCTimer::clearPWM() {
-  void   DCCTimer::getSimulatedMacAddress(byte mac[6]) {
-    memcpy(mac,(void *) &SIGROW.SERNUM0,6);  // serial number
-    mac[0] &= 0xFE;
-    mac[0] |= 0x02;
-  }
+void DCCTimer::getSimulatedMacAddress(byte mac[6]) {
+  memcpy(mac, (void*)&SIGROW.SERNUM0, 6);  // serial number
+  mac[0] &= 0xFE;
+  mac[0] |= 0x02;
+}
@@ -113 +111 @@ void DCCTimer::clearPWM() {
-volatile int DCCTimer::minimum_free_memory=__INT_MAX__;
+volatile int DCCTimer::minimum_free_memory = __INT_MAX__;
@@ -115 +113 @@ volatile int DCCTimer::minimum_free_memory=__INT_MAX__;
-// Return low memory value... 
+// Return low memory value...
@@ -117 +115 @@ int DCCTimer::getMinimumFreeMemory() {
-  noInterrupts(); // Disable interrupts to get volatile value 
+  noInterrupts();  // Disable interrupts to get volatile value
@@ -123,2 +121,2 @@ int DCCTimer::getMinimumFreeMemory() {
-extern char *__brkval;
-extern char *__malloc_heap_start;
+extern char* __brkval;
+extern char* __malloc_heap_start;
@@ -132,3 +130,4 @@ void DCCTimer::reset() {
-  CPU_CCP=0xD8;
-  WDT.CTRLA=0x4;
-  while(true){}
+  CPU_CCP = 0xD8;
+  WDT.CTRLA = 0x4;
+  while (true) {
+  }
@@ -154 +153,2 @@ int ADCee::read(uint8_t pin, bool fromISR) {
-  if (!fromISR) noInterrupts();
+  if (!fromISR)
+    noInterrupts();
@@ -156 +156,2 @@ int ADCee::read(uint8_t pin, bool fromISR) {
-  if (!fromISR) interrupts();
+  if (!fromISR)
+    interrupts();
diff --git a/DCCTimerSAMD.cpp b/DCCTimerSAMD.cpp
index 567b98d..4966d0e 100644
--- a/DCCTimerSAMD.cpp
+++ b/DCCTimerSAMD.cpp
@@ -9 +9 @@
- *  
+ *
@@ -34 +34 @@
-INTERRUPT_CALLBACK interruptHandler=0;
+INTERRUPT_CALLBACK interruptHandler = 0;
@@ -37 +37 @@ void DCCTimer::begin(INTERRUPT_CALLBACK callback) {
-  interruptHandler=callback;
+  interruptHandler = callback;
@@ -40,12 +40,12 @@ void DCCTimer::begin(INTERRUPT_CALLBACK callback) {
-  REG_GCLK_GENDIV =   GCLK_GENDIV_DIV(1) |            // Divide 48MHz by 1
-                      GCLK_GENDIV_ID(4);              // Apply to GCLK4
-  while (GCLK->STATUS.bit.SYNCBUSY);                  // Wait for synchronization
-                
-  REG_GCLK_GENCTRL =  GCLK_GENCTRL_GENEN |            // Enable GCLK
-                      GCLK_GENCTRL_SRC_DFLL48M |      // Set the 48MHz clock source
-                      GCLK_GENCTRL_ID(4);             // Select GCLK4
-  while (GCLK->STATUS.bit.SYNCBUSY);                  // Wait for synchronization
-            
-  REG_GCLK_CLKCTRL =  GCLK_CLKCTRL_CLKEN |            // Enable generic clock
-                      4 << GCLK_CLKCTRL_GEN_Pos |     // Apply to GCLK4
-                      GCLK_CLKCTRL_ID_TCC0_TCC1;      // Feed GCLK to TCC0/1
+  REG_GCLK_GENDIV = GCLK_GENDIV_DIV(1) |  // Divide 48MHz by 1
+                    GCLK_GENDIV_ID(4);    // Apply to GCLK4
+  while (GCLK->STATUS.bit.SYNCBUSY);      // Wait for synchronization
+
+  REG_GCLK_GENCTRL = GCLK_GENCTRL_GENEN |        // Enable GCLK
+                     GCLK_GENCTRL_SRC_DFLL48M |  // Set the 48MHz clock source
+                     GCLK_GENCTRL_ID(4);         // Select GCLK4
+  while (GCLK->STATUS.bit.SYNCBUSY);             // Wait for synchronization
+
+  REG_GCLK_CLKCTRL = GCLK_CLKCTRL_CLKEN |         // Enable generic clock
+                     4 << GCLK_CLKCTRL_GEN_Pos |  // Apply to GCLK4
+                     GCLK_CLKCTRL_ID_TCC0_TCC1;   // Feed GCLK to TCC0/1
@@ -58,2 +58,2 @@ void DCCTimer::begin(INTERRUPT_CALLBACK callback) {
-  TCC0->WAVE.reg = TCC_WAVE_WAVEGEN_NPWM;     // Select NPWM as waveform
-  while (TCC0->SYNCBUSY.bit.WAVE);            // Wait for sync
+  TCC0->WAVE.reg = TCC_WAVE_WAVEGEN_NPWM;  // Select NPWM as waveform
+  while (TCC0->SYNCBUSY.bit.WAVE);         // Wait for sync
@@ -71,5 +71,5 @@ void DCCTimer::begin(INTERRUPT_CALLBACK callback) {
-  TCC0->INTENSET.reg = TCC_INTENSET_OVF;      // Only interrupt on overflow
-  int USBprio = NVIC_GetPriority((IRQn_Type) USB_IRQn);  // Fetch the USB priority
-  NVIC_SetPriority((IRQn_Type)TCC0_IRQn, USBprio);  // Match the USB priority
-//  NVIC_SetPriority((IRQn_Type)TCC0_IRQn, 0);  // Make this highest priority
-  NVIC_EnableIRQ((IRQn_Type)TCC0_IRQn);       // Enable the interrupt
+  TCC0->INTENSET.reg = TCC_INTENSET_OVF;                // Only interrupt on overflow
+  int USBprio = NVIC_GetPriority((IRQn_Type)USB_IRQn);  // Fetch the USB priority
+  NVIC_SetPriority((IRQn_Type)TCC0_IRQn, USBprio);      // Match the USB priority
+                                                        //  NVIC_SetPriority((IRQn_Type)TCC0_IRQn, 0);  // Make this highest priority
+  NVIC_EnableIRQ((IRQn_Type)TCC0_IRQn);                 // Enable the interrupt
@@ -81 +81 @@ void DCCTimer::startRailcomTimer(byte brakePin) {
-  (void) brakePin; 
+  (void)brakePin;
@@ -91,4 +91,4 @@ void TCC0_Handler() {
-    if(TCC0->INTFLAG.bit.OVF) {
-        TCC0->INTFLAG.bit.OVF = 1; // writing a 1 clears the flag
-        interruptHandler();
-    }
+  if (TCC0->INTFLAG.bit.OVF) {
+    TCC0->INTFLAG.bit.OVF = 1;  // writing a 1 clears the flag
+    interruptHandler();
+  }
@@ -98,4 +98,4 @@ void TCC1_Handler() {
-    if(TCC1->INTFLAG.bit.OVF) {
-        TCC1->INTFLAG.bit.OVF = 1; // writing a 1 clears the flag
-        interruptHandler();
-    }
+  if (TCC1->INTFLAG.bit.OVF) {
+    TCC1->INTFLAG.bit.OVF = 1;  // writing a 1 clears the flag
+    interruptHandler();
+  }
@@ -105,4 +105,4 @@ void TCC2_Handler() {
-    if(TCC2->INTFLAG.bit.OVF) {
-        TCC2->INTFLAG.bit.OVF = 1; // writing a 1 clears the flag
-        interruptHandler();
-    }
+  if (TCC2->INTFLAG.bit.OVF) {
+    TCC2->INTFLAG.bit.OVF = 1;  // writing a 1 clears the flag
+    interruptHandler();
+  }
@@ -111 +110,0 @@ void TCC2_Handler() {
-
@@ -113,3 +112,3 @@ bool DCCTimer::isPWMPin(byte pin) {
-  //TODO: SAMD whilst this call to digitalPinHasPWM will reveal which pins can do PWM,
-  //      there's no support yet for High Accuracy, so for now return false
-  //  return digitalPinHasPWM(pin);
+  // TODO: SAMD whilst this call to digitalPinHasPWM will reveal which pins can do PWM,
+  //       there's no support yet for High Accuracy, so for now return false
+  //   return digitalPinHasPWM(pin);
@@ -120,3 +119,3 @@ void DCCTimer::setPWM(byte pin, bool high) {
-    // TODO: High Accuracy mode is not supported as yet, and may never need to be
-    (void) pin;
-    (void) high;
+  // TODO: High Accuracy mode is not supported as yet, and may never need to be
+  (void)pin;
+  (void)high;
@@ -129,5 +128,5 @@ void DCCTimer::clearPWM() {
-void   DCCTimer::getSimulatedMacAddress(byte mac[6]) {
-  volatile uint32_t *serno1 = (volatile uint32_t *)0x0080A00C;
-  volatile uint32_t *serno2 = (volatile uint32_t *)0x0080A040;
-//  volatile uint32_t *serno3 = (volatile uint32_t *)0x0080A044;
-//  volatile uint32_t *serno4 = (volatile uint32_t *)0x0080A048;
+void DCCTimer::getSimulatedMacAddress(byte mac[6]) {
+  volatile uint32_t* serno1 = (volatile uint32_t*)0x0080A00C;
+  volatile uint32_t* serno2 = (volatile uint32_t*)0x0080A040;
+  //  volatile uint32_t *serno3 = (volatile uint32_t *)0x0080A044;
+  //  volatile uint32_t *serno4 = (volatile uint32_t *)0x0080A048;
@@ -145 +144 @@ void   DCCTimer::getSimulatedMacAddress(byte mac[6]) {
-volatile int DCCTimer::minimum_free_memory=__INT_MAX__;
+volatile int DCCTimer::minimum_free_memory = __INT_MAX__;
@@ -147 +146 @@ volatile int DCCTimer::minimum_free_memory=__INT_MAX__;
-// Return low memory value... 
+// Return low memory value...
@@ -149 +148 @@ int DCCTimer::getMinimumFreeMemory() {
-  noInterrupts(); // Disable interrupts to get volatile value 
+  noInterrupts();  // Disable interrupts to get volatile value
@@ -159 +158 @@ int DCCTimer::freeMemory() {
-  return (int)(&top - reinterpret_cast<char *>(sbrk(0)));
+  return (int)(&top - reinterpret_cast<char*>(sbrk(0)));
@@ -163,3 +162,4 @@ void DCCTimer::reset() {
-   __disable_irq();
-    NVIC_SystemReset();
-    while(true) {};
+  __disable_irq();
+  NVIC_SystemReset();
+  while (true) {
+  };
@@ -176 +176 @@ uint16_t ADCee::usedpins = 0;
-int * ADCee::analogvals = NULL;
+int* ADCee::analogvals = NULL;
@@ -187 +187 @@ int ADCee::init(uint8_t pin) {
-  ADC->INPUTCTRL.bit.MUXPOS = g_APinDescription[pin].ulADCChannelNumber; // Selection for the positive ADC input
+  ADC->INPUTCTRL.bit.MUXPOS = g_APinDescription[pin].ulADCChannelNumber;  // Selection for the positive ADC input
@@ -193 +193 @@ int ADCee::init(uint8_t pin) {
-  while (ADC->INTFLAG.bit.RESRDY == 0);   // Waiting for conversion to complete
+  while (ADC->INTFLAG.bit.RESRDY == 0);  // Waiting for conversion to complete
@@ -199 +199 @@ int ADCee::init(uint8_t pin) {
-    analogvals = (int *)calloc(NUM_ADC_INPUTS+1, sizeof(int));
+    analogvals = (int*)calloc(NUM_ADC_INPUTS + 1, sizeof(int));
@@ -201 +201 @@ int ADCee::init(uint8_t pin) {
-  usedpins |= (1<<id);
+  usedpins |= (1 << id);
@@ -215 +215 @@ int ADCee::read(uint8_t pin, bool fromISR) {
-  if ((usedpins & (1<<id) ) == 0)
+  if ((usedpins & (1 << id)) == 0)
@@ -225 +225 @@ int ADCee::read(uint8_t pin, bool fromISR) {
-#pragma GCC optimize ("-O3")
+#pragma GCC optimize("-O3")
@@ -227 +227 @@ void ADCee::scan() {
-  static uint8_t id = 0;        // id and mask are the same thing but it is faster to 
+  static uint8_t id = 0;     // id and mask are the same thing but it is faster to
@@ -234 +234 @@ void ADCee::scan() {
-      return; // no result, continue to wait
+      return;  // no result, continue to wait
@@ -242 +242 @@ void ADCee::scan() {
-    if (id == NUM_ADC_INPUTS+1) {
+    if (id == NUM_ADC_INPUTS + 1) {
@@ -248 +248 @@ void ADCee::scan() {
-    if (usedpins == 0) // otherwise we would loop forever
+    if (usedpins == 0)  // otherwise we would loop forever
@@ -252,4 +252,4 @@ void ADCee::scan() {
-      if (mask  & usedpins) {
-    	  // start new ADC aquire on id
-        ADC->INPUTCTRL.bit.MUXPOS = g_APinDescription[id + A0].ulADCChannelNumber; // Selection for the positive ADC input
-          // Start conversion
+      if (mask & usedpins) {
+        // start new ADC aquire on id
+        ADC->INPUTCTRL.bit.MUXPOS = g_APinDescription[id + A0].ulADCChannelNumber;  // Selection for the positive ADC input
+                                                                                    // Start conversion
@@ -257,3 +257,3 @@ void ADCee::scan() {
-	      // for scope debug TrackManager::track[1]->setBrake(1);
-	      waiting = true;
-	      return;
+        // for scope debug TrackManager::track[1]->setBrake(1);
+        waiting = true;
+        return;
@@ -263,3 +263,3 @@ void ADCee::scan() {
-      if (id == NUM_ADC_INPUTS+1) {
-	      id = 0;
-	      mask = 1;
+      if (id == NUM_ADC_INPUTS + 1) {
+        id = 0;
+        mask = 1;
@@ -278,2 +278,2 @@ void ADCee::begin() {
-  ADC->CTRLA.bit.ENABLE = 0;                      // disable ADC
-  while( ADC->STATUS.bit.SYNCBUSY == 1 );         // wait for synchronization
+  ADC->CTRLA.bit.ENABLE = 0;              // disable ADC
+  while (ADC->STATUS.bit.SYNCBUSY == 1);  // wait for synchronization
@@ -288 +288 @@ void ADCee::begin() {
-  while( ADC->STATUS.bit.SYNCBUSY == 1 );         // wait for synchronization
+  while (ADC->STATUS.bit.SYNCBUSY == 1);          // wait for synchronization
diff --git a/DCCTimerSTM32.cpp b/DCCTimerSTM32.cpp
index df00df3..5842de6 100644
--- a/DCCTimerSTM32.cpp
+++ b/DCCTimerSTM32.cpp
@@ -10 +10 @@
- *  
+ *
@@ -62 +62 @@ HardwareSerial Serial6(PA12, PA11);  // Rx=PA12, Tx=PA11 -- CN10 pins 12 and 14
-// HardwareSerial Serial1(PA10, PB6);  // Rx=PA10 (D2), Tx=PB6 (D10) -- CN10 pins 17 and 9 - F446RE 
+// HardwareSerial Serial1(PA10, PB6);  // Rx=PA10 (D2), Tx=PB6 (D10) -- CN10 pins 17 and 9 - F446RE
@@ -67 +67 @@ HardwareSerial Serial3(PC11, PC10);  // Rx=PC11, Tx=PC10 -- USART3 - F446RE
-HardwareSerial Serial5(PD2, PC12);  // Rx=PD2, Tx=PC12 -- UART5 - F446RE
+HardwareSerial Serial5(PD2, PC12);   // Rx=PD2, Tx=PC12 -- UART5 - F446RE
@@ -69,2 +69,2 @@ HardwareSerial Serial5(PD2, PC12);  // Rx=PD2, Tx=PC12 -- UART5 - F446RE
-#elif defined(ARDUINO_NUCLEO_F412ZG) || defined(ARDUINO_NUCLEO_F413ZH) || defined(ARDUINO_NUCLEO_F446ZE) || \
-      defined(ARDUINO_NUCLEO_F429ZI) || defined(ARDUINO_NUCLEO_F439ZI) || defined(ARDUINO_NUCLEO_F4X9ZI)
+#elif defined(ARDUINO_NUCLEO_F412ZG) || defined(ARDUINO_NUCLEO_F413ZH) || defined(ARDUINO_NUCLEO_F446ZE) || defined(ARDUINO_NUCLEO_F429ZI) || \
+    defined(ARDUINO_NUCLEO_F439ZI) || defined(ARDUINO_NUCLEO_F4X9ZI)
@@ -73 +73 @@ HardwareSerial Serial6(PG9, PG14);  // Rx=PG9, Tx=PG14 -- USART6
-HardwareSerial Serial2(PD6, PD5);  // Rx=PD6, Tx=PD5 -- UART2
+HardwareSerial Serial2(PD6, PD5);   // Rx=PD6, Tx=PD5 -- UART2
@@ -75,2 +75,2 @@ HardwareSerial Serial2(PD6, PD5);  // Rx=PD6, Tx=PD5 -- UART2
-  HardwareSerial Serial5(PD2, PC12);  // Rx=PD2, Tx=PC12 -- UART5
-#endif  
+HardwareSerial Serial5(PD2, PC12);  // Rx=PD2, Tx=PC12 -- UART5
+#endif
@@ -119 +119 @@ HardwareSerial Serial2(PD6, PD5);  // Rx=PD6, Tx=PD5 -- UART2
-  
+
@@ -149 +149 @@ HardwareSerial Serial2(PD6, PD5);  // Rx=PD6, Tx=PD5 -- UART2
-//       if (high) 
+//       if (high)
@@ -159 +159 @@ HardwareSerial Serial2(PD6, PD5);  // Rx=PD6, Tx=PD5 -- UART2
-//       if (high) 
+//       if (high)
@@ -164 +164 @@ HardwareSerial Serial2(PD6, PD5);  // Rx=PD6, Tx=PD5 -- UART2
-//   }   
+//   }
@@ -170 +170 @@ HardwareSerial Serial2(PD6, PD5);  // Rx=PD6, Tx=PD5 -- UART2
-//   timerAux.setMode(1, TIMER_OUTPUT_COMPARE_INACTIVE, NC);  
+//   timerAux.setMode(1, TIMER_OUTPUT_COMPARE_INACTIVE, NC);
@@ -175 +175 @@ HardwareSerial Serial2(PD6, PD5);  // Rx=PD6, Tx=PD5 -- UART2
-INTERRUPT_CALLBACK interruptHandler=0;
+INTERRUPT_CALLBACK interruptHandler = 0;
@@ -191 +191 @@ INTERRUPT_CALLBACK interruptHandler=0;
-#endif // ifndef DCC_EX_TIMER
+#endif  // ifndef DCC_EX_TIMER
@@ -202 +202 @@ void DCCTimer::begin(INTERRUPT_CALLBACK callback) {
-  interruptHandler=callback;
+  interruptHandler = callback;
@@ -207 +207 @@ void DCCTimer::begin(INTERRUPT_CALLBACK callback) {
-//  timer.setOverflow(CLOCK_CYCLES * 2);
+  //  timer.setOverflow(CLOCK_CYCLES * 2);
@@ -211 +211 @@ void DCCTimer::begin(INTERRUPT_CALLBACK callback) {
-  dcctimer.setInterruptPriority(0, 0); // Set highest preemptive priority!
+  dcctimer.setInterruptPriority(0, 0);  // Set highest preemptive priority!
@@ -220 +220 @@ void DCCTimer::startRailcomTimer(byte brakePin) {
-  (void) brakePin; 
+  (void)brakePin;
@@ -228,4 +228,4 @@ bool DCCTimer::isPWMPin(byte pin) {
-  //TODO: STM32 whilst this call to digitalPinHasPWM will reveal which pins can do PWM,
-  //      there's no support yet for High Accuracy, so for now return false
-  //  return digitalPinHasPWM(pin);
-  (void) pin;
+  // TODO: STM32 whilst this call to digitalPinHasPWM will reveal which pins can do PWM,
+  //       there's no support yet for High Accuracy, so for now return false
+  //   return digitalPinHasPWM(pin);
+  (void)pin;
@@ -236,3 +236,3 @@ void DCCTimer::setPWM(byte pin, bool high) {
-    // TODO: High Accuracy mode is not supported as yet, and may never need to be
-    (void) pin;
-    (void) high;
+  // TODO: High Accuracy mode is not supported as yet, and may never need to be
+  (void)pin;
+  (void)high;
@@ -245,3 +245,3 @@ void DCCTimer::clearPWM() {
-void   DCCTimer::getSimulatedMacAddress(byte mac[6]) {
-  volatile uint32_t *serno1 = (volatile uint32_t *)UID_BASE;
-  volatile uint32_t *serno2 = (volatile uint32_t *)UID_BASE+4;
+void DCCTimer::getSimulatedMacAddress(byte mac[6]) {
+  volatile uint32_t* serno1 = (volatile uint32_t*)UID_BASE;
+  volatile uint32_t* serno2 = (volatile uint32_t*)UID_BASE + 4;
@@ -260 +260 @@ void   DCCTimer::getSimulatedMacAddress(byte mac[6]) {
-volatile int DCCTimer::minimum_free_memory=__INT_MAX__;
+volatile int DCCTimer::minimum_free_memory = __INT_MAX__;
@@ -262 +262 @@ volatile int DCCTimer::minimum_free_memory=__INT_MAX__;
-// Return low memory value... 
+// Return low memory value...
@@ -264 +264 @@ int DCCTimer::getMinimumFreeMemory() {
-  noInterrupts(); // Disable interrupts to get volatile value 
+  noInterrupts();  // Disable interrupts to get volatile value
@@ -274 +274 @@ int DCCTimer::freeMemory() {
-  return (int)(&top - reinterpret_cast<char *>(sbrk(0)));
+  return (int)(&top - reinterpret_cast<char*>(sbrk(0)));
@@ -278,3 +278,4 @@ void DCCTimer::reset() {
-   __disable_irq();
-    NVIC_SystemReset();
-    while(true) {};
+  __disable_irq();
+  NVIC_SystemReset();
+  while (true) {
+  };
@@ -301 +302 @@ void DCCTimer::DCCEXanalogWriteFrequency(uint8_t pin, uint32_t f) {
-static HardwareTimer * pin_timer[100] = {0};
+static HardwareTimer* pin_timer[100] = {0};
@@ -310,2 +311 @@ static uint32_t pin_channel[100] = {0};
-void DCCTimer::DCCEXanalogWriteFrequencyInternal(uint8_t pin, uint32_t frequency)
-{
+void DCCTimer::DCCEXanalogWriteFrequencyInternal(uint8_t pin, uint32_t frequency) {
@@ -315 +315 @@ void DCCTimer::DCCEXanalogWriteFrequencyInternal(uint8_t pin, uint32_t frequency
-    TIM_TypeDef *Instance = (TIM_TypeDef *)pinmap_peripheral(digitalPinToPinName(pin), PinMap_PWM);
+    TIM_TypeDef* Instance = (TIM_TypeDef*)pinmap_peripheral(digitalPinToPinName(pin), PinMap_PWM);
@@ -328,3 +328,2 @@ void DCCTimer::DCCEXanalogWriteFrequencyInternal(uint8_t pin, uint32_t frequency
-    if (pin_timer[pin] != NULL)
-    {
-      pin_timer[pin]->setPWM(pin_channel[pin], pin, frequency, 0); // set frequency in Hertz, 0% dutycycle
+    if (pin_timer[pin] != NULL) {
+      pin_timer[pin]->setPWM(pin_channel[pin], pin, frequency, 0);  // set frequency in Hertz, 0% dutycycle
@@ -332,2 +331 @@ void DCCTimer::DCCEXanalogWriteFrequencyInternal(uint8_t pin, uint32_t frequency
-    }
-    else
+    } else
@@ -335,3 +333 @@ void DCCTimer::DCCEXanalogWriteFrequencyInternal(uint8_t pin, uint32_t frequency
-  }
-  else
-  {
+  } else {
@@ -339,4 +335,3 @@ void DCCTimer::DCCEXanalogWriteFrequencyInternal(uint8_t pin, uint32_t frequency
-    if (frequency != channel_frequency[pin])
-    {
-      pinmap_pinout(digitalPinToPinName(pin), PinMap_TIM); // ensure the pin has been configured!
-      pin_timer[pin]->setOverflow(frequency, HERTZ_FORMAT); // Just change the frequency if it's already running!
+    if (frequency != channel_frequency[pin]) {
+      pinmap_pinout(digitalPinToPinName(pin), PinMap_TIM);   // ensure the pin has been configured!
+      pin_timer[pin]->setOverflow(frequency, HERTZ_FORMAT);  // Just change the frequency if it's already running!
@@ -351,20 +346,19 @@ void DCCTimer::DCCEXanalogWrite(uint8_t pin, int value, bool invert) {
-    if (invert)
-      value = 255-value;
-    // Calculate percentage duty cycle from value given
-    uint32_t duty_cycle = (value * 100 / 256) + 1;
-    if (pin_timer[pin] != NULL) {
-      // if (duty_cycle == 100)
-      // {
-      //   pin_timer[pin]->pauseChannel(pin_channel[pin]);
-      //   DIAG(F("DCCEXanalogWrite::Pausing timer channel on pin %d"), pin);
-      // }
-      // else
-      // {
-        pinmap_pinout(digitalPinToPinName(pin), PinMap_TIM); // ensure the pin has been configured!
-        // pin_timer[pin]->resumeChannel(pin_channel[pin]);
-        pin_timer[pin]->setCaptureCompare(pin_channel[pin], duty_cycle, PERCENT_COMPARE_FORMAT); // DCC_EX_PWM_FREQ Hertz, duty_cycle% dutycycle
-        DIAG(F("DCCEXanalogWrite::Pin %d, value %d, duty cycle %d"), pin, value, duty_cycle);
-      // }
-    }
-    else
-      DIAG(F("DCCEXanalogWrite::Pin %d is not configured for PWM!"), pin);
+  if (invert)
+    value = 255 - value;
+  // Calculate percentage duty cycle from value given
+  uint32_t duty_cycle = (value * 100 / 256) + 1;
+  if (pin_timer[pin] != NULL) {
+    // if (duty_cycle == 100)
+    // {
+    //   pin_timer[pin]->pauseChannel(pin_channel[pin]);
+    //   DIAG(F("DCCEXanalogWrite::Pausing timer channel on pin %d"), pin);
+    // }
+    // else
+    // {
+    pinmap_pinout(digitalPinToPinName(pin), PinMap_TIM);  // ensure the pin has been configured!
+    // pin_timer[pin]->resumeChannel(pin_channel[pin]);
+    pin_timer[pin]->setCaptureCompare(pin_channel[pin], duty_cycle, PERCENT_COMPARE_FORMAT);  // DCC_EX_PWM_FREQ Hertz, duty_cycle% dutycycle
+    DIAG(F("DCCEXanalogWrite::Pin %d, value %d, duty cycle %d"), pin, value, duty_cycle);
+    // }
+  } else
+    DIAG(F("DCCEXanalogWrite::Pin %d is not configured for PWM!"), pin);
@@ -373 +366,0 @@ void DCCTimer::DCCEXanalogWrite(uint8_t pin, int value, bool invert) {
-
@@ -379,2 +372,2 @@ uint8_t ADCee::highestPin = 0;        // Highest pin to scan
-int * ADCee::analogvals = NULL;       // Array of analog values last captured
-uint32_t * ADCee::analogchans = NULL;        // Array of channel numbers to be scanned
+int* ADCee::analogvals = NULL;        // Array of analog values last captured
+uint32_t* ADCee::analogchans = NULL;  // Array of channel numbers to be scanned
@@ -382 +375 @@ uint32_t * ADCee::analogchans = NULL;        // Array of channel numbers to be s
-ADC_TypeDef * * ADCee::adcchans = NULL;      // Array to capture which ADC is each input channel on
+ADC_TypeDef** ADCee::adcchans = NULL;  // Array to capture which ADC is each input channel on
@@ -384,3 +377,2 @@ ADC_TypeDef * * ADCee::adcchans = NULL;      // Array to capture which ADC is ea
-int16_t ADCee::ADCmax()
-{
-    return 4095;
+int16_t ADCee::ADCmax() {
+  return 4095;
@@ -390 +381,0 @@ int ADCee::init(uint8_t pin) {
-
@@ -393,2 +384,2 @@ int ADCee::init(uint8_t pin) {
-  if (stmpin == NC) // do not continue if this is not an analog pin at all
-    return -1024;   // some silly value as error
+  if (stmpin == NC)  // do not continue if this is not an analog pin at all
+    return -1024;    // some silly value as error
@@ -396,3 +387,3 @@ int ADCee::init(uint8_t pin) {
-  uint32_t stmgpio = STM_PORT(stmpin); // converts to the GPIO port (16-bits per port group on STM32)
-  uint32_t adcchan =  STM_PIN_CHANNEL(pinmap_function(stmpin, PinMap_ADC)); // find ADC input channel
-  ADC_TypeDef *adc = (ADC_TypeDef *)pinmap_find_peripheral(stmpin, PinMap_ADC); // find which ADC this pin is on ADC1/2/3 etc.
+  uint32_t stmgpio = STM_PORT(stmpin);                                          // converts to the GPIO port (16-bits per port group on STM32)
+  uint32_t adcchan = STM_PIN_CHANNEL(pinmap_function(stmpin, PinMap_ADC));      // find ADC input channel
+  ADC_TypeDef* adc = (ADC_TypeDef*)pinmap_find_peripheral(stmpin, PinMap_ADC);  // find which ADC this pin is on ADC1/2/3 etc.
@@ -405,2 +396 @@ int ADCee::init(uint8_t pin) {
-  else if (adc == ADC2)
-  {
+  else if (adc == ADC2) {
@@ -412,2 +402 @@ int ADCee::init(uint8_t pin) {
-  else if (adc == ADC3)
-  {
+  else if (adc == ADC3) {
@@ -418 +407,2 @@ int ADCee::init(uint8_t pin) {
-  else DIAG(F("ADCee::init(): found pin %d on unknown ADC!"), pin);
+  else
+    DIAG(F("ADCee::init(): found pin %d on unknown ADC!"), pin);
@@ -420,2 +410,2 @@ int ADCee::init(uint8_t pin) {
-    // Port config - find which port we're on and power it up
-    GPIO_TypeDef *gpioBase;
+  // Port config - find which port we're on and power it up
+  GPIO_TypeDef* gpioBase;
@@ -423,2 +413 @@ int ADCee::init(uint8_t pin) {
-    switch (stmgpio)
-    {
+  switch (stmgpio) {
@@ -426,3 +415,3 @@ int ADCee::init(uint8_t pin) {
-        RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN; //Power up PORTA
-        gpioBase = GPIOA;
-        break;
+      RCC->AHB1ENR |= RCC_AHB1ENR_GPIOAEN;  // Power up PORTA
+      gpioBase = GPIOA;
+      break;
@@ -430,3 +419,3 @@ int ADCee::init(uint8_t pin) {
-        RCC->AHB1ENR |= RCC_AHB1ENR_GPIOBEN; //Power up PORTB
-        gpioBase = GPIOB;
-        break;
+      RCC->AHB1ENR |= RCC_AHB1ENR_GPIOBEN;  // Power up PORTB
+      gpioBase = GPIOB;
+      break;
@@ -434,3 +423,3 @@ int ADCee::init(uint8_t pin) {
-        RCC->AHB1ENR |= RCC_AHB1ENR_GPIOCEN; //Power up PORTC
-        gpioBase = GPIOC;
-        break;
+      RCC->AHB1ENR |= RCC_AHB1ENR_GPIOCEN;  // Power up PORTC
+      gpioBase = GPIOC;
+      break;
@@ -438,3 +427,3 @@ int ADCee::init(uint8_t pin) {
-        RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN; //Power up PORTD
-        gpioBase = GPIOD;
-        break;
+      RCC->AHB1ENR |= RCC_AHB1ENR_GPIODEN;  // Power up PORTD
+      gpioBase = GPIOD;
+      break;
@@ -442,3 +431,3 @@ int ADCee::init(uint8_t pin) {
-        RCC->AHB1ENR |= RCC_AHB1ENR_GPIOEEN; //Power up PORTE
-        gpioBase = GPIOE;
-        break;
+      RCC->AHB1ENR |= RCC_AHB1ENR_GPIOEEN;  // Power up PORTE
+      gpioBase = GPIOE;
+      break;
@@ -447,3 +436,3 @@ int ADCee::init(uint8_t pin) {
-        RCC->AHB1ENR |= RCC_AHB1ENR_GPIOFEN; //Power up PORTF
-        gpioBase = GPIOF;
-        break;
+      RCC->AHB1ENR |= RCC_AHB1ENR_GPIOFEN;  // Power up PORTF
+      gpioBase = GPIOF;
+      break;
@@ -453,3 +442,3 @@ int ADCee::init(uint8_t pin) {
-        RCC->AHB1ENR |= RCC_AHB1ENR_GPIOGEN; //Power up PORTG
-        gpioBase = GPIOG;
-        break;
+      RCC->AHB1ENR |= RCC_AHB1ENR_GPIOGEN;  // Power up PORTG
+      gpioBase = GPIOG;
+      break;
@@ -459,3 +448,3 @@ int ADCee::init(uint8_t pin) {
-        RCC->AHB1ENR |= RCC_AHB1ENR_GPIOHEN; //Power up PORTH
-        gpioBase = GPIOH;
-        break;
+      RCC->AHB1ENR |= RCC_AHB1ENR_GPIOHEN;  // Power up PORTH
+      gpioBase = GPIOH;
+      break;
@@ -464 +453 @@ int ADCee::init(uint8_t pin) {
-      return -1023; // some silly value as error
+      return -1023;  // some silly value as error
@@ -468 +457 @@ int ADCee::init(uint8_t pin) {
-  gpioBase->MODER |= (0b011 << (STM_PIN(stmpin) << 1)); // Set pin mux to analog mode (binary 11)
+  gpioBase->MODER |= (0b011 << (STM_PIN(stmpin) << 1));  // Set pin mux to analog mode (binary 11)
@@ -476 +465 @@ int ADCee::init(uint8_t pin) {
-    return -1022; // silly value as error
+    return -1022;  // silly value as error
@@ -478 +467 @@ int ADCee::init(uint8_t pin) {
-    adc->SMPR2 |= (0b111 << (adcchan * 3)); // Channel sampling rate 480 cycles
+    adc->SMPR2 |= (0b111 << (adcchan * 3));  // Channel sampling rate 480 cycles
@@ -480 +469 @@ int ADCee::init(uint8_t pin) {
-    adc->SMPR1 |= (0b111 << ((adcchan - 10) * 3)); // Channel sampling rate 480 cycles
+    adc->SMPR1 |= (0b111 << ((adcchan - 10) * 3));  // Channel sampling rate 480 cycles
@@ -483,4 +472,4 @@ int ADCee::init(uint8_t pin) {
-  adc->SQR3 = adcchan;           // 1st conversion in regular sequence
-  adc->CR2 |= ADC_CR2_SWSTART;   //(1 << 30);                     // Start 1st conversion SWSTART
-  while(!(adc->SR & (1 << 1)));  // Wait until conversion is complete
-  value = adc->DR;               // Read value from register
+  adc->SQR3 = adcchan;            // 1st conversion in regular sequence
+  adc->CR2 |= ADC_CR2_SWSTART;    //(1 << 30);                     // Start 1st conversion SWSTART
+  while (!(adc->SR & (1 << 1)));  // Wait until conversion is complete
+  value = adc->DR;                // Read value from register
@@ -494,3 +483,3 @@ int ADCee::init(uint8_t pin) {
-    analogvals = (int *)calloc(NUM_ADC_INPUTS+1, sizeof(int));
-    analogchans = (uint32_t *)calloc(NUM_ADC_INPUTS+1, sizeof(uint32_t));
-    adcchans = (ADC_TypeDef **)calloc(NUM_ADC_INPUTS+1, sizeof(ADC_TypeDef));
+    analogvals = (int*)calloc(NUM_ADC_INPUTS + 1, sizeof(int));
+    analogchans = (uint32_t*)calloc(NUM_ADC_INPUTS + 1, sizeof(uint32_t));
+    adcchans = (ADC_TypeDef**)calloc(NUM_ADC_INPUTS + 1, sizeof(ADC_TypeDef));
@@ -501,2 +490,3 @@ int ADCee::init(uint8_t pin) {
-  usedpins |= (1 << id);                // This pin is now ready
-  if (id > highestPin) highestPin = id; // Store our highest pin in use
+  usedpins |= (1 << id);      // This pin is now ready
+  if (id > highestPin)
+    highestPin = id;  // Store our highest pin in use
@@ -515 +505 @@ int ADCee::read(uint8_t pin, bool fromISR) {
-  if ((usedpins & (1<<id) ) == 0)
+  if ((usedpins & (1 << id)) == 0)
@@ -526 +516 @@ int ADCee::read(uint8_t pin, bool fromISR) {
-#pragma GCC optimize ("-O3")
+#pragma GCC optimize("-O3")
@@ -531 +521 @@ void ADCee::scan() {
-  static ADC_TypeDef *adc;
+  static ADC_TypeDef* adc;
@@ -534,2 +524 @@ void ADCee::scan() {
-  if (waiting)
-  {
+  if (waiting) {
@@ -538 +527 @@ void ADCee::scan() {
-      return; // no result, continue to wait
+      return;  // no result, continue to wait
@@ -543 +532,2 @@ void ADCee::scan() {
-    if (id == 1) TrackManager::track[1]->setBrake(0);
+    if (id == 1)
+      TrackManager::track[1]->setBrake(0);
@@ -548 +538 @@ void ADCee::scan() {
-    if (id > highestPin) { // the 1 has been shifted out
+    if (id > highestPin) {  // the 1 has been shifted out
@@ -554 +544 @@ void ADCee::scan() {
-    if (usedpins == 0) // otherwise we would loop forever
+    if (usedpins == 0)  // otherwise we would loop forever
@@ -558 +548 @@ void ADCee::scan() {
-      if (mask  & usedpins) {
+      if (mask & usedpins) {
@@ -561,2 +551,2 @@ void ADCee::scan() {
-        adc->SQR3 = analogchans[id]; // 1st conversion in regular sequence
-        adc->CR2 |= (1 << 30);       // Start 1st conversion SWSTART
+        adc->SQR3 = analogchans[id];  // 1st conversion in regular sequence
+        adc->CR2 |= (1 << 30);        // Start 1st conversion SWSTART
@@ -564 +554,2 @@ void ADCee::scan() {
-	if (id == 1) TrackManager::track[1]->setBrake(1);
+        if (id == 1)
+          TrackManager::track[1]->setBrake(1);
@@ -566,2 +557,2 @@ void ADCee::scan() {
-	waiting = true;
-	return;
+        waiting = true;
+        return;
@@ -572,2 +563,2 @@ void ADCee::scan() {
-      	id = 0;
-      	mask = 1;
+        id = 0;
+        mask = 1;
@@ -582,2 +573,2 @@ void ADCee::begin() {
-  //ADC1 config sequence
-  RCC->APB2ENR |= RCC_APB2ENR_ADC1EN; // Enable ADC1 clock
+  // ADC1 config sequence
+  RCC->APB2ENR |= RCC_APB2ENR_ADC1EN;  // Enable ADC1 clock
@@ -585,4 +576,4 @@ void ADCee::begin() {
-  ADC->CCR = (0 << 16); // Set prescaler 0=DIV2, 1=DIV4, 2=DIV6, 3=DIV8
-  ADC1->CR1 &= ~(1 << 8); //SCAN mode disabled (Bit8)
-  ADC1->CR1 &= ~(3 << 24); //12bit resolution (Bit24,25 0b00)
-  ADC1->SQR1 = (1 << 20); //Set number of conversions projected (L[3:0] 0b0001) -> 1 conversion
+  ADC->CCR = (0 << 16);     // Set prescaler 0=DIV2, 1=DIV4, 2=DIV6, 3=DIV8
+  ADC1->CR1 &= ~(1 << 8);   // SCAN mode disabled (Bit8)
+  ADC1->CR1 &= ~(3 << 24);  // 12bit resolution (Bit24,25 0b00)
+  ADC1->SQR1 = (1 << 20);   // Set number of conversions projected (L[3:0] 0b0001) -> 1 conversion
@@ -591,6 +582,6 @@ void ADCee::begin() {
-  ADC1->CR2 &= ~(1 << 1); //Single conversion
-  ADC1->CR2 &= ~(1 << 11); //Right alignment of data bits bit12....bit0
-  ADC1->SQR1 &= ~(0x3FFFFFFF); //Clear whole 1st 30bits in register
-  ADC1->SQR2 &= ~(0x3FFFFFFF); //Clear whole 1st 30bits in register
-  ADC1->SQR3 &= ~(0x3FFFFFFF); //Clear whole 1st 30bits in register
-  ADC1->CR2 |= (1 << 0); // Switch on ADC1
+  ADC1->CR2 &= ~(1 << 1);       // Single conversion
+  ADC1->CR2 &= ~(1 << 11);      // Right alignment of data bits bit12....bit0
+  ADC1->SQR1 &= ~(0x3FFFFFFF);  // Clear whole 1st 30bits in register
+  ADC1->SQR2 &= ~(0x3FFFFFFF);  // Clear whole 1st 30bits in register
+  ADC1->SQR3 &= ~(0x3FFFFFFF);  // Clear whole 1st 30bits in register
+  ADC1->CR2 |= (1 << 0);        // Switch on ADC1
@@ -605,12 +596,12 @@ void ADCee::begin() {
-  ADC2->CR1 = 0; // Disable all channels
-  ADC2->CR2 = 0; // Clear CR2 register
-
-  ADC2->CR1 &= ~(1 << 8); //SCAN mode disabled (Bit8)
-  ADC2->CR1 &= ~(3 << 24); //12bit resolution (Bit24,25 0b00)
-  ADC2->SQR1 = (1 << 20); //Set number of conversions projected (L[3:0] 0b0001) -> 1 conversion
-  ADC2->CR2 &= ~ADC_CR2_DMA;   // Disable the DMA controller for ADC3
-  ADC2->CR2 &= ~(1 << 1); //Single conversion
-  ADC2->CR2 &= ~(1 << 11); //Right alignment of data bits bit12....bit0
-  ADC2->SQR1 &= ~(0x3FFFFFFF); //Clear whole 1st 30bits in register
-  ADC2->SQR2 &= ~(0x3FFFFFFF); //Clear whole 1st 30bits in register
-  ADC2->SQR3 &= ~(0x3FFFFFFF); //Clear whole 1st 30bits in register
+  ADC2->CR1 = 0;  // Disable all channels
+  ADC2->CR2 = 0;  // Clear CR2 register
+
+  ADC2->CR1 &= ~(1 << 8);       // SCAN mode disabled (Bit8)
+  ADC2->CR1 &= ~(3 << 24);      // 12bit resolution (Bit24,25 0b00)
+  ADC2->SQR1 = (1 << 20);       // Set number of conversions projected (L[3:0] 0b0001) -> 1 conversion
+  ADC2->CR2 &= ~ADC_CR2_DMA;    // Disable the DMA controller for ADC3
+  ADC2->CR2 &= ~(1 << 1);       // Single conversion
+  ADC2->CR2 &= ~(1 << 11);      // Right alignment of data bits bit12....bit0
+  ADC2->SQR1 &= ~(0x3FFFFFFF);  // Clear whole 1st 30bits in register
+  ADC2->SQR2 &= ~(0x3FFFFFFF);  // Clear whole 1st 30bits in register
+  ADC2->SQR3 &= ~(0x3FFFFFFF);  // Clear whole 1st 30bits in register
@@ -635,12 +626,12 @@ void ADCee::begin() {
-  ADC3->CR1 = 0; // Disable all channels
-  ADC3->CR2 = 0; // Clear CR2 register
-
-  ADC3->CR1 &= ~(1 << 8); //SCAN mode disabled (Bit8)
-  ADC3->CR1 &= ~(3 << 24); //12bit resolution (Bit24,25 0b00)
-  ADC3->SQR1 = (1 << 20); //Set number of conversions projected (L[3:0] 0b0001) -> 1 conversion
-  ADC3->CR2 &= ~ADC_CR2_DMA;   // Disable the DMA controller for ADC3
-  ADC3->CR2 &= ~(1 << 1); //Single conversion
-  ADC3->CR2 &= ~(1 << 11); //Right alignment of data bits bit12....bit0
-  ADC3->SQR1 &= ~(0x3FFFFFFF); //Clear whole 1st 30bits in register
-  ADC3->SQR2 &= ~(0x3FFFFFFF); //Clear whole 1st 30bits in register
-  ADC3->SQR3 &= ~(0x3FFFFFFF); //Clear whole 1st 30bits in register
+  ADC3->CR1 = 0;  // Disable all channels
+  ADC3->CR2 = 0;  // Clear CR2 register
+
+  ADC3->CR1 &= ~(1 << 8);       // SCAN mode disabled (Bit8)
+  ADC3->CR1 &= ~(3 << 24);      // 12bit resolution (Bit24,25 0b00)
+  ADC3->SQR1 = (1 << 20);       // Set number of conversions projected (L[3:0] 0b0001) -> 1 conversion
+  ADC3->CR2 &= ~ADC_CR2_DMA;    // Disable the DMA controller for ADC3
+  ADC3->CR2 &= ~(1 << 1);       // Single conversion
+  ADC3->CR2 &= ~(1 << 11);      // Right alignment of data bits bit12....bit0
+  ADC3->SQR1 &= ~(0x3FFFFFFF);  // Clear whole 1st 30bits in register
+  ADC3->SQR2 &= ~(0x3FFFFFFF);  // Clear whole 1st 30bits in register
+  ADC3->SQR3 &= ~(0x3FFFFFFF);  // Clear whole 1st 30bits in register
diff --git a/DCCTimerTEENSY.cpp b/DCCTimerTEENSY.cpp
index 384691b..3cd8af3 100644
--- a/DCCTimerTEENSY.cpp
+++ b/DCCTimerTEENSY.cpp
@@ -9 +9 @@
- *  
+ *
@@ -33 +33 @@
-INTERRUPT_CALLBACK interruptHandler=0;
+INTERRUPT_CALLBACK interruptHandler = 0;
@@ -38 +38 @@ void DCCTimer::begin(INTERRUPT_CALLBACK callback) {
-  interruptHandler=callback;
+  interruptHandler = callback;
@@ -40 +40 @@ void DCCTimer::begin(INTERRUPT_CALLBACK callback) {
-  }
+}
@@ -44 +44 @@ void DCCTimer::startRailcomTimer(byte brakePin) {
-  (void) brakePin; 
+  (void)brakePin;
@@ -52,4 +52,4 @@ bool DCCTimer::isPWMPin(byte pin) {
-       //Teensy: digitalPinHasPWM, todo
-      (void) pin;
-       return false;  // TODO what are the relevant pins? 
-  }
+  // Teensy: digitalPinHasPWM, todo
+  (void)pin;
+  return false;  // TODO what are the relevant pins?
+}
@@ -58,3 +58,3 @@ void DCCTimer::setPWM(byte pin, bool high) {
-    // TODO what are the relevant pins?
-    (void) pin;
-    (void) high;
+  // TODO what are the relevant pins?
+  (void)pin;
+  (void)high;
@@ -64 +64 @@ void DCCTimer::clearPWM() {
-    // Do nothing unless we implent HA
+  // Do nothing unless we implent HA
@@ -67,11 +67,11 @@ void DCCTimer::clearPWM() {
-#if defined(__IMXRT1062__)  //Teensy 4.0 and Teensy 4.1
-void   DCCTimer::getSimulatedMacAddress(byte mac[6]) {
-    uint32_t m1 = HW_OCOTP_MAC1;
-    uint32_t m2 = HW_OCOTP_MAC0;
-    mac[0] = m1 >> 8;
-    mac[1] = m1 >> 0;
-    mac[2] = m2 >> 24;
-    mac[3] = m2 >> 16;
-    mac[4] = m2 >> 8;
-    mac[5] = m2 >> 0;
-  }
+#if defined(__IMXRT1062__)  // Teensy 4.0 and Teensy 4.1
+void DCCTimer::getSimulatedMacAddress(byte mac[6]) {
+  uint32_t m1 = HW_OCOTP_MAC1;
+  uint32_t m2 = HW_OCOTP_MAC0;
+  mac[0] = m1 >> 8;
+  mac[1] = m1 >> 0;
+  mac[2] = m2 >> 24;
+  mac[3] = m2 >> 16;
+  mac[4] = m2 >> 8;
+  mac[5] = m2 >> 0;
+}
@@ -82,3 +82,3 @@ void   DCCTimer::getSimulatedMacAddress(byte mac[6]) {
-void teensyRead(uint8_t word, uint8_t *mac, uint8_t offset) {
-  FTFL_FCCOB0 = 0x41;             // Selects the READONCE command
-  FTFL_FCCOB1 = word;             // read the given word of read once area
+void teensyRead(uint8_t word, uint8_t* mac, uint8_t offset) {
+  FTFL_FCCOB0 = 0x41;  // Selects the READONCE command
+  FTFL_FCCOB1 = word;  // read the given word of read once area
@@ -88 +88 @@ void teensyRead(uint8_t word, uint8_t *mac, uint8_t offset) {
-  while(!(FTFL_FSTAT & FTFL_FSTAT_CCIF));
+  while (!(FTFL_FSTAT & FTFL_FSTAT_CCIF));
@@ -90,3 +90,3 @@ void teensyRead(uint8_t word, uint8_t *mac, uint8_t offset) {
-  *(mac+offset) =   FTFL_FCCOB5;       // collect only the top three bytes,
-  *(mac+offset+1) = FTFL_FCCOB6;       // in the right orientation (big endian).
-  *(mac+offset+2) = FTFL_FCCOB7;       // Skip FTFL_FCCOB4 as it's always 0.
+  *(mac + offset) = FTFL_FCCOB5;      // collect only the top three bytes,
+  *(mac + offset + 1) = FTFL_FCCOB6;  // in the right orientation (big endian).
+  *(mac + offset + 2) = FTFL_FCCOB7;  // Skip FTFL_FCCOB4 as it's always 0.
@@ -95,5 +95,5 @@ void teensyRead(uint8_t word, uint8_t *mac, uint8_t offset) {
-void   DCCTimer::getSimulatedMacAddress(byte mac[6]) {
-    teensyRead(0xe,mac,0);
-    teensyRead(0xf,mac,3);
-  }
-#endif 
+void DCCTimer::getSimulatedMacAddress(byte mac[6]) {
+  teensyRead(0xe, mac, 0);
+  teensyRead(0xf, mac, 3);
+}
+#endif
@@ -101 +101 @@ void   DCCTimer::getSimulatedMacAddress(byte mac[6]) {
-volatile int DCCTimer::minimum_free_memory=__INT_MAX__;
+volatile int DCCTimer::minimum_free_memory = __INT_MAX__;
@@ -103 +103 @@ volatile int DCCTimer::minimum_free_memory=__INT_MAX__;
-// Return low memory value... 
+// Return low memory value...
@@ -105 +105 @@ int DCCTimer::getMinimumFreeMemory() {
-  noInterrupts(); // Disable interrupts to get volatile value 
+  noInterrupts();  // Disable interrupts to get volatile value
@@ -121,4 +121,4 @@ int DCCTimer::freeMemory() {
-  static const unsigned DTCM_START = 0x20000000UL;
-  static const unsigned OCRAM_START = 0x20200000UL;
-  static const unsigned OCRAM_SIZE = 512;
-  static const unsigned FLASH_SIZE = 1984;
+static const unsigned DTCM_START = 0x20000000UL;
+static const unsigned OCRAM_START = 0x20200000UL;
+static const unsigned OCRAM_SIZE = 512;
+static const unsigned FLASH_SIZE = 1984;
@@ -126,6 +126,6 @@ int DCCTimer::freeMemory() {
-  static const unsigned DTCM_START = 0x20000000UL;
-  static const unsigned OCRAM_START = 0x20200000UL;
-  static const unsigned OCRAM_SIZE = 512;
-  static const unsigned FLASH_SIZE = 7936;
-#if TEENSYDUINO>151
-  extern "C" uint8_t external_psram_size;
+static const unsigned DTCM_START = 0x20000000UL;
+static const unsigned OCRAM_START = 0x20200000UL;
+static const unsigned OCRAM_SIZE = 512;
+static const unsigned FLASH_SIZE = 7936;
+#if TEENSYDUINO > 151
+extern "C" uint8_t external_psram_size;
@@ -141 +141 @@ int DCCTimer::freeMemory() {
-  unsigned stackinuse = (unsigned) &_estack -  (unsigned) __builtin_frame_address(0);
+  unsigned stackinuse = (unsigned)&_estack - (unsigned)__builtin_frame_address(0);
@@ -170 +170,2 @@ int ADCee::read(uint8_t pin, bool fromISR) {
-  if (!fromISR) noInterrupts();
+  if (!fromISR)
+    noInterrupts();
@@ -172 +173,2 @@ int ADCee::read(uint8_t pin, bool fromISR) {
-  if (!fromISR) interrupts();
+  if (!fromISR)
+    interrupts();
diff --git a/DCCWaveform.cpp b/DCCWaveform.cpp
index eb25144..c32744a 100644
--- a/DCCWaveform.cpp
+++ b/DCCWaveform.cpp
@@ -8 +8 @@
- *  
+ *
@@ -25 +25 @@
-  // This code is replaced entirely on an ESP32
+// This code is replaced entirely on an ESP32
@@ -34,4 +34,2 @@
-
-DCCWaveform  DCCWaveform::mainTrack(PREAMBLE_BITS_MAIN, true);
-DCCWaveform  DCCWaveform::progTrack(PREAMBLE_BITS_PROG, false);
-
+DCCWaveform DCCWaveform::mainTrack(PREAMBLE_BITS_MAIN, true);
+DCCWaveform DCCWaveform::progTrack(PREAMBLE_BITS_PROG, false);
@@ -45,18 +43,17 @@ const byte resetPacket[] = {0x00, 0x00, 0x00};
-
-// For each state of the wave  nextState=stateTransform[currentState] 
-const WAVE_STATE stateTransform[]={
-   /* WAVE_START   -> */ WAVE_PENDING,
-   /* WAVE_MID_1   -> */ WAVE_START,
-   /* WAVE_HIGH_0  -> */ WAVE_MID_0,
-   /* WAVE_MID_0   -> */ WAVE_LOW_0,
-   /* WAVE_LOW_0   -> */ WAVE_START,
-   /* WAVE_PENDING (should not happen) -> */ WAVE_PENDING};
-
-// For each state of the wave, signal pin is HIGH or LOW   
-const bool signalTransform[]={
-   /* WAVE_START   -> */ HIGH,
-   /* WAVE_MID_1   -> */ LOW,
-   /* WAVE_HIGH_0  -> */ HIGH,
-   /* WAVE_MID_0   -> */ LOW,
-   /* WAVE_LOW_0   -> */ LOW,
-   /* WAVE_PENDING (should not happen) -> */ LOW};
+// For each state of the wave  nextState=stateTransform[currentState]
+const WAVE_STATE stateTransform[] = {
+    /* WAVE_START   -> */ WAVE_PENDING,
+    /* WAVE_MID_1   -> */ WAVE_START,
+    /* WAVE_HIGH_0  -> */ WAVE_MID_0,
+    /* WAVE_MID_0   -> */ WAVE_LOW_0,
+    /* WAVE_LOW_0   -> */ WAVE_START,
+    /* WAVE_PENDING (should not happen) -> */ WAVE_PENDING};
+
+// For each state of the wave, signal pin is HIGH or LOW
+const bool signalTransform[] = {
+    /* WAVE_START   -> */ HIGH,
+    /* WAVE_MID_1   -> */ LOW,
+    /* WAVE_HIGH_0  -> */ HIGH,
+    /* WAVE_MID_0   -> */ LOW,
+    /* WAVE_LOW_0   -> */ LOW,
+    /* WAVE_PENDING (should not happen) -> */ LOW};
@@ -65 +62 @@ void DCCWaveform::begin() {
-  DCCTimer::begin(DCCWaveform::interruptHandler);     
+  DCCTimer::begin(DCCWaveform::interruptHandler);
@@ -69 +66 @@ void DCCWaveform::loop() {
- // empty placemarker in case ESP32 needs something here 
+  // empty placemarker in case ESP32 needs something here
@@ -73 +70 @@ void DCCWaveform::loop() {
-#pragma GCC optimize ("-O3")
+#pragma GCC optimize("-O3")
@@ -77,3 +74,3 @@ void DCCWaveform::interruptHandler() {
-  byte sigMain=signalTransform[mainTrack.state];
-  byte sigProg=TrackManager::progTrackSyncMain? sigMain : signalTransform[progTrack.state];
-  
+  byte sigMain = signalTransform[mainTrack.state];
+  byte sigProg = TrackManager::progTrackSyncMain ? sigMain : signalTransform[progTrack.state];
+
@@ -88,2 +85,2 @@ void DCCWaveform::interruptHandler() {
-  mainTrack.state=stateTransform[mainTrack.state];    
-  progTrack.state=stateTransform[progTrack.state];    
+  mainTrack.state = stateTransform[mainTrack.state];
+  progTrack.state = stateTransform[progTrack.state];
@@ -92,4 +89,6 @@ void DCCWaveform::interruptHandler() {
-  if (mainTrack.state==WAVE_PENDING) mainTrack.interrupt2();  
-  if (progTrack.state==WAVE_PENDING) progTrack.interrupt2();
-  else DCCACK::checkAck(progTrack.getResets());
-
+  if (mainTrack.state == WAVE_PENDING)
+    mainTrack.interrupt2();
+  if (progTrack.state == WAVE_PENDING)
+    progTrack.interrupt2();
+  else
+    DCCACK::checkAck(progTrack.getResets());
@@ -104,3 +103 @@ void DCCWaveform::interruptHandler() {
-
-
-DCCWaveform::DCCWaveform( byte preambleBits, bool isMain) {
+DCCWaveform::DCCWaveform(byte preambleBits, bool isMain) {
@@ -113,2 +110,2 @@ DCCWaveform::DCCWaveform( byte preambleBits, bool isMain) {
-  // for the previous packet. 
-  requiredPreambles = preambleBits+1;  
+  // for the previous packet.
+  requiredPreambles = preambleBits + 1;
@@ -118,3 +115,3 @@ DCCWaveform::DCCWaveform( byte preambleBits, bool isMain) {
-    
-volatile bool DCCWaveform::railcomActive=false;     // switched on by user
-volatile bool DCCWaveform::railcomDebug=false;     // switched on by user
+
+volatile bool DCCWaveform::railcomActive = false;  // switched on by user
+volatile bool DCCWaveform::railcomDebug = false;   // switched on by user
@@ -125,2 +122,5 @@ bool DCCWaveform::setRailcom(bool on, bool debug) {
-    railcomActive=true;
-    railcomDebug=debug;
+    railcomActive = true;
+    railcomDebug = debug;
+  } else {
+    railcomActive = false;
+    railcomDebug = false;
@@ -128,4 +127,0 @@ bool DCCWaveform::setRailcom(bool on, bool debug) {
-  else {
-    railcomActive=false;
-    railcomDebug=false;
-  } 
@@ -136 +132 @@ bool DCCWaveform::setRailcom(bool on, bool debug) {
-#pragma GCC optimize ("-O3")
+#pragma GCC optimize("-O3")
@@ -141,2 +137,2 @@ void DCCWaveform::interrupt2() {
-  if (remainingPreambles > 0 ) {
-    state=WAVE_MID_1;  // switch state to trigger LOW on next interrupt
+  if (remainingPreambles > 0) {
+    state = WAVE_MID_1;  // switch state to trigger LOW on next interrupt
@@ -144 +140 @@ void DCCWaveform::interrupt2() {
-  
+
@@ -147,4 +143,6 @@ void DCCWaveform::interrupt2() {
-    // that the reminder doesn't block a more urgent packet. 
-    reminderWindowOpen=transmitRepeats==0 && remainingPreambles<4 && remainingPreambles>1;
-    if (remainingPreambles==1) promotePendingPacket();
-    else if (remainingPreambles==10 && isMainTrack && railcomActive) DCCTimer::ackRailcomTimer();
+    // that the reminder doesn't block a more urgent packet.
+    reminderWindowOpen = transmitRepeats == 0 && remainingPreambles < 4 && remainingPreambles > 1;
+    if (remainingPreambles == 1)
+      promotePendingPacket();
+    else if (remainingPreambles == 10 && isMainTrack && railcomActive)
+      DCCTimer::ackRailcomTimer();
@@ -153 +151,2 @@ void DCCWaveform::interrupt2() {
-    else DCCTimer::updateMinimumFreeMemoryISR(22); 
+    else
+      DCCTimer::updateMinimumFreeMemoryISR(22);
@@ -159 +158 @@ void DCCWaveform::interrupt2() {
-  state=(transmitPacket[bytes_sent] & bitMask[bits_sent])? WAVE_MID_1 : WAVE_HIGH_0; 
+  state = (transmitPacket[bytes_sent] & bitMask[bits_sent]) ? WAVE_MID_1 : WAVE_HIGH_0;
@@ -164,2 +163,2 @@ void DCCWaveform::interrupt2() {
-  if (bits_sent == 9) { // zero followed by 8 bits of a byte
-    //end of Byte
+  if (bits_sent == 9) {  // zero followed by 8 bits of a byte
+    // end of Byte
@@ -174,2 +173,2 @@ void DCCWaveform::interrupt2() {
-      
-      // set the railcom coundown to trigger half way 
+
+      // set the railcom coundown to trigger half way
@@ -179,3 +178,4 @@ void DCCWaveform::interrupt2() {
-      if (isMainTrack && railcomActive) DCCTimer::startRailcomTimer(9);
-      }
-  }  
+      if (isMainTrack && railcomActive)
+        DCCTimer::startRailcomTimer(9);
+    }
+  }
@@ -187 +187,2 @@ void DCCWaveform::schedulePacket(const byte buffer[], byte byteCount, byte repea
-  if (byteCount > MAX_PACKET_SIZE) return; // allow for chksum
+  if (byteCount > MAX_PACKET_SIZE)
+    return;  // allow for chksum
@@ -204 +205 @@ bool DCCWaveform::isReminderWindowOpen() {
-  return reminderWindowOpen && ! packetPending;
+  return reminderWindowOpen && !packetPending;
@@ -208,31 +209,32 @@ void DCCWaveform::promotePendingPacket() {
-    // fill the transmission packet from the pending packet
-    
-    // Just keep going if repeating  
-    if (transmitRepeats > 0) {
-        transmitRepeats--;
-        return;
-      }
-
-    if (packetPending) {
-        // Copy pending packet to transmit packet
-        // a fixed length memcpy is faster than a variable length loop for these small lengths
-        // for (int b = 0; b < pendingLength; b++) transmitPacket[b] = pendingPacket[b];
-        memcpy( transmitPacket, pendingPacket, sizeof(pendingPacket));
-        
-        transmitLength = pendingLength;
-        transmitRepeats = pendingRepeats;
-        packetPending = false;
-        clearResets();
-        return;
-      }
-      
-      // nothing to do, just send idles or resets
-      // Fortunately reset and idle packets are the same length
-      // Note: If railcomDebug is on, then we send resets to the main
-      //       track instead of idles. This means that all data will be zeros
-      //       and only the porersets will be ones, making it much
-      //       easier to read on a logic analyser.
-      memcpy( transmitPacket, (isMainTrack && (!railcomDebug)) ? idlePacket : resetPacket, sizeof(idlePacket));
-      transmitLength = sizeof(idlePacket);
-      transmitRepeats = 0;
-      if (getResets() < 250) sentResetsSincePacket++; // only place to increment (private!)
+  // fill the transmission packet from the pending packet
+
+  // Just keep going if repeating
+  if (transmitRepeats > 0) {
+    transmitRepeats--;
+    return;
+  }
+
+  if (packetPending) {
+    // Copy pending packet to transmit packet
+    // a fixed length memcpy is faster than a variable length loop for these small lengths
+    // for (int b = 0; b < pendingLength; b++) transmitPacket[b] = pendingPacket[b];
+    memcpy(transmitPacket, pendingPacket, sizeof(pendingPacket));
+
+    transmitLength = pendingLength;
+    transmitRepeats = pendingRepeats;
+    packetPending = false;
+    clearResets();
+    return;
+  }
+
+  // nothing to do, just send idles or resets
+  // Fortunately reset and idle packets are the same length
+  // Note: If railcomDebug is on, then we send resets to the main
+  //       track instead of idles. This means that all data will be zeros
+  //       and only the porersets will be ones, making it much
+  //       easier to read on a logic analyser.
+  memcpy(transmitPacket, (isMainTrack && (!railcomDebug)) ? idlePacket : resetPacket, sizeof(idlePacket));
+  transmitLength = sizeof(idlePacket);
+  transmitRepeats = 0;
+  if (getResets() < 250)
+    sentResetsSincePacket++;  // only place to increment (private!)
@@ -246,4 +248,4 @@ void DCCWaveform::promotePendingPacket() {
-DCCWaveform  DCCWaveform::mainTrack(PREAMBLE_BITS_MAIN, true);
-DCCWaveform  DCCWaveform::progTrack(PREAMBLE_BITS_PROG, false);
-RMTChannel *DCCWaveform::rmtMainChannel = NULL;
-RMTChannel *DCCWaveform::rmtProgChannel = NULL;
+DCCWaveform DCCWaveform::mainTrack(PREAMBLE_BITS_MAIN, true);
+DCCWaveform DCCWaveform::progTrack(PREAMBLE_BITS_PROG, false);
+RMTChannel* DCCWaveform::rmtMainChannel = NULL;
+RMTChannel* DCCWaveform::rmtProgChannel = NULL;
@@ -256 +258 @@ void DCCWaveform::begin() {
-  for(const auto& md: TrackManager::getMainDrivers()) {
+  for (const auto& md : TrackManager::getMainDrivers()) {
@@ -258,3 +260,3 @@ void DCCWaveform::begin() {
-    if(rmtMainChannel) {
-      //DIAG(F("added pins %d %d to MAIN channel"), p.pin, p.invpin);
-      rmtMainChannel->addPin(p); // add pin to existing main channel
+    if (rmtMainChannel) {
+      // DIAG(F("added pins %d %d to MAIN channel"), p.pin, p.invpin);
+      rmtMainChannel->addPin(p);  // add pin to existing main channel
@@ -262 +264 @@ void DCCWaveform::begin() {
-      //DIAG(F("new MAIN channel with pins %d %d"), p.pin, p.invpin);
+      // DIAG(F("new MAIN channel with pins %d %d"), p.pin, p.invpin);
@@ -266 +268 @@ void DCCWaveform::begin() {
-  MotorDriver *md = TrackManager::getProgDriver();
+  MotorDriver* md = TrackManager::getProgDriver();
@@ -270,2 +272,2 @@ void DCCWaveform::begin() {
-      //DIAG(F("added pins %d %d to PROG channel"), p.pin, p.invpin);
-      rmtProgChannel->addPin(p); // add pin to existing prog channel
+      // DIAG(F("added pins %d %d to PROG channel"), p.pin, p.invpin);
+      rmtProgChannel->addPin(p);  // add pin to existing prog channel
@@ -273 +275 @@ void DCCWaveform::begin() {
-      //DIAG(F("new PROGchannel with pins %d %d"), p.pin, p.invpin);
+      // DIAG(F("new PROGchannel with pins %d %d"), p.pin, p.invpin);
@@ -280,2 +282,3 @@ void DCCWaveform::schedulePacket(const byte buffer[], byte byteCount, byte repea
-  if (byteCount > MAX_PACKET_SIZE) return; // allow for chksum
-  RMTChannel *rmtchannel = (isMainTrack ? rmtMainChannel : rmtProgChannel);
+  if (byteCount > MAX_PACKET_SIZE)
+    return;  // allow for chksum
+  RMTChannel* rmtchannel = (isMainTrack ? rmtMainChannel : rmtProgChannel);
@@ -283 +286 @@ void DCCWaveform::schedulePacket(const byte buffer[], byte byteCount, byte repea
-    return; // no idea to prepare packet if we can not send it anyway
+    return;  // no idea to prepare packet if we can not send it anyway
@@ -285 +288 @@ void DCCWaveform::schedulePacket(const byte buffer[], byte byteCount, byte repea
-  rmtchannel->waitForDataCopy(); // blocking wait so we can write into buffer
+  rmtchannel->waitForDataCopy();  // blocking wait so we can write into buffer
@@ -295,3 +298,3 @@ void DCCWaveform::schedulePacket(const byte buffer[], byte byteCount, byte repea
-// DIAG repeated commands (accesories)
-//  if (pendingRepeats > 0)
-//    DIAG(F("Repeats=%d on %s track"), pendingRepeats, isMainTrack ? "MAIN" : "PROG");
+  // DIAG repeated commands (accesories)
+  //  if (pendingRepeats > 0)
+  //    DIAG(F("Repeats=%d on %s track"), pendingRepeats, isMainTrack ? "MAIN" : "PROG");
@@ -299 +302 @@ void DCCWaveform::schedulePacket(const byte buffer[], byte byteCount, byte repea
-  clearResets(repeats+1);
+  clearResets(repeats + 1);
@@ -304 +307 @@ void DCCWaveform::schedulePacket(const byte buffer[], byte byteCount, byte repea
-    } while(ret > 0);
+    } while (ret > 0);
@@ -309 +312 @@ bool DCCWaveform::isReminderWindowOpen() {
-  if(isMainTrack) {
+  if (isMainTrack) {
diff --git a/DCCWaveform.h b/DCCWaveform.h
index a3e20da..6511366 100644
--- a/DCCWaveform.h
+++ b/DCCWaveform.h
@@ -8 +8 @@
- *  
+ *
@@ -33,2 +32,0 @@
-
-
@@ -38,2 +36 @@ const byte PREAMBLE_BITS_PROG = 22;
-const byte MAX_PACKET_SIZE = 5;     // NMRA standard extended packets, payload size WITHOUT checksum.
-
+const byte MAX_PACKET_SIZE = 5;  // NMRA standard extended packets, payload size WITHOUT checksum.
@@ -43,8 +40,8 @@ const byte MAX_PACKET_SIZE = 5;     // NMRA standard extended packets, payload s
-enum  WAVE_STATE : byte {
-  WAVE_START=0,  // wave going high at start of bit 
-  WAVE_MID_1=1,  // middle of 1 bit 
-  WAVE_HIGH_0=2, // first part of 0 bit high
-  WAVE_MID_0=3,  // middle of 0 bit
-  WAVE_LOW_0=4,  // first part of 0 bit low
-  WAVE_PENDING=5 // next bit not yet known
-  };
+enum WAVE_STATE : byte {
+  WAVE_START = 0,   // wave going high at start of bit
+  WAVE_MID_1 = 1,   // middle of 1 bit
+  WAVE_HIGH_0 = 2,  // first part of 0 bit high
+  WAVE_MID_0 = 3,   // middle of 0 bit
+  WAVE_LOW_0 = 4,   // first part of 0 bit low
+  WAVE_PENDING = 5  // next bit not yet known
+};
@@ -56,7 +53,9 @@ class DCCWaveform {
-  public:
-    DCCWaveform( byte preambleBits, bool isMain);
-    static void begin();
-    static void loop();
-    static DCCWaveform  mainTrack;
-    static DCCWaveform  progTrack;
-    inline void clearRepeats() { transmitRepeats=0; }
+ public:
+  DCCWaveform(byte preambleBits, bool isMain);
+  static void begin();
+  static void loop();
+  static DCCWaveform mainTrack;
+  static DCCWaveform progTrack;
+  inline void clearRepeats() {
+    transmitRepeats = 0;
+  }
@@ -64,2 +63,6 @@ class DCCWaveform {
-    inline void clearResets() { sentResetsSincePacket=0; }
-    inline byte getResets() { return sentResetsSincePacket; }
+  inline void clearResets() {
+    sentResetsSincePacket = 0;
+  }
+  inline byte getResets() {
+    return sentResetsSincePacket;
+  }
@@ -68,16 +71,17 @@ class DCCWaveform {
-    inline void clearResets(byte extrafudge=0) {
-      if ((isMainTrack ? rmtMainChannel : rmtProgChannel) == NULL) return;
-      resetPacketBase = isMainTrack ? rmtMainChannel->packetCount() : rmtProgChannel->packetCount();
-      resetPacketBase += extrafudge;
-    };
-    inline byte getResets() {
-      if ((isMainTrack ? rmtMainChannel : rmtProgChannel) == NULL) return 0;
-      uint32_t packetcount = isMainTrack ?
-	rmtMainChannel->packetCount() : rmtProgChannel->packetCount();
-      uint32_t count = packetcount - resetPacketBase; // Beware of unsigned interger arithmetic.
-      if (count > UINT32_MAX/2)                       // we are in the extrafudge area
-	return 0;
-      if (count > 255)                                // cap to 255
-	return 255;
-      return count;                                   // all special cases handled above
-    };
+  inline void clearResets(byte extrafudge = 0) {
+    if ((isMainTrack ? rmtMainChannel : rmtProgChannel) == NULL)
+      return;
+    resetPacketBase = isMainTrack ? rmtMainChannel->packetCount() : rmtProgChannel->packetCount();
+    resetPacketBase += extrafudge;
+  };
+  inline byte getResets() {
+    if ((isMainTrack ? rmtMainChannel : rmtProgChannel) == NULL)
+      return 0;
+    uint32_t packetcount = isMainTrack ? rmtMainChannel->packetCount() : rmtProgChannel->packetCount();
+    uint32_t count = packetcount - resetPacketBase;  // Beware of unsigned interger arithmetic.
+    if (count > UINT32_MAX / 2)                      // we are in the extrafudge area
+      return 0;
+    if (count > 255)  // cap to 255
+      return 255;
+    return count;  // all special cases handled above
+  };
@@ -85,7 +89,9 @@ class DCCWaveform {
-    void schedulePacket(const byte buffer[], byte byteCount, byte repeats);
-    bool isReminderWindowOpen();
-    void promotePendingPacket();
-    static bool setRailcom(bool on, bool debug);
-    static bool isRailcom() {return railcomActive;}
-    
-  private:
+  void schedulePacket(const byte buffer[], byte byteCount, byte repeats);
+  bool isReminderWindowOpen();
+  void promotePendingPacket();
+  static bool setRailcom(bool on, bool debug);
+  static bool isRailcom() {
+    return railcomActive;
+  }
+
+ private:
@@ -93,3 +99,3 @@ class DCCWaveform {
-    volatile bool packetPending;
-    volatile bool reminderWindowOpen;
-    volatile byte sentResetsSincePacket;
+  volatile bool packetPending;
+  volatile bool reminderWindowOpen;
+  volatile byte sentResetsSincePacket;
@@ -97 +103 @@ class DCCWaveform {
-    volatile uint32_t resetPacketBase;
+  volatile uint32_t resetPacketBase;
@@ -99,19 +105,19 @@ class DCCWaveform {
-    static void interruptHandler();
-    void interrupt2();
-    
-    bool isMainTrack;
-    // Transmission controller
-    byte transmitPacket[MAX_PACKET_SIZE+1]; // +1 for checksum
-    byte transmitLength;
-    byte transmitRepeats;      // remaining repeats of transmission
-    byte remainingPreambles;
-    byte requiredPreambles;
-    byte bits_sent;           // 0-8 (yes 9 bits) sent for current byte
-    byte bytes_sent;          // number of bytes sent from transmitPacket
-    WAVE_STATE state;         // wave generator state machine
-    byte pendingPacket[MAX_PACKET_SIZE+1]; // +1 for checksum
-    byte pendingLength;
-    byte pendingRepeats;
-    static volatile bool railcomActive;     // switched on by user
-    static volatile bool railcomDebug;     // switched on by user
-    
+  static void interruptHandler();
+  void interrupt2();
+
+  bool isMainTrack;
+  // Transmission controller
+  byte transmitPacket[MAX_PACKET_SIZE + 1];  // +1 for checksum
+  byte transmitLength;
+  byte transmitRepeats;  // remaining repeats of transmission
+  byte remainingPreambles;
+  byte requiredPreambles;
+  byte bits_sent;                           // 0-8 (yes 9 bits) sent for current byte
+  byte bytes_sent;                          // number of bytes sent from transmitPacket
+  WAVE_STATE state;                         // wave generator state machine
+  byte pendingPacket[MAX_PACKET_SIZE + 1];  // +1 for checksum
+  byte pendingLength;
+  byte pendingRepeats;
+  static volatile bool railcomActive;  // switched on by user
+  static volatile bool railcomDebug;   // switched on by user
+
@@ -119,2 +125,2 @@ class DCCWaveform {
-  static RMTChannel *rmtMainChannel;
-  static RMTChannel *rmtProgChannel;
+  static RMTChannel* rmtMainChannel;
+  static RMTChannel* rmtProgChannel;
diff --git a/DIAG.h b/DIAG.h
index 5aa54aa..eed3a04 100644
--- a/DIAG.h
+++ b/DIAG.h
@@ -5 +5 @@
- *  
+ *
@@ -25,3 +25,3 @@
-#define DIAG  StringFormatter::diag
-#define LCD   StringFormatter::lcd
-#define SCREEN  StringFormatter::lcd2
+#define DIAG StringFormatter::diag
+#define LCD StringFormatter::lcd
+#define SCREEN StringFormatter::lcd2
diff --git a/Display.cpp b/Display.cpp
index d581149..1915729 100644
--- a/Display.cpp
+++ b/Display.cpp
@@ -32 +32 @@
- *  5) On each entry into loop2(), a single operation is sent to the 
+ *  5) On each entry into loop2(), a single operation is sent to the
@@ -36,2 +36,2 @@
- *     not held up significantly.  The exception to this is when 
- *     the loop2() function is called with force=true, where 
+ *     not held up significantly.  The exception to this is when
+ *     the loop2() function is called with force=true, where
@@ -51 +51 @@
-Display::Display(DisplayDevice *deviceDriver) {
+Display::Display(DisplayDevice* deviceDriver) {
@@ -56,3 +56,2 @@ Display::Display(DisplayDevice *deviceDriver) {
-  for (uint8_t row = 0; row < MAX_CHARACTER_ROWS; row++) 
-    rowBuffer[row][0] = '\0';
-  
+  for (uint8_t row = 0; row < MAX_CHARACTER_ROWS; row++) rowBuffer[row][0] = '\0';
+
@@ -69,2 +68 @@ void Display::_clear() {
-  for (uint8_t row = 0; row < MAX_CHARACTER_ROWS; row++) 
-    rowBuffer[row][0] = '\0';
+  for (uint8_t row = 0; row < MAX_CHARACTER_ROWS; row++) rowBuffer[row][0] = '\0';
@@ -80 +78,2 @@ size_t Display::_write(uint8_t b) {
-  if (hotRow >= MAX_CHARACTER_ROWS || hotCol >= MAX_CHARACTER_COLS) return -1;
+  if (hotRow >= MAX_CHARACTER_ROWS || hotCol >= MAX_CHARACTER_COLS)
+    return -1;
@@ -98 +97,2 @@ void Display::_displayLoop() {
-  if (!_deviceDriver->isBusy()) loop2(false);
+  if (!_deviceDriver->isBusy())
+    loop2(false);
@@ -101 +101 @@ void Display::_displayLoop() {
-Display *Display::loop2(bool force) {
+Display* Display::loop2(bool force) {
@@ -121 +121,2 @@ Display *Display::loop2(bool force) {
-        if (!isCurrentRowBlank()) break;
+        if (!isCurrentRowBlank())
+          break;
@@ -123 +124,2 @@ Display *Display::loop2(bool force) {
-        if (rowCurrent == rowFirst) noMoreRowsToDisplay = true;  
+        if (rowCurrent == rowFirst)
+          noMoreRowsToDisplay = true;
@@ -131,2 +133 @@ Display *Display::loop2(bool force) {
-        for (uint8_t i = 0; i <= MAX_CHARACTER_COLS; i++)
-          buffer[i] = rowBuffer[rowCurrent][i];
+        for (uint8_t i = 0; i <= MAX_CHARACTER_COLS; i++) buffer[i] = rowBuffer[rowCurrent][i];
@@ -155,2 +156,3 @@ Display *Display::loop2(bool force) {
-          }  
-          if (!isCurrentRowBlank()) break;
+          }
+          if (!isCurrentRowBlank())
+            break;
@@ -162 +164 @@ Display *Display::loop2(bool force) {
-#if SCROLLMODE==0
+#if SCROLLMODE == 0
@@ -169 +171 @@ Display *Display::loop2(bool force) {
-#elif SCROLLMODE==1
+#elif SCROLLMODE == 1
@@ -172 +174 @@ Display *Display::loop2(bool force) {
-          if (noMoreRowsToDisplay) 
+          if (noMoreRowsToDisplay)
@@ -176 +178 @@ Display *Display::loop2(bool force) {
-          // then start one row further on next time.  If they do fit, then 
+          // then start one row further on next time.  If they do fit, then
@@ -207,2 +209,2 @@ void Display::moveToNextRow() {
-  if (++rowCurrent >= MAX_CHARACTER_ROWS) 
-      rowCurrent = 0;
+  if (++rowCurrent >= MAX_CHARACTER_ROWS)
+    rowCurrent = 0;
@@ -213 +215 @@ uint8_t Display::countNonBlankRows() {
-  for (uint8_t rowNumber=0; rowNumber<MAX_CHARACTER_ROWS; rowNumber++) {
+  for (uint8_t rowNumber = 0; rowNumber < MAX_CHARACTER_ROWS; rowNumber++) {
@@ -219 +220,0 @@ uint8_t Display::countNonBlankRows() {
-  
diff --git a/Display.h b/Display.h
index 467424f..1fbc22f 100644
--- a/Display.h
+++ b/Display.h
@@ -27 +27 @@
-#define MAX_MSG_SIZE 20 
+#define MAX_MSG_SIZE 20
@@ -31 +31 @@
-#if !defined(SCROLLMODE) 
+#if !defined(SCROLLMODE)
@@ -38,3 +38,3 @@ class Display : public DisplayInterface {
-public:
-  Display(DisplayDevice *deviceDriver);
-#if !defined (MAX_CHARACTER_ROWS)
+ public:
+  Display(DisplayDevice* deviceDriver);
+#if !defined(MAX_CHARACTER_ROWS)
@@ -46,2 +46,2 @@ public:
-private:
-  DisplayDevice *_deviceDriver;
+ private:
+  DisplayDevice* _deviceDriver;
@@ -62 +62 @@ private:
-  char rowBuffer[MAX_CHARACTER_ROWS][MAX_CHARACTER_COLS+1];
+  char rowBuffer[MAX_CHARACTER_ROWS][MAX_CHARACTER_COLS + 1];
@@ -64,2 +64,2 @@ private:
-public:
-  void begin() override;  
+ public:
+  void begin() override;
@@ -71 +71 @@ public:
-  Display *loop2(bool force);
+  Display* loop2(bool force);
@@ -76 +75,0 @@ public:
-
diff --git a/DisplayInterface.cpp b/DisplayInterface.cpp
index f2c144e..f3fecfd 100644
--- a/DisplayInterface.cpp
+++ b/DisplayInterface.cpp
@@ -25 +25 @@
-DisplayInterface *DisplayInterface::_displayHandler = new DisplayInterface();
+DisplayInterface* DisplayInterface::_displayHandler = new DisplayInterface();
diff --git a/DisplayInterface.h b/DisplayInterface.h
index c5d8e96..1ce5283 100644
--- a/DisplayInterface.h
+++ b/DisplayInterface.h
@@ -28,2 +28,2 @@ class DisplayInterface : public Print {
-protected:
-  static DisplayInterface *_displayHandler;
+ protected:
+  static DisplayInterface* _displayHandler;
@@ -31 +31 @@ protected:
-  DisplayInterface *_nextHandler = NULL;
+  DisplayInterface* _nextHandler = NULL;
@@ -34 +34 @@ protected:
-public:
+ public:
@@ -41 +41 @@ public:
-  static DisplayInterface *getDisplayHandler() {
+  static DisplayInterface* getDisplayHandler() {
@@ -50,3 +50,9 @@ public:
-  static void refresh() { refresh(0); };
-  static void setRow(uint8_t line) { setRow(0, line); };
-  static void clear() { clear(0); };
+  static void refresh() {
+    refresh(0);
+  };
+  static void setRow(uint8_t line) {
+    setRow(0, line);
+  };
+  static void clear() {
+    clear(0);
+  };
@@ -57 +63 @@ public:
-  static void setRow(uint8_t displayNo, uint8_t line) { 
+  static void setRow(uint8_t displayNo, uint8_t line) {
@@ -59,2 +65,3 @@ public:
-    for (DisplayInterface *p = _displayHandler; p!=0; p=p->_nextHandler) { 
-      if (displayNo == p->_displayNo) p->_setRow(line);
+    for (DisplayInterface* p = _displayHandler; p != 0; p = p->_nextHandler) {
+      if (displayNo == p->_displayNo)
+        p->_setRow(line);
@@ -63,3 +70,4 @@ public:
-  size_t write (uint8_t c) override {
-    for (DisplayInterface *p = _displayHandler; p!=0; p=p->_nextHandler) 
-      if (_selectedDisplayNo == p->_displayNo) p->_write(c);
+  size_t write(uint8_t c) override {
+    for (DisplayInterface* p = _displayHandler; p != 0; p = p->_nextHandler)
+      if (_selectedDisplayNo == p->_displayNo)
+        p->_write(c);
@@ -68,3 +76,4 @@ public:
-  static void clear(uint8_t displayNo) { 
-    for (DisplayInterface *p = _displayHandler; p!=0; p=p->_nextHandler) 
-      if (displayNo == p->_displayNo) p->_clear();
+  static void clear(uint8_t displayNo) {
+    for (DisplayInterface* p = _displayHandler; p != 0; p = p->_nextHandler)
+      if (displayNo == p->_displayNo)
+        p->_clear();
@@ -73,2 +82,3 @@ public:
-    for (DisplayInterface *p = _displayHandler; p!=0; p=p->_nextHandler)
-      if (displayNo == p->_displayNo) p->_refresh();
+    for (DisplayInterface* p = _displayHandler; p != 0; p = p->_nextHandler)
+      if (displayNo == p->_displayNo)
+        p->_refresh();
@@ -77,2 +87 @@ public:
-    for (DisplayInterface *p = _displayHandler; p!=0; p=p->_nextHandler) 
-      p->_displayLoop();
+    for (DisplayInterface* p = _displayHandler; p != 0; p = p->_nextHandler) p->_displayLoop();
@@ -82,5 +91,13 @@ public:
-  virtual size_t _write(uint8_t c) { (void)c; return 0; };
-  virtual void _setRow(uint8_t line) { (void)line; }
-  virtual void _clear() {}
-  virtual void _refresh() {}
-  virtual void _displayLoop() {}
+  virtual size_t _write(uint8_t c) {
+    (void)c;
+    return 0;
+  };
+  virtual void _setRow(uint8_t line) {
+    (void)line;
+  }
+  virtual void _clear() {
+  }
+  virtual void _refresh() {
+  }
+  virtual void _displayLoop() {
+  }
@@ -90,2 +107,4 @@ class DisplayDevice {
-public:
-  virtual bool begin() { return true; }
+ public:
+  virtual bool begin() {
+    return true;
+  }
diff --git a/Display_Implementation.h b/Display_Implementation.h
index 6a3c995..accd369 100644
--- a/Display_Implementation.h
+++ b/Display_Implementation.h
@@ -3 +3 @@
- *  
+ *
@@ -21 +21 @@
-// This implementation is designed to be #included ONLY ONCE in the .ino 
+// This implementation is designed to be #included ONLY ONCE in the .ino
@@ -33 +32,0 @@
-  
@@ -43,7 +42,8 @@
-  #define DISPLAY_START(xxx) { \
-    DisplayInterface *t = new Display(new SSD1306AsciiWire(OLED_DRIVER)); \
-    t->begin(); \
-    xxx; \
-    t->refresh(); \
-  } 
-  
+#define DISPLAY_START(xxx)                                                \
+  {                                                                       \
+    DisplayInterface* t = new Display(new SSD1306AsciiWire(OLED_DRIVER)); \
+    t->begin();                                                           \
+    xxx;                                                                  \
+    t->refresh();                                                         \
+  }
+
@@ -51,5 +51,7 @@
-  #define DISPLAY_START(xxx) { \
-    DisplayInterface *t = new Display(new LiquidCrystal_I2C(LCD_DRIVER)); \
-    t->begin(); \
-    xxx;  \
-    t->refresh();}
+#define DISPLAY_START(xxx)                                                \
+  {                                                                       \
+    DisplayInterface* t = new Display(new LiquidCrystal_I2C(LCD_DRIVER)); \
+    t->begin();                                                           \
+    xxx;                                                                  \
+    t->refresh();                                                         \
+  }
@@ -57,2 +59,3 @@
-  #define DISPLAY_START(xxx) { \
-  xxx; \
+#define DISPLAY_START(xxx) \
+  {                        \
+    xxx;                   \
@@ -62 +65 @@
-#endif // LCD_Implementation_h
+#endif  // LCD_Implementation_h
diff --git a/EEStore.cpp b/EEStore.cpp
index 57def0f..ea0cd95 100644
--- a/EEStore.cpp
+++ b/EEStore.cpp
@@ -44 +44 @@ void EEStore::init() {
-  eeStore = (EEStore *)calloc(1, sizeof(EEStore));
+  eeStore = (EEStore*)calloc(1, sizeof(EEStore));
@@ -49 +49 @@ void EEStore::init() {
-  if (strncmp(eeStore->data.id, EESTORE_ID, sizeof(EESTORE_ID)) != 0) {  
+  if (strncmp(eeStore->data.id, EESTORE_ID, sizeof(EESTORE_ID)) != 0) {
@@ -51,2 +51,2 @@ void EEStore::init() {
-    // turnouts, no sensors) and save it back to EEPROM  
-    strncpy(eeStore->data.id, EESTORE_ID, sizeof(EESTORE_ID)+0);  
+    // turnouts, no sensors) and save it back to EEPROM
+    strncpy(eeStore->data.id, EESTORE_ID, sizeof(EESTORE_ID) + 0);
@@ -90 +90,3 @@ void EEStore::store() {
-void EEStore::advance(int n) { eeAddress += n; }
+void EEStore::advance(int n) {
+  eeAddress += n;
+}
@@ -94 +96,3 @@ void EEStore::advance(int n) { eeAddress += n; }
-void EEStore::reset() { eeAddress = sizeof(EEStore); }
+void EEStore::reset() {
+  eeAddress = sizeof(EEStore);
+}
@@ -97 +101,3 @@ void EEStore::reset() { eeAddress = sizeof(EEStore); }
-int EEStore::pointer() { return (eeAddress); }
+int EEStore::pointer() {
+  return (eeAddress);
+}
@@ -110 +116 @@ void EEStore::dump(int num) {
-EEStore *EEStore::eeStore = NULL;
+EEStore* EEStore::eeStore = NULL;
diff --git a/EEStore.h b/EEStore.h
index 360cc9c..1d37a8c 100644
--- a/EEStore.h
+++ b/EEStore.h
@@ -7 +7 @@
- *  
+ *
@@ -38 +38 @@ extern ExternalEEPROM EEPROM;
-struct EEStoreData{
+struct EEStoreData {
@@ -45,2 +45,2 @@ struct EEStoreData{
-struct EEStore{
-  static EEStore *eeStore;
+struct EEStore {
+  static EEStore* eeStore;
@@ -59 +59 @@ struct EEStore{
-#endif // DISABLE_EEPROM
+#endif  // DISABLE_EEPROM
diff --git a/EXRAIL.h b/EXRAIL.h
index 2fc41d8..f02cbf9 100644
--- a/EXRAIL.h
+++ b/EXRAIL.h
@@ -4 +4 @@
- *  
+ *
@@ -25 +25,11 @@
- #include "EXRAIL2.h"
+#include "EXRAIL2.h"
+
+class RMFT {
+ public:
+  static void inline begin() {
+    RMFT2::begin();
+  }
+  static void inline loop() {
+    RMFT2::loop();
+  }
+};
@@ -27,5 +37 @@
-  class RMFT {
-    public:
-      static void inline begin() {RMFT2::begin();}
-      static void inline loop() {RMFT2::loop();}
-  };
+#include "EXRAILMacros.h"
@@ -33,9 +39,9 @@
-  #include "EXRAILMacros.h"
-  
-#else 
-  // Dummy RMFT 
-  class RMFT {
-    public:
-      static void inline begin() {}
-      static void inline loop() {}
-  };
+#else
+// Dummy RMFT
+class RMFT {
+ public:
+  static void inline begin() {
+  }
+  static void inline loop() {
+  }
+};
diff --git a/EXRAIL2.cpp b/EXRAIL2.cpp
index 3007440..28e7bc0 100644
--- a/EXRAIL2.cpp
+++ b/EXRAIL2.cpp
@@ -9 +9 @@
- *  
+ *
@@ -28 +28 @@
-   F2. [DONE] ONAccessory catchers 
+   F2. [DONE] ONAccessory catchers
@@ -39 +39 @@
-   F13. [DONE] IFGTE/IFLT function  
+   F13. [DONE] IFGTE/IFLT function
@@ -61 +60,0 @@
-
@@ -66,8 +65,8 @@
-// Statics 
-const int16_t LOCO_ID_WAITING=-99; // waiting for loco id from prog track
-int16_t RMFT2::progtrackLocoId;  // used for callback when detecting a loco on prog track
-bool RMFT2::diag=false;      // <D EXRAIL ON>  
-RMFT2 * RMFT2::loopTask=NULL; // loopTask contains the address of ONE of the tasks in a ring.
-RMFT2 * RMFT2::pausingTask=NULL; // Task causing a PAUSE.
- // when pausingTask is set, that is the ONLY task that gets any service,
- // and all others will have their locos stopped, then resumed after the pausing task resumes.
+// Statics
+const int16_t LOCO_ID_WAITING = -99;  // waiting for loco id from prog track
+int16_t RMFT2::progtrackLocoId;       // used for callback when detecting a loco on prog track
+bool RMFT2::diag = false;             // <D EXRAIL ON>
+RMFT2* RMFT2::loopTask = NULL;        // loopTask contains the address of ONE of the tasks in a ring.
+RMFT2* RMFT2::pausingTask = NULL;     // Task causing a PAUSE.
+                                      // when pausingTask is set, that is the ONLY task that gets any service,
+                                      // and all others will have their locos stopped, then resumed after the pausing task resumes.
@@ -75,12 +74,12 @@ byte RMFT2::flags[MAX_FLAGS];
-Print * RMFT2::LCCSerial=0;
-LookList *  RMFT2::routeLookup=NULL;
-LookList *  RMFT2::signalLookup=NULL;
-LookList *  RMFT2::onThrowLookup=NULL;
-LookList *  RMFT2::onCloseLookup=NULL;
-LookList *  RMFT2::onActivateLookup=NULL;
-LookList *  RMFT2::onDeactivateLookup=NULL;
-LookList *  RMFT2::onRedLookup=NULL;
-LookList *  RMFT2::onAmberLookup=NULL;
-LookList *  RMFT2::onGreenLookup=NULL;
-LookList *  RMFT2::onChangeLookup=NULL;
-LookList *  RMFT2::onClockLookup=NULL;
+Print* RMFT2::LCCSerial = 0;
+LookList* RMFT2::routeLookup = NULL;
+LookList* RMFT2::signalLookup = NULL;
+LookList* RMFT2::onThrowLookup = NULL;
+LookList* RMFT2::onCloseLookup = NULL;
+LookList* RMFT2::onActivateLookup = NULL;
+LookList* RMFT2::onDeactivateLookup = NULL;
+LookList* RMFT2::onRedLookup = NULL;
+LookList* RMFT2::onAmberLookup = NULL;
+LookList* RMFT2::onGreenLookup = NULL;
+LookList* RMFT2::onChangeLookup = NULL;
+LookList* RMFT2::onClockLookup = NULL;
@@ -88 +87 @@ LookList *  RMFT2::onClockLookup=NULL;
-LookList *  RMFT2::onRotateLookup=NULL;
+LookList* RMFT2::onRotateLookup = NULL;
@@ -90,5 +89,5 @@ LookList *  RMFT2::onRotateLookup=NULL;
-LookList *  RMFT2::onOverloadLookup=NULL;
-byte * RMFT2::routeStateArray=nullptr; 
-const FSH  * * RMFT2::routeCaptionArray=nullptr; 
-int16_t * RMFT2::stashArray=nullptr;
-int16_t RMFT2::maxStashId=0;
+LookList* RMFT2::onOverloadLookup = NULL;
+byte* RMFT2::routeStateArray = nullptr;
+const FSH** RMFT2::routeCaptionArray = nullptr;
+int16_t* RMFT2::stashArray = nullptr;
+int16_t RMFT2::maxStashId = 0;
@@ -98 +97 @@ uint16_t RMFT2::getOperand(byte n) {
-  return getOperand(progCounter,n);
+  return getOperand(progCounter, n);
@@ -102,5 +101,5 @@ uint16_t RMFT2::getOperand(byte n) {
-uint16_t RMFT2::getOperand(int progCounter,byte n) {
-  int offset=progCounter+1+(n*3);
-  byte lsb=GETHIGHFLASH(RouteCode,offset);
-  byte msb=GETHIGHFLASH(RouteCode,offset+1);
-  return msb<<8|lsb;
+uint16_t RMFT2::getOperand(int progCounter, byte n) {
+  int offset = progCounter + 1 + (n * 3);
+  byte lsb = GETHIGHFLASH(RouteCode, offset);
+  byte msb = GETHIGHFLASH(RouteCode, offset + 1);
+  return msb << 8 | lsb;
@@ -110,3 +109,3 @@ LookList::LookList(int16_t size) {
-  m_size=size;
-  m_loaded=0;
-  m_chain=nullptr;
+  m_size = size;
+  m_loaded = 0;
+  m_chain = nullptr;
@@ -114,2 +113,2 @@ LookList::LookList(int16_t size) {
-    m_lookupArray=new int16_t[size];
-    m_resultArray=new int16_t[size];
+    m_lookupArray = new int16_t[size];
+    m_resultArray = new int16_t[size];
@@ -120,3 +119,4 @@ void LookList::add(int16_t lookup, int16_t result) {
-  if (m_loaded==m_size) return; // and forget
-  m_lookupArray[m_loaded]=lookup;
-  m_resultArray[m_loaded]=result;
+  if (m_loaded == m_size)
+    return;  // and forget
+  m_lookupArray[m_loaded] = lookup;
+  m_resultArray[m_loaded] = result;
@@ -127,2 +127,3 @@ int16_t LookList::find(int16_t value) {
-  for (int16_t i=0;i<m_size;i++) {
-    if (m_lookupArray[i]==value) return m_resultArray[i];
+  for (int16_t i = 0; i < m_size; i++) {
+    if (m_lookupArray[i] == value)
+      return m_resultArray[i];
@@ -130 +131 @@ int16_t LookList::find(int16_t value) {
-  return m_chain ?  m_chain->find(value)  :-1;
+  return m_chain ? m_chain->find(value) : -1;
@@ -132,2 +133,2 @@ int16_t LookList::find(int16_t value) {
-void LookList::chain(LookList * chain) {
-  m_chain=chain;
+void LookList::chain(LookList* chain) {
+  m_chain = chain;
@@ -135 +136 @@ void LookList::chain(LookList * chain) {
-void LookList::handleEvent(const FSH* reason,int16_t id) {
+void LookList::handleEvent(const FSH* reason, int16_t id) {
@@ -137,3 +138,3 @@ void LookList::handleEvent(const FSH* reason,int16_t id) {
-  for (int i=0;i<m_size;i++) 
-    if (m_lookupArray[i]==id)
-       RMFT2::startNonRecursiveTask(reason,id,m_resultArray[i]);
+  for (int i = 0; i < m_size; i++)
+    if (m_lookupArray[i] == id)
+      RMFT2::startNonRecursiveTask(reason, id, m_resultArray[i]);
@@ -142,3 +143,2 @@ void LookList::handleEvent(const FSH* reason,int16_t id) {
-
-void LookList::stream(Print * _stream) {
-  for (int16_t i=0;i<m_size;i++) {
+void LookList::stream(Print* _stream) {
+  for (int16_t i = 0; i < m_size; i++) {
@@ -151,2 +151,3 @@ int16_t LookList::findPosition(int16_t value) {
-  for (int16_t i=0;i<m_size;i++) {
-    if (m_lookupArray[i]==value) return i;
+  for (int16_t i = 0; i < m_size; i++) {
+    if (m_lookupArray[i] == value)
+      return i;
@@ -157 +158 @@ int16_t LookList::size() {
-   return m_size;
+  return m_size;
@@ -162 +163 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-  int16_t count=0;
+  int16_t count = 0;
@@ -164,4 +165,6 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-  for (progCounter=0;; SKIPOP) {
-    byte opcode=GET_OPCODE;
-    if (opcode==OPCODE_ENDEXRAIL) break;
-    if (opcode==op1 || opcode==op2 || opcode==op3) count++;
+  for (progCounter = 0;; SKIPOP) {
+    byte opcode = GET_OPCODE;
+    if (opcode == OPCODE_ENDEXRAIL)
+      break;
+    if (opcode == op1 || opcode == op2 || opcode == op3)
+      count++;
@@ -169,8 +172,11 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-  // create list 
-  LookList* list=new LookList(count);
-  if (count==0) return list;
-
-  for (progCounter=0;; SKIPOP) {
-    byte opcode=GET_OPCODE;
-    if (opcode==OPCODE_ENDEXRAIL) break;
-    if (opcode==op1 || opcode==op2 || opcode==op3)  list->add(getOperand(progCounter,0),progCounter);   
+  // create list
+  LookList* list = new LookList(count);
+  if (count == 0)
+    return list;
+
+  for (progCounter = 0;; SKIPOP) {
+    byte opcode = GET_OPCODE;
+    if (opcode == OPCODE_ENDEXRAIL)
+      break;
+    if (opcode == op1 || opcode == op2 || opcode == op3)
+      list->add(getOperand(progCounter, 0), progCounter);
@@ -181,0 +188 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
+  // DIAG(F("EXRAIL RoutCode at =%P"),RouteCode);
@@ -183,4 +190,2 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-  //DIAG(F("EXRAIL RoutCode at =%P"),RouteCode);
-    
-  bool saved_diag=diag;
-  diag=true;
+  bool saved_diag = diag;
+  diag = true;
@@ -188,2 +193,2 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-  for (int f=0;f<MAX_FLAGS;f++) flags[f]=0;
-  
+  for (int f = 0; f < MAX_FLAGS; f++) flags[f] = 0;
+
@@ -191 +196 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-  routeLookup=LookListLoader(OPCODE_ROUTE, OPCODE_AUTOMATION);
+  routeLookup = LookListLoader(OPCODE_ROUTE, OPCODE_AUTOMATION);
@@ -194,2 +199,2 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-    routeStateArray=(byte *)calloc(routeLookup->size(),sizeof(byte));
-    routeCaptionArray=(const FSH * *)calloc(routeLookup->size(),sizeof(const FSH *));
+    routeStateArray = (byte*)calloc(routeLookup->size(), sizeof(byte));
+    routeCaptionArray = (const FSH**)calloc(routeLookup->size(), sizeof(const FSH*));
@@ -197,6 +202,6 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-  onThrowLookup=LookListLoader(OPCODE_ONTHROW);
-  onCloseLookup=LookListLoader(OPCODE_ONCLOSE);
-  onActivateLookup=LookListLoader(OPCODE_ONACTIVATE);
-  onDeactivateLookup=LookListLoader(OPCODE_ONDEACTIVATE);
-  onChangeLookup=LookListLoader(OPCODE_ONCHANGE);
-  onClockLookup=LookListLoader(OPCODE_ONTIME);
+  onThrowLookup = LookListLoader(OPCODE_ONTHROW);
+  onCloseLookup = LookListLoader(OPCODE_ONCLOSE);
+  onActivateLookup = LookListLoader(OPCODE_ONACTIVATE);
+  onDeactivateLookup = LookListLoader(OPCODE_ONDEACTIVATE);
+  onChangeLookup = LookListLoader(OPCODE_ONCHANGE);
+  onClockLookup = LookListLoader(OPCODE_ONTIME);
@@ -204 +209 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-  onRotateLookup=LookListLoader(OPCODE_ONROTATE);
+  onRotateLookup = LookListLoader(OPCODE_ONROTATE);
@@ -206,2 +211,2 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-  onOverloadLookup=LookListLoader(OPCODE_ONOVERLOAD);
-  // onLCCLookup is not the same so not loaded here. 
+  onOverloadLookup = LookListLoader(OPCODE_ONOVERLOAD);
+  // onLCCLookup is not the same so not loaded here.
@@ -212,4 +217,3 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-    
-    onRedLookup=LookListLoader(OPCODE_ONRED);
-    onAmberLookup=LookListLoader(OPCODE_ONAMBER);
-    onGreenLookup=LookListLoader(OPCODE_ONGREEN);
+    onRedLookup = LookListLoader(OPCODE_ONRED);
+    onAmberLookup = LookListLoader(OPCODE_ONAMBER);
+    onGreenLookup = LookListLoader(OPCODE_ONGREEN);
@@ -217,35 +221,9 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-    int signalCount=0; 
-    for (int16_t slot=0;;slot++) {
-        SIGNAL_DEFINITION signal=getSignalSlot(slot);
-        DIAG(F("Signal s=%d id=%d t=%d"),slot,signal.id,signal.type);
-        if (signal.type==sigtypeNoMoreSignals) break;
-        if (signal.type==sigtypeContinuation) continue;
-        signalCount++;
-    }    
-    signalLookup=new LookList(signalCount);
-    for (int16_t slot=0;;slot++) {
-        SIGNAL_DEFINITION signal=getSignalSlot(slot);
-        if (signal.type==sigtypeNoMoreSignals) break;
-        if (signal.type==sigtypeContinuation) continue;
-        signalLookup->add(signal.id,slot);
-        doSignal(signal.id, SIGNAL_RED);
-    }    
-   }
-
-  int progCounter;
-  for (progCounter=0;; SKIPOP){
-    byte opcode=GET_OPCODE;
-    if (opcode==OPCODE_ENDEXRAIL) break;
-    VPIN operand=getOperand(progCounter,0);
-    
-    switch (opcode) {
-    case OPCODE_AT:
-    case OPCODE_ATTIMEOUT2:
-    case OPCODE_AFTER:
-    case OPCODE_IF:
-    case OPCODE_IFNOT: {
-      int16_t pin = (int16_t)operand;
-      if (pin<0) pin = -pin;
-      DIAG(F("EXRAIL input VPIN %u"),pin);
-      IODevice::configureInput((VPIN)pin,true);
-      break;
+    int signalCount = 0;
+    for (int16_t slot = 0;; slot++) {
+      SIGNAL_DEFINITION signal = getSignalSlot(slot);
+      DIAG(F("Signal s=%d id=%d t=%d"), slot, signal.id, signal.type);
+      if (signal.type == sigtypeNoMoreSignals)
+        break;
+      if (signal.type == sigtypeContinuation)
+        continue;
+      signalCount++;
@@ -253,5 +231,9 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-    case OPCODE_STASH:
-    case OPCODE_CLEAR_STASH:
-    case OPCODE_PICKUP_STASH: {
-      maxStashId=max(maxStashId,((int16_t)operand));
-      break;
+    signalLookup = new LookList(signalCount);
+    for (int16_t slot = 0;; slot++) {
+      SIGNAL_DEFINITION signal = getSignalSlot(slot);
+      if (signal.type == sigtypeNoMoreSignals)
+        break;
+      if (signal.type == sigtypeContinuation)
+        continue;
+      signalLookup->add(signal.id, slot);
+      doSignal(signal.id, SIGNAL_RED);
@@ -258,0 +241 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
+  }
@@ -260,7 +243,4 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-    case OPCODE_ATGTE:
-    case OPCODE_ATLT:
-    case OPCODE_IFGTE:
-    case OPCODE_IFLT:
-    case OPCODE_DRIVE: {
-      DIAG(F("EXRAIL analog input VPIN %u"),(VPIN)operand);
-      IODevice::configureAnalogIn((VPIN)operand);
+  int progCounter;
+  for (progCounter = 0;; SKIPOP) {
+    byte opcode = GET_OPCODE;
+    if (opcode == OPCODE_ENDEXRAIL)
@@ -268 +248 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-    }
+    VPIN operand = getOperand(progCounter, 0);
@@ -270,15 +250,19 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-    case OPCODE_ONSENSOR:
-      if (compileFeatures & FEATURE_SENSOR) 
-        new EXRAILSensor(operand,progCounter+3,true );
-      break;
-    case OPCODE_ONBUTTON:
-      if (compileFeatures & FEATURE_SENSOR) 
-        new EXRAILSensor(operand,progCounter+3,false );
-      break;
-    case OPCODE_TURNOUT: {
-      VPIN id=operand;
-      int addr=getOperand(progCounter,1);
-      byte subAddr=getOperand(progCounter,2);
-      setTurnoutHiddenState(DCCTurnout::create(id,addr,subAddr));
-      break;
-    }
+    switch (opcode) {
+      case OPCODE_AT:
+      case OPCODE_ATTIMEOUT2:
+      case OPCODE_AFTER:
+      case OPCODE_IF:
+      case OPCODE_IFNOT: {
+        int16_t pin = (int16_t)operand;
+        if (pin < 0)
+          pin = -pin;
+        DIAG(F("EXRAIL input VPIN %u"), pin);
+        IODevice::configureInput((VPIN)pin, true);
+        break;
+      }
+      case OPCODE_STASH:
+      case OPCODE_CLEAR_STASH:
+      case OPCODE_PICKUP_STASH: {
+        maxStashId = max(maxStashId, ((int16_t)operand));
+        break;
+      }
@@ -286,9 +270,9 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-    case OPCODE_SERVOTURNOUT: {
-      VPIN id=operand;
-      VPIN pin=getOperand(progCounter,1);
-      int activeAngle=getOperand(progCounter,2);
-      int inactiveAngle=getOperand(progCounter,3);
-      int profile=getOperand(progCounter,4);
-      setTurnoutHiddenState(ServoTurnout::create(id,pin,activeAngle,inactiveAngle,profile));
-      break;
-    }
+      case OPCODE_ATGTE:
+      case OPCODE_ATLT:
+      case OPCODE_IFGTE:
+      case OPCODE_IFLT:
+      case OPCODE_DRIVE: {
+        DIAG(F("EXRAIL analog input VPIN %u"), (VPIN)operand);
+        IODevice::configureAnalogIn((VPIN)operand);
+        break;
+      }
@@ -296,6 +280,32 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-    case OPCODE_PINTURNOUT: {
-      VPIN id=operand;
-      VPIN pin=getOperand(progCounter,1);
-      setTurnoutHiddenState(VpinTurnout::create(id,pin));
-      break;
-    }
+      case OPCODE_ONSENSOR:
+        if (compileFeatures & FEATURE_SENSOR)
+          new EXRAILSensor(operand, progCounter + 3, true);
+        break;
+      case OPCODE_ONBUTTON:
+        if (compileFeatures & FEATURE_SENSOR)
+          new EXRAILSensor(operand, progCounter + 3, false);
+        break;
+      case OPCODE_TURNOUT: {
+        VPIN id = operand;
+        int addr = getOperand(progCounter, 1);
+        byte subAddr = getOperand(progCounter, 2);
+        setTurnoutHiddenState(DCCTurnout::create(id, addr, subAddr));
+        break;
+      }
+
+      case OPCODE_SERVOTURNOUT: {
+        VPIN id = operand;
+        VPIN pin = getOperand(progCounter, 1);
+        int activeAngle = getOperand(progCounter, 2);
+        int inactiveAngle = getOperand(progCounter, 3);
+        int profile = getOperand(progCounter, 4);
+        setTurnoutHiddenState(ServoTurnout::create(id, pin, activeAngle, inactiveAngle, profile));
+        break;
+      }
+
+      case OPCODE_PINTURNOUT: {
+        VPIN id = operand;
+        VPIN pin = getOperand(progCounter, 1);
+        setTurnoutHiddenState(VpinTurnout::create(id, pin));
+        break;
+      }
@@ -304,8 +314,8 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-    case OPCODE_DCCTURNTABLE: {
-      VPIN id=operand;
-      int home=getOperand(progCounter,1);
-      setTurntableHiddenState(DCCTurntable::create(id));
-      Turntable *tto=Turntable::get(id);
-      tto->addPosition(0,0,home);
-      break;
-    }
+      case OPCODE_DCCTURNTABLE: {
+        VPIN id = operand;
+        int home = getOperand(progCounter, 1);
+        setTurntableHiddenState(DCCTurntable::create(id));
+        Turntable* tto = Turntable::get(id);
+        tto->addPosition(0, 0, home);
+        break;
+      }
@@ -313,9 +323,9 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-    case OPCODE_EXTTTURNTABLE: {
-      VPIN id=operand;
-      VPIN pin=getOperand(progCounter,1);
-      int home=getOperand(progCounter,2);
-      setTurntableHiddenState(EXTTTurntable::create(id,pin));
-      Turntable *tto=Turntable::get(id);
-      tto->addPosition(0,0,home);
-      break;
-    }
+      case OPCODE_EXTTTURNTABLE: {
+        VPIN id = operand;
+        VPIN pin = getOperand(progCounter, 1);
+        int home = getOperand(progCounter, 2);
+        setTurntableHiddenState(EXTTTurntable::create(id, pin));
+        Turntable* tto = Turntable::get(id);
+        tto->addPosition(0, 0, home);
+        break;
+      }
@@ -323,9 +333,9 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-    case OPCODE_TTADDPOSITION: {
-      VPIN id=operand;
-      int position=getOperand(progCounter,1);
-      int value=getOperand(progCounter,2);
-      int angle=getOperand(progCounter,3);
-      Turntable *tto=Turntable::get(id);
-      tto->addPosition(position,value,angle);
-      break;
-    }
+      case OPCODE_TTADDPOSITION: {
+        VPIN id = operand;
+        int position = getOperand(progCounter, 1);
+        int value = getOperand(progCounter, 2);
+        int angle = getOperand(progCounter, 3);
+        Turntable* tto = Turntable::get(id);
+        tto->addPosition(position, value, angle);
+        break;
+      }
@@ -334,9 +344,9 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-    case OPCODE_AUTOSTART:
-      // automatically create a task from here at startup.
-      // Removed if (progCounter>0) check 4.2.31 because 
-      // default start it top of file is now removed. .   
-      new RMFT2(progCounter);
-      break;
-      
-    default: // Ignore
-      break;
+      case OPCODE_AUTOSTART:
+        // automatically create a task from here at startup.
+        // Removed if (progCounter>0) check 4.2.31 because
+        // default start it top of file is now removed. .
+        new RMFT2(progCounter);
+        break;
+
+      default:  // Ignore
+        break;
@@ -345,2 +355,2 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-  SKIPOP; // include ENDROUTES opcode
-  
+  SKIPOP;  // include ENDROUTES opcode
+
@@ -349,2 +359,3 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-    if (maxStashId>0) stashArray=(int16_t*)calloc(maxStashId+1, sizeof(int16_t));
-     //TODO check EEPROM and fetch stashArray
+    if (maxStashId > 0)
+      stashArray = (int16_t*)calloc(maxStashId + 1, sizeof(int16_t));
+    // TODO check EEPROM and fetch stashArray
@@ -352,2 +363,2 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-  
-  DIAG(F("EXRAIL %db, fl=%d, stash=%d"),progCounter,MAX_FLAGS, maxStashId);
+
+  DIAG(F("EXRAIL %db, fl=%d, stash=%d"), progCounter, MAX_FLAGS, maxStashId);
@@ -356 +367 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-  diag=saved_diag;
+  diag = saved_diag;
@@ -359 +370 @@ LookList* RMFT2::LookListLoader(OPCODE op1, OPCODE op2, OPCODE op3) {
-void RMFT2::setTurnoutHiddenState(Turnout * t) {
+void RMFT2::setTurnoutHiddenState(Turnout* t) {
@@ -361,2 +372,3 @@ void RMFT2::setTurnoutHiddenState(Turnout * t) {
-  const FSH *desc = getTurnoutDescription(t->getId());
-  if (desc) t->setHidden(GETFLASH(desc)==0x01);
+  const FSH* desc = getTurnoutDescription(t->getId());
+  if (desc)
+    t->setHidden(GETFLASH(desc) == 0x01);
@@ -366,3 +378,4 @@ void RMFT2::setTurnoutHiddenState(Turnout * t) {
-void RMFT2::setTurntableHiddenState(Turntable * tto) {
-  const FSH *desc = getTurntableDescription(tto->getId());
-  if (desc) tto->setHidden(GETFLASH(desc)==0x01);
+void RMFT2::setTurntableHiddenState(Turntable* tto) {
+  const FSH* desc = getTurntableDescription(tto->getId());
+  if (desc)
+    tto->setHidden(GETFLASH(desc) == 0x01);
@@ -373,5 +386,7 @@ char RMFT2::getRouteType(int16_t id) {
-  int16_t progCounter=routeLookup->find(id);
-  if (progCounter>=0) {
-    byte type=GET_OPCODE; 
-    if (type==OPCODE_ROUTE) return 'R';
-    if (type==OPCODE_AUTOMATION) return 'A';
+  int16_t progCounter = routeLookup->find(id);
+  if (progCounter >= 0) {
+    byte type = GET_OPCODE;
+    if (type == OPCODE_ROUTE)
+      return 'R';
+    if (type == OPCODE_AUTOMATION)
+      return 'A';
@@ -382 +396,0 @@ char RMFT2::getRouteType(int16_t id) {
-
@@ -384 +398 @@ RMFT2::RMFT2(int progCtr) {
-  progCounter=progCtr;
+  progCounter = progCtr;
@@ -387,4 +401,4 @@ RMFT2::RMFT2(int progCtr) {
-  taskId=255; // in case of overflow
-  for (int f=0;f<MAX_FLAGS;f++) {
-    if (!getFlag(f,TASK_FLAG)) {
-      taskId=f;
+  taskId = 255;  // in case of overflow
+  for (int f = 0; f < MAX_FLAGS; f++) {
+    if (!getFlag(f, TASK_FLAG)) {
+      taskId = f;
@@ -395,8 +409,8 @@ RMFT2::RMFT2(int progCtr) {
-  delayTime=0;
-  loco=0;
-  speedo=0;
-  forward=true;
-  invert=false;
-  blinkState=not_blink_task;
-  stackDepth=0;
-  onEventStartPosition=-1; // Not handling an ONxxx 
+  delayTime = 0;
+  loco = 0;
+  speedo = 0;
+  forward = true;
+  invert = false;
+  blinkState = not_blink_task;
+  stackDepth = 0;
+  onEventStartPosition = -1;  // Not handling an ONxxx
@@ -405,3 +419,3 @@ RMFT2::RMFT2(int progCtr) {
-  if (loopTask==NULL) {
-    loopTask=this;
-    next=this;
+  if (loopTask == NULL) {
+    loopTask = this;
+    next = this;
@@ -409,2 +423,2 @@ RMFT2::RMFT2(int progCtr) {
-    next=loopTask->next;
-    loopTask->next=this;
+    next = loopTask->next;
+    loopTask->next = this;
@@ -414 +427,0 @@ RMFT2::RMFT2(int progCtr) {
-
@@ -416,4 +429,4 @@ RMFT2::~RMFT2() {
-  driveLoco(1); // ESTOP my loco if any
-  setFlag(taskId,0,TASK_FLAG); // we are no longer using this id
-  if (next==this)
-    loopTask=NULL;
+  driveLoco(1);                   // ESTOP my loco if any
+  setFlag(taskId, 0, TASK_FLAG);  // we are no longer using this id
+  if (next == this)
+    loopTask = NULL;
@@ -421 +434 @@ RMFT2::~RMFT2() {
-    for (RMFT2* ring=next;;ring=ring->next)
+    for (RMFT2* ring = next;; ring = ring->next)
@@ -423,3 +436,3 @@ RMFT2::~RMFT2() {
-	ring->next=next;
-	loopTask=next;
-	break;
+        ring->next = next;
+        loopTask = next;
+        break;
@@ -430,4 +443,5 @@ void RMFT2::createNewTask(int route, uint16_t cab) {
-      int pc=routeLookup->find(route);
-      if (pc<0) return;
-      RMFT2* task=new RMFT2(pc);
-      task->loco=cab;
+  int pc = routeLookup->find(route);
+  if (pc < 0)
+    return;
+  RMFT2* task = new RMFT2(pc);
+  task->loco = cab;
@@ -437,8 +451,9 @@ void RMFT2::driveLoco(byte speed) {
-  if (loco<=0) return;  // Prevent broadcast!
-  //if (diag) DIAG(F("EXRAIL drive %d %d %d"),loco,speed,forward^invert);
- /* TODO.....
- power on appropriate track if DC or main if dcc
-  if (TrackManager::getMainPowerMode()==POWERMODE::OFF) {
-    TrackManager::setMainPower(POWERMODE::ON);
-  }
-  **********/
+  if (loco <= 0)
+    return;  // Prevent broadcast!
+  // if (diag) DIAG(F("EXRAIL drive %d %d %d"),loco,speed,forward^invert);
+  /* TODO.....
+  power on appropriate track if DC or main if dcc
+   if (TrackManager::getMainPowerMode()==POWERMODE::OFF) {
+     TrackManager::setMainPower(POWERMODE::ON);
+   }
+   **********/
@@ -446,2 +461,2 @@ void RMFT2::driveLoco(byte speed) {
-  DCC::setThrottle(loco,speed, forward^invert);
-  speedo=speed;
+  DCC::setThrottle(loco, speed, forward ^ invert);
+  speedo = speed;
@@ -452 +467,5 @@ bool RMFT2::readSensor(uint16_t sensorId) {
-  int16_t sId=(int16_t) sensorId;
+  int16_t sId = (int16_t)sensorId;
+
+  VPIN vpin = abs(sId);
+  if (getFlag(vpin, LATCH_FLAG))
+    return true;  // latched on
@@ -454,3 +472,0 @@ bool RMFT2::readSensor(uint16_t sensorId) {
-  VPIN vpin=abs(sId);
-  if (getFlag(vpin,LATCH_FLAG)) return true; // latched on
-  
@@ -458,2 +474,3 @@ bool RMFT2::readSensor(uint16_t sensorId) {
-  bool s= IODevice::read(vpin) ^ (sId<0);
-  if (s && diag) DIAG(F("EXRAIL Sensor %d hit"),sId);
+  bool s = IODevice::read(vpin) ^ (sId < 0);
+  if (s && diag)
+    DIAG(F("EXRAIL Sensor %d hit"), sId);
@@ -469 +486 @@ bool RMFT2::skipIfBlock() {
-    byte opcode =  GET_OPCODE;
+    byte opcode = GET_OPCODE;
@@ -471,17 +488,20 @@ bool RMFT2::skipIfBlock() {
-    if (opcode>IF_TYPE_OPCODES) nest++;
-    else switch(opcode) {
-      case OPCODE_ENDEXRAIL:
-        kill(F("missing ENDIF"), nest);
-        return false;
-    
-      case OPCODE_ENDIF:
-        nest--;
-        break;
-    
-      case OPCODE_ELSE:
-        // if nest==1 then this is the ELSE for the IF we are skipping
-        if (nest==1) nest=0; // cause loop exit and return after ELSE
-        break;
-    default:
-      break;
-    }
+    if (opcode > IF_TYPE_OPCODES)
+      nest++;
+    else
+      switch (opcode) {
+        case OPCODE_ENDEXRAIL:
+          kill(F("missing ENDIF"), nest);
+          return false;
+
+        case OPCODE_ENDIF:
+          nest--;
+          break;
+
+        case OPCODE_ELSE:
+          // if nest==1 then this is the ELSE for the IF we are skipping
+          if (nest == 1)
+            nest = 0;  // cause loop exit and return after ELSE
+          break;
+        default:
+          break;
+      }
@@ -492,2 +511,0 @@ bool RMFT2::skipIfBlock() {
-
-
@@ -500,3 +518,3 @@ bool RMFT2::skipIfBlock() {
-  if (cv & LONG_ADDR_MARKER) {               // maker bit indicates long addr
-    progtrackLocoId = cv ^ LONG_ADDR_MARKER; // remove marker bit to get real long addr
-    if (progtrackLocoId <= HIGHEST_SHORT_ADDR ) {     // out of range for long addr
+  if (cv & LONG_ADDR_MARKER) {                    // maker bit indicates long addr
+    progtrackLocoId = cv ^ LONG_ADDR_MARKER;      // remove marker bit to get real long addr
+    if (progtrackLocoId <= HIGHEST_SHORT_ADDR) {  // out of range for long addr
@@ -507 +525 @@ bool RMFT2::skipIfBlock() {
-    progtrackLocoId=cv;
+    progtrackLocoId = cv;
@@ -512,2 +530,2 @@ void RMFT2::loop() {
-  if (compileFeatures & FEATURE_SENSOR) 
-      EXRAILSensor::checkAll();
+  if (compileFeatures & FEATURE_SENSOR)
+    EXRAILSensor::checkAll();
@@ -516,3 +534,5 @@ void RMFT2::loop() {
-  if (loopTask==NULL) return;
-  loopTask=loopTask->next;
-  if (pausingTask==NULL || pausingTask==loopTask) loopTask->loop2();
+  if (loopTask == NULL)
+    return;
+  loopTask = loopTask->next;
+  if (pausingTask == NULL || pausingTask == loopTask)
+    loopTask->loop2();
@@ -521 +540,0 @@ void RMFT2::loop() {
-
@@ -523 +542,2 @@ void RMFT2::loop2() {
-  if (delayTime!=0 && millis()-delayStart < delayTime) return;
+  if (delayTime != 0 && millis() - delayStart < delayTime)
+    return;
@@ -526,4 +546,4 @@ void RMFT2::loop2() {
-  if (compileFeatures & FEATURE_BLINK) { 
-    if (blinkState==blink_low) {
-      IODevice::write(blinkPin,HIGH);
-      blinkState=blink_high;
+  if (compileFeatures & FEATURE_BLINK) {
+    if (blinkState == blink_low) {
+      IODevice::write(blinkPin, HIGH);
+      blinkState = blink_high;
@@ -533,3 +553,3 @@ void RMFT2::loop2() {
-    if (blinkState==blink_high) {
-      IODevice::write(blinkPin,LOW);
-      blinkState=blink_low;
+    if (blinkState == blink_high) {
+      IODevice::write(blinkPin, LOW);
+      blinkState = blink_low;
@@ -540 +560 @@ void RMFT2::loop2() {
-  
+
@@ -543 +563 @@ void RMFT2::loop2() {
-  int16_t operand =  getOperand(0);
+  int16_t operand = getOperand(0);
@@ -545,2 +565,2 @@ void RMFT2::loop2() {
-  // skipIf will get set to indicate a failing IF condition 
-  bool skipIf=false; 
+  // skipIf will get set to indicate a failing IF condition
+  bool skipIf = false;
@@ -552,0 +573,3 @@ void RMFT2::loop2() {
+    case OPCODE_THROW:
+      Turnout::setClosed(operand, false);
+      break;
@@ -554,7 +577,3 @@ void RMFT2::loop2() {
-  case OPCODE_THROW:
-    Turnout::setClosed(operand, false);
-    break;
-    
-  case OPCODE_CLOSE:
-    Turnout::setClosed(operand, true);
-    break;
+    case OPCODE_CLOSE:
+      Turnout::setClosed(operand, true);
+      break;
@@ -562,3 +581,3 @@ void RMFT2::loop2() {
-  case OPCODE_TOGGLE_TURNOUT:
-    Turnout::setClosed(operand, Turnout::isThrown(operand));
-    break;
+    case OPCODE_TOGGLE_TURNOUT:
+      Turnout::setClosed(operand, Turnout::isThrown(operand));
+      break;
@@ -567,5 +586,5 @@ void RMFT2::loop2() {
-  case OPCODE_ROTATE:
-    uint8_t activity;
-    activity=getOperand(2);
-    Turntable::setPosition(operand,getOperand(1),activity);
-    break;
+    case OPCODE_ROTATE:
+      uint8_t activity;
+      activity = getOperand(2);
+      Turntable::setPosition(operand, getOperand(1), activity);
+      break;
@@ -574,6 +593,6 @@ void RMFT2::loop2() {
-  case OPCODE_REV:
-    forward = false;
-    driveLoco(operand);
-    break;
-    
-  case OPCODE_FWD:
+    case OPCODE_REV:
+      forward = false;
+      driveLoco(operand);
+      break;
+
+    case OPCODE_FWD:
@@ -583,22 +602,36 @@ void RMFT2::loop2() {
-      
-  case OPCODE_SPEED:
-    forward=DCC::getThrottleDirection(loco)^invert;
-    driveLoco(operand);
-    break;
-    
-  case OPCODE_FORGET:
-    if (loco!=0) {
-      DCC::forgetLoco(loco);
-      loco=0; 
-    } 
-    break;
-
-  case OPCODE_INVERT_DIRECTION:
-    invert= !invert;
-    driveLoco(speedo);
-    break;
-    
-  case OPCODE_RESERVE:
-    if (getFlag(operand,SECTION_FLAG)) {
-      driveLoco(0);
-      delayMe(500);
+
+    case OPCODE_SPEED:
+      forward = DCC::getThrottleDirection(loco) ^ invert;
+      driveLoco(operand);
+      break;
+
+    case OPCODE_FORGET:
+      if (loco != 0) {
+        DCC::forgetLoco(loco);
+        loco = 0;
+      }
+      break;
+
+    case OPCODE_INVERT_DIRECTION:
+      invert = !invert;
+      driveLoco(speedo);
+      break;
+
+    case OPCODE_RESERVE:
+      if (getFlag(operand, SECTION_FLAG)) {
+        driveLoco(0);
+        delayMe(500);
+        return;
+      }
+      setFlag(operand, SECTION_FLAG);
+      break;
+
+    case OPCODE_FREE:
+      setFlag(operand, 0, SECTION_FLAG);
+      break;
+
+    case OPCODE_AT:
+      blinkState = not_blink_task;
+      if (readSensor(operand))
+        break;
+      delayMe(50);
@@ -606,50 +639,5 @@ void RMFT2::loop2() {
-    }
-    setFlag(operand,SECTION_FLAG);
-    break;
-    
-  case OPCODE_FREE:
-    setFlag(operand,0,SECTION_FLAG);
-    break;
-    
-  case OPCODE_AT:
-    blinkState=not_blink_task;
-    if (readSensor(operand)) break;
-    delayMe(50);
-    return;
-    
-  case OPCODE_ATGTE: // wait for analog sensor>= value
-    blinkState=not_blink_task;
-    if (IODevice::readAnalogue(operand) >= (int)(getOperand(1))) break;
-    delayMe(50);
-    return;
-    
-  case OPCODE_ATLT: // wait for analog sensor < value
-    blinkState=not_blink_task;
-    if (IODevice::readAnalogue(operand) < (int)(getOperand(1))) break;
-    delayMe(50);
-    return;
-      
-  case OPCODE_ATTIMEOUT1:   // ATTIMEOUT(vpin,timeout) part 1
-    timeoutStart=millis();
-    blinkState=not_blink_task;
-    break;
-    
-  case OPCODE_ATTIMEOUT2:
-    if (readSensor(operand)) break; // success without timeout
-    if (millis()-timeoutStart > 100*getOperand(1)) {
-      blinkState=at_timeout;
-      break; // and drop through
-    }
-    delayMe(50);
-    return;
-    
-  case OPCODE_IFTIMEOUT: // do next operand if timeout flag set
-    skipIf=blinkState!=at_timeout;
-    break;
-    
-  case OPCODE_AFTER: // waits for sensor to hit and then remain off for x mS. 
-    // Note, this must come after an AT operation, which is 
-    // automatically inserted by the AFTER macro. 
-    if (readSensor(operand)) {
-      // reset timer and keep waiting
-      waitAfter=millis();
+
+    case OPCODE_ATGTE:  // wait for analog sensor>= value
+      blinkState = not_blink_task;
+      if (IODevice::readAnalogue(operand) >= (int)(getOperand(1)))
+        break;
@@ -658,3 +645,0 @@ void RMFT2::loop2() {
-    }
-    if (millis()-waitAfter < getOperand(1) ) return;
-    break;
@@ -662,4 +647,4 @@ void RMFT2::loop2() {
-  case OPCODE_AFTEROVERLOAD: // waits for the power to be turned back on - either by power routine or button
-    if (!TrackManager::isPowerOn(operand)) {
-      // reset timer to half a second and keep waiting
-      waitAfter=millis();
+    case OPCODE_ATLT:  // wait for analog sensor < value
+      blinkState = not_blink_task;
+      if (IODevice::readAnalogue(operand) < (int)(getOperand(1)))
+        break;
@@ -668,19 +653,12 @@ void RMFT2::loop2() {
-    }
-    if (millis()-waitAfter < 500 ) return;
-    break;
-
-  case OPCODE_LATCH:
-    setFlag(operand,LATCH_FLAG);
-    break;
-    
-  case OPCODE_UNLATCH:
-    setFlag(operand,0,LATCH_FLAG);
-    break;
-
-  case OPCODE_SET:
-  case OPCODE_RESET:
-    { 
-      auto count=getOperand(1);
-      for (uint16_t i=0;i<count;i++) {
-        killBlinkOnVpin(operand+i);
-        IODevice::write(operand+i,opcode==OPCODE_SET);
+
+    case OPCODE_ATTIMEOUT1:  // ATTIMEOUT(vpin,timeout) part 1
+      timeoutStart = millis();
+      blinkState = not_blink_task;
+      break;
+
+    case OPCODE_ATTIMEOUT2:
+      if (readSensor(operand))
+        break;  // success without timeout
+      if (millis() - timeoutStart > 100 * getOperand(1)) {
+        blinkState = at_timeout;
+        break;  // and drop through
@@ -688,28 +666,74 @@ void RMFT2::loop2() {
-    }
-    break;
-  
-  case OPCODE_BLINK: 
-     // Start a new task to blink this vpin
-     killBlinkOnVpin(operand);
-     {
-      auto newtask=new RMFT2(progCounter);
-      newtask->blinkPin=operand;
-      newtask->blinkState=blink_low; // will go high on first call
-     }
-     break; 
-
-  case OPCODE_PAUSE:
-    DCC::setThrottle(0,1,true);  // pause all locos on the track
-    pausingTask=this;
-    break;
-
-  case OPCODE_POM:
-    if (loco) DCC::writeCVByteMain(loco, operand, getOperand(1));
-    break;
-
-  case OPCODE_POWEROFF:
-    TrackManager::setPower(POWERMODE::OFF);
-    TrackManager::setJoin(false);
-    break;
-  
-  case OPCODE_SET_POWER:
+      delayMe(50);
+      return;
+
+    case OPCODE_IFTIMEOUT:  // do next operand if timeout flag set
+      skipIf = blinkState != at_timeout;
+      break;
+
+    case OPCODE_AFTER:  // waits for sensor to hit and then remain off for x mS.
+      // Note, this must come after an AT operation, which is
+      // automatically inserted by the AFTER macro.
+      if (readSensor(operand)) {
+        // reset timer and keep waiting
+        waitAfter = millis();
+        delayMe(50);
+        return;
+      }
+      if (millis() - waitAfter < getOperand(1))
+        return;
+      break;
+
+    case OPCODE_AFTEROVERLOAD:  // waits for the power to be turned back on - either by power routine or button
+      if (!TrackManager::isPowerOn(operand)) {
+        // reset timer to half a second and keep waiting
+        waitAfter = millis();
+        delayMe(50);
+        return;
+      }
+      if (millis() - waitAfter < 500)
+        return;
+      break;
+
+    case OPCODE_LATCH:
+      setFlag(operand, LATCH_FLAG);
+      break;
+
+    case OPCODE_UNLATCH:
+      setFlag(operand, 0, LATCH_FLAG);
+      break;
+
+    case OPCODE_SET:
+    case OPCODE_RESET: {
+      auto count = getOperand(1);
+      for (uint16_t i = 0; i < count; i++) {
+        killBlinkOnVpin(operand + i);
+        IODevice::write(operand + i, opcode == OPCODE_SET);
+      }
+    } break;
+
+    case OPCODE_BLINK:
+      // Start a new task to blink this vpin
+      killBlinkOnVpin(operand);
+      {
+        auto newtask = new RMFT2(progCounter);
+        newtask->blinkPin = operand;
+        newtask->blinkState = blink_low;  // will go high on first call
+      }
+      break;
+
+    case OPCODE_PAUSE:
+      DCC::setThrottle(0, 1, true);  // pause all locos on the track
+      pausingTask = this;
+      break;
+
+    case OPCODE_POM:
+      if (loco)
+        DCC::writeCVByteMain(loco, operand, getOperand(1));
+      break;
+
+    case OPCODE_POWEROFF:
+      TrackManager::setPower(POWERMODE::OFF);
+      TrackManager::setJoin(false);
+      break;
+
+    case OPCODE_SET_POWER:
@@ -717,4 +741,4 @@ void RMFT2::loop2() {
-        //byte thistrack=getOperand(1);
-        switch (operand) {
-          case TRACK_POWER_0:
-            TrackManager::setTrackPower(POWERMODE::OFF, getOperand(1));
+      // byte thistrack=getOperand(1);
+      switch (operand) {
+        case TRACK_POWER_0:
+          TrackManager::setTrackPower(POWERMODE::OFF, getOperand(1));
@@ -722,2 +746,2 @@ void RMFT2::loop2() {
-          case TRACK_POWER_1:
-            TrackManager::setTrackPower(POWERMODE::ON, getOperand(1));
+        case TRACK_POWER_1:
+          TrackManager::setTrackPower(POWERMODE::ON, getOperand(1));
@@ -725 +749 @@ void RMFT2::loop2() {
-        }
+      }
@@ -727 +751 @@ void RMFT2::loop2() {
-    break;
+      break;
@@ -729 +753 @@ void RMFT2::loop2() {
-  case OPCODE_SET_TRACK:
+    case OPCODE_SET_TRACK:
@@ -731 +755 @@ void RMFT2::loop2() {
-      // If DC/DCX use  my loco for DC address 
+      // If DC/DCX use  my loco for DC address
@@ -733,2 +757,2 @@ void RMFT2::loop2() {
-        TRACK_MODE mode = (TRACK_MODE)(operand>>8);
-        int16_t cab=(mode & TRACK_MODE_DC) ? loco : 0;
+        TRACK_MODE mode = (TRACK_MODE)(operand >> 8);
+        int16_t cab = (mode & TRACK_MODE_DC) ? loco : 0;
@@ -737 +761 @@ void RMFT2::loop2() {
-      break; 
+      break;
@@ -739 +763 @@ void RMFT2::loop2() {
-  case OPCODE_SETFREQ:
+    case OPCODE_SETFREQ:
@@ -741,65 +765,69 @@ void RMFT2::loop2() {
-      DCC::setDCFreq(loco,operand);
-      break;
-
-  case OPCODE_RESUME:
-    pausingTask=NULL;
-    driveLoco(speedo);
-    for (RMFT2 * t=next; t!=this;t=t->next) if (t->loco >0) t->driveLoco(t->speedo);
-    break;
-    
-  case OPCODE_IF: // do next operand if sensor set
-    skipIf=!readSensor(operand);
-    break;
-    
-  case OPCODE_ELSE: // skip to matching ENDIF
-    skipIf=true;
-    break;
-    
-  case OPCODE_IFGTE: // do next operand if sensor>= value
-    skipIf=IODevice::readAnalogue(operand)<(int)(getOperand(1));
-    break;
-    
-  case OPCODE_IFLT: // do next operand if sensor< value
-    skipIf=IODevice::readAnalogue(operand)>=(int)(getOperand(1));
-    break;
-    
-  case OPCODE_IFLOCO: // do if the loco is the active one
-    skipIf=loco!=(uint16_t)operand; // bad luck if someone enters negative loco numbers into EXRAIL
-    break;
-
-  case OPCODE_IFNOT: // do next operand if sensor not set
-    skipIf=readSensor(operand);
-    break;
-
-  case OPCODE_IFRE: // do next operand if rotary encoder != position
-    skipIf=IODevice::readAnalogue(operand)!=(int)(getOperand(1));
-    break;
-    
-  case OPCODE_IFRANDOM: // do block on random percentage
-    skipIf=(uint8_t)micros() >= operand * 255/100;
-    break;
-    
-  case OPCODE_IFRESERVE: // do block if we successfully RERSERVE
-    if (!getFlag(operand,SECTION_FLAG)) setFlag(operand,SECTION_FLAG);
-    else skipIf=true;
-    break;
-    
-  case OPCODE_IFRED: // do block if signal as expected
-    skipIf=!isSignal(operand,SIGNAL_RED);
-    break;
-    
-  case OPCODE_IFAMBER: // do block if signal as expected
-    skipIf=!isSignal(operand,SIGNAL_AMBER);
-    break;
-    
-  case OPCODE_IFGREEN: // do block if signal as expected
-    skipIf=!isSignal(operand,SIGNAL_GREEN);
-    break;
-    
-  case OPCODE_IFTHROWN:
-    skipIf=Turnout::isClosed(operand);
-    break;
-    
-  case OPCODE_IFCLOSED:
-    skipIf=Turnout::isThrown(operand);
-    break;
+      DCC::setDCFreq(loco, operand);
+      break;
+
+    case OPCODE_RESUME:
+      pausingTask = NULL;
+      driveLoco(speedo);
+      for (RMFT2* t = next; t != this; t = t->next)
+        if (t->loco > 0)
+          t->driveLoco(t->speedo);
+      break;
+
+    case OPCODE_IF:  // do next operand if sensor set
+      skipIf = !readSensor(operand);
+      break;
+
+    case OPCODE_ELSE:  // skip to matching ENDIF
+      skipIf = true;
+      break;
+
+    case OPCODE_IFGTE:  // do next operand if sensor>= value
+      skipIf = IODevice::readAnalogue(operand) < (int)(getOperand(1));
+      break;
+
+    case OPCODE_IFLT:  // do next operand if sensor< value
+      skipIf = IODevice::readAnalogue(operand) >= (int)(getOperand(1));
+      break;
+
+    case OPCODE_IFLOCO:                    // do if the loco is the active one
+      skipIf = loco != (uint16_t)operand;  // bad luck if someone enters negative loco numbers into EXRAIL
+      break;
+
+    case OPCODE_IFNOT:  // do next operand if sensor not set
+      skipIf = readSensor(operand);
+      break;
+
+    case OPCODE_IFRE:  // do next operand if rotary encoder != position
+      skipIf = IODevice::readAnalogue(operand) != (int)(getOperand(1));
+      break;
+
+    case OPCODE_IFRANDOM:  // do block on random percentage
+      skipIf = (uint8_t)micros() >= operand * 255 / 100;
+      break;
+
+    case OPCODE_IFRESERVE:  // do block if we successfully RERSERVE
+      if (!getFlag(operand, SECTION_FLAG))
+        setFlag(operand, SECTION_FLAG);
+      else
+        skipIf = true;
+      break;
+
+    case OPCODE_IFRED:  // do block if signal as expected
+      skipIf = !isSignal(operand, SIGNAL_RED);
+      break;
+
+    case OPCODE_IFAMBER:  // do block if signal as expected
+      skipIf = !isSignal(operand, SIGNAL_AMBER);
+      break;
+
+    case OPCODE_IFGREEN:  // do block if signal as expected
+      skipIf = !isSignal(operand, SIGNAL_GREEN);
+      break;
+
+    case OPCODE_IFTHROWN:
+      skipIf = Turnout::isClosed(operand);
+      break;
+
+    case OPCODE_IFCLOSED:
+      skipIf = Turnout::isThrown(operand);
+      break;
@@ -808,3 +836,3 @@ void RMFT2::loop2() {
-  case OPCODE_IFTTPOSITION: // do block if turntable at this position
-    skipIf=Turntable::getPosition(operand)!=(int)getOperand(1);
-    break;
+    case OPCODE_IFTTPOSITION:  // do block if turntable at this position
+      skipIf = Turntable::getPosition(operand) != (int)getOperand(1);
+      break;
@@ -813,47 +841,50 @@ void RMFT2::loop2() {
-  case OPCODE_ENDIF:
-    break;
-    
-  case OPCODE_DELAYMS:
-    delayMe(operand);
-    break;
-    
-  case OPCODE_DELAY:
-    delayMe(operand*100L);
-    break;
-    
-  case OPCODE_DELAYMINS:
-    delayMe(operand*60L*1000L);
-    break;
-    
-  case OPCODE_RANDWAIT:
-    delayMe(operand==0 ? 0 : (micros()%operand) *100L);
-    break;
-    
-  case OPCODE_RED:
-    doSignal(operand,SIGNAL_RED);
-    break;
-    
-  case OPCODE_AMBER:
-    doSignal(operand,SIGNAL_AMBER);
-    break;
-    
-  case OPCODE_GREEN:
-    doSignal(operand,SIGNAL_GREEN);
-    break;
-    
-  case OPCODE_FON:
-    if (loco) DCC::setFn(loco,operand,true);
-    break;
-
-  case OPCODE_FOFF:
-    if (loco) DCC::setFn(loco,operand,false);
-    break;
-  
-  case OPCODE_FTOGGLE:
-    if (loco) DCC::changeFn(loco,operand);
-    break;
-    
-  case OPCODE_DRIVE:
-    {
-      byte analogSpeed=IODevice::readAnalogue(operand) *127 / 1024;
-      if (speedo!=analogSpeed) driveLoco(analogSpeed);
+    case OPCODE_ENDIF:
+      break;
+
+    case OPCODE_DELAYMS:
+      delayMe(operand);
+      break;
+
+    case OPCODE_DELAY:
+      delayMe(operand * 100L);
+      break;
+
+    case OPCODE_DELAYMINS:
+      delayMe(operand * 60L * 1000L);
+      break;
+
+    case OPCODE_RANDWAIT:
+      delayMe(operand == 0 ? 0 : (micros() % operand) * 100L);
+      break;
+
+    case OPCODE_RED:
+      doSignal(operand, SIGNAL_RED);
+      break;
+
+    case OPCODE_AMBER:
+      doSignal(operand, SIGNAL_AMBER);
+      break;
+
+    case OPCODE_GREEN:
+      doSignal(operand, SIGNAL_GREEN);
+      break;
+
+    case OPCODE_FON:
+      if (loco)
+        DCC::setFn(loco, operand, true);
+      break;
+
+    case OPCODE_FOFF:
+      if (loco)
+        DCC::setFn(loco, operand, false);
+      break;
+
+    case OPCODE_FTOGGLE:
+      if (loco)
+        DCC::changeFn(loco, operand);
+      break;
+
+    case OPCODE_DRIVE: {
+      byte analogSpeed = IODevice::readAnalogue(operand) * 127 / 1024;
+      if (speedo != analogSpeed)
+        driveLoco(analogSpeed);
@@ -862,47 +893,28 @@ void RMFT2::loop2() {
-    
-  case OPCODE_XFON:
-    DCC::setFn(operand,getOperand(1),true);
-    break;
-    
-  case OPCODE_XFOFF:
-    DCC::setFn(operand,getOperand(1),false);
-    break;
-
-  case OPCODE_XFTOGGLE:
-    DCC::changeFn(operand,getOperand(1));
-    break;
-    
-  case OPCODE_XFWD:
-    DCC::setThrottle(operand,getOperand(1), true);
-    break;
-
-  case OPCODE_XREV:
-    DCC::setThrottle(operand,getOperand(1), false);
-    break;
-
-  case OPCODE_DCCACTIVATE: {
-    // operand is address<<3 | subaddr<<1 | active
-    int16_t addr=operand>>3;
-    int16_t subaddr=(operand>>1) & 0x03;
-    bool active=operand & 0x01;
-    DCC::setAccessory(addr,subaddr,active);
-    break;
-  }
-   case OPCODE_ASPECT: {
-    // operand is address<<5 |  value
-    int16_t address=operand>>5;
-    byte aspect=operand & 0x1f;
-    if (!signalAspectEvent(address,aspect))
-      DCC::setExtendedAccessory(address,aspect);
-    break;
-  }
-    
-  case OPCODE_FOLLOW:
-    progCounter=routeLookup->find(operand);
-    if (progCounter<0) kill(F("FOLLOW unknown"), operand);
-    return;
-    
-  case OPCODE_CALL:
-    if (stackDepth==MAX_STACK_DEPTH) {
-      kill(F("CALL stack"), stackDepth);
-      return;
+
+    case OPCODE_XFON:
+      DCC::setFn(operand, getOperand(1), true);
+      break;
+
+    case OPCODE_XFOFF:
+      DCC::setFn(operand, getOperand(1), false);
+      break;
+
+    case OPCODE_XFTOGGLE:
+      DCC::changeFn(operand, getOperand(1));
+      break;
+
+    case OPCODE_XFWD:
+      DCC::setThrottle(operand, getOperand(1), true);
+      break;
+
+    case OPCODE_XREV:
+      DCC::setThrottle(operand, getOperand(1), false);
+      break;
+
+    case OPCODE_DCCACTIVATE: {
+      // operand is address<<3 | subaddr<<1 | active
+      int16_t addr = operand >> 3;
+      int16_t subaddr = (operand >> 1) & 0x03;
+      bool active = operand & 0x01;
+      DCC::setAccessory(addr, subaddr, active);
+      break;
@@ -910,9 +922,7 @@ void RMFT2::loop2() {
-    callStack[stackDepth++]=progCounter+3;
-    progCounter=routeLookup->find(operand);
-    if (progCounter<0) kill(F("CALL unknown"),operand);
-    return;
-    
-  case OPCODE_RETURN:
-    if (stackDepth==0) {
-      kill(F("RETURN stack"));
-      return;
+    case OPCODE_ASPECT: {
+      // operand is address<<5 |  value
+      int16_t address = operand >> 5;
+      byte aspect = operand & 0x1f;
+      if (!signalAspectEvent(address, aspect))
+        DCC::setExtendedAccessory(address, aspect);
+      break;
@@ -920,7 +929,0 @@ void RMFT2::loop2() {
-    progCounter=callStack[--stackDepth];
-    return;
-    
-  case OPCODE_ENDTASK:
-  case OPCODE_ENDEXRAIL:
-    kill();
-    return;
@@ -928,3 +931,33 @@ void RMFT2::loop2() {
-  case OPCODE_KILLALL:
-    while(loopTask) loopTask->kill(F("KILLALL"));
-    return;
+    case OPCODE_FOLLOW:
+      progCounter = routeLookup->find(operand);
+      if (progCounter < 0)
+        kill(F("FOLLOW unknown"), operand);
+      return;
+
+    case OPCODE_CALL:
+      if (stackDepth == MAX_STACK_DEPTH) {
+        kill(F("CALL stack"), stackDepth);
+        return;
+      }
+      callStack[stackDepth++] = progCounter + 3;
+      progCounter = routeLookup->find(operand);
+      if (progCounter < 0)
+        kill(F("CALL unknown"), operand);
+      return;
+
+    case OPCODE_RETURN:
+      if (stackDepth == 0) {
+        kill(F("RETURN stack"));
+        return;
+      }
+      progCounter = callStack[--stackDepth];
+      return;
+
+    case OPCODE_ENDTASK:
+    case OPCODE_ENDEXRAIL:
+      kill();
+      return;
+
+    case OPCODE_KILLALL:
+      while (loopTask) loopTask->kill(F("KILLALL"));
+      return;
@@ -933,29 +966,29 @@ void RMFT2::loop2() {
-  case OPCODE_JOIN:
-    TrackManager::setJoin(true);
-    TrackManager::setMainPower(POWERMODE::ON);
-    TrackManager::setProgPower(POWERMODE::ON);
-    break;
-
-  case OPCODE_UNJOIN:
-    TrackManager::setJoin(false);
-    break;
-
-  case OPCODE_READ_LOCO1: // READ_LOCO is implemented as 2 separate opcodes
-    progtrackLocoId=LOCO_ID_WAITING;  // Nothing found yet
-    DCC::getLocoId(readLocoCallback);
-    break;
-    
-  case OPCODE_READ_LOCO2:
-    if (progtrackLocoId==LOCO_ID_WAITING) {
-      delayMe(100);
-      return; // still waiting for callback
-    }
-    
-    // At failed read will result in loco == -1
-    // which is intended so it can be checked
-    // from within EXRAIL
-    loco=progtrackLocoId;
-    speedo=0;
-    forward=true;
-    invert=false;
-    break;
+    case OPCODE_JOIN:
+      TrackManager::setJoin(true);
+      TrackManager::setMainPower(POWERMODE::ON);
+      TrackManager::setProgPower(POWERMODE::ON);
+      break;
+
+    case OPCODE_UNJOIN:
+      TrackManager::setJoin(false);
+      break;
+
+    case OPCODE_READ_LOCO1:               // READ_LOCO is implemented as 2 separate opcodes
+      progtrackLocoId = LOCO_ID_WAITING;  // Nothing found yet
+      DCC::getLocoId(readLocoCallback);
+      break;
+
+    case OPCODE_READ_LOCO2:
+      if (progtrackLocoId == LOCO_ID_WAITING) {
+        delayMe(100);
+        return;  // still waiting for callback
+      }
+
+      // At failed read will result in loco == -1
+      // which is intended so it can be checked
+      // from within EXRAIL
+      loco = progtrackLocoId;
+      speedo = 0;
+      forward = true;
+      invert = false;
+      break;
@@ -964,9 +997,9 @@ void RMFT2::loop2() {
-  case OPCODE_POWERON:
-    TrackManager::setMainPower(POWERMODE::ON);
-    TrackManager::setJoin(false);
-    break;
-    
-  case OPCODE_START:
-    {
-      int newPc=routeLookup->find(operand);
-      if (newPc<0) break;
+    case OPCODE_POWERON:
+      TrackManager::setMainPower(POWERMODE::ON);
+      TrackManager::setJoin(false);
+      break;
+
+    case OPCODE_START: {
+      int newPc = routeLookup->find(operand);
+      if (newPc < 0)
+        break;
@@ -974,13 +1007,3 @@ void RMFT2::loop2() {
-    }
-    break;
-    
-  case OPCODE_SENDLOCO:  // cab, route
-    {
-      int newPc=routeLookup->find(getOperand(1));
-      if (newPc<0) break;
-      RMFT2* newtask=new RMFT2(newPc); // create new task
-      newtask->loco=operand;
-    }
-    break;
-    
-  case OPCODE_SETLOCO:
+    } break;
+
+    case OPCODE_SENDLOCO:  // cab, route
@@ -988,41 +1011,42 @@ void RMFT2::loop2() {
-      loco=operand;
-      speedo=0;
-      forward=true;
-      invert=false;
-    }
-    break;
-
-  case OPCODE_LCC:  // short form LCC
-      if ((compileFeatures & FEATURE_LCC) && LCCSerial) 
-          StringFormatter::send(LCCSerial,F("<L x%h>"),(uint16_t)operand);
-       break; 
-  
-  case OPCODE_ACON:  // MERG adapter 
-  case OPCODE_ACOF: 
-      if ((compileFeatures & FEATURE_LCC) && LCCSerial) 
-          StringFormatter::send(LCCSerial,F("<L x%c%h%h>"),
-          opcode==OPCODE_ACON?'0':'1',
-          (uint16_t)operand,getOperand(progCounter,1));
-       break; 
-
-  case OPCODE_LCCX: // long form LCC
-       if ((compileFeatures & FEATURE_LCC) && LCCSerial)
-            StringFormatter::send(LCCSerial,F("<L x%h%h%h%h>\n"),
-                 getOperand(progCounter,1),
-                 getOperand(progCounter,2),
-                 getOperand(progCounter,3),
-                 getOperand(progCounter,0)
-                 );    
-        break;  
-    
-  case OPCODE_SERVO: // OPCODE_SERVO,V(vpin),OPCODE_PAD,V(position),OPCODE_PAD,V(profile),OPCODE_PAD,V(duration)
-    IODevice::writeAnalogue(operand,getOperand(1),getOperand(2),getOperand(3));
-    break;
-    
-  case OPCODE_WAITFOR: // OPCODE_SERVO,V(pin)
-    if (IODevice::isBusy(operand)) {
-      delayMe(100);
-      return;
-    }
-    break;
-    
+      int newPc = routeLookup->find(getOperand(1));
+      if (newPc < 0)
+        break;
+      RMFT2* newtask = new RMFT2(newPc);  // create new task
+      newtask->loco = operand;
+    } break;
+
+    case OPCODE_SETLOCO: {
+      loco = operand;
+      speedo = 0;
+      forward = true;
+      invert = false;
+    } break;
+
+    case OPCODE_LCC:  // short form LCC
+      if ((compileFeatures & FEATURE_LCC) && LCCSerial)
+        StringFormatter::send(LCCSerial, F("<L x%h>"), (uint16_t)operand);
+      break;
+
+    case OPCODE_ACON:  // MERG adapter
+    case OPCODE_ACOF:
+      if ((compileFeatures & FEATURE_LCC) && LCCSerial)
+        StringFormatter::send(LCCSerial, F("<L x%c%h%h>"), opcode == OPCODE_ACON ? '0' : '1', (uint16_t)operand, getOperand(progCounter, 1));
+      break;
+
+    case OPCODE_LCCX:  // long form LCC
+      if ((compileFeatures & FEATURE_LCC) && LCCSerial)
+        StringFormatter::send(LCCSerial, F("<L x%h%h%h%h>\n"), getOperand(progCounter, 1), getOperand(progCounter, 2), getOperand(progCounter, 3),
+                              getOperand(progCounter, 0));
+      break;
+
+    case OPCODE_SERVO:  // OPCODE_SERVO,V(vpin),OPCODE_PAD,V(position),OPCODE_PAD,V(profile),OPCODE_PAD,V(duration)
+      IODevice::writeAnalogue(operand, getOperand(1), getOperand(2), getOperand(3));
+      break;
+
+    case OPCODE_WAITFOR:  // OPCODE_SERVO,V(pin)
+      if (IODevice::isBusy(operand)) {
+        delayMe(100);
+        return;
+      }
+      break;
+
@@ -1030,16 +1054,16 @@ void RMFT2::loop2() {
-  case OPCODE_NEOPIXEL: 
-    // OPCODE_NEOPIXEL,V([-]vpin),OPCODE_PAD,V(colour_RG),OPCODE_PAD,V(colour_B),OPCODE_PAD,V(count)
-    { 
-      VPIN vpin=operand>0?operand:-operand;
-      auto count=getOperand(3);
-      killBlinkOnVpin(vpin,count);
-      IODevice::writeAnalogueRange(vpin,getOperand(1),operand>0,getOperand(2),count);
-    }
-    break;
-  
-  case OPCODE_WAITFORTT:  // OPCODE_WAITFOR,V(turntable_id)
-    if (Turntable::ttMoving(operand)) {
-      delayMe(100);
-      return;
-    }
-    break;
+    case OPCODE_NEOPIXEL:
+      // OPCODE_NEOPIXEL,V([-]vpin),OPCODE_PAD,V(colour_RG),OPCODE_PAD,V(colour_B),OPCODE_PAD,V(count)
+      {
+        VPIN vpin = operand > 0 ? operand : -operand;
+        auto count = getOperand(3);
+        killBlinkOnVpin(vpin, count);
+        IODevice::writeAnalogueRange(vpin, getOperand(1), operand > 0, getOperand(2), count);
+      }
+      break;
+
+    case OPCODE_WAITFORTT:  // OPCODE_WAITFOR,V(turntable_id)
+      if (Turntable::ttMoving(operand)) {
+        delayMe(100);
+        return;
+      }
+      break;
@@ -1048,38 +1072,41 @@ void RMFT2::loop2() {
-  case OPCODE_PRINT:
-    printMessage(operand);
-    break;
-  case OPCODE_ROUTE_HIDDEN:
-    manageRouteState(operand,2);
-    break;   
-  case OPCODE_ROUTE_INACTIVE:
-    manageRouteState(operand,0);
-    break;   
-  case OPCODE_ROUTE_ACTIVE:
-    manageRouteState(operand,1);
-    break;   
-  case OPCODE_ROUTE_DISABLED:
-    manageRouteState(operand,4);
-    break;   
-
-  case OPCODE_STASH:
-    if (compileFeatures & FEATURE_STASH) 
-      stashArray[operand] = invert? -loco : loco;
-    break; 
-
-  case OPCODE_CLEAR_STASH:
-    if (compileFeatures & FEATURE_STASH) 
-      stashArray[operand] = 0;
-    break; 
-       
-  case OPCODE_CLEAR_ALL_STASH:
-    if (compileFeatures & FEATURE_STASH) 
-      for (int i=0;i<=maxStashId;i++) stashArray[operand]=0;
-    break;
-
-  case OPCODE_PICKUP_STASH:
-    if (compileFeatures & FEATURE_STASH) {
-      int16_t x=stashArray[operand];
-      if (x>=0) {
-        loco=x;
-        invert=false;
-        break;
+    case OPCODE_PRINT:
+      printMessage(operand);
+      break;
+    case OPCODE_ROUTE_HIDDEN:
+      manageRouteState(operand, 2);
+      break;
+    case OPCODE_ROUTE_INACTIVE:
+      manageRouteState(operand, 0);
+      break;
+    case OPCODE_ROUTE_ACTIVE:
+      manageRouteState(operand, 1);
+      break;
+    case OPCODE_ROUTE_DISABLED:
+      manageRouteState(operand, 4);
+      break;
+
+    case OPCODE_STASH:
+      if (compileFeatures & FEATURE_STASH)
+        stashArray[operand] = invert ? -loco : loco;
+      break;
+
+    case OPCODE_CLEAR_STASH:
+      if (compileFeatures & FEATURE_STASH)
+        stashArray[operand] = 0;
+      break;
+
+    case OPCODE_CLEAR_ALL_STASH:
+      if (compileFeatures & FEATURE_STASH)
+        for (int i = 0; i <= maxStashId; i++) stashArray[operand] = 0;
+      break;
+
+    case OPCODE_PICKUP_STASH:
+      if (compileFeatures & FEATURE_STASH) {
+        int16_t x = stashArray[operand];
+        if (x >= 0) {
+          loco = x;
+          invert = false;
+          break;
+        }
+        loco = -x;
+        invert = true;
@@ -1087,30 +1114,27 @@ void RMFT2::loop2() {
-      loco=-x;
-      invert=true;
-    }
-    break;
-  
-  case OPCODE_ROUTE:
-  case OPCODE_AUTOMATION:
-  case OPCODE_SEQUENCE:
-    //if (diag) DIAG(F("EXRAIL begin(%d)"),operand);
-    break;
-    
-  case OPCODE_AUTOSTART: // Handled only during begin process
-  case OPCODE_PAD: // Just a padding for previous opcode needing >1 operand byte.
-  case OPCODE_TURNOUT: // Turnout definition ignored at runtime
-  case OPCODE_SERVOTURNOUT: // Turnout definition ignored at runtime
-  case OPCODE_PINTURNOUT: // Turnout definition ignored at runtime
-  case OPCODE_ONCLOSE: // Turnout event catchers ignored here
-  case OPCODE_ONLCC:   // LCC event catchers ignored here 
-  case OPCODE_ONACON:   // MERG event catchers ignored here 
-  case OPCODE_ONACOF:   // MERG event catchers ignored here 
-  case OPCODE_ONTHROW:
-  case OPCODE_ONACTIVATE: // Activate event catchers ignored here
-  case OPCODE_ONDEACTIVATE:
-  case OPCODE_ONRED:
-  case OPCODE_ONAMBER:
-  case OPCODE_ONGREEN:
-  case OPCODE_ONCHANGE:
-  case OPCODE_ONTIME:
-  case OPCODE_ONBUTTON:
-  case OPCODE_ONSENSOR:
+      break;
+
+    case OPCODE_ROUTE:
+    case OPCODE_AUTOMATION:
+    case OPCODE_SEQUENCE:
+      // if (diag) DIAG(F("EXRAIL begin(%d)"),operand);
+      break;
+
+    case OPCODE_AUTOSTART:     // Handled only during begin process
+    case OPCODE_PAD:           // Just a padding for previous opcode needing >1 operand byte.
+    case OPCODE_TURNOUT:       // Turnout definition ignored at runtime
+    case OPCODE_SERVOTURNOUT:  // Turnout definition ignored at runtime
+    case OPCODE_PINTURNOUT:    // Turnout definition ignored at runtime
+    case OPCODE_ONCLOSE:       // Turnout event catchers ignored here
+    case OPCODE_ONLCC:         // LCC event catchers ignored here
+    case OPCODE_ONACON:        // MERG event catchers ignored here
+    case OPCODE_ONACOF:        // MERG event catchers ignored here
+    case OPCODE_ONTHROW:
+    case OPCODE_ONACTIVATE:  // Activate event catchers ignored here
+    case OPCODE_ONDEACTIVATE:
+    case OPCODE_ONRED:
+    case OPCODE_ONAMBER:
+    case OPCODE_ONGREEN:
+    case OPCODE_ONCHANGE:
+    case OPCODE_ONTIME:
+    case OPCODE_ONBUTTON:
+    case OPCODE_ONSENSOR:
@@ -1118,4 +1142,4 @@ void RMFT2::loop2() {
-  case OPCODE_DCCTURNTABLE: // Turntable definition ignored at runtime
-  case OPCODE_EXTTTURNTABLE:  // Turntable definition ignored at runtime
-  case OPCODE_TTADDPOSITION:  // Turntable position definition ignored at runtime
-  case OPCODE_ONROTATE:
+    case OPCODE_DCCTURNTABLE:   // Turntable definition ignored at runtime
+    case OPCODE_EXTTTURNTABLE:  // Turntable definition ignored at runtime
+    case OPCODE_TTADDPOSITION:  // Turntable position definition ignored at runtime
+    case OPCODE_ONROTATE:
@@ -1123,6 +1147,6 @@ void RMFT2::loop2() {
-  case OPCODE_ONOVERLOAD:
-  
-    break;
-    
-  default:
-    kill(F("INVOP"),operand);
+    case OPCODE_ONOVERLOAD:
+
+      break;
+
+    default:
+      kill(F("INVOP"), operand);
@@ -1132 +1156,3 @@ void RMFT2::loop2() {
-  if (skipIf)  if (!skipIfBlock()) return;
+  if (skipIf)
+    if (!skipIfBlock())
+      return;
@@ -1137,2 +1163,2 @@ void RMFT2::delayMe(long delay) {
-  delayTime=delay;
-  delayStart=millis();
+  delayTime = delay;
+  delayStart = millis();
@@ -1141,7 +1167,8 @@ void RMFT2::delayMe(long delay) {
-bool RMFT2::setFlag(VPIN id,byte onMask, byte offMask) {
-   if (FLAGOVERFLOW(id)) return false; // Outside range limit
-   byte f=flags[id];
-   f &= ~offMask;
-   f |= onMask;
-   flags[id]=f;
-   return true;
+bool RMFT2::setFlag(VPIN id, byte onMask, byte offMask) {
+  if (FLAGOVERFLOW(id))
+    return false;  // Outside range limit
+  byte f = flags[id];
+  f &= ~offMask;
+  f |= onMask;
+  flags[id] = f;
+  return true;
@@ -1150,3 +1177,4 @@ bool RMFT2::setFlag(VPIN id,byte onMask, byte offMask) {
-bool RMFT2::getFlag(VPIN id,byte mask) {
-  if (FLAGOVERFLOW(id)) return 0; // Outside range limit
-  return flags[id]&mask;
+bool RMFT2::getFlag(VPIN id, byte mask) {
+  if (FLAGOVERFLOW(id))
+    return 0;  // Outside range limit
+  return flags[id] & mask;
@@ -1155,3 +1183,5 @@ bool RMFT2::getFlag(VPIN id,byte mask) {
-void RMFT2::kill(const FSH * reason, int operand) {
-  if (reason) DIAG(F("EXRAIL ERROR pc=%d, cab=%d, %S %d"), progCounter,loco, reason, operand);
-  else if (diag) DIAG(F("ENDTASK at pc=%d"), progCounter);
+void RMFT2::kill(const FSH* reason, int operand) {
+  if (reason)
+    DIAG(F("EXRAIL ERROR pc=%d, cab=%d, %S %d"), progCounter, loco, reason, operand);
+  else if (diag)
+    DIAG(F("ENDTASK at pc=%d"), progCounter);
@@ -1161 +1190,0 @@ void RMFT2::kill(const FSH * reason, int operand) {
-
@@ -1164 +1193 @@ SIGNAL_DEFINITION RMFT2::getSignalSlot(int16_t slot) {
-  COPYHIGHFLASH(&signal,SignalDefinitions,slot*sizeof(SIGNAL_DEFINITION),sizeof(SIGNAL_DEFINITION));
+  COPYHIGHFLASH(&signal, SignalDefinitions, slot * sizeof(SIGNAL_DEFINITION), sizeof(SIGNAL_DEFINITION));
@@ -1168,4 +1197,5 @@ SIGNAL_DEFINITION RMFT2::getSignalSlot(int16_t slot) {
-/* static */ void RMFT2::doSignal(int16_t id,char rag) {
-  if (!(compileFeatures & FEATURE_SIGNAL)) return; // dont compile code below
-  //if (diag) DIAG(F(" doSignal %d %x"),id,rag);
-  
+/* static */ void RMFT2::doSignal(int16_t id, char rag) {
+  if (!(compileFeatures & FEATURE_SIGNAL))
+    return;  // dont compile code below
+  // if (diag) DIAG(F(" doSignal %d %x"),id,rag);
+
@@ -1173,11 +1203,15 @@ SIGNAL_DEFINITION RMFT2::getSignalSlot(int16_t slot) {
-  // This will work even without a signal definition. 
-  if (rag==SIGNAL_RED) onRedLookup->handleEvent(F("RED"),id);
-  else if (rag==SIGNAL_GREEN) onGreenLookup->handleEvent(F("GREEN"),id);
-  else onAmberLookup->handleEvent(F("AMBER"),id);
-  
-  auto sigslot=signalLookup->find(id);
-  if (sigslot<0) return; 
-  
-  // keep track of signal state 
-  setFlag(sigslot,rag,SIGNAL_MASK);
- 
+  // This will work even without a signal definition.
+  if (rag == SIGNAL_RED)
+    onRedLookup->handleEvent(F("RED"), id);
+  else if (rag == SIGNAL_GREEN)
+    onGreenLookup->handleEvent(F("GREEN"), id);
+  else
+    onAmberLookup->handleEvent(F("AMBER"), id);
+
+  auto sigslot = signalLookup->find(id);
+  if (sigslot < 0)
+    return;
+
+  // keep track of signal state
+  setFlag(sigslot, rag, SIGNAL_MASK);
+
@@ -1185,2 +1219,2 @@ SIGNAL_DEFINITION RMFT2::getSignalSlot(int16_t slot) {
-  auto signal=getSignalSlot(sigslot);
-  
+  auto signal = getSignalSlot(sigslot);
+
@@ -1188,7 +1222,7 @@ SIGNAL_DEFINITION RMFT2::getSignalSlot(int16_t slot) {
-  case sigtypeSERVO: 
-    { 
-    auto servopos = rag==SIGNAL_RED? signal.redpin: (rag==SIGNAL_GREEN? signal.greenpin : signal.amberpin);
-    //if (diag) DIAG(F("sigA %d %d"),id,servopos);
-    if  (servopos!=0) IODevice::writeAnalogue(id,servopos,PCA9685::Bounce);
-    return;  
-   }
+    case sigtypeSERVO: {
+      auto servopos = rag == SIGNAL_RED ? signal.redpin : (rag == SIGNAL_GREEN ? signal.greenpin : signal.amberpin);
+      // if (diag) DIAG(F("sigA %d %d"),id,servopos);
+      if (servopos != 0)
+        IODevice::writeAnalogue(id, servopos, PCA9685::Bounce);
+      return;
+    }
@@ -1196,6 +1230,5 @@ SIGNAL_DEFINITION RMFT2::getSignalSlot(int16_t slot) {
-  case sigtypeDCC:
-   {
-    // redpin,amberpin are the DCC addr,subaddr 
-    DCC::setAccessory(signal.redpin,signal.amberpin, rag!=SIGNAL_RED);
-    return; 
-  }
+    case sigtypeDCC: {
+      // redpin,amberpin are the DCC addr,subaddr
+      DCC::setAccessory(signal.redpin, signal.amberpin, rag != SIGNAL_RED);
+      return;
+    }
@@ -1203,9 +1236,10 @@ SIGNAL_DEFINITION RMFT2::getSignalSlot(int16_t slot) {
- case sigtypeDCCX:
-  {
-    // redpin,amberpin,greenpin are the 3 aspects
-    auto value=signal.redpin;
-    if (rag==SIGNAL_AMBER) value=signal.amberpin;
-    if (rag==SIGNAL_GREEN) value=signal.greenpin; 
-    DCC::setExtendedAccessory(id, value);
-    return; 
-  }
+    case sigtypeDCCX: {
+      // redpin,amberpin,greenpin are the 3 aspects
+      auto value = signal.redpin;
+      if (rag == SIGNAL_AMBER)
+        value = signal.amberpin;
+      if (rag == SIGNAL_GREEN)
+        value = signal.greenpin;
+      DCC::setExtendedAccessory(id, value);
+      return;
+    }
@@ -1213,50 +1247,59 @@ SIGNAL_DEFINITION RMFT2::getSignalSlot(int16_t slot) {
-case sigtypeNEOPIXEL: 
-  {
-    // redpin,amberpin,greenpin are the 3 RG values but with no blue permitted. . (code limitation hack) 
-    auto colour_RG=signal.redpin;
-    if (rag==SIGNAL_AMBER) colour_RG=signal.amberpin;
-    if (rag==SIGNAL_GREEN) colour_RG=signal.greenpin; 
-
-    // blue channel is in followng signal slot (a continuation)
-    auto signal2=getSignalSlot(sigslot+1);
-    auto colour_B=signal2.redpin;
-    if (rag==SIGNAL_AMBER) colour_B=signal2.amberpin;
-    if (rag==SIGNAL_GREEN) colour_B=signal2.greenpin; 
-    IODevice::writeAnalogue(id, colour_RG,true,colour_B);
-    return; 
-  }
-  
-  case sigtypeSIGNAL:
-  case sigtypeSIGNALH:
-  {
-  // LED or similar 3 pin signal, (all pins zero would be a virtual signal)
-  // If amberpin is zero, synthesise amber from red+green
-  const byte SIMAMBER=0x00;
-  if (rag==SIGNAL_AMBER && (signal.amberpin==0)) rag=SIMAMBER; // special case this func only
-   
-  // Manage invert (HIGH on) pins
-  bool aHigh=signal.type==sigtypeSIGNALH;
-      
-  // set the three pins 
-  if (signal.redpin) {
-    bool redval=(rag==SIGNAL_RED || rag==SIMAMBER);
-    if (!aHigh) redval=!redval;
-    killBlinkOnVpin(signal.redpin);
-    IODevice::write(signal.redpin,redval);
-  }
-  if (signal.amberpin) {
-    bool amberval=(rag==SIGNAL_AMBER);
-    if (!aHigh) amberval=!amberval;
-    killBlinkOnVpin(signal.amberpin);
-    IODevice::write(signal.amberpin,amberval);
-  }
-  if (signal.greenpin) {
-    bool greenval=(rag==SIGNAL_GREEN || rag==SIMAMBER);
-    if (!aHigh) greenval=!greenval;
-    killBlinkOnVpin(signal.greenpin);
-    IODevice::write(signal.greenpin,greenval);
-  }
-}
-  case sigtypeVIRTUAL: break;
-  case sigtypeContinuation: break;
-  case sigtypeNoMoreSignals: break;
+    case sigtypeNEOPIXEL: {
+      // redpin,amberpin,greenpin are the 3 RG values but with no blue permitted. . (code limitation hack)
+      auto colour_RG = signal.redpin;
+      if (rag == SIGNAL_AMBER)
+        colour_RG = signal.amberpin;
+      if (rag == SIGNAL_GREEN)
+        colour_RG = signal.greenpin;
+
+      // blue channel is in followng signal slot (a continuation)
+      auto signal2 = getSignalSlot(sigslot + 1);
+      auto colour_B = signal2.redpin;
+      if (rag == SIGNAL_AMBER)
+        colour_B = signal2.amberpin;
+      if (rag == SIGNAL_GREEN)
+        colour_B = signal2.greenpin;
+      IODevice::writeAnalogue(id, colour_RG, true, colour_B);
+      return;
+    }
+
+    case sigtypeSIGNAL:
+    case sigtypeSIGNALH: {
+      // LED or similar 3 pin signal, (all pins zero would be a virtual signal)
+      // If amberpin is zero, synthesise amber from red+green
+      const byte SIMAMBER = 0x00;
+      if (rag == SIGNAL_AMBER && (signal.amberpin == 0))
+        rag = SIMAMBER;  // special case this func only
+
+      // Manage invert (HIGH on) pins
+      bool aHigh = signal.type == sigtypeSIGNALH;
+
+      // set the three pins
+      if (signal.redpin) {
+        bool redval = (rag == SIGNAL_RED || rag == SIMAMBER);
+        if (!aHigh)
+          redval = !redval;
+        killBlinkOnVpin(signal.redpin);
+        IODevice::write(signal.redpin, redval);
+      }
+      if (signal.amberpin) {
+        bool amberval = (rag == SIGNAL_AMBER);
+        if (!aHigh)
+          amberval = !amberval;
+        killBlinkOnVpin(signal.amberpin);
+        IODevice::write(signal.amberpin, amberval);
+      }
+      if (signal.greenpin) {
+        bool greenval = (rag == SIGNAL_GREEN || rag == SIMAMBER);
+        if (!aHigh)
+          greenval = !greenval;
+        killBlinkOnVpin(signal.greenpin);
+        IODevice::write(signal.greenpin, greenval);
+      }
+    }
+    case sigtypeVIRTUAL:
+      break;
+    case sigtypeContinuation:
+      break;
+    case sigtypeNoMoreSignals:
+      break;
@@ -1266,4 +1309,6 @@ case sigtypeNEOPIXEL:
-/* static */ bool RMFT2::isSignal(int16_t id,char rag) {
-  if (!(compileFeatures & FEATURE_SIGNAL)) return false; 
-  int16_t sigslot=signalLookup->find(id);
-  if (sigslot<0) return false; 
+/* static */ bool RMFT2::isSignal(int16_t id, char rag) {
+  if (!(compileFeatures & FEATURE_SIGNAL))
+    return false;
+  int16_t sigslot = signalLookup->find(id);
+  if (sigslot < 0)
+    return false;
@@ -1273 +1317,0 @@ case sigtypeNEOPIXEL:
-
@@ -1277,7 +1321,10 @@ case sigtypeNEOPIXEL:
-// Otherwise false so the parser should send the command directly 
-bool RMFT2::signalAspectEvent(int16_t address, byte aspect ) {
-  if (!(compileFeatures & FEATURE_SIGNAL)) return false; 
-  auto sigslot=signalLookup->find(address);
-  if (sigslot<0) return false;  // this is not a defined signal 
-  auto signal=getSignalSlot(sigslot);
-  if (signal.type!=sigtypeDCCX) return false; // not a DCCX signal
+// Otherwise false so the parser should send the command directly
+bool RMFT2::signalAspectEvent(int16_t address, byte aspect) {
+  if (!(compileFeatures & FEATURE_SIGNAL))
+    return false;
+  auto sigslot = signalLookup->find(address);
+  if (sigslot < 0)
+    return false;  // this is not a defined signal
+  auto signal = getSignalSlot(sigslot);
+  if (signal.type != sigtypeDCCX)
+    return false;  // not a DCCX signal
@@ -1285,3 +1332,3 @@ bool RMFT2::signalAspectEvent(int16_t address, byte aspect ) {
-  if (aspect==signal.redpin) {
-      doSignal(address,SIGNAL_RED);
-      return true;
+  if (aspect == signal.redpin) {
+    doSignal(address, SIGNAL_RED);
+    return true;
@@ -1289,4 +1336,4 @@ bool RMFT2::signalAspectEvent(int16_t address, byte aspect ) {
-  
-  if (aspect==signal.amberpin) {
-      doSignal(address,SIGNAL_AMBER);
-      return true;
+
+  if (aspect == signal.amberpin) {
+    doSignal(address, SIGNAL_AMBER);
+    return true;
@@ -1294,4 +1341,4 @@ bool RMFT2::signalAspectEvent(int16_t address, byte aspect ) {
-  
-  if (aspect==signal.greenpin) {
-      doSignal(address,SIGNAL_GREEN);
-      return true;
+
+  if (aspect == signal.greenpin) {
+    doSignal(address, SIGNAL_GREEN);
+    return true;
@@ -1300 +1347 @@ bool RMFT2::signalAspectEvent(int16_t address, byte aspect ) {
-  return false;  // aspect is not a defined one    
+  return false;  // aspect is not a defined one
@@ -1305,2 +1352,4 @@ void RMFT2::turnoutEvent(int16_t turnoutId, bool closed) {
-  if (closed)  onCloseLookup->handleEvent(F("CLOSE"),turnoutId);
-  else onThrowLookup->handleEvent(F("THROW"),turnoutId);
+  if (closed)
+    onCloseLookup->handleEvent(F("CLOSE"), turnoutId);
+  else
+    onThrowLookup->handleEvent(F("THROW"), turnoutId);
@@ -1309 +1357,0 @@ void RMFT2::turnoutEvent(int16_t turnoutId, bool closed) {
-
@@ -1312,2 +1360,4 @@ void RMFT2::activateEvent(int16_t addr, bool activate) {
-  if (activate)  onActivateLookup->handleEvent(F("ACTIVATE"),addr);
-  else onDeactivateLookup->handleEvent(F("DEACTIVATE"),addr);
+  if (activate)
+    onActivateLookup->handleEvent(F("ACTIVATE"), addr);
+  else
+    onDeactivateLookup->handleEvent(F("DEACTIVATE"), addr);
@@ -1318 +1368,2 @@ void RMFT2::changeEvent(int16_t vpin, bool change) {
-  if (change)  onChangeLookup->handleEvent(F("CHANGE"),vpin);
+  if (change)
+    onChangeLookup->handleEvent(F("CHANGE"), vpin);
@@ -1324 +1375,2 @@ void RMFT2::rotateEvent(int16_t turntableId, bool change) {
-  if (change) onRotateLookup->handleEvent(F("ROTATE"),turntableId);
+  if (change)
+    onRotateLookup->handleEvent(F("ROTATE"), turntableId);
@@ -1331 +1383 @@ void RMFT2::clockEvent(int16_t clocktime, bool change) {
-   DIAG(F("clockEvent at : %d"), clocktime);
+    DIAG(F("clockEvent at : %d"), clocktime);
@@ -1333,2 +1385,2 @@ void RMFT2::clockEvent(int16_t clocktime, bool change) {
-    onClockLookup->handleEvent(F("CLOCK"),clocktime);
-    onClockLookup->handleEvent(F("CLOCK"),25*60+clocktime%60);
+    onClockLookup->handleEvent(F("CLOCK"), clocktime);
+    onClockLookup->handleEvent(F("CLOCK"), 25 * 60 + clocktime % 60);
@@ -1336 +1388 @@ void RMFT2::clockEvent(int16_t clocktime, bool change) {
-} 
+}
@@ -1341 +1393 @@ void RMFT2::powerEvent(int16_t track, bool overload) {
-   DIAG(F("powerEvent : %c"), track + 'A');
+    DIAG(F("powerEvent : %c"), track + 'A');
@@ -1343 +1395 @@ void RMFT2::powerEvent(int16_t track, bool overload) {
-    onOverloadLookup->handleEvent(F("POWER"),track);
+    onOverloadLookup->handleEvent(F("POWER"), track);
@@ -1351,17 +1403,16 @@ void RMFT2::killBlinkOnVpin(VPIN pin, uint16_t count) {
-   if (!(compileFeatures & FEATURE_BLINK)) return; 
- 
-  RMFT2 * stoptask=loopTask; // stop when we get back to here
-  RMFT2 * task=loopTask;
-  VPIN lastPin=pin+count-1;
-  while(task) {
-    auto nextTask=task->next;
-    if (
-      (task->blinkState==blink_high || task->blinkState==blink_low) 
-       && task->blinkPin>=pin
-       && task->blinkPin<=lastPin
-       )    {
-        if (diag)  DIAG(F("kill blink %d"),task->blinkPin,lastPin);
-        task->kill();
-       }
-    task=nextTask;
-    if (task==stoptask) return;
+  if (!(compileFeatures & FEATURE_BLINK))
+    return;
+
+  RMFT2* stoptask = loopTask;  // stop when we get back to here
+  RMFT2* task = loopTask;
+  VPIN lastPin = pin + count - 1;
+  while (task) {
+    auto nextTask = task->next;
+    if ((task->blinkState == blink_high || task->blinkState == blink_low) && task->blinkPin >= pin && task->blinkPin <= lastPin) {
+      if (diag)
+        DIAG(F("kill blink %d"), task->blinkPin, lastPin);
+      task->kill();
+    }
+    task = nextTask;
+    if (task == stoptask)
+      return;
@@ -1370,2 +1421,2 @@ void RMFT2::killBlinkOnVpin(VPIN pin, uint16_t count) {
-  
-void RMFT2::startNonRecursiveTask(const FSH* reason, int16_t id,int pc) {  
+
+void RMFT2::startNonRecursiveTask(const FSH* reason, int16_t id, int pc) {
@@ -1373,4 +1424,4 @@ void RMFT2::startNonRecursiveTask(const FSH* reason, int16_t id,int pc) {
-  RMFT2 * task=loopTask;
-  while(task) {
-    if (task->onEventStartPosition==pc) {
-      DIAG(F("Recursive ON%S(%d)"),reason, id);
+  RMFT2* task = loopTask;
+  while (task) {
+    if (task->onEventStartPosition == pc) {
+      DIAG(F("Recursive ON%S(%d)"), reason, id);
@@ -1379,2 +1430,3 @@ void RMFT2::startNonRecursiveTask(const FSH* reason, int16_t id,int pc) {
-    task=task->next;
-    if (task==loopTask) break;
+    task = task->next;
+    if (task == loopTask)
+      break;
@@ -1382,3 +1434,3 @@ void RMFT2::startNonRecursiveTask(const FSH* reason, int16_t id,int pc) {
-  
-  task=new RMFT2(pc);  // new task starts at this instruction
-  task->onEventStartPosition=pc; // flag for recursion detector
+
+  task = new RMFT2(pc);             // new task starts at this instruction
+  task->onEventStartPosition = pc;  // flag for recursion detector
@@ -1387,2 +1439,2 @@ void RMFT2::startNonRecursiveTask(const FSH* reason, int16_t id,int pc) {
-void RMFT2::printMessage2(const FSH * msg) {
-  DIAG(F("EXRAIL(%d) %S"),loco,msg);
+void RMFT2::printMessage2(const FSH* msg) {
+  DIAG(F("EXRAIL(%d) %S"), loco, msg);
@@ -1390 +1442 @@ void RMFT2::printMessage2(const FSH * msg) {
-static StringBuffer * buffer=NULL;
+static StringBuffer* buffer = NULL;
@@ -1392 +1444 @@ static StringBuffer * buffer=NULL;
-and handle the oddities like LCD, BROADCAST and PARSE */    
+and handle the oddities like LCD, BROADCAST and PARSE */
@@ -1394,4 +1446,4 @@ void RMFT2::thrungeString(uint32_t strfar, thrunger mode, byte id) {
-   //DIAG(F("thrunge addr=%l mode=%d id=%d"), strfar,mode,id);
-   Print * stream=NULL;
-   // Find out where the string is going 
-   switch (mode) {
+  // DIAG(F("thrunge addr=%l mode=%d id=%d"), strfar,mode,id);
+  Print* stream = NULL;
+  // Find out where the string is going
+  switch (mode) {
@@ -1399,40 +1451,42 @@ void RMFT2::thrungeString(uint32_t strfar, thrunger mode, byte id) {
-         StringFormatter::send(&USB_SERIAL,F("<* EXRAIL(%d) "),loco);
-         stream=&USB_SERIAL;
-         break;
-
-    case thrunge_serial: stream=&USB_SERIAL; break;  
-    case thrunge_serial1: 
-         #ifdef SERIAL1_COMMANDS
-         stream=&Serial1; 
-         #endif
-         break;
-    case thrunge_serial2: 
-         #ifdef SERIAL2_COMMANDS
-         stream=&Serial2; 
-         #endif
-         break;
-    case thrunge_serial3: 
-         #ifdef SERIAL3_COMMANDS
-         stream=&Serial3; 
-         #endif
-         break;
-    case thrunge_serial4: 
-         #ifdef SERIAL4_COMMANDS
-         stream=&Serial4; 
-         #endif
-         break;
-    case thrunge_serial5: 
-         #ifdef SERIAL5_COMMANDS
-         stream=&Serial5; 
-         #endif
-         break;
-   case thrunge_serial6: 
-         #ifdef SERIAL6_COMMANDS
-         stream=&Serial6; 
-         #endif
-         break;
-    case thrunge_lcn: 
-      #if defined(LCN_SERIAL) 
-      stream=&LCN_SERIAL;
-      #endif
-       break;  
+      StringFormatter::send(&USB_SERIAL, F("<* EXRAIL(%d) "), loco);
+      stream = &USB_SERIAL;
+      break;
+
+    case thrunge_serial:
+      stream = &USB_SERIAL;
+      break;
+    case thrunge_serial1:
+#ifdef SERIAL1_COMMANDS
+      stream = &Serial1;
+#endif
+      break;
+    case thrunge_serial2:
+#ifdef SERIAL2_COMMANDS
+      stream = &Serial2;
+#endif
+      break;
+    case thrunge_serial3:
+#ifdef SERIAL3_COMMANDS
+      stream = &Serial3;
+#endif
+      break;
+    case thrunge_serial4:
+#ifdef SERIAL4_COMMANDS
+      stream = &Serial4;
+#endif
+      break;
+    case thrunge_serial5:
+#ifdef SERIAL5_COMMANDS
+      stream = &Serial5;
+#endif
+      break;
+    case thrunge_serial6:
+#ifdef SERIAL6_COMMANDS
+      stream = &Serial6;
+#endif
+      break;
+    case thrunge_lcn:
+#if defined(LCN_SERIAL)
+      stream = &LCN_SERIAL;
+#endif
+      break;
@@ -1441 +1495 @@ void RMFT2::thrungeString(uint32_t strfar, thrunger mode, byte id) {
-    case thrunge_message: 
+    case thrunge_message:
@@ -1443,20 +1497,23 @@ void RMFT2::thrungeString(uint32_t strfar, thrunger mode, byte id) {
-    default:    // thrunge_lcd+1, ...
-         if (!buffer) buffer=new StringBuffer();
-         buffer->flush();
-         stream=buffer;
-         break; 
-    }
-    if (!stream) return; 
-    
-     #if defined(ARDUINO_AVR_MEGA) || defined(ARDUINO_AVR_MEGA2560)
-    // if mega stream it out 
-    for (;;strfar++) {
-      char c=pgm_read_byte_far(strfar);
-      if (c=='\0') break;
-      stream->write(c);
-    }
-    #else
-    // UNO/NANO CPUs dont have high memory
-    // 32 bit cpus dont care anyway
-    stream->print((FSH *)strfar);
-    #endif
+    default:  // thrunge_lcd+1, ...
+      if (!buffer)
+        buffer = new StringBuffer();
+      buffer->flush();
+      stream = buffer;
+      break;
+  }
+  if (!stream)
+    return;
+
+#if defined(ARDUINO_AVR_MEGA) || defined(ARDUINO_AVR_MEGA2560)
+  // if mega stream it out
+  for (;; strfar++) {
+    char c = pgm_read_byte_far(strfar);
+    if (c == '\0')
+      break;
+    stream->write(c);
+  }
+#else
+  // UNO/NANO CPUs dont have high memory
+  // 32 bit cpus dont care anyway
+  stream->print((FSH*)strfar);
+#endif
@@ -1465 +1522 @@ void RMFT2::thrungeString(uint32_t strfar, thrunger mode, byte id) {
-   switch (mode) {
+  switch (mode) {
@@ -1467,2 +1524,2 @@ void RMFT2::thrungeString(uint32_t strfar, thrunger mode, byte id) {
-         StringFormatter::send(&USB_SERIAL,F(" *>\n"));
-         break;
+      StringFormatter::send(&USB_SERIAL, F(" *>\n"));
+      break;
@@ -1470,2 +1527,2 @@ void RMFT2::thrungeString(uint32_t strfar, thrunger mode, byte id) {
-    case thrunge_parse: 
-      DCCEXParser::parseOne(&USB_SERIAL,(byte*)buffer->getString(),NULL);
+    case thrunge_parse:
+      DCCEXParser::parseOne(&USB_SERIAL, (byte*)buffer->getString(), NULL);
@@ -1474 +1531 @@ void RMFT2::thrungeString(uint32_t strfar, thrunger mode, byte id) {
-      CommandDistributor::broadcastRaw(CommandDistributor::COMMAND_TYPE,buffer->getString());
+      CommandDistributor::broadcastRaw(CommandDistributor::COMMAND_TYPE, buffer->getString());
@@ -1477 +1534 @@ void RMFT2::thrungeString(uint32_t strfar, thrunger mode, byte id) {
-      CommandDistributor::broadcastRaw(CommandDistributor::WITHROTTLE_TYPE,buffer->getString());
+      CommandDistributor::broadcastRaw(CommandDistributor::WITHROTTLE_TYPE, buffer->getString());
@@ -1483,2 +1540,2 @@ void RMFT2::thrungeString(uint32_t strfar, thrunger mode, byte id) {
-         LCD(id,F("%s"),buffer->getString());
-         break;
+      LCD(id, F("%s"), buffer->getString());
+      break;
@@ -1486,4 +1543,4 @@ void RMFT2::thrungeString(uint32_t strfar, thrunger mode, byte id) {
-      if (mode > thrunge_lcd) 
-        SCREEN(mode-thrunge_lcd, id, F("%s"),buffer->getString());  // print to other display
-      break;       
-    }
+      if (mode > thrunge_lcd)
+        SCREEN(mode - thrunge_lcd, id, F("%s"), buffer->getString());  // print to other display
+      break;
+  }
@@ -1496,6 +1553,8 @@ void RMFT2::manageRouteState(uint16_t id, byte state) {
-    int16_t position=routeLookup->findPosition(id);
-    if (position<0) return; 
-    // set state beside it 
-    if (routeStateArray[position]==state) return; 
-    routeStateArray[position]=state;
-    CommandDistributor::broadcastRouteState(id,state);
+    int16_t position = routeLookup->findPosition(id);
+    if (position < 0)
+      return;
+    // set state beside it
+    if (routeStateArray[position] == state)
+      return;
+    routeStateArray[position] = state;
+    CommandDistributor::broadcastRouteState(id, state);
@@ -1504 +1563 @@ void RMFT2::manageRouteState(uint16_t id, byte state) {
-void RMFT2::manageRouteCaption(uint16_t id,const FSH* caption) {
+void RMFT2::manageRouteCaption(uint16_t id, const FSH* caption) {
@@ -1508,6 +1567,8 @@ void RMFT2::manageRouteCaption(uint16_t id,const FSH* caption) {
-    int16_t position=routeLookup->findPosition(id);
-    if (position<0) return; 
-    // set state beside it 
-    if (routeCaptionArray[position]==caption) return; 
-    routeCaptionArray[position]=caption;
-    CommandDistributor::broadcastRouteCaption(id,caption);
+    int16_t position = routeLookup->findPosition(id);
+    if (position < 0)
+      return;
+    // set state beside it
+    if (routeCaptionArray[position] == caption)
+      return;
+    routeCaptionArray[position] = caption;
+    CommandDistributor::broadcastRouteCaption(id, caption);
@@ -1516 +1576,0 @@ void RMFT2::manageRouteCaption(uint16_t id,const FSH* caption) {
-  
diff --git a/EXRAIL2.h b/EXRAIL2.h
index 5b95f8e..e944c7b 100644
--- a/EXRAIL2.h
+++ b/EXRAIL2.h
@@ -8 +8 @@
- *  
+ *
@@ -30 +30 @@
-   
+
@@ -33,20 +33,53 @@
-// In cases where more than one parameter is required, the first parameter is followed by one  
-// or more OPCODE_PAD instructions with the subsequent parameters. This wastes a byte but makes 
-// searching easier as a parameter can never be confused with an opcode. 
-// 
-enum OPCODE : byte {OPCODE_THROW,OPCODE_CLOSE,OPCODE_TOGGLE_TURNOUT,
-             OPCODE_FWD,OPCODE_REV,OPCODE_SPEED,OPCODE_INVERT_DIRECTION,
-             OPCODE_RESERVE,OPCODE_FREE,
-             OPCODE_AT,OPCODE_AFTER,
-             OPCODE_AFTEROVERLOAD,OPCODE_AUTOSTART,
-             OPCODE_ATGTE,OPCODE_ATLT,
-             OPCODE_ATTIMEOUT1,OPCODE_ATTIMEOUT2,
-             OPCODE_LATCH,OPCODE_UNLATCH,OPCODE_SET,OPCODE_RESET,
-             OPCODE_BLINK,
-             OPCODE_ENDIF,OPCODE_ELSE,
-             OPCODE_DELAY,OPCODE_DELAYMINS,OPCODE_DELAYMS,OPCODE_RANDWAIT,
-             OPCODE_FON,OPCODE_FOFF,OPCODE_XFON,OPCODE_XFOFF,
-             OPCODE_FTOGGLE,OPCODE_XFTOGGLE,OPCODE_XFWD,OPCODE_XREV,
-             OPCODE_RED,OPCODE_GREEN,OPCODE_AMBER,OPCODE_DRIVE,
-             OPCODE_SERVO,OPCODE_SIGNAL,OPCODE_TURNOUT,OPCODE_WAITFOR,
-             OPCODE_PAD,OPCODE_FOLLOW,OPCODE_CALL,OPCODE_RETURN,
+// In cases where more than one parameter is required, the first parameter is followed by one
+// or more OPCODE_PAD instructions with the subsequent parameters. This wastes a byte but makes
+// searching easier as a parameter can never be confused with an opcode.
+//
+enum OPCODE : byte {
+  OPCODE_THROW,
+  OPCODE_CLOSE,
+  OPCODE_TOGGLE_TURNOUT,
+  OPCODE_FWD,
+  OPCODE_REV,
+  OPCODE_SPEED,
+  OPCODE_INVERT_DIRECTION,
+  OPCODE_RESERVE,
+  OPCODE_FREE,
+  OPCODE_AT,
+  OPCODE_AFTER,
+  OPCODE_AFTEROVERLOAD,
+  OPCODE_AUTOSTART,
+  OPCODE_ATGTE,
+  OPCODE_ATLT,
+  OPCODE_ATTIMEOUT1,
+  OPCODE_ATTIMEOUT2,
+  OPCODE_LATCH,
+  OPCODE_UNLATCH,
+  OPCODE_SET,
+  OPCODE_RESET,
+  OPCODE_BLINK,
+  OPCODE_ENDIF,
+  OPCODE_ELSE,
+  OPCODE_DELAY,
+  OPCODE_DELAYMINS,
+  OPCODE_DELAYMS,
+  OPCODE_RANDWAIT,
+  OPCODE_FON,
+  OPCODE_FOFF,
+  OPCODE_XFON,
+  OPCODE_XFOFF,
+  OPCODE_FTOGGLE,
+  OPCODE_XFTOGGLE,
+  OPCODE_XFWD,
+  OPCODE_XREV,
+  OPCODE_RED,
+  OPCODE_GREEN,
+  OPCODE_AMBER,
+  OPCODE_DRIVE,
+  OPCODE_SERVO,
+  OPCODE_SIGNAL,
+  OPCODE_TURNOUT,
+  OPCODE_WAITFOR,
+  OPCODE_PAD,
+  OPCODE_FOLLOW,
+  OPCODE_CALL,
+  OPCODE_RETURN,
@@ -54 +87,4 @@ enum OPCODE : byte {OPCODE_THROW,OPCODE_CLOSE,OPCODE_TOGGLE_TURNOUT,
-             OPCODE_JOIN,OPCODE_UNJOIN,OPCODE_READ_LOCO1,OPCODE_READ_LOCO2,
+  OPCODE_JOIN,
+  OPCODE_UNJOIN,
+  OPCODE_READ_LOCO1,
+  OPCODE_READ_LOCO2,
@@ -56,39 +92,79 @@ enum OPCODE : byte {OPCODE_THROW,OPCODE_CLOSE,OPCODE_TOGGLE_TURNOUT,
-             OPCODE_POM,
-             OPCODE_START,OPCODE_SETLOCO,OPCODE_SETFREQ,OPCODE_SENDLOCO,OPCODE_FORGET,
-             OPCODE_PAUSE, OPCODE_RESUME,OPCODE_POWEROFF,OPCODE_POWERON,
-             OPCODE_ONCLOSE, OPCODE_ONTHROW, OPCODE_SERVOTURNOUT, OPCODE_PINTURNOUT,
-             OPCODE_PRINT,OPCODE_DCCACTIVATE,OPCODE_ASPECT,
-             OPCODE_ONACTIVATE,OPCODE_ONDEACTIVATE,
-             OPCODE_ROSTER,OPCODE_KILLALL,
-             OPCODE_ROUTE,OPCODE_AUTOMATION,OPCODE_SEQUENCE,
-             OPCODE_ENDTASK,OPCODE_ENDEXRAIL,
-             OPCODE_SET_TRACK,OPCODE_SET_POWER,
-             OPCODE_ONRED,OPCODE_ONAMBER,OPCODE_ONGREEN,
-             OPCODE_ONCHANGE,
-             OPCODE_ONCLOCKTIME,
-             OPCODE_ONTIME,
-             OPCODE_TTADDPOSITION,OPCODE_DCCTURNTABLE,OPCODE_EXTTTURNTABLE,
-             OPCODE_ONROTATE,OPCODE_ROTATE,OPCODE_WAITFORTT,
-             OPCODE_LCC,OPCODE_LCCX,OPCODE_ONLCC,
-             OPCODE_ACON, OPCODE_ACOF, 
-             OPCODE_ONACON, OPCODE_ONACOF, 
-             OPCODE_ONOVERLOAD,
-             OPCODE_ROUTE_ACTIVE,OPCODE_ROUTE_INACTIVE,OPCODE_ROUTE_HIDDEN,
-             OPCODE_ROUTE_DISABLED,
-             OPCODE_STASH,OPCODE_CLEAR_STASH,OPCODE_CLEAR_ALL_STASH,OPCODE_PICKUP_STASH,
-             OPCODE_ONBUTTON,OPCODE_ONSENSOR,             
-             OPCODE_NEOPIXEL,
-             // OPcodes below this point are skip-nesting IF operations
-             // placed here so that they may be skipped as a group
-             // see skipIfBlock()
-            IF_TYPE_OPCODES, // do not move this... 
-             OPCODE_IFRED,OPCODE_IFAMBER,OPCODE_IFGREEN,
-             OPCODE_IFGTE,OPCODE_IFLT,
-             OPCODE_IFTIMEOUT,
-             OPCODE_IF,OPCODE_IFNOT,
-             OPCODE_IFRANDOM,OPCODE_IFRESERVE,
-             OPCODE_IFCLOSED,OPCODE_IFTHROWN,
-             OPCODE_IFRE,
-             OPCODE_IFLOCO,
-             OPCODE_IFTTPOSITION
-             };
+  OPCODE_POM,
+  OPCODE_START,
+  OPCODE_SETLOCO,
+  OPCODE_SETFREQ,
+  OPCODE_SENDLOCO,
+  OPCODE_FORGET,
+  OPCODE_PAUSE,
+  OPCODE_RESUME,
+  OPCODE_POWEROFF,
+  OPCODE_POWERON,
+  OPCODE_ONCLOSE,
+  OPCODE_ONTHROW,
+  OPCODE_SERVOTURNOUT,
+  OPCODE_PINTURNOUT,
+  OPCODE_PRINT,
+  OPCODE_DCCACTIVATE,
+  OPCODE_ASPECT,
+  OPCODE_ONACTIVATE,
+  OPCODE_ONDEACTIVATE,
+  OPCODE_ROSTER,
+  OPCODE_KILLALL,
+  OPCODE_ROUTE,
+  OPCODE_AUTOMATION,
+  OPCODE_SEQUENCE,
+  OPCODE_ENDTASK,
+  OPCODE_ENDEXRAIL,
+  OPCODE_SET_TRACK,
+  OPCODE_SET_POWER,
+  OPCODE_ONRED,
+  OPCODE_ONAMBER,
+  OPCODE_ONGREEN,
+  OPCODE_ONCHANGE,
+  OPCODE_ONCLOCKTIME,
+  OPCODE_ONTIME,
+  OPCODE_TTADDPOSITION,
+  OPCODE_DCCTURNTABLE,
+  OPCODE_EXTTTURNTABLE,
+  OPCODE_ONROTATE,
+  OPCODE_ROTATE,
+  OPCODE_WAITFORTT,
+  OPCODE_LCC,
+  OPCODE_LCCX,
+  OPCODE_ONLCC,
+  OPCODE_ACON,
+  OPCODE_ACOF,
+  OPCODE_ONACON,
+  OPCODE_ONACOF,
+  OPCODE_ONOVERLOAD,
+  OPCODE_ROUTE_ACTIVE,
+  OPCODE_ROUTE_INACTIVE,
+  OPCODE_ROUTE_HIDDEN,
+  OPCODE_ROUTE_DISABLED,
+  OPCODE_STASH,
+  OPCODE_CLEAR_STASH,
+  OPCODE_CLEAR_ALL_STASH,
+  OPCODE_PICKUP_STASH,
+  OPCODE_ONBUTTON,
+  OPCODE_ONSENSOR,
+  OPCODE_NEOPIXEL,
+  // OPcodes below this point are skip-nesting IF operations
+  // placed here so that they may be skipped as a group
+  // see skipIfBlock()
+  IF_TYPE_OPCODES,  // do not move this...
+  OPCODE_IFRED,
+  OPCODE_IFAMBER,
+  OPCODE_IFGREEN,
+  OPCODE_IFGTE,
+  OPCODE_IFLT,
+  OPCODE_IFTIMEOUT,
+  OPCODE_IF,
+  OPCODE_IFNOT,
+  OPCODE_IFRANDOM,
+  OPCODE_IFRESERVE,
+  OPCODE_IFCLOSED,
+  OPCODE_IFTHROWN,
+  OPCODE_IFRE,
+  OPCODE_IFLOCO,
+  OPCODE_IFTTPOSITION
+};
@@ -96 +172 @@ enum OPCODE : byte {OPCODE_THROW,OPCODE_CLOSE,OPCODE_TOGGLE_TURNOUT,
-// Ensure thrunge_lcd is put last as there may be more than one display, 
+// Ensure thrunge_lcd is put last as there may be more than one display,
@@ -98,6 +174,14 @@ enum OPCODE : byte {OPCODE_THROW,OPCODE_CLOSE,OPCODE_TOGGLE_TURNOUT,
-enum thrunger: byte {
-  thrunge_print, thrunge_broadcast, thrunge_withrottle,
-  thrunge_serial,thrunge_parse,
-  thrunge_serial1, thrunge_serial2, thrunge_serial3,
-  thrunge_serial4, thrunge_serial5, thrunge_serial6,
-  thrunge_lcn,thrunge_message,
+enum thrunger : byte {
+  thrunge_print,
+  thrunge_broadcast,
+  thrunge_withrottle,
+  thrunge_serial,
+  thrunge_parse,
+  thrunge_serial1,
+  thrunge_serial2,
+  thrunge_serial3,
+  thrunge_serial4,
+  thrunge_serial5,
+  thrunge_serial6,
+  thrunge_lcn,
+  thrunge_message,
@@ -105,2 +189 @@ enum thrunger: byte {
-  };
-
+};
@@ -108,6 +191,6 @@ enum thrunger: byte {
-enum BlinkState: byte {
-    not_blink_task, 
-    blink_low, // blink task running with pin LOW
-    blink_high, // blink task running with pin high 
-    at_timeout  // ATTIMEOUT timed out flag
-    }; 
+enum BlinkState : byte {
+  not_blink_task,
+  blink_low,   // blink task running with pin LOW
+  blink_high,  // blink task running with pin high
+  at_timeout   // ATTIMEOUT timed out flag
+};
@@ -115,10 +198,10 @@ enum SignalType {
-       sigtypeVIRTUAL,
-       sigtypeSIGNAL, 
-       sigtypeSIGNALH, 
-       sigtypeDCC,
-       sigtypeDCCX,
-       sigtypeSERVO,
-       sigtypeNEOPIXEL,
-       sigtypeContinuation,  // neopixels require a second line
-       sigtypeNoMoreSignals
-       }; 
+  sigtypeVIRTUAL,
+  sigtypeSIGNAL,
+  sigtypeSIGNALH,
+  sigtypeDCC,
+  sigtypeDCCX,
+  sigtypeSERVO,
+  sigtypeNEOPIXEL,
+  sigtypeContinuation,  // neopixels require a second line
+  sigtypeNoMoreSignals
+};
@@ -126,5 +209,14 @@ enum SignalType {
-  struct SIGNAL_DEFINITION {
-       SignalType type;
-       VPIN id;  
-       VPIN  redpin,amberpin,greenpin; 
-  };
+struct SIGNAL_DEFINITION {
+  SignalType type;
+  VPIN id;
+  VPIN redpin, amberpin, greenpin;
+};
+
+// Flag bits for compile time features.
+static const byte FEATURE_SIGNAL = 0x80;
+static const byte FEATURE_LCC = 0x40;
+static const byte FEATURE_ROSTER = 0x20;
+static const byte FEATURE_ROUTESTATE = 0x10;
+static const byte FEATURE_STASH = 0x08;
+static const byte FEATURE_BLINK = 0x04;
+static const byte FEATURE_SENSOR = 0x02;
@@ -132,19 +224,9 @@ enum SignalType {
-  // Flag bits for compile time features.
-  static const byte FEATURE_SIGNAL= 0x80;
-  static const byte FEATURE_LCC   = 0x40;
-  static const byte FEATURE_ROSTER= 0x20;
-  static const byte FEATURE_ROUTESTATE= 0x10;
-  static const byte FEATURE_STASH = 0x08;
-  static const byte FEATURE_BLINK = 0x04;
-  static const byte FEATURE_SENSOR = 0x02;
-  
- 
-  // Flag bits for status of hardware and TPL
-  static const byte SECTION_FLAG = 0x80;
-  static const byte LATCH_FLAG   = 0x40;
-  static const byte TASK_FLAG    = 0x20;
-  static const byte SPARE_FLAG   = 0x10;
-  static const byte SIGNAL_MASK  = 0x0C;
-  static const byte SIGNAL_RED   = 0x08;
-  static const byte SIGNAL_AMBER = 0x0C;
-  static const byte SIGNAL_GREEN = 0x04;
+// Flag bits for status of hardware and TPL
+static const byte SECTION_FLAG = 0x80;
+static const byte LATCH_FLAG = 0x40;
+static const byte TASK_FLAG = 0x20;
+static const byte SPARE_FLAG = 0x10;
+static const byte SIGNAL_MASK = 0x0C;
+static const byte SIGNAL_RED = 0x08;
+static const byte SIGNAL_AMBER = 0x0C;
+static const byte SIGNAL_GREEN = 0x04;
@@ -152,4 +234,4 @@ enum SignalType {
-  static const byte  MAX_STACK_DEPTH=4;
- 
-   static const short MAX_FLAGS=256;
-  #define FLAGOVERFLOW(x) x>=MAX_FLAGS
+static const byte MAX_STACK_DEPTH = 4;
+
+static const short MAX_FLAGS = 256;
+#define FLAGOVERFLOW(x) x >= MAX_FLAGS
@@ -158,9 +240,9 @@ class LookList {
-  public: 
-    LookList(int16_t size);
-    void chain(LookList* chainTo);
-    void add(int16_t lookup, int16_t result);
-    int16_t find(int16_t value); // finds result value
-    int16_t findPosition(int16_t value); // finds index 
-    int16_t size();
-    void stream(Print * _stream); 
-    void handleEvent(const FSH* reason,int16_t id);
+ public:
+  LookList(int16_t size);
+  void chain(LookList* chainTo);
+  void add(int16_t lookup, int16_t result);
+  int16_t find(int16_t value);          // finds result value
+  int16_t findPosition(int16_t value);  // finds index
+  int16_t size();
+  void stream(Print* _stream);
+  void handleEvent(const FSH* reason, int16_t id);
@@ -168,6 +250,6 @@ class LookList {
-  private:
-     int16_t m_size;
-     int16_t m_loaded;
-     int16_t * m_lookupArray;
-     int16_t * m_resultArray;
-     LookList* m_chain;     
+ private:
+  int16_t m_size;
+  int16_t m_loaded;
+  int16_t* m_lookupArray;
+  int16_t* m_resultArray;
+  LookList* m_chain;
@@ -176,17 +258,17 @@ class LookList {
- class RMFT2 {
-   public:
-    static void begin();
-    static void loop();
-    RMFT2(int progCounter);
-    RMFT2(int route, uint16_t cab);
-    ~RMFT2();
-    static void readLocoCallback(int16_t cv);
-    static void createNewTask(int route, uint16_t cab);
-    static void turnoutEvent(int16_t id, bool closed);  
-    static void activateEvent(int16_t addr, bool active);
-    static void changeEvent(int16_t id, bool change);
-    static void clockEvent(int16_t clocktime, bool change);
-    static void rotateEvent(int16_t id, bool change);
-    static void powerEvent(int16_t track, bool overload);
-    static bool signalAspectEvent(int16_t address, byte aspect );    
-    // Throttle Info Access functions built by exrail macros 
+class RMFT2 {
+ public:
+  static void begin();
+  static void loop();
+  RMFT2(int progCounter);
+  RMFT2(int route, uint16_t cab);
+  ~RMFT2();
+  static void readLocoCallback(int16_t cv);
+  static void createNewTask(int route, uint16_t cab);
+  static void turnoutEvent(int16_t id, bool closed);
+  static void activateEvent(int16_t addr, bool active);
+  static void changeEvent(int16_t id, bool change);
+  static void clockEvent(int16_t clocktime, bool change);
+  static void rotateEvent(int16_t id, bool change);
+  static void powerEvent(int16_t track, bool overload);
+  static bool signalAspectEvent(int16_t address, byte aspect);
+  // Throttle Info Access functions built by exrail macros
@@ -197,8 +279,8 @@ class LookList {
-  static const FSH *  getRouteDescription(int16_t id);
-  static char   getRouteType(int16_t id);
-  static const FSH *  getTurnoutDescription(int16_t id);
-  static const FSH *  getRosterName(int16_t id);
-  static const FSH *  getRosterFunctions(int16_t id);
-  static const FSH *  getTurntableDescription(int16_t id);
-  static const FSH *  getTurntablePositionDescription(int16_t turntableId, uint8_t positionId);
-  static void startNonRecursiveTask(const FSH* reason, int16_t id,int pc);
+  static const FSH* getRouteDescription(int16_t id);
+  static char getRouteType(int16_t id);
+  static const FSH* getTurnoutDescription(int16_t id);
+  static const FSH* getRosterName(int16_t id);
+  static const FSH* getRosterFunctions(int16_t id);
+  static const FSH* getTurntableDescription(int16_t id);
+  static const FSH* getTurntablePositionDescription(int16_t turntableId, uint8_t positionId);
+  static void startNonRecursiveTask(const FSH* reason, int16_t id, int pc);
@@ -206,48 +288,47 @@ class LookList {
-  static bool isSignal(int16_t id,char rag);
-  static SIGNAL_DEFINITION getSignalSlot(int16_t slotno); 
-   
-private: 
-    static void ComandFilter(Print * stream, byte & opcode, byte & paramCount, int16_t p[]);
-    static bool parseSlash(Print * stream, byte & paramCount, int16_t p[]) ;
-    static void streamFlags(Print* stream);
-    static bool setFlag(VPIN id,byte onMask, byte OffMask=0);
-    static bool getFlag(VPIN id,byte mask); 
-    static int16_t progtrackLocoId;
-    static void doSignal(int16_t id,char rag); 
-    static void setTurnoutHiddenState(Turnout * t);
-    #ifndef IO_NO_HAL
-    static void setTurntableHiddenState(Turntable * tto);
-    #endif
-    static LookList* LookListLoader(OPCODE op1,
-                      OPCODE op2=OPCODE_ENDEXRAIL,OPCODE op3=OPCODE_ENDEXRAIL);
-    static uint16_t getOperand(int progCounter,byte n);
-    static void killBlinkOnVpin(VPIN pin,uint16_t count=1);
-    static RMFT2 * loopTask;
-    static RMFT2 * pausingTask;
-    void delayMe(long millisecs);
-    void driveLoco(byte speedo);
-    bool skipIfBlock();
-    bool readLoco();
-    void loop2();
-    void kill(const FSH * reason=NULL,int operand=0);          
-    void printMessage(uint16_t id);  // Built by RMFTMacros.h
-    void printMessage2(const FSH * msg);
-    void thrungeString(uint32_t strfar, thrunger mode, byte id=0);
-    uint16_t getOperand(byte n); 
-    
-   static bool diag;
-   static const  HIGHFLASH3  byte RouteCode[];
-   static const  HIGHFLASH  SIGNAL_DEFINITION SignalDefinitions[];
-   static byte flags[MAX_FLAGS];
-   static Print * LCCSerial;
-   static LookList * routeLookup;
-   static LookList * signalLookup;
-   static LookList * onThrowLookup;
-   static LookList * onCloseLookup;
-   static LookList * onActivateLookup;
-   static LookList * onDeactivateLookup;
-   static LookList * onRedLookup;
-   static LookList * onAmberLookup;
-   static LookList * onGreenLookup;
-   static LookList * onChangeLookup;
-   static LookList * onClockLookup;
+  static bool isSignal(int16_t id, char rag);
+  static SIGNAL_DEFINITION getSignalSlot(int16_t slotno);
+
+ private:
+  static void ComandFilter(Print* stream, byte& opcode, byte& paramCount, int16_t p[]);
+  static bool parseSlash(Print* stream, byte& paramCount, int16_t p[]);
+  static void streamFlags(Print* stream);
+  static bool setFlag(VPIN id, byte onMask, byte OffMask = 0);
+  static bool getFlag(VPIN id, byte mask);
+  static int16_t progtrackLocoId;
+  static void doSignal(int16_t id, char rag);
+  static void setTurnoutHiddenState(Turnout* t);
+#ifndef IO_NO_HAL
+  static void setTurntableHiddenState(Turntable* tto);
+#endif
+  static LookList* LookListLoader(OPCODE op1, OPCODE op2 = OPCODE_ENDEXRAIL, OPCODE op3 = OPCODE_ENDEXRAIL);
+  static uint16_t getOperand(int progCounter, byte n);
+  static void killBlinkOnVpin(VPIN pin, uint16_t count = 1);
+  static RMFT2* loopTask;
+  static RMFT2* pausingTask;
+  void delayMe(long millisecs);
+  void driveLoco(byte speedo);
+  bool skipIfBlock();
+  bool readLoco();
+  void loop2();
+  void kill(const FSH* reason = NULL, int operand = 0);
+  void printMessage(uint16_t id);  // Built by RMFTMacros.h
+  void printMessage2(const FSH* msg);
+  void thrungeString(uint32_t strfar, thrunger mode, byte id = 0);
+  uint16_t getOperand(byte n);
+
+  static bool diag;
+  static const HIGHFLASH3 byte RouteCode[];
+  static const HIGHFLASH SIGNAL_DEFINITION SignalDefinitions[];
+  static byte flags[MAX_FLAGS];
+  static Print* LCCSerial;
+  static LookList* routeLookup;
+  static LookList* signalLookup;
+  static LookList* onThrowLookup;
+  static LookList* onCloseLookup;
+  static LookList* onActivateLookup;
+  static LookList* onDeactivateLookup;
+  static LookList* onRedLookup;
+  static LookList* onAmberLookup;
+  static LookList* onGreenLookup;
+  static LookList* onChangeLookup;
+  static LookList* onClockLookup;
@@ -255 +336 @@ private:
-   static LookList * onRotateLookup;
+  static LookList* onRotateLookup;
@@ -257,31 +338,31 @@ private:
-   static LookList * onOverloadLookup;
-   
-   static const int countLCCLookup;
-   static int onLCCLookup[];
-   static const byte compileFeatures;
-   static void manageRouteState(uint16_t id, byte state);
-   static void manageRouteCaption(uint16_t id, const FSH* caption);
-   static byte * routeStateArray;
-   static const FSH ** routeCaptionArray;
-   static int16_t * stashArray;
-   static int16_t maxStashId;
-    
-  // Local variables - exist for each instance/task 
-    RMFT2 *next;   // loop chain 
-    int progCounter;    // Byte offset of next route opcode in ROUTES table
-    unsigned long delayStart; // Used by opcodes that must be recalled before completing
-    unsigned long  delayTime;
-    union {
-      unsigned long waitAfter; // Used by OPCODE_AFTER
-      unsigned long timeoutStart; // Used by OPCODE_ATTIMEOUT
-      VPIN blinkPin;  // Used by blink tasks 
-    };
-    byte  taskId;
-    BlinkState blinkState; // includes AT_TIMEOUT flag. 
-    uint16_t loco;
-    bool forward;
-    bool invert;
-    byte speedo;
-    int onEventStartPosition;
-    byte stackDepth;
-    int callStack[MAX_STACK_DEPTH];
+  static LookList* onOverloadLookup;
+
+  static const int countLCCLookup;
+  static int onLCCLookup[];
+  static const byte compileFeatures;
+  static void manageRouteState(uint16_t id, byte state);
+  static void manageRouteCaption(uint16_t id, const FSH* caption);
+  static byte* routeStateArray;
+  static const FSH** routeCaptionArray;
+  static int16_t* stashArray;
+  static int16_t maxStashId;
+
+  // Local variables - exist for each instance/task
+  RMFT2* next;               // loop chain
+  int progCounter;           // Byte offset of next route opcode in ROUTES table
+  unsigned long delayStart;  // Used by opcodes that must be recalled before completing
+  unsigned long delayTime;
+  union {
+    unsigned long waitAfter;     // Used by OPCODE_AFTER
+    unsigned long timeoutStart;  // Used by OPCODE_ATTIMEOUT
+    VPIN blinkPin;               // Used by blink tasks
+  };
+  byte taskId;
+  BlinkState blinkState;  // includes AT_TIMEOUT flag.
+  uint16_t loco;
+  bool forward;
+  bool invert;
+  byte speedo;
+  int onEventStartPosition;
+  byte stackDepth;
+  int callStack[MAX_STACK_DEPTH];
@@ -290,2 +371,2 @@ private:
-#define GET_OPCODE GETHIGHFLASH(RMFT2::RouteCode,progCounter)
-#define SKIPOP progCounter+=3
+#define GET_OPCODE GETHIGHFLASH(RMFT2::RouteCode, progCounter)
+#define SKIPOP progCounter += 3
@@ -294,17 +375,17 @@ private:
-enum  : uint8_t{
-    DF_PLAY          = 0x0F,
-    DF_VOL           = 0x06,
-    DF_FOLDER        = 0x2B, // Not a DFPlayer command, used to set folder nr where audio file is
-    DF_REPEATPLAY    = 0x08,
-    DF_STOPPLAY      = 0x16,
-    DF_EQ            = 0x07, // Set equaliser, require parameter NORMAL, POP, ROCK, JAZZ, CLASSIC or BASS
-    DF_RESET         = 0x0C,
-    DF_DACON         = 0x1A,
-    DF_SETAM         = 0x2A, // Set audio mixer 1 or 2 for this DFPLayer   
-    DF_NORMAL        = 0x00, // Equalizer parameters
-    DF_POP           = 0x01,
-    DF_ROCK          = 0x02,
-    DF_JAZZ          = 0x03,
-    DF_CLASSIC       = 0x04,
-    DF_BASS          = 0x05,
-  };
+enum : uint8_t {
+  DF_PLAY = 0x0F,
+  DF_VOL = 0x06,
+  DF_FOLDER = 0x2B,  // Not a DFPlayer command, used to set folder nr where audio file is
+  DF_REPEATPLAY = 0x08,
+  DF_STOPPLAY = 0x16,
+  DF_EQ = 0x07,  // Set equaliser, require parameter NORMAL, POP, ROCK, JAZZ, CLASSIC or BASS
+  DF_RESET = 0x0C,
+  DF_DACON = 0x1A,
+  DF_SETAM = 0x2A,   // Set audio mixer 1 or 2 for this DFPLayer
+  DF_NORMAL = 0x00,  // Equalizer parameters
+  DF_POP = 0x01,
+  DF_ROCK = 0x02,
+  DF_JAZZ = 0x03,
+  DF_CLASSIC = 0x04,
+  DF_BASS = 0x05,
+};
diff --git a/EXRAIL2MacroReset.h b/EXRAIL2MacroReset.h
index 4db69df..53a4056 100644
--- a/EXRAIL2MacroReset.h
+++ b/EXRAIL2MacroReset.h
@@ -6 +6 @@
- *  
+ *
@@ -40 +40 @@
-#undef AUTOMATION 
+#undef AUTOMATION
@@ -44 +44 @@
-#undef CALL 
+#undef CALL
@@ -47 +47 @@
-#undef CLOSE 
+#undef CLOSE
@@ -56 +56 @@
-#undef DELAYRANDOM 
+#undef DELAYRANDOM
@@ -60,2 +60,2 @@
-#undef ENDEXRAIL 
-#undef ENDIF  
+#undef ENDEXRAIL
+#undef ENDIF
@@ -68,2 +68,2 @@
-#undef FOLLOW 
-#undef FON 
+#undef FOLLOW
+#undef FON
@@ -72,2 +72,2 @@
-#undef FREE 
-#undef FWD 
+#undef FREE
+#undef FWD
@@ -77 +77 @@
-#undef IF 
+#undef IF
@@ -85 +85 @@
-#undef IFRANDOM 
+#undef IFRANDOM
@@ -92 +92 @@
-#undef INVERT_DIRECTION 
+#undef INVERT_DIRECTION
@@ -94 +94 @@
-#undef JOIN 
+#undef JOIN
@@ -96,2 +96,2 @@
-#undef LATCH 
-#undef LCD 
+#undef LATCH
+#undef LCD
@@ -99,3 +99,3 @@
-#undef LCC 
-#undef LCCX 
-#undef LCN 
+#undef LCC
+#undef LCCX
+#undef LCN
@@ -115 +115 @@
-#undef ONDEACTIVATEL 
+#undef ONDEACTIVATEL
@@ -127 +127 @@
-#undef ONTHROW 
+#undef ONTHROW
@@ -132 +132 @@
-#undef PIN_TURNOUT 
+#undef PIN_TURNOUT
@@ -139,6 +139,6 @@
-#undef READ_LOCO 
-#undef RED 
-#undef RESERVE 
-#undef RESET 
-#undef RESUME 
-#undef RETURN 
+#undef READ_LOCO
+#undef RED
+#undef RESERVE
+#undef RESET
+#undef RESUME
+#undef RETURN
@@ -155,12 +155,12 @@
-#undef SENDLOCO 
-#undef SEQUENCE 
-#undef SERIAL 
-#undef SERIAL1 
-#undef SERIAL2 
-#undef SERIAL3 
-#undef SERIAL4 
-#undef SERIAL5 
-#undef SERIAL6 
-#undef SERVO 
-#undef SERVO2 
-#undef SERVO_TURNOUT 
+#undef SENDLOCO
+#undef SEQUENCE
+#undef SERIAL
+#undef SERIAL1
+#undef SERIAL2
+#undef SERIAL3
+#undef SERIAL4
+#undef SERIAL5
+#undef SERIAL6
+#undef SERVO
+#undef SERVO2
+#undef SERVO_TURNOUT
@@ -171 +171 @@
-#undef SETLOCO 
+#undef SETLOCO
@@ -173,4 +173,4 @@
-#undef SIGNAL 
-#undef SIGNALH 
-#undef SPEED 
-#undef START 
+#undef SIGNAL
+#undef SIGNALH
+#undef SPEED
+#undef START
@@ -180 +180 @@
-#undef STOP 
+#undef STOP
@@ -184 +184 @@
-#undef TURNOUT 
+#undef TURNOUT
@@ -187 +187 @@
-#undef UNLATCH 
+#undef UNLATCH
@@ -202 +202 @@
-#define ACTIVATE(addr,subaddr)
+#define ACTIVATE(addr, subaddr)
@@ -204 +204 @@
-#define AFTER(sensor_id,timer...)
+#define AFTER(sensor_id, timer...)
@@ -206 +206 @@
-#define ALIAS(name,value...)
+#define ALIAS(name, value...)
@@ -208 +208 @@
-#define ANOUT(vpin,value,param1,param2)
+#define ANOUT(vpin, value, param1, param2)
@@ -210,5 +210,5 @@
-#define ASPECT(address,value)
-#define ATGTE(sensor_id,value) 
-#define ATLT(sensor_id,value) 
-#define ATTIMEOUT(sensor_id,timeout_ms)
-#define AUTOMATION(id,description) 
+#define ASPECT(address, value)
+#define ATGTE(sensor_id, value)
+#define ATLT(sensor_id, value)
+#define ATTIMEOUT(sensor_id, timeout_ms)
+#define AUTOMATION(id, description)
@@ -216 +216 @@
-#define BLINK(vpin,onDuty,offDuty)
+#define BLINK(vpin, onDuty, offDuty)
@@ -222,5 +222,5 @@
-#define CONFIGURE_SERVO(vpin,pos1,pos2,profile) 
-#define DCC_SIGNAL(id,add,subaddr)
-#define DCCX_SIGNAL(id,redAspect,amberAspect,greenAspect)
-#define DCC_TURNTABLE(id,home,description...)
-#define DEACTIVATE(addr,subaddr)
+#define CONFIGURE_SERVO(vpin, pos1, pos2, profile)
+#define DCC_SIGNAL(id, add, subaddr)
+#define DCCX_SIGNAL(id, redAspect, amberAspect, greenAspect)
+#define DCC_TURNTABLE(id, home, description...)
+#define DEACTIVATE(addr, subaddr)
@@ -230 +230 @@
-#define DELAYRANDOM(mindelay,maxdelay) 
+#define DELAYRANDOM(mindelay, maxdelay)
@@ -234,2 +234,2 @@
-#define ENDEXRAIL 
-#define ENDIF  
+#define ENDEXRAIL
+#define ENDIF
@@ -237 +237 @@
-#define ESTOP 
+#define ESTOP
@@ -239,2 +239,2 @@
-#define EXTT_TURNTABLE(id,vpin,home,description...)
-#define FADE(pin,value,ms)
+#define EXTT_TURNTABLE(id, vpin, home, description...)
+#define FADE(pin, value, ms)
@@ -242 +242 @@
-#define FOLLOW(route) 
+#define FOLLOW(route)
@@ -245 +245 @@
-#define FREE(blockid) 
+#define FREE(blockid)
@@ -247 +247 @@
-#define FWD(speed) 
+#define FWD(speed)
@@ -249 +249 @@
-#define HAL(haltype,params...)
+#define HAL(haltype, params...)
@@ -251 +251 @@
-#define IF(sensor_id) 
+#define IF(sensor_id)
@@ -253 +253 @@
-#define IFCLOSED(turnout_id) 
+#define IFCLOSED(turnout_id)
@@ -255 +255 @@
-#define IFGTE(sensor_id,value) 
+#define IFGTE(sensor_id, value)
@@ -257 +257 @@
-#define IFLT(sensor_id,value) 
+#define IFLT(sensor_id, value)
@@ -261 +261 @@
-#define IFTHROWN(turnout_id) 
+#define IFTHROWN(turnout_id)
@@ -264,5 +264,5 @@
-#define IFTTPOSITION(turntable_id,position)
-#define IFRE(sensor_id,value)
-#define INVERT_DIRECTION 
-#define JMRI_SENSOR(vpin,count...)
-#define JOIN 
+#define IFTTPOSITION(turntable_id, position)
+#define IFRE(sensor_id, value)
+#define INVERT_DIRECTION
+#define JMRI_SENSOR(vpin, count...)
+#define JOIN
@@ -271,5 +271,5 @@
-#define LCC(eventid) 
-#define LCCX(senderid,eventid) 
-#define LCD(row,msg)
-#define SCREEN(display,row,msg)
-#define LCN(msg) 
+#define LCC(eventid)
+#define LCCX(senderid, eventid)
+#define LCD(row, msg)
+#define SCREEN(display, row, msg)
+#define LCN(msg)
@@ -277,3 +277,3 @@
-#define MOVETT(id,steps,activity)
-#define NEOPIXEL(id,r,g,b,count...)
-#define NEOPIXEL_SIGNAL(sigid,redcolour,ambercolour,greencolour)
+#define MOVETT(id, steps, activity)
+#define NEOPIXEL(id, r, g, b, count...)
+#define NEOPIXEL_SIGNAL(sigid, redcolour, ambercolour, greencolour)
@@ -284 +284 @@
-#define ONACTIVATE(addr,subaddr)
+#define ONACTIVATE(addr, subaddr)
@@ -286 +286 @@
-#define ONAMBER(signal_id) 
+#define ONAMBER(signal_id)
@@ -288 +288 @@
-#define ONCLOCKTIME(hours,mins)
+#define ONCLOCKTIME(hours, mins)
@@ -291,2 +291,2 @@
-#define ONDEACTIVATE(addr,subaddr)
-#define ONDEACTIVATEL(linear) 
+#define ONDEACTIVATE(addr, subaddr)
+#define ONDEACTIVATEL(linear)
@@ -294,2 +294,2 @@
-#define ONLCC(sender,event)
-#define ONGREEN(signal_id) 
+#define ONLCC(sender, event)
+#define ONGREEN(signal_id)
@@ -298 +298 @@
-#define ONTHROW(turnout_id) 
+#define ONTHROW(turnout_id)
@@ -303,2 +303,2 @@
-#define PIN_TURNOUT(id,pin,description...) 
-#define PRINT(msg) 
+#define PIN_TURNOUT(id, pin, description...)
+#define PRINT(msg)
@@ -308 +308 @@
-#define POM(cv,value)
+#define POM(cv, value)
@@ -312,11 +312,11 @@
-#define READ_LOCO 
-#define RED(signal_id) 
-#define RESERVE(blockid) 
-#define RESET(pin,count...) 
-#define RESUME 
-#define RETURN 
-#define REV(speed) 
-#define ROTATE(turntable_id,position,activity)
-#define ROTATE_DCC(turntable_id,position)
-#define ROSTER(cab,name,funcmap...)
-#define ROUTE(id,description)
+#define READ_LOCO
+#define RED(signal_id)
+#define RESERVE(blockid)
+#define RESET(pin, count...)
+#define RESUME
+#define RETURN
+#define REV(speed)
+#define ROTATE(turntable_id, position, activity)
+#define ROTATE_DCC(turntable_id, position)
+#define ROSTER(cab, name, funcmap...)
+#define ROUTE(id, description)
@@ -327,18 +327,18 @@
-#define ROUTE_CAPTION(id,caption)
-#define SENDLOCO(cab,route) 
-#define SEQUENCE(id) 
-#define SERIAL(msg) 
-#define SERIAL1(msg) 
-#define SERIAL2(msg) 
-#define SERIAL3(msg) 
-#define SERIAL4(msg) 
-#define SERIAL5(msg) 
-#define SERIAL6(msg) 
-#define SERVO(id,position,profile) 
-#define SERVO2(id,position,duration) 
-#define SERVO_SIGNAL(vpin,redpos,amberpos,greenpos)
-#define SERVO_TURNOUT(id,pin,activeAngle,inactiveAngle,profile,description...) 
-#define SET(pin,count...) 
-#define SET_TRACK(track,mode)
-#define SET_POWER(track,onoff)
-#define SETLOCO(loco) 
+#define ROUTE_CAPTION(id, caption)
+#define SENDLOCO(cab, route)
+#define SEQUENCE(id)
+#define SERIAL(msg)
+#define SERIAL1(msg)
+#define SERIAL2(msg)
+#define SERIAL3(msg)
+#define SERIAL4(msg)
+#define SERIAL5(msg)
+#define SERIAL6(msg)
+#define SERVO(id, position, profile)
+#define SERVO2(id, position, duration)
+#define SERVO_SIGNAL(vpin, redpos, amberpos, greenpos)
+#define SERVO_TURNOUT(id, pin, activeAngle, inactiveAngle, profile, description...)
+#define SET(pin, count...)
+#define SET_TRACK(track, mode)
+#define SET_POWER(track, onoff)
+#define SETLOCO(loco)
@@ -346,3 +346,3 @@
-#define SIGNAL(redpin,amberpin,greenpin) 
-#define SIGNALH(redpin,amberpin,greenpin) 
-#define SPEED(speed) 
+#define SIGNAL(redpin, amberpin, greenpin)
+#define SIGNALH(redpin, amberpin, greenpin)
+#define SPEED(speed)
@@ -350 +350 @@
-#define STASH(id) 
+#define STASH(id)
@@ -353 +353 @@
-#define STOP 
+#define STOP
@@ -356,7 +356,7 @@
-#define TT_ADDPOSITION(turntable_id,position,value,angle,description...)
-#define TURNOUT(id,addr,subaddr,description...) 
-#define TURNOUTL(id,addr,description...) 
-#define UNJOIN 
-#define UNLATCH(sensor_id) 
-#define VIRTUAL_SIGNAL(id) 
-#define VIRTUAL_TURNOUT(id,description...) 
+#define TT_ADDPOSITION(turntable_id, position, value, angle, description...)
+#define TURNOUT(id, addr, subaddr, description...)
+#define TURNOUTL(id, addr, description...)
+#define UNJOIN
+#define UNLATCH(sensor_id)
+#define VIRTUAL_SIGNAL(id)
+#define VIRTUAL_TURNOUT(id, description...)
@@ -368,5 +368,5 @@
-#define XFOFF(cab,func)
-#define XFON(cab,func)
-#define XFTOGGLE(cab,func)
-#define XFWD(cab,speed)
-#define XREV(cab,speed)
+#define XFOFF(cab, func)
+#define XFON(cab, func)
+#define XFTOGGLE(cab, func)
+#define XFWD(cab, speed)
+#define XREV(cab, speed)
diff --git a/EXRAIL2Parser.cpp b/EXRAIL2Parser.cpp
index 63bace0..da92939 100644
--- a/EXRAIL2Parser.cpp
+++ b/EXRAIL2Parser.cpp
@@ -7 +7 @@
- *  
+ *
@@ -24 +24 @@
-// THIS file is an extension of the RMFT2 class 
+// THIS file is an extension of the RMFT2 class
@@ -37,105 +37,8 @@
-void RMFT2::ComandFilter(Print * stream, byte & opcode, byte & paramCount, int16_t p[]) {
-  (void)stream; // avoid compiler warning if we don't access this parameter
-  
-  switch(opcode) {
-    
-  case 'D':
-    if (p[0]=="EXRAIL"_hk) { // <D EXRAIL ON/OFF>
-      diag = paramCount==2 && (p[1]=="ON"_hk || p[1]==1);
-      opcode=0;
-    }
-    break;
-	
-  case '/':  // New EXRAIL command
-    if (parseSlash(stream,paramCount,p)) opcode=0;
-    break;
-  
-  case 'A': //  <A address aspect>
-    if (paramCount!=2) break; 
-    // Ask exrail if this is just changing the aspect on a 
-    // predefined DCCX_SIGNAL. Because this will handle all 
-    // the IFRED and ONRED type issues at the same time.  
-    if (signalAspectEvent(p[0],p[1])) opcode=0; // all done 
-    break;
-
-  case 'L':
-    // This entire code block is compiled out if LLC macros not used 
-    if (!(compileFeatures & FEATURE_LCC)) return;
-    static int lccProgCounter=0;
-    static int lccEventIndex=0;
-      
-    if (paramCount==0) {  //<L>  LCC adapter introducing self
-      LCCSerial=stream;   // now we know where to send events we raise
-      opcode=0;  // flag command as intercepted
-
-      // loop through all possible sent/waited events 
-      for (int progCounter=lccProgCounter;; SKIPOP) {
-        byte exrailOpcode=GET_OPCODE;
-        switch (exrailOpcode) {
-          case OPCODE_ENDEXRAIL:
-               stream->print(F("<LR>\n")); // ready to roll
-               lccProgCounter=0; // allow a second pass
-               lccEventIndex=0;
-               return;
-
-          case OPCODE_LCC:  
-               StringFormatter::send(stream,F("<LS x%h>\n"),getOperand(progCounter,0));
-               SKIPOP;
-               lccProgCounter=progCounter; 
-               return;
-
-          case OPCODE_LCCX:  // long form LCC
-               StringFormatter::send(stream,F("<LS x%h%h%h%h>\n"),
-                 getOperand(progCounter,1),
-                 getOperand(progCounter,2),
-                 getOperand(progCounter,3),
-                 getOperand(progCounter,0)
-                 );
-               SKIPOP;SKIPOP;SKIPOP;SKIPOP;          
-               lccProgCounter=progCounter; 
-               return;
-
-          case OPCODE_ACON:  // CBUS ACON 
-          case OPCODE_ACOF:  // CBUS ACOF 
-                StringFormatter::send(stream,F("<LS x%c%h%h>\n"),
-                  exrailOpcode==OPCODE_ACOF?'1':'0',
-                  getOperand(progCounter,0),getOperand(progCounter,1)); 
-               SKIPOP;SKIPOP;
-               lccProgCounter=progCounter; 
-               return;
-      
-      // we stream the hex events we wish to listen to
-      // and at the same time build the event index looku.
-      
-        case OPCODE_ONLCC:
-           StringFormatter::send(stream,F("<LL %d x%h%h%h:%h>\n"),
-                 lccEventIndex,
-                 getOperand(progCounter,1),
-                 getOperand(progCounter,2),
-                 getOperand(progCounter,3),
-                 getOperand(progCounter,0)
-                 );   
-           SKIPOP;SKIPOP;SKIPOP;SKIPOP;      
-           // start on handler at next      
-           onLCCLookup[lccEventIndex]=progCounter; 
-           lccEventIndex++;        
-           lccProgCounter=progCounter; 
-           return;
-
-        case OPCODE_ONACON:
-        case OPCODE_ONACOF:
-           StringFormatter::send(stream,F("<LL %d x%c%h%h>\n"),
-                 lccEventIndex,
-                 exrailOpcode==OPCODE_ONACOF?'1':'0',
-                 getOperand(progCounter,0),getOperand(progCounter,1)
-                 ); 
-           SKIPOP;SKIPOP;
-           // start on handler at next      
-           onLCCLookup[lccEventIndex]=progCounter; 
-           lccEventIndex++;        
-           lccProgCounter=progCounter; 
-           return;
-           
-         default:
-           break;
-        }  
+void RMFT2::ComandFilter(Print* stream, byte& opcode, byte& paramCount, int16_t p[]) {
+  (void)stream;  // avoid compiler warning if we don't access this parameter
+
+  switch (opcode) {
+    case 'D':
+      if (p[0] == "EXRAIL"_hk) {  // <D EXRAIL ON/OFF>
+        diag = paramCount == 2 && (p[1] == "ON"_hk || p[1] == 1);
+        opcode = 0;
@@ -143,4 +46,99 @@ void RMFT2::ComandFilter(Print * stream, byte & opcode, byte & paramCount, int16
-    }
-    if (paramCount==1) {  // <L eventid> LCC event arrived from adapter
-        int16_t eventid=p[0];
-        bool reject = eventid<0 || eventid>=countLCCLookup;
+      break;
+
+    case '/':  // New EXRAIL command
+      if (parseSlash(stream, paramCount, p))
+        opcode = 0;
+      break;
+
+    case 'A':  //  <A address aspect>
+      if (paramCount != 2)
+        break;
+      // Ask exrail if this is just changing the aspect on a
+      // predefined DCCX_SIGNAL. Because this will handle all
+      // the IFRED and ONRED type issues at the same time.
+      if (signalAspectEvent(p[0], p[1]))
+        opcode = 0;  // all done
+      break;
+
+    case 'L':
+      // This entire code block is compiled out if LLC macros not used
+      if (!(compileFeatures & FEATURE_LCC))
+        return;
+      static int lccProgCounter = 0;
+      static int lccEventIndex = 0;
+
+      if (paramCount == 0) {  //<L>  LCC adapter introducing self
+        LCCSerial = stream;   // now we know where to send events we raise
+        opcode = 0;           // flag command as intercepted
+
+        // loop through all possible sent/waited events
+        for (int progCounter = lccProgCounter;; SKIPOP) {
+          byte exrailOpcode = GET_OPCODE;
+          switch (exrailOpcode) {
+            case OPCODE_ENDEXRAIL:
+              stream->print(F("<LR>\n"));  // ready to roll
+              lccProgCounter = 0;          // allow a second pass
+              lccEventIndex = 0;
+              return;
+
+            case OPCODE_LCC:
+              StringFormatter::send(stream, F("<LS x%h>\n"), getOperand(progCounter, 0));
+              SKIPOP;
+              lccProgCounter = progCounter;
+              return;
+
+            case OPCODE_LCCX:  // long form LCC
+              StringFormatter::send(stream, F("<LS x%h%h%h%h>\n"), getOperand(progCounter, 1), getOperand(progCounter, 2), getOperand(progCounter, 3),
+                                    getOperand(progCounter, 0));
+              SKIPOP;
+              SKIPOP;
+              SKIPOP;
+              SKIPOP;
+              lccProgCounter = progCounter;
+              return;
+
+            case OPCODE_ACON:  // CBUS ACON
+            case OPCODE_ACOF:  // CBUS ACOF
+              StringFormatter::send(stream, F("<LS x%c%h%h>\n"), exrailOpcode == OPCODE_ACOF ? '1' : '0', getOperand(progCounter, 0),
+                                    getOperand(progCounter, 1));
+              SKIPOP;
+              SKIPOP;
+              lccProgCounter = progCounter;
+              return;
+
+              // we stream the hex events we wish to listen to
+              // and at the same time build the event index looku.
+
+            case OPCODE_ONLCC:
+              StringFormatter::send(stream, F("<LL %d x%h%h%h:%h>\n"), lccEventIndex, getOperand(progCounter, 1), getOperand(progCounter, 2),
+                                    getOperand(progCounter, 3), getOperand(progCounter, 0));
+              SKIPOP;
+              SKIPOP;
+              SKIPOP;
+              SKIPOP;
+              // start on handler at next
+              onLCCLookup[lccEventIndex] = progCounter;
+              lccEventIndex++;
+              lccProgCounter = progCounter;
+              return;
+
+            case OPCODE_ONACON:
+            case OPCODE_ONACOF:
+              StringFormatter::send(stream, F("<LL %d x%c%h%h>\n"), lccEventIndex, exrailOpcode == OPCODE_ONACOF ? '1' : '0',
+                                    getOperand(progCounter, 0), getOperand(progCounter, 1));
+              SKIPOP;
+              SKIPOP;
+              // start on handler at next
+              onLCCLookup[lccEventIndex] = progCounter;
+              lccEventIndex++;
+              lccProgCounter = progCounter;
+              return;
+
+            default:
+              break;
+          }
+        }
+      }
+      if (paramCount == 1) {  // <L eventid> LCC event arrived from adapter
+        int16_t eventid = p[0];
+        bool reject = eventid < 0 || eventid >= countLCCLookup;
@@ -148,2 +146,2 @@ void RMFT2::ComandFilter(Print * stream, byte & opcode, byte & paramCount, int16
-          startNonRecursiveTask(F("LCC"),eventid,onLCCLookup[eventid]);
-          opcode=0;
+          startNonRecursiveTask(F("LCC"), eventid, onLCCLookup[eventid]);
+          opcode = 0;
@@ -151,3 +149,3 @@ void RMFT2::ComandFilter(Print * stream, byte & opcode, byte & paramCount, int16
-    }
-    break; 
-    
+      }
+      break;
+
@@ -155,24 +153,23 @@ void RMFT2::ComandFilter(Print * stream, byte & opcode, byte & paramCount, int16
-        if (paramCount<1) return; 
-        switch(p[0]) {
-          case "A"_hk: // <JA> returns automations/routes
-            if (paramCount==1) {// <JA>
-              StringFormatter::send(stream, F("<jA"));
-              routeLookup->stream(stream);
-              StringFormatter::send(stream, F(">\n"));
-              opcode=0;
-              return; 
-            }
-            if (paramCount==2) {  // <JA id>
-              int16_t id=p[1];
-              StringFormatter::send(stream,F("<jA %d %c \"%S\">\n"), 
-                id, getRouteType(id), getRouteDescription(id));
-              
-              if (compileFeatures & FEATURE_ROUTESTATE) {
-                // Send any non-default button states or captions
-                int16_t statePos=routeLookup->findPosition(id);
-                if (statePos>=0) {
-                 if (routeStateArray[statePos]) 
-                 StringFormatter::send(stream,F("<jB %d %d>\n"), id, routeStateArray[statePos]);
-                  if (routeCaptionArray[statePos]) 
-                  StringFormatter::send(stream,F("<jB %d \"%S\">\n"), id,routeCaptionArray[statePos]);
-                }
+      if (paramCount < 1)
+        return;
+      switch (p[0]) {
+        case "A"_hk:              // <JA> returns automations/routes
+          if (paramCount == 1) {  // <JA>
+            StringFormatter::send(stream, F("<jA"));
+            routeLookup->stream(stream);
+            StringFormatter::send(stream, F(">\n"));
+            opcode = 0;
+            return;
+          }
+          if (paramCount == 2) {  // <JA id>
+            int16_t id = p[1];
+            StringFormatter::send(stream, F("<jA %d %c \"%S\">\n"), id, getRouteType(id), getRouteDescription(id));
+
+            if (compileFeatures & FEATURE_ROUTESTATE) {
+              // Send any non-default button states or captions
+              int16_t statePos = routeLookup->findPosition(id);
+              if (statePos >= 0) {
+                if (routeStateArray[statePos])
+                  StringFormatter::send(stream, F("<jB %d %d>\n"), id, routeStateArray[statePos]);
+                if (routeCaptionArray[statePos])
+                  StringFormatter::send(stream, F("<jB %d \"%S\">\n"), id, routeCaptionArray[statePos]);
@@ -180,2 +176,0 @@ void RMFT2::ComandFilter(Print * stream, byte & opcode, byte & paramCount, int16
-              opcode=0;
-              return;
@@ -183 +178,4 @@ void RMFT2::ComandFilter(Print * stream, byte & opcode, byte & paramCount, int16
-            break;
+            opcode = 0;
+            return;
+          }
+          break;
@@ -185,8 +183,13 @@ void RMFT2::ComandFilter(Print * stream, byte & opcode, byte & paramCount, int16
-            // NOTE: we only need to handle valid calls here because 
-            // DCCEXParser has to have code to handle the <J<> cases where
-            // exrail isnt involved anyway. 
-            // This entire code block is compiled out if STASH macros not used 
-          if (!(compileFeatures & FEATURE_STASH)) return;
-          if (paramCount==1) { // <JM>
-              StringFormatter::send(stream,F("<jM %d>\n"),maxStashId);
-              opcode=0;
+          // NOTE: we only need to handle valid calls here because
+          // DCCEXParser has to have code to handle the <J<> cases where
+          // exrail isnt involved anyway.
+          // This entire code block is compiled out if STASH macros not used
+          if (!(compileFeatures & FEATURE_STASH))
+            return;
+          if (paramCount == 1) {  // <JM>
+            StringFormatter::send(stream, F("<jM %d>\n"), maxStashId);
+            opcode = 0;
+            break;
+          }
+          if (paramCount == 2) {  // <JM id>
+            if (p[1] <= 0 || p[1] > maxStashId)
@@ -194,13 +197,3 @@ void RMFT2::ComandFilter(Print * stream, byte & opcode, byte & paramCount, int16
-            } 
-          if (paramCount==2) {  // <JM id>
-              if (p[1]<=0 || p[1]>maxStashId) break;
-              StringFormatter::send(stream,F("<jM %d %d>\n"),
-                    p[1],stashArray[p[1]]);
-               opcode=0;     
-               break;    
-          } 
-          if (paramCount==3) {  // <JM id cab>
-              if (p[1]<=0 || p[1]>maxStashId) break;
-              stashArray[p[1]]=p[2];
-              opcode=0;
-              break;      
+            StringFormatter::send(stream, F("<jM %d %d>\n"), p[1], stashArray[p[1]]);
+            opcode = 0;
+            break;
@@ -208 +201,8 @@ void RMFT2::ComandFilter(Print * stream, byte & opcode, byte & paramCount, int16
-          break; 
+          if (paramCount == 3) {  // <JM id cab>
+            if (p[1] <= 0 || p[1] > maxStashId)
+              break;
+            stashArray[p[1]] = p[2];
+            opcode = 0;
+            break;
+          }
+          break;
@@ -211,4 +211,4 @@ void RMFT2::ComandFilter(Print * stream, byte & opcode, byte & paramCount, int16
-            break;
-        }
-  default:  // other commands pass through
-    break;
+          break;
+      }
+    default:  // other commands pass through
+      break;
@@ -218,3 +218,2 @@ void RMFT2::ComandFilter(Print * stream, byte & opcode, byte & paramCount, int16
-bool RMFT2::parseSlash(Print * stream, byte & paramCount, int16_t p[]) {
-
-  if (paramCount==0) { // STATUS
+bool RMFT2::parseSlash(Print* stream, byte& paramCount, int16_t p[]) {
+  if (paramCount == 0) {  // STATUS
@@ -222,7 +221,7 @@ bool RMFT2::parseSlash(Print * stream, byte & paramCount, int16_t p[]) {
-    RMFT2 * task=loopTask;
-    while(task) {
-      if ((compileFeatures & FEATURE_BLINK)
-       && (task->blinkState==blink_high || task->blinkState==blink_low)) {
-        StringFormatter::send(stream,F("\nID=%d,PC=%d,BLINK=%d"),
-			    (int)(task->taskId),task->progCounter,task->blinkPin
-			    );
+    RMFT2* task = loopTask;
+    while (task) {
+      if ((compileFeatures & FEATURE_BLINK) && (task->blinkState == blink_high || task->blinkState == blink_low)) {
+        StringFormatter::send(stream, F("\nID=%d,PC=%d,BLINK=%d"), (int)(task->taskId), task->progCounter, task->blinkPin);
+      } else {
+        StringFormatter::send(stream, F("\nID=%d,PC=%d,LOCO=%d%c,SPEED=%d%c"), (int)(task->taskId), task->progCounter, task->loco,
+                              task->invert ? 'I' : ' ', task->speedo, task->forward ? 'F' : 'R');
@@ -230,10 +229,3 @@ bool RMFT2::parseSlash(Print * stream, byte & paramCount, int16_t p[]) {
-      else {
-      StringFormatter::send(stream,F("\nID=%d,PC=%d,LOCO=%d%c,SPEED=%d%c"),
-			    (int)(task->taskId),task->progCounter,task->loco,
-			    task->invert?'I':' ',
-			    task->speedo,
-			    task->forward?'F':'R'
-			    );
-      }
-      task=task->next;
-      if (task==loopTask) break;
+      task = task->next;
+      if (task == loopTask)
+        break;
@@ -242,6 +234,8 @@ bool RMFT2::parseSlash(Print * stream, byte & paramCount, int16_t p[]) {
-    for (int id=0;id<MAX_FLAGS; id++) {
-      byte flag=flags[id];
-      if (flag & ~TASK_FLAG & ~SIGNAL_MASK) { // not interested in TASK_FLAG only. Already shown above
-	      StringFormatter::send(stream,F("\nflags[%d] "),id);
-	      if (flag & SECTION_FLAG) StringFormatter::send(stream,F(" RESERVED"));
-	      if (flag & LATCH_FLAG) StringFormatter::send(stream,F(" LATCHED"));
+    for (int id = 0; id < MAX_FLAGS; id++) {
+      byte flag = flags[id];
+      if (flag & ~TASK_FLAG & ~SIGNAL_MASK) {  // not interested in TASK_FLAG only. Already shown above
+        StringFormatter::send(stream, F("\nflags[%d] "), id);
+        if (flag & SECTION_FLAG)
+          StringFormatter::send(stream, F(" RESERVED"));
+        if (flag & LATCH_FLAG)
+          StringFormatter::send(stream, F(" LATCHED"));
@@ -253,10 +247,10 @@ bool RMFT2::parseSlash(Print * stream, byte & paramCount, int16_t p[]) {
-      // flags[n] represents the state of the nth signal in the table 
-      for (int sigslot=0;;sigslot++) {
-        SIGNAL_DEFINITION slot=getSignalSlot(sigslot);
-        if (slot.type==sigtypeNoMoreSignals) break; // end of signal list
-	      if (slot.type==sigtypeContinuation) continue; // continueation of previous line
-	      byte flag=flags[sigslot] & SIGNAL_MASK; // obtain signal flags for this ids
-        StringFormatter::send(stream,F("\n%S[%d]"), 
-			      (flag == SIGNAL_RED)? F("RED") : (flag==SIGNAL_GREEN) ? F("GREEN") : F("AMBER"),
-			      slot.id);
-      } 
+      // flags[n] represents the state of the nth signal in the table
+      for (int sigslot = 0;; sigslot++) {
+        SIGNAL_DEFINITION slot = getSignalSlot(sigslot);
+        if (slot.type == sigtypeNoMoreSignals)
+          break;  // end of signal list
+        if (slot.type == sigtypeContinuation)
+          continue;                                // continueation of previous line
+        byte flag = flags[sigslot] & SIGNAL_MASK;  // obtain signal flags for this ids
+        StringFormatter::send(stream, F("\n%S[%d]"), (flag == SIGNAL_RED) ? F("RED") : (flag == SIGNAL_GREEN) ? F("GREEN") : F("AMBER"), slot.id);
+      }
@@ -266 +260 @@ bool RMFT2::parseSlash(Print * stream, byte & paramCount, int16_t p[]) {
-      for (int i=1;i<=maxStashId;i++) {
+      for (int i = 1; i <= maxStashId; i++) {
@@ -268,3 +262,2 @@ bool RMFT2::parseSlash(Print * stream, byte & paramCount, int16_t p[]) {
-          StringFormatter::send(stream,F("\nSTASH[%d] Loco=%d"),
-              i, stashArray[i]); 
-      } 
+          StringFormatter::send(stream, F("\nSTASH[%d] Loco=%d"), i, stashArray[i]);
+      }
@@ -272,2 +265,2 @@ bool RMFT2::parseSlash(Print * stream, byte & paramCount, int16_t p[]) {
-    
-    StringFormatter::send(stream,F(" *>\n"));
+
+    StringFormatter::send(stream, F(" *>\n"));
@@ -277,15 +270,20 @@ bool RMFT2::parseSlash(Print * stream, byte & paramCount, int16_t p[]) {
-  case "PAUSE"_hk: // </ PAUSE>
-    if (paramCount!=1) return false;
-    DCC::setThrottle(0,1,true);  // pause all locos on the track
-    pausingTask=(RMFT2 *)1; // Impossible task address
-    return true;
-    
-  case "RESUME"_hk: // </ RESUME>
-    if (paramCount!=1) return false;
-    pausingTask=NULL;
-    {
-      RMFT2 * task=loopTask;
-      while(task) {
-	if (task->loco) task->driveLoco(task->speedo);
-	task=task->next;
-	if (task==loopTask) break;
+    case "PAUSE"_hk:  // </ PAUSE>
+      if (paramCount != 1)
+        return false;
+      DCC::setThrottle(0, 1, true);  // pause all locos on the track
+      pausingTask = (RMFT2*)1;       // Impossible task address
+      return true;
+
+    case "RESUME"_hk:  // </ RESUME>
+      if (paramCount != 1)
+        return false;
+      pausingTask = NULL;
+      {
+        RMFT2* task = loopTask;
+        while (task) {
+          if (task->loco)
+            task->driveLoco(task->speedo);
+          task = task->next;
+          if (task == loopTask)
+            break;
+        }
@@ -293,18 +291,18 @@ bool RMFT2::parseSlash(Print * stream, byte & paramCount, int16_t p[]) {
-    }
-    return true;
-    
-    
-  case "START"_hk: // </ START [cab] route >
-    if (paramCount<2 || paramCount>3) return false;
-    {
-      int route=(paramCount==2) ? p[1] : p[2];
-      uint16_t cab=(paramCount==2)? 0 : p[1];
-      int pc=routeLookup->find(route);
-      if (pc<0) return false;
-      RMFT2* task=new RMFT2(pc);
-      task->loco=cab;
-    }
-    return true;
-    
-  default:
-    break;
+      return true;
+
+    case "START"_hk:  // </ START [cab] route >
+      if (paramCount < 2 || paramCount > 3)
+        return false;
+      {
+        int route = (paramCount == 2) ? p[1] : p[2];
+        uint16_t cab = (paramCount == 2) ? 0 : p[1];
+        int pc = routeLookup->find(route);
+        if (pc < 0)
+          return false;
+        RMFT2* task = new RMFT2(pc);
+        task->loco = cab;
+      }
+      return true;
+
+    default:
+      break;
@@ -313,4 +311,4 @@ bool RMFT2::parseSlash(Print * stream, byte & paramCount, int16_t p[]) {
-  // check KILL ALL here, otherwise the next validation confuses ALL with a flag  
-  if (p[0]=="KILL"_hk && p[1]=="ALL"_hk) {
-    while (loopTask) loopTask->kill(F("KILL ALL")); // destructor changes loopTask
-    return true;   
+  // check KILL ALL here, otherwise the next validation confuses ALL with a flag
+  if (p[0] == "KILL"_hk && p[1] == "ALL"_hk) {
+    while (loopTask) loopTask->kill(F("KILL ALL"));  // destructor changes loopTask
+    return true;
@@ -320,2 +318,3 @@ bool RMFT2::parseSlash(Print * stream, byte & paramCount, int16_t p[]) {
-  if (paramCount!=2 ) return false;
-  
+  if (paramCount != 2)
+    return false;
+
@@ -323 +322 @@ bool RMFT2::parseSlash(Print * stream, byte & paramCount, int16_t p[]) {
-  case "KILL"_hk: // Kill taskid|ALL
+    case "KILL"_hk:  // Kill taskid|ALL
@@ -325,9 +324,11 @@ bool RMFT2::parseSlash(Print * stream, byte & paramCount, int16_t p[]) {
-    if ( p[1]<0  || p[1]>=MAX_FLAGS) return false;
-    RMFT2 * task=loopTask;
-      while(task) {
-	      if (task->taskId==p[1]) {
-	        task->kill(F("KILL"));
-	        return  true;
-	      }
-	      task=task->next;
-	      if (task==loopTask) break;
+      if (p[1] < 0 || p[1] >= MAX_FLAGS)
+        return false;
+      RMFT2* task = loopTask;
+      while (task) {
+        if (task->taskId == p[1]) {
+          task->kill(F("KILL"));
+          return true;
+        }
+        task = task->next;
+        if (task == loopTask)
+          break;
@@ -336,28 +337,28 @@ bool RMFT2::parseSlash(Print * stream, byte & paramCount, int16_t p[]) {
-    return false;
-    
-  case "RESERVE"_hk:  // force reserve a section
-    return setFlag(p[1],SECTION_FLAG);
-    
-  case "FREE"_hk:  // force free a section
-    return setFlag(p[1],0,SECTION_FLAG);
-    
-  case "LATCH"_hk:
-    return setFlag(p[1], LATCH_FLAG);
-    
-  case "UNLATCH"_hk:
-    return setFlag(p[1], 0, LATCH_FLAG);
- 
-  case "RED"_hk:
-    doSignal(p[1],SIGNAL_RED);
-    return true;
- 
-  case "AMBER"_hk:
-    doSignal(p[1],SIGNAL_AMBER);
-    return true;
- 
-  case "GREEN"_hk:
-    doSignal(p[1],SIGNAL_GREEN);
-    return true;
-    
-  default:
-    return false;
+      return false;
+
+    case "RESERVE"_hk:  // force reserve a section
+      return setFlag(p[1], SECTION_FLAG);
+
+    case "FREE"_hk:  // force free a section
+      return setFlag(p[1], 0, SECTION_FLAG);
+
+    case "LATCH"_hk:
+      return setFlag(p[1], LATCH_FLAG);
+
+    case "UNLATCH"_hk:
+      return setFlag(p[1], 0, LATCH_FLAG);
+
+    case "RED"_hk:
+      doSignal(p[1], SIGNAL_RED);
+      return true;
+
+    case "AMBER"_hk:
+      doSignal(p[1], SIGNAL_AMBER);
+      return true;
+
+    case "GREEN"_hk:
+      doSignal(p[1], SIGNAL_GREEN);
+      return true;
+
+    default:
+      return false;
diff --git a/EXRAILMacros.h b/EXRAILMacros.h
index d0f640a..cd89e88 100644
--- a/EXRAILMacros.h
+++ b/EXRAILMacros.h
@@ -8 +8 @@
- *  
+ *
@@ -32 +31,0 @@
-
@@ -34 +33 @@
-// It does this by including myAutomation.h several times, each with a set of macros to 
+// It does this by including myAutomation.h several times, each with a set of macros to
@@ -39,2 +38,2 @@
-// ech opcode is a 1 byte operation plus 2 byte operand. 
-// The array is normally built using the macros below as this makes it easier 
+// ech opcode is a 1 byte operation plus 2 byte operand.
+// The array is normally built using the macros below as this makes it easier
@@ -48,4 +47 @@
-// can be called to emit a list of routes/automatuions in a form suitable for Withrottle. 
- 
-// PRINT(msg), LCD(row,msg) and SCREEN(display,row,msg) are implemented in a separate pass to create 
-// a getMessageText(id) function.  
+// can be called to emit a list of routes/automatuions in a form suitable for Withrottle.
@@ -53 +49,2 @@
-// CAUTION: The macros below are multiple passed over myAutomation.h
+// PRINT(msg), LCD(row,msg) and SCREEN(display,row,msg) are implemented in a separate pass to create
+// a getMessageText(id) function.
@@ -54,0 +52 @@
+// CAUTION: The macros below are multiple passed over myAutomation.h
@@ -57 +55,3 @@
-#define O_DESC(id, desc) case id: return ("" desc)[0]?F("" desc):NULL;
+#define O_DESC(id, desc) \
+  case id:               \
+    return ("" desc)[0] ? F("" desc) : NULL;
@@ -59,2 +59,4 @@
-#define T_DESC(tid,pid,desc) if(turntableId==tid && positionId==pid) return ("" desc)[0]?F("" desc):NULL;
-// helper macro for turnout description as HIDDEN 
+#define T_DESC(tid, pid, desc)                 \
+  if (turntableId == tid && positionId == pid) \
+    return ("" desc)[0] ? F("" desc) : NULL;
+// helper macro for turnout description as HIDDEN
@@ -68,2 +70 @@
-#define SEG7(vpin,value,format) \
-   ANOUT(vpin,(value & 0xFFFF),TM1638::DF_##format,((uint32_t)value)>>16)
+#define SEG7(vpin, value, format) ANOUT(vpin, (value & 0xFFFF), TM1638::DF_##format, ((uint32_t)value) >> 16)
@@ -73 +74 @@
-#define STRIP_ZERO(value) 10##value%100
+#define STRIP_ZERO(value) 10##value % 100
@@ -76,2 +77,2 @@
-//const byte TRACK_POWER_0=0, TRACK_POWER_OFF=0;    
-//const byte TRACK_POWER_1=1, TRACK_POWER_ON=1;   
+// const byte TRACK_POWER_0=0, TRACK_POWER_OFF=0;
+// const byte TRACK_POWER_1=1, TRACK_POWER_ON=1;
@@ -79,2 +80,2 @@
-// NEOPIXEL RG generator for NEOPIXEL_SIGNAL 
-#define NeoRGB(red,green,blue) (((uint32_t)(red & 0xff)<<16) | ((uint32_t)(green & 0xff)<<8) | (uint32_t)(blue & 0xff))  
+// NEOPIXEL RG generator for NEOPIXEL_SIGNAL
+#define NeoRGB(red, green, blue) (((uint32_t)(red & 0xff) << 16) | ((uint32_t)(green & 0xff) << 8) | (uint32_t)(blue & 0xff))
@@ -82 +83 @@
-// Pass 1 Implements aliases 
+// Pass 1 Implements aliases
@@ -85 +86 @@
-#define ALIAS(name,value...) const int name= #value[0] ? value+0: -__COUNTER__ ; 
+#define ALIAS(name, value...) const int name = #value[0] ? value + 0 : -__COUNTER__;
@@ -89 +90 @@
-// This pass generates no runtime data or code 
+// This pass generates no runtime data or code
@@ -97,6 +98,4 @@
-constexpr int16_t compileTimeSequenceList[]={
-   #include "myAutomation.h"
-   0
-   };
-constexpr int16_t stuffSize=sizeof(compileTimeSequenceList)/sizeof(int16_t) - 1;
-
+constexpr int16_t compileTimeSequenceList[] = {
+#include "myAutomation.h"
+    0};
+constexpr int16_t stuffSize = sizeof(compileTimeSequenceList) / sizeof(int16_t) - 1;
@@ -105,4 +104,2 @@ constexpr int16_t stuffSize=sizeof(compileTimeSequenceList)/sizeof(int16_t) - 1;
-constexpr bool hasseq(const int16_t value, const int16_t pos=0 ) {
-    return pos>=stuffSize? false :
-          compileTimeSequenceList[pos]==value 
-       || hasseq(value,pos+1); 
+constexpr bool hasseq(const int16_t value, const int16_t pos = 0) {
+  return pos >= stuffSize ? false : compileTimeSequenceList[pos] == value || hasseq(value, pos + 1);
@@ -112,5 +109,2 @@ constexpr bool hasseq(const int16_t value, const int16_t pos=0 ) {
-constexpr bool hasdup(const int16_t value, const int16_t pos ) {
-    return pos>=stuffSize? false :
-          compileTimeSequenceList[pos]==value 
-       || hasseq(value,pos+1) 
-       || hasdup(compileTimeSequenceList[pos],pos+1);
+constexpr bool hasdup(const int16_t value, const int16_t pos) {
+  return pos >= stuffSize ? false : compileTimeSequenceList[pos] == value || hasseq(value, pos + 1) || hasdup(compileTimeSequenceList[pos], pos + 1);
@@ -118,0 +113 @@ constexpr bool hasdup(const int16_t value, const int16_t pos ) {
+static_assert(!hasdup(compileTimeSequenceList[0], 1), "Duplicate SEQUENCE/ROUTE/AUTOMATION detected");
@@ -120,6 +115,4 @@ constexpr bool hasdup(const int16_t value, const int16_t pos ) {
-static_assert(!hasdup(compileTimeSequenceList[0],1),"Duplicate SEQUENCE/ROUTE/AUTOMATION detected");
-
-//pass 1s static asserts to
-//  - check call and follows etc for existing sequence numbers
-//  - check range on LATCH/UNLATCH
-// This pass generates no runtime data or code 
+// pass 1s static asserts to
+//   - check call and follows etc for existing sequence numbers
+//   - check range on LATCH/UNLATCH
+//  This pass generates no runtime data or code
@@ -128,2 +121,3 @@ static_assert(!hasdup(compileTimeSequenceList[0],1),"Duplicate SEQUENCE/ROUTE/AU
-#define ASPECT(address,value) static_assert(address <=2044, "invalid Address"); \
-                              static_assert(address>=-3, "Invalid value");
+#define ASPECT(address, value)                       \
+  static_assert(address <= 2044, "invalid Address"); \
+  static_assert(address >= -3, "Invalid value");
@@ -131 +125 @@ static_assert(!hasdup(compileTimeSequenceList[0],1),"Duplicate SEQUENCE/ROUTE/AU
-#define CALL(id) static_assert(hasseq(id),"Sequence not found");
+#define CALL(id) static_assert(hasseq(id), "Sequence not found");
@@ -133 +127 @@ static_assert(!hasdup(compileTimeSequenceList[0],1),"Duplicate SEQUENCE/ROUTE/AU
-#define FOLLOW(id)  static_assert(hasseq(id),"Sequence not found");
+#define FOLLOW(id) static_assert(hasseq(id), "Sequence not found");
@@ -135 +129 @@ static_assert(!hasdup(compileTimeSequenceList[0],1),"Duplicate SEQUENCE/ROUTE/AU
-#define START(id)  static_assert(hasseq(id),"Sequence not found");
+#define START(id) static_assert(hasseq(id), "Sequence not found");
@@ -137 +131 @@ static_assert(!hasdup(compileTimeSequenceList[0],1),"Duplicate SEQUENCE/ROUTE/AU
-#define SENDLOCO(cab,id) static_assert(hasseq(id),"Sequence not found");
+#define SENDLOCO(cab, id) static_assert(hasseq(id), "Sequence not found");
@@ -139 +133 @@ static_assert(!hasdup(compileTimeSequenceList[0],1),"Duplicate SEQUENCE/ROUTE/AU
-#define LATCH(id) static_assert(id>=0 && id<MAX_FLAGS,"Id out of valid range 0-255" );
+#define LATCH(id) static_assert(id >= 0 && id < MAX_FLAGS, "Id out of valid range 0-255");
@@ -141 +135 @@ static_assert(!hasdup(compileTimeSequenceList[0],1),"Duplicate SEQUENCE/ROUTE/AU
-#define UNLATCH(id) static_assert(id>=0 && id<MAX_FLAGS,"Id out of valid range 0-255" );
+#define UNLATCH(id) static_assert(id >= 0 && id < MAX_FLAGS, "Id out of valid range 0-255");
@@ -143 +137 @@ static_assert(!hasdup(compileTimeSequenceList[0],1),"Duplicate SEQUENCE/ROUTE/AU
-#define RESERVE(id) static_assert(id>=0 && id<MAX_FLAGS,"Id out of valid range 0-255" );
+#define RESERVE(id) static_assert(id >= 0 && id < MAX_FLAGS, "Id out of valid range 0-255");
@@ -145 +139 @@ static_assert(!hasdup(compileTimeSequenceList[0],1),"Duplicate SEQUENCE/ROUTE/AU
-#define FREE(id) static_assert(id>=0 && id<MAX_FLAGS,"Id out of valid range 0-255" );
+#define FREE(id) static_assert(id >= 0 && id < MAX_FLAGS, "Id out of valid range 0-255");
@@ -147 +141 @@ static_assert(!hasdup(compileTimeSequenceList[0],1),"Duplicate SEQUENCE/ROUTE/AU
-#define SPEED(speed) static_assert(speed>=0 && speed<128,"Speed out of valid range 0-127");
+#define SPEED(speed) static_assert(speed >= 0 && speed < 128, "Speed out of valid range 0-127");
@@ -149 +143 @@ static_assert(!hasdup(compileTimeSequenceList[0],1),"Duplicate SEQUENCE/ROUTE/AU
-#define FWD(speed) static_assert(speed>=0 && speed<128,"Speed out of valid range 0-127");
+#define FWD(speed) static_assert(speed >= 0 && speed < 128, "Speed out of valid range 0-127");
@@ -151 +145 @@ static_assert(!hasdup(compileTimeSequenceList[0],1),"Duplicate SEQUENCE/ROUTE/AU
-#define REV(speed) static_assert(speed>=0 && speed<128,"Speed out of valid range 0-127");
+#define REV(speed) static_assert(speed >= 0 && speed < 128, "Speed out of valid range 0-127");
@@ -155 +149 @@ static_assert(!hasdup(compileTimeSequenceList[0],1),"Duplicate SEQUENCE/ROUTE/AU
-// Pass 1g Implants STEALTH_GLOBAL in correct place 
+// Pass 1g Implants STEALTH_GLOBAL in correct place
@@ -165 +159 @@ static_assert(!hasdup(compileTimeSequenceList[0],1),"Duplicate SEQUENCE/ROUTE/AU
-#define HAL(haltype,params...)  haltype::create(params);
+#define HAL(haltype, params...) haltype::create(params);
@@ -167 +161 @@ static_assert(!hasdup(compileTimeSequenceList[0],1),"Duplicate SEQUENCE/ROUTE/AU
-#define HAL_IGNORE_DEFAULTS ignore_defaults=true;
+#define HAL_IGNORE_DEFAULTS ignore_defaults = true;
@@ -169,3 +163,3 @@ static_assert(!hasdup(compileTimeSequenceList[0],1),"Duplicate SEQUENCE/ROUTE/AU
-#define JMRI_SENSOR(vpin,count...) Sensor::createMultiple(vpin,##count);
-#undef  CONFIGURE_SERVO
-#define CONFIGURE_SERVO(vpin,pos1,pos2,profile) IODevice::configureServo(vpin,pos1,pos2,PCA9685::profile);
+#define JMRI_SENSOR(vpin, count...) Sensor::createMultiple(vpin, ##count);
+#undef CONFIGURE_SERVO
+#define CONFIGURE_SERVO(vpin, pos1, pos2, profile) IODevice::configureServo(vpin, pos1, pos2, PCA9685::profile);
@@ -173,3 +167,3 @@ bool exrailHalSetup() {
-   bool ignore_defaults=false;
-   #include "myAutomation.h"
-   return ignore_defaults;
+  bool ignore_defaults = false;
+#include "myAutomation.h"
+  return ignore_defaults;
@@ -181 +175 @@ bool exrailHalSetup() {
-#define SIGNAL(redpin,amberpin,greenpin) | FEATURE_SIGNAL 
+#define SIGNAL(redpin, amberpin, greenpin) | FEATURE_SIGNAL
@@ -183 +177 @@ bool exrailHalSetup() {
-#define SIGNALH(redpin,amberpin,greenpin) | FEATURE_SIGNAL 
+#define SIGNALH(redpin, amberpin, greenpin) | FEATURE_SIGNAL
@@ -185 +179 @@ bool exrailHalSetup() {
-#define SERVO_SIGNAL(vpin,redval,amberval,greenval) | FEATURE_SIGNAL 
+#define SERVO_SIGNAL(vpin, redval, amberval, greenval) | FEATURE_SIGNAL
@@ -187 +181 @@ bool exrailHalSetup() {
-#define DCC_SIGNAL(id,addr,subaddr) | FEATURE_SIGNAL
+#define DCC_SIGNAL(id, addr, subaddr) | FEATURE_SIGNAL
@@ -189 +183 @@ bool exrailHalSetup() {
-#define DCCX_SIGNAL(id,redAspect,amberAspect,greenAspect) | FEATURE_SIGNAL
+#define DCCX_SIGNAL(id, redAspect, amberAspect, greenAspect) | FEATURE_SIGNAL
@@ -191 +185 @@ bool exrailHalSetup() {
-#define NEOPIXEL_SIGNAL(sigid,redcolour,ambercolour,greencolour) | FEATURE_SIGNAL
+#define NEOPIXEL_SIGNAL(sigid, redcolour, ambercolour, greencolour) | FEATURE_SIGNAL
@@ -196 +190 @@ bool exrailHalSetup() {
-#define LCC(eventid)  | FEATURE_LCC
+#define LCC(eventid) | FEATURE_LCC
@@ -198 +192 @@ bool exrailHalSetup() {
-#define LCCX(senderid,eventid) | FEATURE_LCC 
+#define LCCX(senderid, eventid) | FEATURE_LCC
@@ -200 +194 @@ bool exrailHalSetup() {
-#define ONLCC(senderid,eventid) | FEATURE_LCC
+#define ONLCC(senderid, eventid) | FEATURE_LCC
@@ -218 +212 @@ bool exrailHalSetup() {
-#define ROUTE_CAPTION(id,caption) | FEATURE_ROUTESTATE
+#define ROUTE_CAPTION(id, caption) | FEATURE_ROUTESTATE
@@ -229 +223 @@ bool exrailHalSetup() {
-#define BLINK(vpin,onDuty,offDuty) | FEATURE_BLINK
+#define BLINK(vpin, onDuty, offDuty) | FEATURE_BLINK
@@ -236,2 +230,2 @@ const byte RMFT2::compileFeatures = 0
-   #include "myAutomation.h"
-;
+#include "myAutomation.h"
+    ;
@@ -239 +233 @@ const byte RMFT2::compileFeatures = 0
-// Pass 2 create throttle route list 
+// Pass 2 create throttle route list
@@ -243,2 +237,2 @@ const byte RMFT2::compileFeatures = 0
-const int16_t HIGHFLASH  RMFT2::routeIdList[]= {
-    #include "myAutomation.h"
+const int16_t HIGHFLASH RMFT2::routeIdList[] = {
+#include "myAutomation.h"
@@ -246 +240 @@ const int16_t HIGHFLASH  RMFT2::routeIdList[]= {
-// Pass 2a create throttle automation list 
+// Pass 2a create throttle automation list
@@ -250,2 +244,2 @@ const int16_t HIGHFLASH  RMFT2::routeIdList[]= {
-const int16_t HIGHFLASH RMFT2::automationIdList[]= {
-    #include "myAutomation.h"
+const int16_t HIGHFLASH RMFT2::automationIdList[] = {
+#include "myAutomation.h"
@@ -256 +250,3 @@ const int16_t HIGHFLASH RMFT2::automationIdList[]= {
-#define ROUTE(id, description) case id: return F(description);
+#define ROUTE(id, description) \
+  case id:                     \
+    return F(description);
@@ -258,7 +254,10 @@ const int16_t HIGHFLASH RMFT2::automationIdList[]= {
-#define AUTOMATION(id, description) case id: return F(description);
-const FSH * RMFT2::getRouteDescription(int16_t id) {
-   switch(id) {
-    #include "myAutomation.h"
-    default: break;
-   }
-   return F("");
+#define AUTOMATION(id, description) \
+  case id:                          \
+    return F(description);
+const FSH* RMFT2::getRouteDescription(int16_t id) {
+  switch (id) {
+#include "myAutomation.h"
+    default:
+      break;
+  }
+  return F("");
@@ -269,8 +268,8 @@ const FSH * RMFT2::getRouteDescription(int16_t id) {
-const int StringMacroTracker1=__COUNTER__;
-#define THRUNGE(msg,mode) \
-     case (__COUNTER__ - StringMacroTracker1) : {\
-         static const char HIGHFLASH thrunge[]=msg;\
-         strfar=(uint32_t)GETFARPTR(thrunge);\
-         tmode=mode;\
-         break;\
-      } 
+const int StringMacroTracker1 = __COUNTER__;
+#define THRUNGE(msg, mode)                       \
+  case (__COUNTER__ - StringMacroTracker1): {    \
+    static const char HIGHFLASH thrunge[] = msg; \
+    strfar = (uint32_t)GETFARPTR(thrunge);       \
+    tmode = mode;                                \
+    break;                                       \
+  }
@@ -278 +277 @@ const int StringMacroTracker1=__COUNTER__;
-#define BROADCAST(msg) THRUNGE(msg,thrunge_broadcast)
+#define BROADCAST(msg) THRUNGE(msg, thrunge_broadcast)
@@ -280 +279 @@ const int StringMacroTracker1=__COUNTER__;
-#define PARSE(msg) THRUNGE(msg,thrunge_parse)
+#define PARSE(msg) THRUNGE(msg, thrunge_parse)
@@ -282 +281 @@ const int StringMacroTracker1=__COUNTER__;
-#define PRINT(msg) THRUNGE(msg,thrunge_print)
+#define PRINT(msg) THRUNGE(msg, thrunge_print)
@@ -284 +283 @@ const int StringMacroTracker1=__COUNTER__;
-#define LCN(msg)   THRUNGE(msg,thrunge_lcn)
+#define LCN(msg) THRUNGE(msg, thrunge_lcn)
@@ -286 +285 @@ const int StringMacroTracker1=__COUNTER__;
-#define MESSAGE(msg) THRUNGE(msg,thrunge_message)
+#define MESSAGE(msg) THRUNGE(msg, thrunge_message)
@@ -289,5 +288,5 @@ const int StringMacroTracker1=__COUNTER__;
-#define ROUTE_CAPTION(id,caption) \
-case (__COUNTER__ - StringMacroTracker1) : {\
-   manageRouteCaption(id,F(caption));\
-   return;\
-   }
+#define ROUTE_CAPTION(id, caption)            \
+  case (__COUNTER__ - StringMacroTracker1): { \
+    manageRouteCaption(id, F(caption));       \
+    return;                                   \
+  }
@@ -295 +294 @@ case (__COUNTER__ - StringMacroTracker1) : {\
-#define SERIAL(msg)   THRUNGE(msg,thrunge_serial)
+#define SERIAL(msg) THRUNGE(msg, thrunge_serial)
@@ -297 +296 @@ case (__COUNTER__ - StringMacroTracker1) : {\
-#define SERIAL1(msg)  THRUNGE(msg,thrunge_serial1)
+#define SERIAL1(msg) THRUNGE(msg, thrunge_serial1)
@@ -299 +298 @@ case (__COUNTER__ - StringMacroTracker1) : {\
-#define SERIAL2(msg)  THRUNGE(msg,thrunge_serial2)
+#define SERIAL2(msg) THRUNGE(msg, thrunge_serial2)
@@ -301 +300 @@ case (__COUNTER__ - StringMacroTracker1) : {\
-#define SERIAL3(msg)  THRUNGE(msg,thrunge_serial3)
+#define SERIAL3(msg) THRUNGE(msg, thrunge_serial3)
@@ -303 +302 @@ case (__COUNTER__ - StringMacroTracker1) : {\
-#define SERIAL4(msg)  THRUNGE(msg,thrunge_serial4)
+#define SERIAL4(msg) THRUNGE(msg, thrunge_serial4)
@@ -305 +304 @@ case (__COUNTER__ - StringMacroTracker1) : {\
-#define SERIAL5(msg)  THRUNGE(msg,thrunge_serial5)
+#define SERIAL5(msg) THRUNGE(msg, thrunge_serial5)
@@ -307 +306 @@ case (__COUNTER__ - StringMacroTracker1) : {\
-#define SERIAL6(msg)  THRUNGE(msg,thrunge_serial6)
+#define SERIAL6(msg) THRUNGE(msg, thrunge_serial6)
@@ -309,8 +308,8 @@ case (__COUNTER__ - StringMacroTracker1) : {\
-#define LCD(id,msg)  \
-     case (__COUNTER__ - StringMacroTracker1) : {\
-         static const char HIGHFLASH thrunge[]=msg;\
-         strfar=(uint32_t)GETFARPTR(thrunge);\
-         tmode=thrunge_lcd; \
-         lcdid=id;\
-         break;\
-      }
+#define LCD(id, msg)                             \
+  case (__COUNTER__ - StringMacroTracker1): {    \
+    static const char HIGHFLASH thrunge[] = msg; \
+    strfar = (uint32_t)GETFARPTR(thrunge);       \
+    tmode = thrunge_lcd;                         \
+    lcdid = id;                                  \
+    break;                                       \
+  }
@@ -318,8 +317,8 @@ case (__COUNTER__ - StringMacroTracker1) : {\
-#define SCREEN(display,id,msg)  \
-     case (__COUNTER__ - StringMacroTracker1) : {\
-         static const char HIGHFLASH thrunge[]=msg;\
-         strfar=(uint32_t)GETFARPTR(thrunge);\
-         tmode=(thrunger)(thrunge_lcd+display); \
-         lcdid=id;\
-         break;\
-      } 
+#define SCREEN(display, id, msg)                 \
+  case (__COUNTER__ - StringMacroTracker1): {    \
+    static const char HIGHFLASH thrunge[] = msg; \
+    strfar = (uint32_t)GETFARPTR(thrunge);       \
+    tmode = (thrunger)(thrunge_lcd + display);   \
+    lcdid = id;                                  \
+    break;                                       \
+  }
@@ -327 +326,5 @@ case (__COUNTER__ - StringMacroTracker1) : {\
-#define STEALTH(code...) case (__COUNTER__ - StringMacroTracker1) : {code} return; 
+#define STEALTH(code...)                      \
+  case (__COUNTER__ - StringMacroTracker1): { \
+    code                                      \
+  }                                           \
+    return;
@@ -329 +332 @@ case (__COUNTER__ - StringMacroTracker1) : {\
-#define WITHROTTLE(msg) THRUNGE(msg,thrunge_withrottle)
+#define WITHROTTLE(msg) THRUNGE(msg, thrunge_withrottle)
@@ -331 +334 @@ case (__COUNTER__ - StringMacroTracker1) : {\
-void  RMFT2::printMessage(uint16_t id) { 
+void RMFT2::printMessage(uint16_t id) {
@@ -333,5 +336,6 @@ void  RMFT2::printMessage(uint16_t id) {
-  uint32_t strfar=0;
-  byte lcdid=0; 
-  switch(id) {
-    #include "myAutomation.h"
-    default: break ; 
+  uint32_t strfar = 0;
+  byte lcdid = 0;
+  switch (id) {
+#include "myAutomation.h"
+    default:
+      break;
@@ -339 +343,2 @@ void  RMFT2::printMessage(uint16_t id) {
-  if (strfar) thrungeString(strfar,tmode,lcdid);
+  if (strfar)
+    thrungeString(strfar, tmode, lcdid);
@@ -342 +346,0 @@ void  RMFT2::printMessage(uint16_t id) {
-
@@ -346 +350 @@ void  RMFT2::printMessage(uint16_t id) {
-#define TURNOUT(id,addr,subaddr,description...) O_DESC(id,description)
+#define TURNOUT(id, addr, subaddr, description...) O_DESC(id, description)
@@ -348 +352 @@ void  RMFT2::printMessage(uint16_t id) {
-#define TURNOUTL(id,addr,description...) O_DESC(id,description)
+#define TURNOUTL(id, addr, description...) O_DESC(id, description)
@@ -350 +354 @@ void  RMFT2::printMessage(uint16_t id) {
-#define PIN_TURNOUT(id,pin,description...) O_DESC(id,description)
+#define PIN_TURNOUT(id, pin, description...) O_DESC(id, description)
@@ -352 +356 @@ void  RMFT2::printMessage(uint16_t id) {
-#define SERVO_TURNOUT(id,pin,activeAngle,inactiveAngle,profile,description...) O_DESC(id,description)
+#define SERVO_TURNOUT(id, pin, activeAngle, inactiveAngle, profile, description...) O_DESC(id, description)
@@ -354,8 +358,9 @@ void  RMFT2::printMessage(uint16_t id) {
-#define VIRTUAL_TURNOUT(id,description...) O_DESC(id,description)
-
-const FSH * RMFT2::getTurnoutDescription(int16_t turnoutid) {
-     switch (turnoutid) {
-        #include "myAutomation.h"
-     default:break;
-     }
-     return NULL;
+#define VIRTUAL_TURNOUT(id, description...) O_DESC(id, description)
+
+const FSH* RMFT2::getTurnoutDescription(int16_t turnoutid) {
+  switch (turnoutid) {
+#include "myAutomation.h"
+    default:
+      break;
+  }
+  return NULL;
@@ -367 +372 @@ const FSH * RMFT2::getTurnoutDescription(int16_t turnoutid) {
-#define DCC_TURNTABLE(id,home,description...) O_DESC(id,description)
+#define DCC_TURNTABLE(id, home, description...) O_DESC(id, description)
@@ -369,8 +374,9 @@ const FSH * RMFT2::getTurnoutDescription(int16_t turnoutid) {
-#define EXTT_TURNTABLE(id,vpin,home,description...) O_DESC(id,description)
-
-const FSH * RMFT2::getTurntableDescription(int16_t turntableId) {
-   switch (turntableId) {
-      #include "myAutomation.h"
-   default:break;
-   }
-   return NULL;
+#define EXTT_TURNTABLE(id, vpin, home, description...) O_DESC(id, description)
+
+const FSH* RMFT2::getTurntableDescription(int16_t turntableId) {
+  switch (turntableId) {
+#include "myAutomation.h"
+    default:
+      break;
+  }
+  return NULL;
@@ -382 +388 @@ const FSH * RMFT2::getTurntableDescription(int16_t turntableId) {
-#define TT_ADDPOSITION(turntable_id,position,value,home,description...) T_DESC(turntable_id,position,description)
+#define TT_ADDPOSITION(turntable_id, position, value, home, description...) T_DESC(turntable_id, position, description)
@@ -384 +390 @@ const FSH * RMFT2::getTurntableDescription(int16_t turntableId) {
-const FSH * RMFT2::getTurntablePositionDescription(int16_t turntableId, uint8_t positionId) {
+const FSH* RMFT2::getTurntablePositionDescription(int16_t turntableId, uint8_t positionId) {
@@ -387,2 +393,2 @@ const FSH * RMFT2::getTurntablePositionDescription(int16_t turntableId, uint8_t
-   #include "myAutomation.h"
-   return NULL;
+#include "myAutomation.h"
+  return NULL;
@@ -394,6 +400,6 @@ const FSH * RMFT2::getTurntablePositionDescription(int16_t turntableId, uint8_t
-#define ROSTER(cabid,name,funcmap...) +(cabid <= 0 ? 0 : 1)
-const byte RMFT2::rosterNameCount=0
-   #include "myAutomation.h"
-   ;
-   
-// Pass 6: Roster IDs 
+#define ROSTER(cabid, name, funcmap...) +(cabid <= 0 ? 0 : 1)
+const byte RMFT2::rosterNameCount = 0
+#include "myAutomation.h"
+    ;
+
+// Pass 6: Roster IDs
@@ -402,4 +408,4 @@ const byte RMFT2::rosterNameCount=0
-#define ROSTER(cabid,name,funcmap...) cabid,
-const int16_t HIGHFLASH  RMFT2::rosterIdList[]={
-   #include "myAutomation.h"
-   INT16_MAX};
+#define ROSTER(cabid, name, funcmap...) cabid,
+const int16_t HIGHFLASH RMFT2::rosterIdList[] = {
+#include "myAutomation.h"
+    INT16_MAX};
@@ -410,10 +416,13 @@ const int16_t HIGHFLASH  RMFT2::rosterIdList[]={
-#define ROSTER(cabid,name,funcmap...) case cabid: return F(name);
-const FSH * RMFT2::getRosterName(int16_t id) {
-   switch(id) {
-      #include "myAutomation.h"
-   default: break;
-   }
-   return F("");   
-} 
-
-// Pass to get roster functions 
+#define ROSTER(cabid, name, funcmap...) \
+  case cabid:                           \
+    return F(name);
+const FSH* RMFT2::getRosterName(int16_t id) {
+  switch (id) {
+#include "myAutomation.h"
+    default:
+      break;
+  }
+  return F("");
+}
+
+// Pass to get roster functions
@@ -421,8 +430,11 @@ const FSH * RMFT2::getRosterName(int16_t id) {
-#define ROSTER(cabid,name,funcmap...) case cabid: return F("" funcmap);
-const FSH * RMFT2::getRosterFunctions(int16_t id) {
-   switch(id) {
-      #include "myAutomation.h"
-   default: break; 
-   }   
-   return NULL;
-} 
+#define ROSTER(cabid, name, funcmap...) \
+  case cabid:                           \
+    return F("" funcmap);
+const FSH* RMFT2::getRosterFunctions(int16_t id) {
+  switch (id) {
+#include "myAutomation.h"
+    default:
+      break;
+  }
+  return NULL;
+}
@@ -433 +445 @@ const FSH * RMFT2::getRosterFunctions(int16_t id) {
-#define SIGNAL(redpin,amberpin,greenpin) {sigtypeSIGNAL,redpin,redpin,amberpin,greenpin}, 
+#define SIGNAL(redpin, amberpin, greenpin) {sigtypeSIGNAL, redpin, redpin, amberpin, greenpin},
@@ -435 +447 @@ const FSH * RMFT2::getRosterFunctions(int16_t id) {
-#define SIGNALH(redpin,amberpin,greenpin) {sigtypeSIGNALH,redpin,redpin,amberpin,greenpin}, 
+#define SIGNALH(redpin, amberpin, greenpin) {sigtypeSIGNALH, redpin, redpin, amberpin, greenpin},
@@ -437 +449 @@ const FSH * RMFT2::getRosterFunctions(int16_t id) {
-#define SERVO_SIGNAL(vpin,redval,amberval,greenval) {sigtypeSERVO,vpin,redval,amberval,greenval}, 
+#define SERVO_SIGNAL(vpin, redval, amberval, greenval) {sigtypeSERVO, vpin, redval, amberval, greenval},
@@ -439 +451 @@ const FSH * RMFT2::getRosterFunctions(int16_t id) {
-#define DCC_SIGNAL(id,addr,subaddr) {sigtypeDCC,id,addr,subaddr,0},
+#define DCC_SIGNAL(id, addr, subaddr) {sigtypeDCC, id, addr, subaddr, 0},
@@ -441 +453 @@ const FSH * RMFT2::getRosterFunctions(int16_t id) {
-#define DCCX_SIGNAL(id,redAspect,amberAspect,greenAspect) {sigtypeDCCX,id,redAspect,amberAspect,greenAspect},
+#define DCCX_SIGNAL(id, redAspect, amberAspect, greenAspect) {sigtypeDCCX, id, redAspect, amberAspect, greenAspect},
@@ -443,3 +455,3 @@ const FSH * RMFT2::getRosterFunctions(int16_t id) {
-#define NEOPIXEL_SIGNAL(id,redRGB,amberRGB,greenRGB) \
-        {sigtypeNEOPIXEL,id,((VPIN)((redRGB)>>8)), ((VPIN)((amberRGB)>>8)), ((VPIN)((greenRGB)>>8))},\
-        {sigtypeContinuation,id,((VPIN)((redRGB) & 0xff)), ((VPIN)((amberRGB) & 0xFF)), ((VPIN)((greenRGB) & 0xFF))},
+#define NEOPIXEL_SIGNAL(id, redRGB, amberRGB, greenRGB)                                                 \
+  {sigtypeNEOPIXEL, id, ((VPIN)((redRGB) >> 8)), ((VPIN)((amberRGB) >> 8)), ((VPIN)((greenRGB) >> 8))}, \
+      {sigtypeContinuation, id, ((VPIN)((redRGB) & 0xff)), ((VPIN)((amberRGB) & 0xFF)), ((VPIN)((greenRGB) & 0xFF))},
@@ -447 +459 @@ const FSH * RMFT2::getRosterFunctions(int16_t id) {
-#define VIRTUAL_SIGNAL(id) {sigtypeVIRTUAL,id,0,0,0},
+#define VIRTUAL_SIGNAL(id) {sigtypeVIRTUAL, id, 0, 0, 0},
@@ -449,4 +461,3 @@ const FSH * RMFT2::getRosterFunctions(int16_t id) {
-const  HIGHFLASH  SIGNAL_DEFINITION RMFT2::SignalDefinitions[] = {
-    #include "myAutomation.h"
-     {sigtypeNoMoreSignals,0,0,0,0}
-    };
+const HIGHFLASH SIGNAL_DEFINITION RMFT2::SignalDefinitions[] = {
+#include "myAutomation.h"
+    {sigtypeNoMoreSignals, 0, 0, 0, 0}};
@@ -457 +468 @@ const  HIGHFLASH  SIGNAL_DEFINITION RMFT2::SignalDefinitions[] = {
-#define ONLCC(sender,event) +1 
+#define ONLCC(sender, event) +1
@@ -459 +470 @@ const  HIGHFLASH  SIGNAL_DEFINITION RMFT2::SignalDefinitions[] = {
-#define ONACON(event) +1 
+#define ONACON(event) +1
@@ -461 +472 @@ const  HIGHFLASH  SIGNAL_DEFINITION RMFT2::SignalDefinitions[] = {
-#define ONACOF(event) +1 
+#define ONACOF(event) +1
@@ -463 +474 @@ const  HIGHFLASH  SIGNAL_DEFINITION RMFT2::SignalDefinitions[] = {
-const int RMFT2::countLCCLookup=0
+const int RMFT2::countLCCLookup = 0
@@ -465 +476 @@ const int RMFT2::countLCCLookup=0
-;
+    ;
@@ -469,2 +480,2 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-// Only undef the macros, not dummy them.  
-#define  RMFT2_UNDEF_ONLY
+// Only undef the macros, not dummy them.
+#define RMFT2_UNDEF_ONLY
@@ -473,20 +484,20 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-// Everything we generate here has to be compile-time evaluated to 
-// a constant.  
-#define V(val) (byte)(((int16_t)(val))&0x00FF),(byte)(((int16_t)(val)>>8)&0x00FF)
-// Define macros for route code creation 
-
-#define ACTIVATE(addr,subaddr) OPCODE_DCCACTIVATE,V(addr<<3 | subaddr<<1 | 1),
-#define ACTIVATEL(addr) OPCODE_DCCACTIVATE,V((addr+3)<<1 | 1),
-#define AFTER(sensor_id,timer...) OPCODE_AT,V(sensor_id),OPCODE_AFTER,V(sensor_id),OPCODE_PAD,V(#timer[0]?timer+0:500),
-#define AFTEROVERLOAD(track_id) OPCODE_AFTEROVERLOAD,V(TRACK_NUMBER_##track_id),
-#define ALIAS(name,value...) 
-#define AMBER(signal_id) OPCODE_AMBER,V(signal_id),
-#define ANOUT(vpin,value,param1,param2) OPCODE_SERVO,V(vpin),OPCODE_PAD,V(value),OPCODE_PAD,V(param1),OPCODE_PAD,V(param2),
-#define ASPECT(address,value) OPCODE_ASPECT,V((address<<5) | (value & 0x1F)),
-#define AT(sensor_id) OPCODE_AT,V(sensor_id),
-#define ATGTE(sensor_id,value) OPCODE_ATGTE,V(sensor_id),OPCODE_PAD,V(value),  
-#define ATLT(sensor_id,value) OPCODE_ATLT,V(sensor_id),OPCODE_PAD,V(value),  
-#define ATTIMEOUT(sensor_id,timeout) OPCODE_ATTIMEOUT1,0,0,OPCODE_ATTIMEOUT2,V(sensor_id),OPCODE_PAD,V(timeout/100L),
-#define AUTOMATION(id, description)  OPCODE_AUTOMATION, V(id), 
-#define AUTOSTART OPCODE_AUTOSTART,0,0,
-#define BLINK(vpin,onDuty,offDuty) OPCODE_BLINK,V(vpin),OPCODE_PAD,V(onDuty),OPCODE_PAD,V(offDuty),
+// Everything we generate here has to be compile-time evaluated to
+// a constant.
+#define V(val) (byte)(((int16_t)(val)) & 0x00FF), (byte)(((int16_t)(val) >> 8) & 0x00FF)
+// Define macros for route code creation
+
+#define ACTIVATE(addr, subaddr) OPCODE_DCCACTIVATE, V(addr << 3 | subaddr << 1 | 1),
+#define ACTIVATEL(addr) OPCODE_DCCACTIVATE, V((addr + 3) << 1 | 1),
+#define AFTER(sensor_id, timer...) OPCODE_AT, V(sensor_id), OPCODE_AFTER, V(sensor_id), OPCODE_PAD, V(#timer[0] ? timer + 0 : 500),
+#define AFTEROVERLOAD(track_id) OPCODE_AFTEROVERLOAD, V(TRACK_NUMBER_##track_id),
+#define ALIAS(name, value...)
+#define AMBER(signal_id) OPCODE_AMBER, V(signal_id),
+#define ANOUT(vpin, value, param1, param2) OPCODE_SERVO, V(vpin), OPCODE_PAD, V(value), OPCODE_PAD, V(param1), OPCODE_PAD, V(param2),
+#define ASPECT(address, value) OPCODE_ASPECT, V((address << 5) | (value & 0x1F)),
+#define AT(sensor_id) OPCODE_AT, V(sensor_id),
+#define ATGTE(sensor_id, value) OPCODE_ATGTE, V(sensor_id), OPCODE_PAD, V(value),
+#define ATLT(sensor_id, value) OPCODE_ATLT, V(sensor_id), OPCODE_PAD, V(value),
+#define ATTIMEOUT(sensor_id, timeout) OPCODE_ATTIMEOUT1, 0, 0, OPCODE_ATTIMEOUT2, V(sensor_id), OPCODE_PAD, V(timeout / 100L),
+#define AUTOMATION(id, description) OPCODE_AUTOMATION, V(id),
+#define AUTOSTART OPCODE_AUTOSTART, 0, 0,
+#define BLINK(vpin, onDuty, offDuty) OPCODE_BLINK, V(vpin), OPCODE_PAD, V(onDuty), OPCODE_PAD, V(offDuty),
@@ -494,5 +505,5 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-#define CALL(route) OPCODE_CALL,V(route),
-#define CLEAR_STASH(id) OPCODE_CLEAR_STASH,V(id),
-#define CLEAR_ALL_STASH OPCODE_CLEAR_ALL_STASH,V(0),
-#define CLOSE(id)  OPCODE_CLOSE,V(id),
-#define CONFIGURE_SERVO(vpin,pos1,pos2,profile)
+#define CALL(route) OPCODE_CALL, V(route),
+#define CLEAR_STASH(id) OPCODE_CLEAR_STASH, V(id),
+#define CLEAR_ALL_STASH OPCODE_CLEAR_ALL_STASH, V(0),
+#define CLOSE(id) OPCODE_CLOSE, V(id),
+#define CONFIGURE_SERVO(vpin, pos1, pos2, profile)
@@ -500 +511 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-#define DCC_TURNTABLE(id,home,description...) OPCODE_DCCTURNTABLE,V(id),OPCODE_PAD,V(home),
+#define DCC_TURNTABLE(id, home, description...) OPCODE_DCCTURNTABLE, V(id), OPCODE_PAD, V(home),
@@ -502,14 +513,14 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-#define DEACTIVATE(addr,subaddr) OPCODE_DCCACTIVATE,V(addr<<3 | subaddr<<1),
-#define DEACTIVATEL(addr) OPCODE_DCCACTIVATE,V((addr+3)<<1),
-#define DELAY(ms) ms<30000?OPCODE_DELAYMS:OPCODE_DELAY,V(ms/(ms<30000?1L:100L)),
-#define DELAYMINS(mindelay) OPCODE_DELAYMINS,V(mindelay),
-#define DELAYRANDOM(mindelay,maxdelay) DELAY(mindelay) OPCODE_RANDWAIT,V((maxdelay-mindelay)/100L),
-#define DCC_SIGNAL(id,add,subaddr)
-#define DCCX_SIGNAL(id,redAspect,amberAspect,greenAspect)
-#define DONE OPCODE_ENDTASK,0,0,
-#define DRIVE(analogpin) OPCODE_DRIVE,V(analogpin),
-#define ELSE OPCODE_ELSE,0,0,
-#define ENDEXRAIL 
-#define ENDIF  OPCODE_ENDIF,0,0,
-#define ENDTASK OPCODE_ENDTASK,0,0,
-#define ESTOP OPCODE_SPEED,V(1), 
+#define DEACTIVATE(addr, subaddr) OPCODE_DCCACTIVATE, V(addr << 3 | subaddr << 1),
+#define DEACTIVATEL(addr) OPCODE_DCCACTIVATE, V((addr + 3) << 1),
+#define DELAY(ms) ms < 30000 ? OPCODE_DELAYMS : OPCODE_DELAY, V(ms / (ms < 30000 ? 1L : 100L)),
+#define DELAYMINS(mindelay) OPCODE_DELAYMINS, V(mindelay),
+#define DELAYRANDOM(mindelay, maxdelay) DELAY(mindelay) OPCODE_RANDWAIT, V((maxdelay - mindelay) / 100L),
+#define DCC_SIGNAL(id, add, subaddr)
+#define DCCX_SIGNAL(id, redAspect, amberAspect, greenAspect)
+#define DONE OPCODE_ENDTASK, 0, 0,
+#define DRIVE(analogpin) OPCODE_DRIVE, V(analogpin),
+#define ELSE OPCODE_ELSE, 0, 0,
+#define ENDEXRAIL
+#define ENDIF OPCODE_ENDIF, 0, 0,
+#define ENDTASK OPCODE_ENDTASK, 0, 0,
+#define ESTOP OPCODE_SPEED, V(1),
@@ -518 +529 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-#define EXTT_TURNTABLE(id,vpin,home,description...) OPCODE_EXTTTURNTABLE,V(id),OPCODE_PAD,V(vpin),OPCODE_PAD,V(home),
+#define EXTT_TURNTABLE(id, vpin, home, description...) OPCODE_EXTTTURNTABLE, V(id), OPCODE_PAD, V(vpin), OPCODE_PAD, V(home),
@@ -520,10 +531,12 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-#define FADE(pin,value,ms) OPCODE_SERVO,V(pin),OPCODE_PAD,V(value),OPCODE_PAD,V((int16_t)PCA9685::ProfileType::UseDuration|(int16_t)PCA9685::ProfileType::NoPowerOff),OPCODE_PAD,V(ms/100L),
-#define FOFF(func) OPCODE_FOFF,V(func),
-#define FOLLOW(route) OPCODE_FOLLOW,V(route),
-#define FON(func) OPCODE_FON,V(func),
-#define FORGET OPCODE_FORGET,0,0,
-#define FREE(blockid) OPCODE_FREE,V(blockid),
-#define FTOGGLE(func) OPCODE_FTOGGLE,V(func),
-#define FWD(speed) OPCODE_FWD,V(speed),
-#define GREEN(signal_id) OPCODE_GREEN,V(signal_id),
-#define HAL(haltype,params...)
+#define FADE(pin, value, ms)                                                                                                                         \
+  OPCODE_SERVO, V(pin), OPCODE_PAD, V(value), OPCODE_PAD, V((int16_t)PCA9685::ProfileType::UseDuration | (int16_t)PCA9685::ProfileType::NoPowerOff), \
+      OPCODE_PAD, V(ms / 100L),
+#define FOFF(func) OPCODE_FOFF, V(func),
+#define FOLLOW(route) OPCODE_FOLLOW, V(route),
+#define FON(func) OPCODE_FON, V(func),
+#define FORGET OPCODE_FORGET, 0, 0,
+#define FREE(blockid) OPCODE_FREE, V(blockid),
+#define FTOGGLE(func) OPCODE_FTOGGLE, V(func),
+#define FWD(speed) OPCODE_FWD, V(speed),
+#define GREEN(signal_id) OPCODE_GREEN, V(signal_id),
+#define HAL(haltype, params...)
@@ -531,13 +544,13 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-#define IF(sensor_id) OPCODE_IF,V(sensor_id),
-#define IFAMBER(signal_id) OPCODE_IFAMBER,V(signal_id),
-#define IFCLOSED(turnout_id) OPCODE_IFCLOSED,V(turnout_id),
-#define IFGREEN(signal_id) OPCODE_IFGREEN,V(signal_id),
-#define IFGTE(sensor_id,value) OPCODE_IFGTE,V(sensor_id),OPCODE_PAD,V(value),
-#define IFLOCO(loco_id) OPCODE_IFLOCO,V(loco_id),
-#define IFLT(sensor_id,value) OPCODE_IFLT,V(sensor_id),OPCODE_PAD,V(value),
-#define IFNOT(sensor_id) OPCODE_IFNOT,V(sensor_id),
-#define IFRANDOM(percent) OPCODE_IFRANDOM,V(percent),
-#define IFRED(signal_id) OPCODE_IFRED,V(signal_id),
-#define IFRESERVE(block) OPCODE_IFRESERVE,V(block),
-#define IFTHROWN(turnout_id) OPCODE_IFTHROWN,V(turnout_id),
-#define IFTIMEOUT OPCODE_IFTIMEOUT,0,0,
+#define IF(sensor_id) OPCODE_IF, V(sensor_id),
+#define IFAMBER(signal_id) OPCODE_IFAMBER, V(signal_id),
+#define IFCLOSED(turnout_id) OPCODE_IFCLOSED, V(turnout_id),
+#define IFGREEN(signal_id) OPCODE_IFGREEN, V(signal_id),
+#define IFGTE(sensor_id, value) OPCODE_IFGTE, V(sensor_id), OPCODE_PAD, V(value),
+#define IFLOCO(loco_id) OPCODE_IFLOCO, V(loco_id),
+#define IFLT(sensor_id, value) OPCODE_IFLT, V(sensor_id), OPCODE_PAD, V(value),
+#define IFNOT(sensor_id) OPCODE_IFNOT, V(sensor_id),
+#define IFRANDOM(percent) OPCODE_IFRANDOM, V(percent),
+#define IFRED(signal_id) OPCODE_IFRED, V(signal_id),
+#define IFRESERVE(block) OPCODE_IFRESERVE, V(block),
+#define IFTHROWN(turnout_id) OPCODE_IFTHROWN, V(turnout_id),
+#define IFTIMEOUT OPCODE_IFTIMEOUT, 0, 0,
@@ -545 +558 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-#define IFTTPOSITION(id,position) OPCODE_IFTTPOSITION,V(id),OPCODE_PAD,V(position),
+#define IFTTPOSITION(id, position) OPCODE_IFTTPOSITION, V(id), OPCODE_PAD, V(position),
@@ -547,17 +560,16 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-#define IFRE(sensor_id,value) OPCODE_IFRE,V(sensor_id),OPCODE_PAD,V(value),
-#define INVERT_DIRECTION OPCODE_INVERT_DIRECTION,0,0,
-#define JMRI_SENSOR(vpin,count...)
-#define JOIN OPCODE_JOIN,0,0,
-#define KILLALL OPCODE_KILLALL,0,0,
-#define LATCH(sensor_id) OPCODE_LATCH,V(sensor_id),
-#define LCC(eventid) OPCODE_LCC,V(eventid),
-#define LCCX(sender,event) OPCODE_LCCX,V(event),\
-        OPCODE_PAD,V((((uint64_t)sender)>>32)&0xFFFF),\
-        OPCODE_PAD,V((((uint64_t)sender)>>16)&0xFFFF),\
-        OPCODE_PAD,V((((uint64_t)sender)>>0)&0xFFFF),  
-#define ACON(eventid) OPCODE_ACON,V(((uint32_t)eventid >>16) & 0xFFFF),OPCODE_PAD,V(eventid & 0xFFFF),
-#define ACOF(eventid) OPCODE_ACOF,V(((uint32_t)eventid >>16) & 0xFFFF),OPCODE_PAD,V(eventid & 0xFFFF),
-#define ONACON(eventid) OPCODE_ONACON,V((uint32_t)(eventid) >>16),OPCODE_PAD,V(eventid & 0xFFFF),
-#define ONACOF(eventid) OPCODE_ONACOF,V((uint32_t)(eventid) >>16),OPCODE_PAD,V(eventid & 0xFFFF),
-#define LCD(id,msg) PRINT(msg)
-#define SCREEN(display,id,msg) PRINT(msg)
+#define IFRE(sensor_id, value) OPCODE_IFRE, V(sensor_id), OPCODE_PAD, V(value),
+#define INVERT_DIRECTION OPCODE_INVERT_DIRECTION, 0, 0,
+#define JMRI_SENSOR(vpin, count...)
+#define JOIN OPCODE_JOIN, 0, 0,
+#define KILLALL OPCODE_KILLALL, 0, 0,
+#define LATCH(sensor_id) OPCODE_LATCH, V(sensor_id),
+#define LCC(eventid) OPCODE_LCC, V(eventid),
+#define LCCX(sender, event)                                                                                                                  \
+  OPCODE_LCCX, V(event), OPCODE_PAD, V((((uint64_t)sender) >> 32) & 0xFFFF), OPCODE_PAD, V((((uint64_t)sender) >> 16) & 0xFFFF), OPCODE_PAD, \
+      V((((uint64_t)sender) >> 0) & 0xFFFF),
+#define ACON(eventid) OPCODE_ACON, V(((uint32_t)eventid >> 16) & 0xFFFF), OPCODE_PAD, V(eventid & 0xFFFF),
+#define ACOF(eventid) OPCODE_ACOF, V(((uint32_t)eventid >> 16) & 0xFFFF), OPCODE_PAD, V(eventid & 0xFFFF),
+#define ONACON(eventid) OPCODE_ONACON, V((uint32_t)(eventid) >> 16), OPCODE_PAD, V(eventid & 0xFFFF),
+#define ONACOF(eventid) OPCODE_ONACOF, V((uint32_t)(eventid) >> 16), OPCODE_PAD, V(eventid & 0xFFFF),
+#define LCD(id, msg) PRINT(msg)
+#define SCREEN(display, id, msg) PRINT(msg)
@@ -565 +577 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-#define STEALTH_GLOBAL(code...) 
+#define STEALTH_GLOBAL(code...)
@@ -568,23 +580,20 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-#define MOVETT(id,steps,activity) OPCODE_SERVO,V(id),OPCODE_PAD,V(steps),OPCODE_PAD,V(EXTurntable::activity),OPCODE_PAD,V(0),
-#define NEOPIXEL(id,r,g,b,count...) OPCODE_NEOPIXEL,V(id),\
-        OPCODE_PAD,V(((r & 0xff)<<8) | (g & 0xff)),\
-        OPCODE_PAD,V((b & 0xff)),\
-        OPCODE_PAD,V(#count[0]?(count+0):1),
-         
-#define NEOPIXEL_SIGNAL(sigid,redcolour,ambercolour,greencolour)
-#define ONACTIVATE(addr,subaddr) OPCODE_ONACTIVATE,V(addr<<2|subaddr),
-#define ONACTIVATEL(linear) OPCODE_ONACTIVATE,V(linear+3),
-#define ONAMBER(signal_id) OPCODE_ONAMBER,V(signal_id),
-#define ONCLOSE(turnout_id) OPCODE_ONCLOSE,V(turnout_id),
-#define ONLCC(sender,event) OPCODE_ONLCC,V(event),\
-        OPCODE_PAD,V((((uint64_t)sender)>>32)&0xFFFF),\
-        OPCODE_PAD,V((((uint64_t)sender)>>16)&0xFFFF),\
-        OPCODE_PAD,V((((uint64_t)sender)>>0)&0xFFFF),        
-#define ONTIME(value) OPCODE_ONTIME,V(value),  
-#define ONCLOCKTIME(hours,mins) OPCODE_ONTIME,V((STRIP_ZERO(hours)*60)+STRIP_ZERO(mins)),
-#define ONCLOCKMINS(mins) ONCLOCKTIME(25,mins)
-#define ONOVERLOAD(track_id) OPCODE_ONOVERLOAD,V(TRACK_NUMBER_##track_id),
-#define ONDEACTIVATE(addr,subaddr) OPCODE_ONDEACTIVATE,V(addr<<2|subaddr),
-#define ONDEACTIVATEL(linear) OPCODE_ONDEACTIVATE,V(linear+3),
-#define ONGREEN(signal_id) OPCODE_ONGREEN,V(signal_id),
-#define ONRED(signal_id) OPCODE_ONRED,V(signal_id),
+#define MOVETT(id, steps, activity) OPCODE_SERVO, V(id), OPCODE_PAD, V(steps), OPCODE_PAD, V(EXTurntable::activity), OPCODE_PAD, V(0),
+#define NEOPIXEL(id, r, g, b, count...) \
+  OPCODE_NEOPIXEL, V(id), OPCODE_PAD, V(((r & 0xff) << 8) | (g & 0xff)), OPCODE_PAD, V((b & 0xff)), OPCODE_PAD, V(#count[0] ? (count + 0) : 1),
+
+#define NEOPIXEL_SIGNAL(sigid, redcolour, ambercolour, greencolour)
+#define ONACTIVATE(addr, subaddr) OPCODE_ONACTIVATE, V(addr << 2 | subaddr),
+#define ONACTIVATEL(linear) OPCODE_ONACTIVATE, V(linear + 3),
+#define ONAMBER(signal_id) OPCODE_ONAMBER, V(signal_id),
+#define ONCLOSE(turnout_id) OPCODE_ONCLOSE, V(turnout_id),
+#define ONLCC(sender, event)                                                                                                                  \
+  OPCODE_ONLCC, V(event), OPCODE_PAD, V((((uint64_t)sender) >> 32) & 0xFFFF), OPCODE_PAD, V((((uint64_t)sender) >> 16) & 0xFFFF), OPCODE_PAD, \
+      V((((uint64_t)sender) >> 0) & 0xFFFF),
+#define ONTIME(value) OPCODE_ONTIME, V(value),
+#define ONCLOCKTIME(hours, mins) OPCODE_ONTIME, V((STRIP_ZERO(hours) * 60) + STRIP_ZERO(mins)),
+#define ONCLOCKMINS(mins) ONCLOCKTIME(25, mins)
+#define ONOVERLOAD(track_id) OPCODE_ONOVERLOAD, V(TRACK_NUMBER_##track_id),
+#define ONDEACTIVATE(addr, subaddr) OPCODE_ONDEACTIVATE, V(addr << 2 | subaddr),
+#define ONDEACTIVATEL(linear) OPCODE_ONDEACTIVATE, V(linear + 3),
+#define ONGREEN(signal_id) OPCODE_ONGREEN, V(signal_id),
+#define ONRED(signal_id) OPCODE_ONRED, V(signal_id),
@@ -592 +601 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-#define ONROTATE(id) OPCODE_ONROTATE,V(id),
+#define ONROTATE(id) OPCODE_ONROTATE, V(id),
@@ -594,7 +603,7 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-#define ONTHROW(turnout_id) OPCODE_ONTHROW,V(turnout_id),
-#define ONCHANGE(sensor_id) OPCODE_ONCHANGE,V(sensor_id),
-#define ONSENSOR(sensor_id) OPCODE_ONSENSOR,V(sensor_id),
-#define ONBUTTON(sensor_id) OPCODE_ONBUTTON,V(sensor_id),
-#define PAUSE OPCODE_PAUSE,0,0,
-#define PICKUP_STASH(id) OPCODE_PICKUP_STASH,V(id),
-#define PIN_TURNOUT(id,pin,description...) OPCODE_PINTURNOUT,V(id),OPCODE_PAD,V(pin),
+#define ONTHROW(turnout_id) OPCODE_ONTHROW, V(turnout_id),
+#define ONCHANGE(sensor_id) OPCODE_ONCHANGE, V(sensor_id),
+#define ONSENSOR(sensor_id) OPCODE_ONSENSOR, V(sensor_id),
+#define ONBUTTON(sensor_id) OPCODE_ONBUTTON, V(sensor_id),
+#define PAUSE OPCODE_PAUSE, 0, 0,
+#define PICKUP_STASH(id) OPCODE_PICKUP_STASH, V(id),
+#define PIN_TURNOUT(id, pin, description...) OPCODE_PINTURNOUT, V(id), OPCODE_PAD, V(pin),
@@ -602 +611 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-#define POM(cv,value) OPCODE_POM,V(cv),OPCODE_PAD,V(value),
+#define POM(cv, value) OPCODE_POM, V(cv), OPCODE_PAD, V(value),
@@ -604,3 +613,3 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-#define POWEROFF OPCODE_POWEROFF,0,0,
-#define POWERON OPCODE_POWERON,0,0,
-#define PRINT(msg) OPCODE_PRINT,V(__COUNTER__ - StringMacroTracker2),
+#define POWEROFF OPCODE_POWEROFF, 0, 0,
+#define POWERON OPCODE_POWERON, 0, 0,
+#define PRINT(msg) OPCODE_PRINT, V(__COUNTER__ - StringMacroTracker2),
@@ -608,8 +617,8 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-#define READ_LOCO OPCODE_READ_LOCO1,0,0,OPCODE_READ_LOCO2,0,0,
-#define RED(signal_id) OPCODE_RED,V(signal_id),
-#define RESERVE(blockid) OPCODE_RESERVE,V(blockid),
-#define RESET(pin,count...) OPCODE_RESET,V(pin),OPCODE_PAD,V(#count[0] ? count+0: 1),
-#define RESUME OPCODE_RESUME,0,0,
-#define RETURN OPCODE_RETURN,0,0,
-#define REV(speed) OPCODE_REV,V(speed),
-#define ROSTER(cabid,name,funcmap...)
+#define READ_LOCO OPCODE_READ_LOCO1, 0, 0, OPCODE_READ_LOCO2, 0, 0,
+#define RED(signal_id) OPCODE_RED, V(signal_id),
+#define RESERVE(blockid) OPCODE_RESERVE, V(blockid),
+#define RESET(pin, count...) OPCODE_RESET, V(pin), OPCODE_PAD, V(#count[0] ? count + 0 : 1),
+#define RESUME OPCODE_RESUME, 0, 0,
+#define RETURN OPCODE_RETURN, 0, 0,
+#define REV(speed) OPCODE_REV, V(speed),
+#define ROSTER(cabid, name, funcmap...)
@@ -617,2 +626,2 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-#define ROTATE(id,position,activity) OPCODE_ROTATE,V(id),OPCODE_PAD,V(position),OPCODE_PAD,V(EXTurntable::activity),
-#define ROTATE_DCC(id,position) OPCODE_ROTATE,V(id),OPCODE_PAD,V(position),OPCODE_PAD,V(0),
+#define ROTATE(id, position, activity) OPCODE_ROTATE, V(id), OPCODE_PAD, V(position), OPCODE_PAD, V(EXTurntable::activity),
+#define ROTATE_DCC(id, position) OPCODE_ROTATE, V(id), OPCODE_PAD, V(position), OPCODE_PAD, V(0),
@@ -620,8 +629,8 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-#define ROUTE(id, description)  OPCODE_ROUTE, V(id), 
-#define ROUTE_ACTIVE(id)  OPCODE_ROUTE_ACTIVE,V(id),
-#define ROUTE_INACTIVE(id)  OPCODE_ROUTE_INACTIVE,V(id),
-#define ROUTE_HIDDEN(id)  OPCODE_ROUTE_HIDDEN,V(id),
-#define ROUTE_DISABLED(id)  OPCODE_ROUTE_DISABLED,V(id),
-#define ROUTE_CAPTION(id,caption) PRINT(caption)
-#define SENDLOCO(cab,route) OPCODE_SENDLOCO,V(cab),OPCODE_PAD,V(route),
-#define SEQUENCE(id)  OPCODE_SEQUENCE, V(id), 
+#define ROUTE(id, description) OPCODE_ROUTE, V(id),
+#define ROUTE_ACTIVE(id) OPCODE_ROUTE_ACTIVE, V(id),
+#define ROUTE_INACTIVE(id) OPCODE_ROUTE_INACTIVE, V(id),
+#define ROUTE_HIDDEN(id) OPCODE_ROUTE_HIDDEN, V(id),
+#define ROUTE_DISABLED(id) OPCODE_ROUTE_DISABLED, V(id),
+#define ROUTE_CAPTION(id, caption) PRINT(caption)
+#define SENDLOCO(cab, route) OPCODE_SENDLOCO, V(cab), OPCODE_PAD, V(route),
+#define SEQUENCE(id) OPCODE_SEQUENCE, V(id),
@@ -635,17 +644,19 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-#define SERVO(id,position,profile) OPCODE_SERVO,V(id),OPCODE_PAD,V(position),OPCODE_PAD,V(PCA9685::profile),OPCODE_PAD,V(0),
-#define SERVO2(id,position,ms) OPCODE_SERVO,V(id),OPCODE_PAD,V(position),OPCODE_PAD,V(PCA9685::Instant),OPCODE_PAD,V(ms/100L),
-#define SERVO_SIGNAL(vpin,redpos,amberpos,greenpos)
-#define SERVO_TURNOUT(id,pin,activeAngle,inactiveAngle,profile,description...) OPCODE_SERVOTURNOUT,V(id),OPCODE_PAD,V(pin),OPCODE_PAD,V(activeAngle),OPCODE_PAD,V(inactiveAngle),OPCODE_PAD,V(PCA9685::ProfileType::profile),
-#define SET(pin,count...) OPCODE_SET,V(pin),OPCODE_PAD,V(#count[0] ? count+0: 1),
-#define SET_TRACK(track,mode)  OPCODE_SET_TRACK,V(TRACK_MODE_##mode  <<8 | TRACK_NUMBER_##track),
-#define SET_POWER(track,onoff) OPCODE_SET_POWER,V(TRACK_POWER_##onoff),OPCODE_PAD, V(TRACK_NUMBER_##track),
-#define SETLOCO(loco) OPCODE_SETLOCO,V(loco),
-#define SETFREQ(freq) OPCODE_SETFREQ,V(freq),
-#define SIGNAL(redpin,amberpin,greenpin) 
-#define SIGNALH(redpin,amberpin,greenpin) 
-#define SPEED(speed) OPCODE_SPEED,V(speed),
-#define START(route) OPCODE_START,V(route), 
-#define STASH(id) OPCODE_STASH,V(id), 
-#define STOP OPCODE_SPEED,V(0), 
-#define THROW(id)  OPCODE_THROW,V(id),
-#define TOGGLE_TURNOUT(id)  OPCODE_TOGGLE_TURNOUT,V(id),
+#define SERVO(id, position, profile) OPCODE_SERVO, V(id), OPCODE_PAD, V(position), OPCODE_PAD, V(PCA9685::profile), OPCODE_PAD, V(0),
+#define SERVO2(id, position, ms) OPCODE_SERVO, V(id), OPCODE_PAD, V(position), OPCODE_PAD, V(PCA9685::Instant), OPCODE_PAD, V(ms / 100L),
+#define SERVO_SIGNAL(vpin, redpos, amberpos, greenpos)
+#define SERVO_TURNOUT(id, pin, activeAngle, inactiveAngle, profile, description...)                                     \
+  OPCODE_SERVOTURNOUT, V(id), OPCODE_PAD, V(pin), OPCODE_PAD, V(activeAngle), OPCODE_PAD, V(inactiveAngle), OPCODE_PAD, \
+      V(PCA9685::ProfileType::profile),
+#define SET(pin, count...) OPCODE_SET, V(pin), OPCODE_PAD, V(#count[0] ? count + 0 : 1),
+#define SET_TRACK(track, mode) OPCODE_SET_TRACK, V(TRACK_MODE_##mode << 8 | TRACK_NUMBER_##track),
+#define SET_POWER(track, onoff) OPCODE_SET_POWER, V(TRACK_POWER_##onoff), OPCODE_PAD, V(TRACK_NUMBER_##track),
+#define SETLOCO(loco) OPCODE_SETLOCO, V(loco),
+#define SETFREQ(freq) OPCODE_SETFREQ, V(freq),
+#define SIGNAL(redpin, amberpin, greenpin)
+#define SIGNALH(redpin, amberpin, greenpin)
+#define SPEED(speed) OPCODE_SPEED, V(speed),
+#define START(route) OPCODE_START, V(route),
+#define STASH(id) OPCODE_STASH, V(id),
+#define STOP OPCODE_SPEED, V(0),
+#define THROW(id) OPCODE_THROW, V(id),
+#define TOGGLE_TURNOUT(id) OPCODE_TOGGLE_TURNOUT, V(id),
@@ -653 +664,2 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-#define TT_ADDPOSITION(id,position,value,angle,description...) OPCODE_TTADDPOSITION,V(id),OPCODE_PAD,V(position),OPCODE_PAD,V(value),OPCODE_PAD,V(angle),
+#define TT_ADDPOSITION(id, position, value, angle, description...) \
+  OPCODE_TTADDPOSITION, V(id), OPCODE_PAD, V(position), OPCODE_PAD, V(value), OPCODE_PAD, V(angle),
@@ -655,6 +667,6 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-#define TURNOUT(id,addr,subaddr,description...) OPCODE_TURNOUT,V(id),OPCODE_PAD,V(addr),OPCODE_PAD,V(subaddr),
-#define TURNOUTL(id,addr,description...) TURNOUT(id,(addr-1)/4+1,(addr-1)%4, description)
-#define UNJOIN OPCODE_UNJOIN,0,0,
-#define UNLATCH(sensor_id) OPCODE_UNLATCH,V(sensor_id),
-#define VIRTUAL_SIGNAL(id) 
-#define VIRTUAL_TURNOUT(id,description...) OPCODE_PINTURNOUT,V(id),OPCODE_PAD,V(0), 
+#define TURNOUT(id, addr, subaddr, description...) OPCODE_TURNOUT, V(id), OPCODE_PAD, V(addr), OPCODE_PAD, V(subaddr),
+#define TURNOUTL(id, addr, description...) TURNOUT(id, (addr - 1) / 4 + 1, (addr - 1) % 4, description)
+#define UNJOIN OPCODE_UNJOIN, 0, 0,
+#define UNLATCH(sensor_id) OPCODE_UNLATCH, V(sensor_id),
+#define VIRTUAL_SIGNAL(id)
+#define VIRTUAL_TURNOUT(id, description...) OPCODE_PINTURNOUT, V(id), OPCODE_PAD, V(0),
@@ -662 +674 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-#define WAITFOR(pin) OPCODE_WAITFOR,V(pin),
+#define WAITFOR(pin) OPCODE_WAITFOR, V(pin),
@@ -664 +676 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-#define WAITFORTT(turntable_id) OPCODE_WAITFORTT,V(turntable_id),
+#define WAITFORTT(turntable_id) OPCODE_WAITFORTT, V(turntable_id),
@@ -666,5 +678,5 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-#define XFOFF(cab,func) OPCODE_XFOFF,V(cab),OPCODE_PAD,V(func),
-#define XFON(cab,func) OPCODE_XFON,V(cab),OPCODE_PAD,V(func),
-#define XFTOGGLE(cab,func) OPCODE_XFTOGGLE,V(cab),OPCODE_PAD,V(func),
-#define XFWD(cab,speed) OPCODE_XFWD,V(cab),OPCODE_PAD,V(speed),
-#define XREV(cab,speed) OPCODE_XREV,V(cab),OPCODE_PAD,V(speed),
+#define XFOFF(cab, func) OPCODE_XFOFF, V(cab), OPCODE_PAD, V(func),
+#define XFON(cab, func) OPCODE_XFON, V(cab), OPCODE_PAD, V(func),
+#define XFTOGGLE(cab, func) OPCODE_XFTOGGLE, V(cab), OPCODE_PAD, V(func),
+#define XFWD(cab, speed) OPCODE_XFWD, V(cab), OPCODE_PAD, V(speed),
+#define XREV(cab, speed) OPCODE_XREV, V(cab), OPCODE_PAD, V(speed),
@@ -673,4 +685,4 @@ int RMFT2::onLCCLookup[RMFT2::countLCCLookup];
-const int StringMacroTracker2=__COUNTER__;
-const  HIGHFLASH3  byte RMFT2::RouteCode[] = {
-    #include "myAutomation.h"
-    OPCODE_ENDTASK,0,0,OPCODE_ENDEXRAIL,0,0 };
+const int StringMacroTracker2 = __COUNTER__;
+const HIGHFLASH3 byte RMFT2::RouteCode[] = {
+#include "myAutomation.h"
+    OPCODE_ENDTASK, 0, 0, OPCODE_ENDEXRAIL, 0, 0};
@@ -680 +692 @@ const  HIGHFLASH3  byte RMFT2::RouteCode[] = {
-#define LCD   StringFormatter::lcd
+#define LCD StringFormatter::lcd
@@ -682 +694 @@ const  HIGHFLASH3  byte RMFT2::RouteCode[] = {
-#define SCREEN  StringFormatter::lcd2
+#define SCREEN StringFormatter::lcd2
@@ -684 +696 @@ const  HIGHFLASH3  byte RMFT2::RouteCode[] = {
-#define SERIAL  0x0
+#define SERIAL 0x0
diff --git a/EXRAILSensor.cpp b/EXRAILSensor.cpp
index 218b970..f6f0896 100644
--- a/EXRAILSensor.cpp
+++ b/EXRAILSensor.cpp
@@ -4 +4 @@
- *  
+ *
@@ -27 +27 @@ The basic logic is similar to that found in the Sensor class
-except that on the relevant change an EXRAIL thread is started.    
+except that on the relevant change an EXRAIL thread is started.
@@ -34,2 +34,3 @@ void EXRAILSensor::checkAll() {
-  if (firstSensor == NULL) return;  // No sensors to be scanned
-  if (readingSensor == NULL) { 
+  if (firstSensor == NULL)
+    return;  // No sensors to be scanned
+  if (readingSensor == NULL) {
@@ -38 +39,2 @@ void EXRAILSensor::checkAll() {
-    if (thisTime - lastReadCycle < cycleInterval) return;
+    if (thisTime - lastReadCycle < cycleInterval)
+      return;
@@ -44 +46 @@ void EXRAILSensor::checkAll() {
-  
+
@@ -49 +51 @@ void EXRAILSensor::checkAll() {
-    bool pause=readingSensor->check();
+    bool pause = readingSensor->check();
@@ -56 +58,2 @@ void EXRAILSensor::checkAll() {
-    if (pause || (++sensorCount)>=16) return; 
+    if (pause || (++sensorCount) >= 16)
+      return;
@@ -58 +61 @@ void EXRAILSensor::checkAll() {
-} 
+}
@@ -61 +64 @@ bool EXRAILSensor::check() {
-  // check for debounced change in this sensor 
+  // check for debounced change in this sensor
@@ -65,3 +68,3 @@ bool EXRAILSensor::check() {
-  if (inputState == active) {// no change
-    latchDelay = minReadCount; // Reset counter
-    return false;  // no change 
+  if (inputState == active) {   // no change
+    latchDelay = minReadCount;  // Reset counter
+    return false;               // no change
@@ -70,14 +73,14 @@ bool EXRAILSensor::check() {
-    // Change detected ... has it stayed changed for long enough
-    if (latchDelay > 0) {
-      latchDelay--;
-      return false; 
-    } 
-    
-    // change validated, act on it.
-    active = inputState;
-    latchDelay = minReadCount;  // Reset debounce counter
-    if (onChange || active) {
-      new RMFT2(progCounter);
-      return true;  // Don't check any more sensors on this entry
-    }
-    return false; 
+  // Change detected ... has it stayed changed for long enough
+  if (latchDelay > 0) {
+    latchDelay--;
+    return false;
+  }
+
+  // change validated, act on it.
+  active = inputState;
+  latchDelay = minReadCount;  // Reset debounce counter
+  if (onChange || active) {
+    new RMFT2(progCounter);
+    return true;  // Don't check any more sensors on this entry
+  }
+  return false;
@@ -88 +91 @@ EXRAILSensor::EXRAILSensor(VPIN _pin, int _progCounter, bool _onChange) {
-  //DIAG(F("ONthing vpin=%d at %d"), _pin, _progCounter);
+  // DIAG(F("ONthing vpin=%d at %d"), _pin, _progCounter);
@@ -92,3 +95,3 @@ EXRAILSensor::EXRAILSensor(VPIN _pin, int _progCounter, bool _onChange) {
-  pin=_pin;
-  progCounter=_progCounter;
-  onChange=_onChange;
+  pin = _pin;
+  progCounter = _progCounter;
+  onChange = _onChange;
@@ -96 +99 @@ EXRAILSensor::EXRAILSensor(VPIN _pin, int _progCounter, bool _onChange) {
-  IODevice::configureInput(pin, true);   
+  IODevice::configureInput(pin, true);
@@ -102,3 +105,3 @@ EXRAILSensor::EXRAILSensor(VPIN _pin, int _progCounter, bool _onChange) {
-EXRAILSensor *EXRAILSensor::firstSensor=NULL;
-EXRAILSensor *EXRAILSensor::readingSensor=NULL;
-unsigned long EXRAILSensor::lastReadCycle=0;
+EXRAILSensor* EXRAILSensor::firstSensor = NULL;
+EXRAILSensor* EXRAILSensor::readingSensor = NULL;
+unsigned long EXRAILSensor::lastReadCycle = 0;
diff --git a/EXRAILSensor.h b/EXRAILSensor.h
index c9929f6..257be6b 100644
--- a/EXRAILSensor.h
+++ b/EXRAILSensor.h
@@ -4 +4 @@
- *  
+ *
@@ -22 +22 @@
-#define EXRAILSensor_h 
+#define EXRAILSensor_h
@@ -25,5 +25,5 @@ class EXRAILSensor {
-  static EXRAILSensor * firstSensor;
- static EXRAILSensor * readingSensor;
- static unsigned long lastReadCycle;
- 
-  public:
+  static EXRAILSensor* firstSensor;
+  static EXRAILSensor* readingSensor;
+  static unsigned long lastReadCycle;
+
+ public:
@@ -31 +31 @@ class EXRAILSensor {
-  
+
@@ -34,8 +34,8 @@ class EXRAILSensor {
-  
-  private:
-  static const unsigned int cycleInterval = 10000; // min time between consecutive reads of each sensor in microsecs.
-                                                   // should not be less than device scan cycle time.
-  static const byte minReadCount = 4; // number of additional scans before acting on change
-                                        // E.g. 1 means that a change is ignored for one scan and actioned on the next.
-                                        // Max value is 63
-  
+
+ private:
+  static const unsigned int cycleInterval = 10000;  // min time between consecutive reads of each sensor in microsecs.
+                                                    // should not be less than device scan cycle time.
+  static const byte minReadCount = 4;               // number of additional scans before acting on change
+                                                    // E.g. 1 means that a change is ignored for one scan and actioned on the next.
+                                                    // Max value is 63
+
@@ -43,3 +43,3 @@ class EXRAILSensor {
-  VPIN pin; 
-  int progCounter; 
-  bool active; 
+  VPIN pin;
+  int progCounter;
+  bool active;
diff --git a/EthernetInterface.cpp b/EthernetInterface.cpp
index f8306cb..4542a97 100644
--- a/EthernetInterface.cpp
+++ b/EthernetInterface.cpp
@@ -10 +10 @@
- *  
+ *
@@ -25 +25 @@
- * 
+ *
@@ -27 +27 @@
-#include "defines.h" 
+#include "defines.h"
@@ -34,5 +34,5 @@
-#if __has_include ( "MDNS_Generic.h")
-  #include "MDNS_Generic.h"
-  #define DO_MDNS 
-  EthernetUDP udp;
-  MDNS mdns(udp);
+#if __has_include("MDNS_Generic.h")
+#include "MDNS_Generic.h"
+#define DO_MDNS
+EthernetUDP udp;
+MDNS mdns(udp);
@@ -40,0 +41,2 @@
+// extern void looptimer(unsigned long timeout, const FSH* message);
+#define looptimer(a, b)
@@ -42,9 +44,8 @@
-//extern void looptimer(unsigned long timeout, const FSH* message);
-#define looptimer(a,b)
-
-bool EthernetInterface::connected=false;
-EthernetServer * EthernetInterface::server= nullptr;
-EthernetClient EthernetInterface::clients[MAX_SOCK_NUM];                // accept up to MAX_SOCK_NUM client connections at the same time; This depends on the chipset used on the Shield
-bool EthernetInterface::inUse[MAX_SOCK_NUM];                // accept up to MAX_SOCK_NUM client connections at the same time; This depends on the chipset used on the Shield
-uint8_t EthernetInterface::buffer[MAX_ETH_BUFFER+1];                    // buffer used by TCP for the recv
-RingStream * EthernetInterface::outboundRing = nullptr;
+bool EthernetInterface::connected = false;
+EthernetServer* EthernetInterface::server = nullptr;
+EthernetClient EthernetInterface::clients[MAX_SOCK_NUM];  // accept up to MAX_SOCK_NUM client connections at the same time; This depends on the
+                                                          // chipset used on the Shield
+bool EthernetInterface::inUse[MAX_SOCK_NUM];  // accept up to MAX_SOCK_NUM client connections at the same time; This depends on the chipset used on
+                                              // the Shield
+uint8_t EthernetInterface::buffer[MAX_ETH_BUFFER + 1];  // buffer used by TCP for the recv
+RingStream* EthernetInterface::outboundRing = nullptr;
@@ -54 +55 @@ RingStream * EthernetInterface::outboundRing = nullptr;
- * 
+ *
@@ -57,21 +58,7 @@ RingStream * EthernetInterface::outboundRing = nullptr;
-void EthernetInterface::setup() 
-{
-  DIAG(F("Ethernet starting"
-  #ifdef DO_MDNS
-    " (with mDNS)"
-  #endif 
-    " Please be patient, especially if no cable is connected!"
-  ));
-  
-  #ifdef STM32_ETHERNET
-    // Set a HOSTNAME for the DHCP request - a nice to have, but hard it seems on LWIP for STM32
-    // The default is "lwip", which is **always** set in STM32Ethernet/src/utility/ethernetif.cpp
-    // for some reason. One can edit it to instead read:
-    //      #if LWIP_NETIF_HOSTNAME
-    //      /* Initialize interface hostname */
-    //      if (netif->hostname == NULL)
-    //         netif->hostname = "lwip";
-    //      #endif /* LWIP_NETIF_HOSTNAME */
-    // Which seems more useful! We should propose the patch... so the following line actually works!
-    netif_set_hostname(&gnetif, WIFI_HOSTNAME);   // Should probably be passed in the contructor...
-  #endif   
+void EthernetInterface::setup() {
+  DIAG(
+      F("Ethernet starting"
+#ifdef DO_MDNS
+        " (with mDNS)"
+#endif
+        " Please be patient, especially if no cable is connected!"));
@@ -79,10 +66,22 @@ void EthernetInterface::setup()
-    byte mac[6];
-    DCCTimer::getSimulatedMacAddress(mac);
-  
-  #ifdef IP_ADDRESS
-    static IPAddress myIP(IP_ADDRESS);
-    Ethernet.begin(mac,myIP);
-  #else
-    if (Ethernet.begin(mac)==0)
-  {
-    LCD(4,F("IP: No DHCP"));
+#ifdef STM32_ETHERNET
+  // Set a HOSTNAME for the DHCP request - a nice to have, but hard it seems on LWIP for STM32
+  // The default is "lwip", which is **always** set in STM32Ethernet/src/utility/ethernetif.cpp
+  // for some reason. One can edit it to instead read:
+  //      #if LWIP_NETIF_HOSTNAME
+  //      /* Initialize interface hostname */
+  //      if (netif->hostname == NULL)
+  //         netif->hostname = "lwip";
+  //      #endif /* LWIP_NETIF_HOSTNAME */
+  // Which seems more useful! We should propose the patch... so the following line actually works!
+  netif_set_hostname(&gnetif, WIFI_HOSTNAME);  // Should probably be passed in the contructor...
+#endif
+
+  byte mac[6];
+  DCCTimer::getSimulatedMacAddress(mac);
+
+#ifdef IP_ADDRESS
+  static IPAddress myIP(IP_ADDRESS);
+  Ethernet.begin(mac, myIP);
+#else
+  if (Ethernet.begin(mac) == 0) {
+    LCD(4, F("IP: No DHCP"));
@@ -91 +90 @@ void EthernetInterface::setup()
-  #endif
+#endif
@@ -93 +92 @@ void EthernetInterface::setup()
-  auto ip = Ethernet.localIP();    // look what IP was obtained (dynamic or static)
+  auto ip = Ethernet.localIP();  // look what IP was obtained (dynamic or static)
@@ -95 +94 @@ void EthernetInterface::setup()
-    LCD(4,F("IP: None"));
+    LCD(4, F("IP: None"));
@@ -98 +97 @@ void EthernetInterface::setup()
-  server = new EthernetServer(IP_PORT); // Ethernet Server listening on default port IP_PORT
+  server = new EthernetServer(IP_PORT);  // Ethernet Server listening on default port IP_PORT
@@ -101,7 +100,7 @@ void EthernetInterface::setup()
-  // Arrange display of IP address and port
-  #ifdef LCD_DRIVER
-    const byte lcdData[]={LCD_DRIVER};
-    const bool wideDisplay=lcdData[1]>=24; // data[1] is cols. 
-  #else 
-    const bool wideDisplay=true;
-  #endif    
+// Arrange display of IP address and port
+#ifdef LCD_DRIVER
+  const byte lcdData[] = {LCD_DRIVER};
+  const bool wideDisplay = lcdData[1] >= 24;  // data[1] is cols.
+#else
+  const bool wideDisplay = true;
+#endif
@@ -109,6 +108,5 @@ void EthernetInterface::setup()
-    // OLEDS or just usb diag is ok on one line. 
-    LCD(4,F("IP %d.%d.%d.%d:%d"), ip[0], ip[1], ip[2], ip[3], IP_PORT);    
-  } 
-  else { // LCDs generally too narrow, so take 2 lines
-    LCD(4,F("IP %d.%d.%d.%d"), ip[0], ip[1], ip[2], ip[3]);
-    LCD(5,F("Port %d"), IP_PORT);
+    // OLEDS or just usb diag is ok on one line.
+    LCD(4, F("IP %d.%d.%d.%d:%d"), ip[0], ip[1], ip[2], ip[3], IP_PORT);
+  } else {  // LCDs generally too narrow, so take 2 lines
+    LCD(4, F("IP %d.%d.%d.%d"), ip[0], ip[1], ip[2], ip[3]);
+    LCD(5, F("Port %d"), IP_PORT);
@@ -116,5 +114,5 @@ void EthernetInterface::setup()
- 
-  outboundRing=new RingStream(OUTBOUND_RING_SIZE);
-  #ifdef DO_MDNS
-    mdns.begin(Ethernet.localIP(), WIFI_HOSTNAME); // hostname
-    mdns.addServiceRecord(WIFI_HOSTNAME "._withrottle", IP_PORT, MDNSServiceTCP);
+
+  outboundRing = new RingStream(OUTBOUND_RING_SIZE);
+#ifdef DO_MDNS
+  mdns.begin(Ethernet.localIP(), WIFI_HOSTNAME);  // hostname
+  mdns.addServiceRecord(WIFI_HOSTNAME "._withrottle", IP_PORT, MDNSServiceTCP);
@@ -122,3 +120,3 @@ void EthernetInterface::setup()
-    mdns.run();
-  #endif  
-  connected=true;    
+  mdns.run();
+#endif
+  connected = true;
@@ -127,4 +125,5 @@ void EthernetInterface::setup()
-#if defined (STM32_ETHERNET)
-void EthernetInterface::acceptClient() { // STM32 version
-  auto client=server->available();
-  if (!client) return;
+#if defined(STM32_ETHERNET)
+void EthernetInterface::acceptClient() {  // STM32 version
+  auto client = server->available();
+  if (!client)
+    return;
@@ -133,2 +132,3 @@ void EthernetInterface::acceptClient() { // STM32 version
-    if (inUse[socket] && client == clients[socket]) return;
-      
+    if (inUse[socket] && client == clients[socket])
+      return;
+
@@ -136,4 +136,2 @@ void EthernetInterface::acceptClient() { // STM32 version
-  for (byte socket = 0; socket < MAX_SOCK_NUM; socket++)
-  {
-    if (!inUse[socket])
-    {
+  for (byte socket = 0; socket < MAX_SOCK_NUM; socket++) {
+    if (!inUse[socket]) {
@@ -141 +139 @@ void EthernetInterface::acceptClient() { // STM32 version
-      inUse[socket]=true;
+      inUse[socket] = true;
@@ -150,6 +148,7 @@ void EthernetInterface::acceptClient() { // STM32 version
-void EthernetInterface::acceptClient() { // non-STM32 version
-  auto client=server->accept();
-  if (!client) return;
-  auto socket=client.getSocketNumber();
-  clients[socket]=client;
-  inUse[socket]=true;
+void EthernetInterface::acceptClient() {  // non-STM32 version
+  auto client = server->accept();
+  if (!client)
+    return;
+  auto socket = client.getSocketNumber();
+  clients[socket] = client;
+  inUse[socket] = true;
@@ -161,2 +160 @@ void EthernetInterface::acceptClient() { // non-STM32 version
-void EthernetInterface::dropClient(byte socket) 
-{ 
+void EthernetInterface::dropClient(byte socket) {
@@ -164 +162 @@ void EthernetInterface::dropClient(byte socket)
-  inUse[socket]=false;
+  inUse[socket] = false;
@@ -166 +164,2 @@ void EthernetInterface::dropClient(byte socket)
-	if (Diag::ETHERNET)  DIAG(F("Ethernet: Disconnect %d "), socket);  
+  if (Diag::ETHERNET)
+    DIAG(F("Ethernet: Disconnect %d "), socket);
@@ -171 +170 @@ void EthernetInterface::dropClient(byte socket)
- * 
+ *
@@ -173,26 +172,4 @@ void EthernetInterface::dropClient(byte socket)
-void EthernetInterface::loop()
-{
-    if (!connected) return;
-    looptimer(5000, F("E.loop"));
-	      
-    static bool warnedAboutLink=false;
-    if (Ethernet.linkStatus() == LinkOFF){
-        if (warnedAboutLink) return;
-        DIAG(F("Ethernet link OFF"));
-        warnedAboutLink=true;
-        return;
-    }
-    looptimer(5000, F("E.loop warn"));
-	  
-    // link status must be ok here 
-    if (warnedAboutLink) {
-      DIAG(F("Ethernet link RESTORED"));
-      warnedAboutLink=false;
-    } 
-    
-  #ifdef DO_MDNS
-    // Always do this because we don't want traffic to intefere with being found!
-    mdns.run();
-    looptimer(5000, F("E.mdns"));
-	  
-  #endif
+void EthernetInterface::loop() {
+  if (!connected)
+    return;
+  looptimer(5000, F("E.loop"));
@@ -200,2 +177,25 @@ void EthernetInterface::loop()
-    //
-    switch (Ethernet.maintain()) {
+  static bool warnedAboutLink = false;
+  if (Ethernet.linkStatus() == LinkOFF) {
+    if (warnedAboutLink)
+      return;
+    DIAG(F("Ethernet link OFF"));
+    warnedAboutLink = true;
+    return;
+  }
+  looptimer(5000, F("E.loop warn"));
+
+  // link status must be ok here
+  if (warnedAboutLink) {
+    DIAG(F("Ethernet link RESTORED"));
+    warnedAboutLink = false;
+  }
+
+#ifdef DO_MDNS
+  // Always do this because we don't want traffic to intefere with being found!
+  mdns.run();
+  looptimer(5000, F("E.mdns"));
+
+#endif
+
+  //
+  switch (Ethernet.maintain()) {
@@ -203,4 +203,4 @@ void EthernetInterface::loop()
-        //renewed fail
-        DIAG(F("Ethernet Error: renewed fail"));
-        connected=false;
-        return;
+      // renewed fail
+      DIAG(F("Ethernet Error: renewed fail"));
+      connected = false;
+      return;
@@ -208,4 +208,4 @@ void EthernetInterface::loop()
-        //rebind fail
-        DIAG(F("Ethernet Error: rebind fail"));
-        connected=false;
-        return;
+      // rebind fail
+      DIAG(F("Ethernet Error: rebind fail"));
+      connected = false;
+      return;
@@ -213,15 +213,23 @@ void EthernetInterface::loop()
-        //nothing happened
-        //DIAG(F("maintained"));
-        break;
-    }
-    looptimer(5000, F("E.maintain"));
-	  
-    // get client from the server
-    acceptClient();
-    
-    // handle disconnected sockets because STM32 library doesnt
-    // do the read==0 response.
-    for (byte socket = 0; socket < MAX_SOCK_NUM; socket++)
-    {
-      if (inUse[socket] && !clients[socket].connected()) dropClient(socket);
-    }  
+      // nothing happened
+      // DIAG(F("maintained"));
+      break;
+  }
+  looptimer(5000, F("E.maintain"));
+
+  // get client from the server
+  acceptClient();
+
+  // handle disconnected sockets because STM32 library doesnt
+  // do the read==0 response.
+  for (byte socket = 0; socket < MAX_SOCK_NUM; socket++) {
+    if (inUse[socket] && !clients[socket].connected())
+      dropClient(socket);
+  }
+
+  // check for incoming data from all possible clients
+  for (byte socket = 0; socket < MAX_SOCK_NUM; socket++) {
+    if (!inUse[socket])
+      continue;  // socket is not in use
+
+    // read any bytes from this client
+    auto count = clients[socket].read(buffer, MAX_ETH_BUFFER);
@@ -229,21 +237,11 @@ void EthernetInterface::loop()
-    // check for incoming data from all possible clients
-    for (byte socket = 0; socket < MAX_SOCK_NUM; socket++)
-    {
-      if (!inUse[socket]) continue; // socket is not in use
-	
-	    // read any bytes from this client
-	    auto count = clients[socket].read(buffer, MAX_ETH_BUFFER);
-      
-      if (count<0) continue;  // -1 indicates nothing to read
-	    
-      if (count > 0) {  // we have incoming data 
-	      buffer[count] = '\0'; // terminate the string properly
-	      if (Diag::ETHERNET) DIAG(F("Ethernet s=%d, c=%d b=:%e"), socket, count, buffer);
-	      // execute with data going directly back
-	      CommandDistributor::parse(socket,buffer,outboundRing);
-	      //looptimer(5000, F("Ethloop2 parse"));
-	      return; // limit the amount of processing that takes place within 1 loop() cycle. 
-	    }
-	    
-      // count=0 The client has disconnected
-	    dropClient(socket);
+    if (count < 0)
+      continue;  // -1 indicates nothing to read
+
+    if (count > 0) {         // we have incoming data
+      buffer[count] = '\0';  // terminate the string properly
+      if (Diag::ETHERNET)
+        DIAG(F("Ethernet s=%d, c=%d b=:%e"), socket, count, buffer);
+      // execute with data going directly back
+      CommandDistributor::parse(socket, buffer, outboundRing);
+      // looptimer(5000, F("Ethloop2 parse"));
+      return;  // limit the amount of processing that takes place within 1 loop() cycle.
@@ -251,2 +248,0 @@ void EthernetInterface::loop()
-	
-    WiThrottle::loop(outboundRing);
@@ -254,3 +250,3 @@ void EthernetInterface::loop()
-    // handle at most 1 outbound transmission 
-    auto socketOut=outboundRing->read();
-    if (socketOut<0) return;  // no outbound pending
+    // count=0 The client has disconnected
+    dropClient(socket);
+  }
@@ -258,6 +254,6 @@ void EthernetInterface::loop()
-    if (socketOut >= MAX_SOCK_NUM) {
-      // This is a catastrophic code failure and unrecoverable.  
-      DIAG(F("Ethernet outboundRing s=%d error"), socketOut);
-      connected=false;
-      return;
-    } 
+  WiThrottle::loop(outboundRing);
+
+  // handle at most 1 outbound transmission
+  auto socketOut = outboundRing->read();
+  if (socketOut < 0)
+    return;  // no outbound pending
@@ -265,12 +261,12 @@ void EthernetInterface::loop()
-    auto count=outboundRing->count();
-    {
-	    char tmpbuf[count+1]; // one extra for '\0'
-	    for(int i=0;i<count;i++) {
-	      tmpbuf[i] = outboundRing->read();
-	    }
-	    tmpbuf[count]=0;
-      if (inUse[socketOut]) {
-  	    if (Diag::ETHERNET) DIAG(F("Ethernet reply s=%d, c=%d, b:%e"),
-                              socketOut,count,tmpbuf);
-	      clients[socketOut].write(tmpbuf,count);
-      }
+  if (socketOut >= MAX_SOCK_NUM) {
+    // This is a catastrophic code failure and unrecoverable.
+    DIAG(F("Ethernet outboundRing s=%d error"), socketOut);
+    connected = false;
+    return;
+  }
+
+  auto count = outboundRing->count();
+  {
+    char tmpbuf[count + 1];  // one extra for '\0'
+    for (int i = 0; i < count; i++) {
+      tmpbuf[i] = outboundRing->read();
@@ -278 +274,7 @@ void EthernetInterface::loop()
-    
+    tmpbuf[count] = 0;
+    if (inUse[socketOut]) {
+      if (Diag::ETHERNET)
+        DIAG(F("Ethernet reply s=%d, c=%d, b:%e"), socketOut, count, tmpbuf);
+      clients[socketOut].write(tmpbuf, count);
+    }
+  }
diff --git a/EthernetInterface.h b/EthernetInterface.h
index 16156fa..a119acc 100644
--- a/EthernetInterface.h
+++ b/EthernetInterface.h
@@ -10 +10 @@
- *  
+ *
@@ -26 +26 @@
- * 
+ *
@@ -36,7 +36,7 @@
-//#include <avr/pgmspace.h>
-#if defined (ARDUINO_TEENSY41)
- #include <NativeEthernet.h>         //TEENSY Ethernet Treiber
- #include <NativeEthernetUdp.h>   
- #define MAX_SOCK_NUM 4
-#elif defined (ARDUINO_NUCLEO_F429ZI) || defined (ARDUINO_NUCLEO_F439ZI) || defined (ARDUINO_NUCLEO_F4X9ZI)
- #include <LwIP.h>
+// #include <avr/pgmspace.h>
+#if defined(ARDUINO_TEENSY41)
+#include <NativeEthernet.h>  //TEENSY Ethernet Treiber
+#include <NativeEthernetUdp.h>
+#define MAX_SOCK_NUM 4
+#elif defined(ARDUINO_NUCLEO_F429ZI) || defined(ARDUINO_NUCLEO_F439ZI) || defined(ARDUINO_NUCLEO_F4X9ZI)
+#include <LwIP.h>
@@ -44,5 +44,5 @@
- #include <STM32Ethernet.h>
- #include <lwip/netif.h>
- extern "C" struct netif gnetif;
- #define STM32_ETHERNET
- #define MAX_SOCK_NUM 8
+#include <STM32Ethernet.h>
+#include <lwip/netif.h>
+extern "C" struct netif gnetif;
+#define STM32_ETHERNET
+#define MAX_SOCK_NUM 8
@@ -50 +50 @@
- #include "Ethernet.h"
+#include "Ethernet.h"
@@ -56 +56 @@
- * 
+ *
@@ -63 +62,0 @@ class EthernetInterface {
-
@@ -65,4 +64,3 @@ class EthernetInterface {
-     
-     static void setup();       
-     static void loop();
-   
+  static void setup();
+  static void loop();
+
@@ -70,9 +68,9 @@ class EthernetInterface {
-    static bool connected;
-    static EthernetServer * server;
-    static EthernetClient clients[MAX_SOCK_NUM];                // accept up to MAX_SOCK_NUM client connections at the same time; This depends on the chipset used on the Shield
-    static bool inUse[MAX_SOCK_NUM];                // accept up to MAX_SOCK_NUM client connections at the same time; This depends on the chipset used on the Shield
-    static uint8_t buffer[MAX_ETH_BUFFER+1];                    // buffer used by TCP for the recv
-    static RingStream * outboundRing;
-    static void acceptClient();
-    static void dropClient(byte socketnum);
-    
+  static bool connected;
+  static EthernetServer* server;
+  static EthernetClient
+      clients[MAX_SOCK_NUM];        // accept up to MAX_SOCK_NUM client connections at the same time; This depends on the chipset used on the Shield
+  static bool inUse[MAX_SOCK_NUM];  // accept up to MAX_SOCK_NUM client connections at the same time; This depends on the chipset used on the Shield
+  static uint8_t buffer[MAX_ETH_BUFFER + 1];  // buffer used by TCP for the recv
+  static RingStream* outboundRing;
+  static void acceptClient();
+  static void dropClient(byte socketnum);
diff --git a/FSH.h b/FSH.h
index 8610a6a..dbe9631 100644
--- a/FSH.h
+++ b/FSH.h
@@ -7 +7 @@
- *  
+ *
@@ -26 +26 @@
-/* This is an architecture support file to manage the differences 
+/* This is an architecture support file to manage the differences
@@ -28 +28 @@
- *  
+ *
@@ -30,3 +30,3 @@
- *  To maintain portability the main code should NOT contain ANY references 
- *  to the following: 
- *  
+ *  To maintain portability the main code should NOT contain ANY references
+ *  to the following:
+ *
@@ -37 +37 @@
- * 
+ *
@@ -41 +41 @@
- *  
+ *
@@ -55 +55 @@ typedef __FlashStringHelper FSH;
-#define STRCHR_P strchr_P 
+#define STRCHR_P strchr_P
@@ -62,4 +62,3 @@ typedef __FlashStringHelper FSH;
-#define GETHIGHFLASH(data,offset) pgm_read_byte_far(GETFARPTR(data)+offset)
-#define GETHIGHFLASHW(data,offset) pgm_read_word_far(GETFARPTR(data)+offset)
-#define COPYHIGHFLASH(target,base,offset,length) \
-  memcpy_PF(target,GETFARPTR(base) + offset,length)  
+#define GETHIGHFLASH(data, offset) pgm_read_byte_far(GETFARPTR(data) + offset)
+#define GETHIGHFLASHW(data, offset) pgm_read_word_far(GETFARPTR(data) + offset)
+#define COPYHIGHFLASH(target, base, offset, length) memcpy_PF(target, GETFARPTR(base) + offset, length)
@@ -72,4 +71,3 @@ typedef __FlashStringHelper FSH;
-#define GETHIGHFLASH(data,offset) pgm_read_byte_near(GETFARPTR(data)+(offset))
-#define GETHIGHFLASHW(data,offset) pgm_read_word_near(GETFARPTR(data)+(offset))
-#define COPYHIGHFLASH(target,base,offset,length) \
-  memcpy_P(target,(byte *)base + offset,length)  
+#define GETHIGHFLASH(data, offset) pgm_read_byte_near(GETFARPTR(data) + (offset))
+#define GETHIGHFLASHW(data, offset) pgm_read_word_near(GETFARPTR(data) + (offset))
+#define COPYHIGHFLASH(target, base, offset, length) memcpy_P(target, (byte*)base + offset, length)
@@ -78 +76 @@ typedef __FlashStringHelper FSH;
-#else 
+#else
@@ -81 +79 @@ typedef __FlashStringHelper FSH;
-  #undef F
+#undef F
@@ -84 +82 @@ typedef __FlashStringHelper FSH;
-  #undef FLASH
+#undef FLASH
@@ -87 +85 @@ typedef __FlashStringHelper FSH;
-typedef char FSH; 
+typedef char FSH;
@@ -92,5 +90,4 @@ typedef char FSH;
-#define GETFLASH(addr) (*(const byte *)(addr))
-#define GETHIGHFLASH(data,offset)  (*(const byte *)(GETFARPTR(data)+offset))
-#define GETHIGHFLASHW(data,offset) (*(const uint16_t *)(GETFARPTR(data)+offset))
-#define COPYHIGHFLASH(target,base,offset,length) \
-  memcpy(target,(byte *)&base + offset,length)  
+#define GETFLASH(addr) (*(const byte*)(addr))
+#define GETHIGHFLASH(data, offset) (*(const byte*)(GETFARPTR(data) + offset))
+#define GETHIGHFLASHW(data, offset) (*(const uint16_t*)(GETFARPTR(data) + offset))
+#define COPYHIGHFLASH(target, base, offset, length) memcpy(target, (byte*)&base + offset, length)
diff --git a/I2CManager.cpp b/I2CManager.cpp
index 59f455f..b91e5db 100644
--- a/I2CManager.cpp
+++ b/I2CManager.cpp
@@ -27 +27 @@
-#if defined(I2C_USE_WIRE) 
+#if defined(I2C_USE_WIRE)
@@ -31,2 +31,2 @@
-#include "I2CManager_AVR.h"       // Uno/Nano/Mega2560
-#elif defined(ARDUINO_ARCH_MEGAAVR) 
+#include "I2CManager_AVR.h"  // Uno/Nano/Mega2560
+#elif defined(ARDUINO_ARCH_MEGAAVR)
@@ -37 +37 @@
-#include "I2CManager_SAMD.h"      // SAMD21 for now... SAMD51 as well later
+#include "I2CManager_SAMD.h"  // SAMD21 for now... SAMD51 as well later
@@ -40 +40 @@
-#include "I2CManager_STM32.h"      // STM32F411RE for now... more later
+#include "I2CManager_STM32.h"  // STM32F411RE for now... more later
@@ -43 +43 @@
-#include "I2CManager_Wire.h"      // Other platforms
+#include "I2CManager_Wire.h"  // Other platforms
@@ -46 +45,0 @@
-
@@ -48 +47 @@
-static const FSH * guessI2CDeviceType(uint8_t address) {
+static const FSH* guessI2CDeviceType(uint8_t address) {
@@ -65 +64 @@ static const FSH * guessI2CDeviceType(uint8_t address) {
-  if (address >= 0x48 && address <= 0x57) // SC16IS752x UART detection
+  if (address >= 0x48 && address <= 0x57)  // SC16IS752x UART detection
@@ -71,6 +70,6 @@ static const FSH * guessI2CDeviceType(uint8_t address) {
-  if (address >= 0x50 && address <= 0x5f) 
-    return F("EEPROM"); 
-  if (address >= 0x60 && address <= 0x68) 
-    return F("Adafruit NeoPixel Driver"); 
-  if (address == 0x68) 
-    return F("Real-time clock"); 
+  if (address >= 0x50 && address <= 0x5f)
+    return F("EEPROM");
+  if (address >= 0x60 && address <= 0x68)
+    return F("Adafruit NeoPixel Driver");
+  if (address == 0x68)
+    return F("Real-time clock");
@@ -80 +79 @@ static const FSH * guessI2CDeviceType(uint8_t address) {
-    return F("?");
+  return F("?");
@@ -89 +88 @@ void I2CManagerClass::begin(void) {
-    const FSH *message = F("WARNING: Check I2C %S line for short/pullup");
+    const FSH* message = F("WARNING: Check I2C %S line for short/pullup");
@@ -100 +99 @@ void I2CManagerClass::begin(void) {
-    #if defined(I2C_USE_WIRE)
+#if defined(I2C_USE_WIRE)
@@ -102 +101 @@ void I2CManagerClass::begin(void) {
-    #endif
+#endif
@@ -104 +103 @@ void I2CManagerClass::begin(void) {
-    // Probe and list devices.  Use standard mode 
+    // Probe and list devices.  Use standard mode
@@ -108 +107 @@ void I2CManagerClass::begin(void) {
-    setTimeout(1000);       // use 1ms timeout for probes
+    setTimeout(1000);  // use 1ms timeout for probes
@@ -110 +109 @@ void I2CManagerClass::begin(void) {
-  #if defined(I2C_EXTENDED_ADDRESS)
+#if defined(I2C_EXTENDED_ADDRESS)
@@ -113,2 +112,2 @@ void I2CManagerClass::begin(void) {
-    for (uint8_t muxNo=I2CMux_0; muxNo <= I2CMux_7; muxNo++) {
-      if (I2CManager.muxSelectSubBus({(I2CMux)muxNo, SubBus_None})==I2C_STATUS_OK)
+    for (uint8_t muxNo = I2CMux_0; muxNo <= I2CMux_7; muxNo++) {
+      if (I2CManager.muxSelectSubBus({(I2CMux)muxNo, SubBus_None}) == I2C_STATUS_OK)
@@ -117 +116 @@ void I2CManagerClass::begin(void) {
-  #endif
+#endif
@@ -121 +120 @@ void I2CManagerClass::begin(void) {
-    for (uint8_t addr=0x08; addr<0x78; addr++) {
+    for (uint8_t addr = 0x08; addr < 0x78; addr++) {
@@ -123 +122 @@ void I2CManagerClass::begin(void) {
-        found = true; 
+        found = true;
@@ -129 +128 @@ void I2CManagerClass::begin(void) {
-    // Enumerate all I2C devices that are connected via multiplexer, 
+    // Enumerate all I2C devices that are connected via multiplexer,
@@ -134 +133 @@ void I2CManagerClass::begin(void) {
-    for (uint8_t muxNo=I2CMux_0; muxNo <= I2CMux_7; muxNo++) {
+    for (uint8_t muxNo = I2CMux_0; muxNo <= I2CMux_7; muxNo++) {
@@ -138 +137 @@ void I2CManagerClass::begin(void) {
-        for (uint8_t subBus=0; subBus<=SubBus_No; subBus++) {
+        for (uint8_t subBus = 0; subBus <= SubBus_No; subBus++) {
@@ -140 +139 @@ void I2CManagerClass::begin(void) {
-          for (uint8_t addr=0x08; addr<0x78; addr++) {
+          for (uint8_t addr = 0x08; addr < 0x78; addr++) {
@@ -148,3 +147,2 @@ void I2CManagerClass::begin(void) {
-                found = true; 
-                DIAG(F("I2C Device found at {I2CMux_%d,SubBus_%d,0x%x}, %S?"), 
-                  muxNo, subBus, addr, guessI2CDeviceType(addr));
+                found = true;
+                DIAG(F("I2C Device found at {I2CMux_%d,SubBus_%d,0x%x}, %S?"), muxNo, subBus, addr, guessI2CDeviceType(addr));
@@ -163 +161 @@ void I2CManagerClass::begin(void) {
-      } 
+      }
@@ -166 +164,2 @@ void I2CManagerClass::begin(void) {
-    if (!found) DIAG(F("No I2C Devices found"));
+    if (!found)
+      DIAG(F("No I2C Devices found"));
@@ -168 +167 @@ void I2CManagerClass::begin(void) {
-    setTimeout(originalTimeout);      // set timeout back to original
+    setTimeout(originalTimeout);  // set timeout back to original
@@ -201 +199,0 @@ uint8_t I2CManagerClass::checkAddress(I2CAddress address) {
-
@@ -209,2 +207 @@ uint8_t I2CManagerClass::write(I2CAddress address, uint8_t nBytes, ...) {
-  for (uint8_t i=0; i<nBytes; i++)
-    buffer[i] = va_arg(args, int);
+  for (uint8_t i = 0; i < nBytes; i++) buffer[i] = va_arg(args, int);
@@ -227 +224 @@ uint8_t I2CManagerClass::write(I2CAddress i2cAddress, const uint8_t writeBuffer[
-uint8_t I2CManagerClass::write_P(I2CAddress i2cAddress, const uint8_t * data, uint8_t dataLen) {
+uint8_t I2CManagerClass::write_P(I2CAddress i2cAddress, const uint8_t* data, uint8_t dataLen) {
@@ -236,3 +233 @@ uint8_t I2CManagerClass::write_P(I2CAddress i2cAddress, const uint8_t * data, ui
-uint8_t I2CManagerClass::read(I2CAddress i2cAddress, uint8_t *readBuffer, uint8_t readLen, 
-    const uint8_t *writeBuffer, uint8_t writeLen)
-{
+uint8_t I2CManagerClass::read(I2CAddress i2cAddress, uint8_t* readBuffer, uint8_t readLen, const uint8_t* writeBuffer, uint8_t writeLen) {
@@ -247,2 +242 @@ uint8_t I2CManagerClass::read(I2CAddress i2cAddress, uint8_t *readBuffer, uint8_
-uint8_t I2CManagerClass::read(I2CAddress address, uint8_t readBuffer[], uint8_t readSize, 
-                                  uint8_t writeSize, ...) {
+uint8_t I2CManagerClass::read(I2CAddress address, uint8_t readBuffer[], uint8_t readSize, uint8_t writeSize, ...) {
@@ -253,2 +247 @@ uint8_t I2CManagerClass::read(I2CAddress address, uint8_t readBuffer[], uint8_t
-  for (uint8_t i=0; i<writeSize; i++)
-    writeBuffer[i] = va_arg(args, int);
+  for (uint8_t i = 0; i < writeSize; i++) writeBuffer[i] = va_arg(args, int);
@@ -262 +255 @@ uint8_t I2CManagerClass::read(I2CAddress address, uint8_t readBuffer[], uint8_t
-uint8_t I2CManagerClass::finishRB(I2CRB *rb, uint8_t status) {
+uint8_t I2CManagerClass::finishRB(I2CRB* rb, uint8_t status) {
@@ -271 +264 @@ uint8_t I2CManagerClass::finishRB(I2CRB *rb, uint8_t status) {
-const FSH *I2CManagerClass::getErrorMessage(uint8_t status) {
+const FSH* I2CManagerClass::getErrorMessage(uint8_t status) {
@@ -273,11 +266,22 @@ const FSH *I2CManagerClass::getErrorMessage(uint8_t status) {
-    case I2C_STATUS_OK: return F("OK");
-    case I2C_STATUS_TRUNCATED: return F("Transmission truncated");
-    case I2C_STATUS_NEGATIVE_ACKNOWLEDGE: return F("No response from device (address NAK)");
-    case I2C_STATUS_TRANSMIT_ERROR: return F("Transmit error (data NAK)");
-    case I2C_STATUS_OTHER_TWI_ERROR: return F("Other Wire/TWI error");
-    case I2C_STATUS_TIMEOUT: return F("I2C bus timeout");
-    case I2C_STATUS_ARBITRATION_LOST: return F("Arbitration lost");
-    case I2C_STATUS_BUS_ERROR: return F("I2C bus error");
-    case I2C_STATUS_UNEXPECTED_ERROR: return F("Unexpected error");
-    case I2C_STATUS_PENDING: return F("Request pending");
-    default: return F("Error code not recognised");
+    case I2C_STATUS_OK:
+      return F("OK");
+    case I2C_STATUS_TRUNCATED:
+      return F("Transmission truncated");
+    case I2C_STATUS_NEGATIVE_ACKNOWLEDGE:
+      return F("No response from device (address NAK)");
+    case I2C_STATUS_TRANSMIT_ERROR:
+      return F("Transmit error (data NAK)");
+    case I2C_STATUS_OTHER_TWI_ERROR:
+      return F("Other Wire/TWI error");
+    case I2C_STATUS_TIMEOUT:
+      return F("I2C bus timeout");
+    case I2C_STATUS_ARBITRATION_LOST:
+      return F("Arbitration lost");
+    case I2C_STATUS_BUS_ERROR:
+      return F("I2C bus error");
+    case I2C_STATUS_UNEXPECTED_ERROR:
+      return F("Unexpected error");
+    case I2C_STATUS_PENDING:
+      return F("Request pending");
+    default:
+      return F("Error code not recognised");
@@ -304 +308 @@ uint8_t I2CRB::wait() {
-  while (status==I2C_STATUS_PENDING) {
+  while (status == I2C_STATUS_PENDING) {
@@ -315 +319 @@ bool I2CRB::isBusy() {
-  if (status==I2C_STATUS_PENDING) {
+  if (status == I2C_STATUS_PENDING) {
@@ -325 +329 @@ bool I2CRB::isBusy() {
-void I2CRB::setReadParams(I2CAddress i2cAddress, uint8_t *readBuffer, uint8_t readLen) {
+void I2CRB::setReadParams(I2CAddress i2cAddress, uint8_t* readBuffer, uint8_t readLen) {
@@ -334,2 +338 @@ void I2CRB::setReadParams(I2CAddress i2cAddress, uint8_t *readBuffer, uint8_t re
-void I2CRB::setRequestParams(I2CAddress i2cAddress, uint8_t *readBuffer, uint8_t readLen, 
-    const uint8_t *writeBuffer, uint8_t writeLen) {
+void I2CRB::setRequestParams(I2CAddress i2cAddress, uint8_t* readBuffer, uint8_t readLen, const uint8_t* writeBuffer, uint8_t writeLen) {
@@ -345 +348 @@ void I2CRB::setRequestParams(I2CAddress i2cAddress, uint8_t *readBuffer, uint8_t
-void I2CRB::setWriteParams(I2CAddress i2cAddress, const uint8_t *writeBuffer, uint8_t writeLen) {
+void I2CRB::setWriteParams(I2CAddress i2cAddress, const uint8_t* writeBuffer, uint8_t writeLen) {
@@ -361 +363,0 @@ void I2CRB::suppressRetries(bool suppress) {
-
@@ -363,2 +365,2 @@ void I2CRB::suppressRetries(bool suppress) {
-void I2CAddress::toHex(const uint8_t value, char *buffer) {
-  char *ptr = buffer;
+void I2CAddress::toHex(const uint8_t value, char* buffer) {
+  char* ptr = buffer;
@@ -369 +371 @@ void I2CAddress::toHex(const uint8_t value, char *buffer) {
-  *ptr++ = bits > 9 ? bits-10+'a' : bits+'0';
+  *ptr++ = bits > 9 ? bits - 10 + 'a' : bits + '0';
@@ -371 +373 @@ void I2CAddress::toHex(const uint8_t value, char *buffer) {
-  *ptr++ = bits > 9 ? bits-10+'a' : bits+'0';
+  *ptr++ = bits > 9 ? bits - 10 + 'a' : bits + '0';
@@ -374 +376 @@ void I2CAddress::toHex(const uint8_t value, char *buffer) {
-#if !defined(I2C_EXTENDED_ADDRESS) 
+#if !defined(I2C_EXTENDED_ADDRESS)
diff --git a/I2CManager.h b/I2CManager.h
index 08d81d4..7e36cdd 100644
--- a/I2CManager.h
+++ b/I2CManager.h
@@ -29,2 +29,2 @@
-/* 
- * Manager for I2C communications.  For portability, it allows use 
+/*
+ * Manager for I2C communications.  For portability, it allows use
@@ -33 +33 @@
- * 
+ *
@@ -36 +36 @@
- * 
+ *
@@ -39,2 +39,2 @@
- * 
- * Thirdly, it provides a convenient way to check whether there is a 
+ *
+ * Thirdly, it provides a convenient way to check whether there is a
@@ -42 +42 @@
- * 
+ *
@@ -44 +44 @@
- * (I2CRB) which is then added to the I2C manager's queue.  The 
+ * (I2CRB) which is then added to the I2C manager's queue.  The
@@ -47 +47 @@
- * 
+ *
@@ -64 +64 @@
- *  if (status == I2C_STATUS_OK) { 
+ *  if (status == I2C_STATUS_OK) {
@@ -71,2 +71,2 @@
- *  
- * Synchronous (blocking) calls are also possible, e.g. 
+ *
+ * Synchronous (blocking) calls are also possible, e.g.
@@ -74 +74 @@
- * 
+ *
@@ -77 +77 @@
- * 
+ *
@@ -83 +83 @@
- * 
+ *
@@ -86 +86 @@
-/* 
+/*
@@ -88 +88 @@
- * 
+ *
@@ -91 +91 @@
- *  And a single I2C bus can have up to 8 multiplexers, giving up to 64 sub-buses and, in theory, up to 512 I/O extenders; that's 
+ *  And a single I2C bus can have up to 8 multiplexers, giving up to 64 sub-buses and, in theory, up to 512 I/O extenders; that's
@@ -94,2 +94,2 @@
- *  The multiplexer isolates each sub-bus from the others, and so reduces the capacitance of the bus.  For example, with one 
- *  multiplexer and 64 GPIO extenders, only 9 devices are connected to the bus at any time (multiplexer plus 8 extenders). 
+ *  The multiplexer isolates each sub-bus from the others, and so reduces the capacitance of the bus.  For example, with one
+ *  multiplexer and 64 GPIO extenders, only 9 devices are connected to the bus at any time (multiplexer plus 8 extenders).
@@ -98,2 +98,2 @@
- * 
- * 
+ *
+ *
@@ -101 +101 @@
- * 
+ *
@@ -104,2 +104,2 @@
- *  The speed at which I2C operations can be performed then becomes highly dependent on the frequency that 
- *  the loop() function is called, and may be adequate under some circumstances.  
+ *  The speed at which I2C operations can be performed then becomes highly dependent on the frequency that
+ *  the loop() function is called, and may be adequate under some circumstances.
@@ -108 +108 @@
- * 
+ *
@@ -119 +119 @@
-//#define I2C_USE_WIRE
+// #define I2C_USE_WIRE
@@ -122 +122 @@
-//#define I2C_NO_INTERRUPTS
+// #define I2C_NO_INTERRUPTS
@@ -129 +129 @@
-// I2C Extended Address support I2C Multiplexers and allows various properties to be 
+// I2C Extended Address support I2C Multiplexers and allows various properties to be
@@ -131 +131 @@
-// may be extended to include multiple buses, and other features. 
+// may be extended to include multiple buses, and other features.
@@ -135 +135 @@
-//#define I2C_EXTENDED_ADDRESS
+// #define I2C_EXTENDED_ADDRESS
@@ -144 +144 @@ enum I2CBus : uint8_t {
-    I2CBus_0 = 0,
+  I2CBus_0 = 0,
@@ -158 +158 @@ enum I2CMux : uint8_t {
-  I2CMux_None = 255,   // Address doesn't need mux switching
+  I2CMux_None = 255,  // Address doesn't need mux switching
@@ -160 +160 @@ enum I2CMux : uint8_t {
-  
+
@@ -162 +162 @@ enum I2CSubBus : uint8_t {
-  SubBus_0 = 0,        // Enable individual sub-buses...
+  SubBus_0 = 0,  // Enable individual sub-buses...
@@ -174,3 +174,3 @@ enum I2CSubBus : uint8_t {
-  SubBus_No,           // Number of subbuses (highest + 1)
-  SubBus_None = 254,   // Disable all sub-buses on selected mux
-  SubBus_All = 255,    // Enable all sub-buses (not supported by some multiplexers)
+  SubBus_No,          // Number of subbuses (highest + 1)
+  SubBus_None = 254,  // Disable all sub-buses on selected mux
+  SubBus_All = 255,   // Enable all sub-buses (not supported by some multiplexers)
@@ -187 +187 @@ enum I2CSubBus : uint8_t {
-// This structure could be extended in the future (if there is a need) 
+// This structure could be extended in the future (if there is a need)
@@ -191 +191 @@ struct I2CAddress {
-private:
+ private:
@@ -198 +198,2 @@ private:
-public:
+
+ public:
@@ -209 +210,2 @@ public:
-  I2CAddress() : I2CAddress(I2CMux_None, SubBus_None, 0) {}
+  I2CAddress() : I2CAddress(I2CMux_None, SubBus_None, 0) {
+  }
@@ -212,2 +214,2 @@ public:
-  I2CAddress(const I2CMux muxNumber, const I2CSubBus subBus, const uint8_t deviceAddress) :
-    I2CAddress(I2CBus_0, muxNumber, subBus, deviceAddress) {}
+  I2CAddress(const I2CMux muxNumber, const I2CSubBus subBus, const uint8_t deviceAddress) : I2CAddress(I2CBus_0, muxNumber, subBus, deviceAddress) {
+  }
@@ -216,2 +218,2 @@ public:
-  I2CAddress(I2CSubBus subBus, uint8_t deviceAddress) : 
-    I2CAddress(I2CMux_0, subBus, deviceAddress) {}
+  I2CAddress(I2CSubBus subBus, uint8_t deviceAddress) : I2CAddress(I2CMux_0, subBus, deviceAddress) {
+  }
@@ -222,3 +224,3 @@ public:
-  I2CAddress(const uint8_t deviceAddress) : 
-    I2CAddress(I2CMux_None, SubBus_None, deviceAddress) {}
-    
+  I2CAddress(const uint8_t deviceAddress) : I2CAddress(I2CMux_None, SubBus_None, deviceAddress) {
+  }
+
@@ -228,2 +230,2 @@ public:
-  I2CAddress(const I2CBus bus, const uint8_t deviceAddress) : 
-    I2CAddress(bus, I2CMux_None, SubBus_None, deviceAddress) {}
+  I2CAddress(const I2CBus bus, const uint8_t deviceAddress) : I2CAddress(bus, I2CMux_None, SubBus_None, deviceAddress) {
+  }
@@ -232,2 +234,2 @@ public:
-  I2CAddress(const I2CMux muxNumber, const I2CSubBus subBus) :
-    I2CAddress(muxNumber, subBus, 0x00) {}
+  I2CAddress(const I2CMux muxNumber, const I2CSubBus subBus) : I2CAddress(muxNumber, subBus, 0x00) {
+  }
@@ -237,2 +239,2 @@ public:
-  I2CAddress(I2CAddress firstAddress, uint8_t newDeviceAddress) :
-    I2CAddress(firstAddress._muxNumber, firstAddress._subBus, newDeviceAddress) {}
+  I2CAddress(I2CAddress firstAddress, uint8_t newDeviceAddress) : I2CAddress(firstAddress._muxNumber, firstAddress._subBus, newDeviceAddress) {
+  }
@@ -243 +245,3 @@ public:
-  operator uint8_t () const { return _deviceAddress; }
+  operator uint8_t() const {
+    return _deviceAddress;
+  }
@@ -245 +249 @@ public:
-  // Conversion from I2CAddress to char* (uses static storage so only 
+  // Conversion from I2CAddress to char* (uses static storage so only
@@ -248,2 +252,2 @@ public:
-  const char* toString() { 
-    char *ptr = addressBuffer;
+  const char* toString() {
+    char* ptr = addressBuffer;
@@ -262 +266 @@ public:
-      } else 
+      } else
@@ -270 +274 @@ public:
-    *ptr = 0; // terminate string
+    *ptr = 0;  // terminate string
@@ -275,3 +279,3 @@ public:
-  int operator == (I2CAddress &a) const {
-    if (_deviceAddress != a._deviceAddress) 
-      return false; // Different device address so no match
+  int operator==(I2CAddress& a) const {
+    if (_deviceAddress != a._deviceAddress)
+      return false;  // Different device address so no match
@@ -280 +284 @@ public:
-    if (_subBus == SubBus_None || a._subBus == SubBus_None) 
+    if (_subBus == SubBus_None || a._subBus == SubBus_None)
@@ -282,2 +286,2 @@ public:
-    if (_muxNumber != a._muxNumber) 
-      return false; // Connected to a subbus on a different mux
+    if (_muxNumber != a._muxNumber)
+      return false;  // Connected to a subbus on a different mux
@@ -286 +290 @@ public:
-    return true;  // Same address on same mux and same subbus
+    return true;     // Same address on same mux and same subbus
@@ -289,3 +293,9 @@ public:
-  I2CMux muxNumber() { return _muxNumber; }
-  I2CSubBus subBus() { return _subBus; }
-  uint8_t deviceAddress() { return _deviceAddress; }
+  I2CMux muxNumber() {
+    return _muxNumber;
+  }
+  I2CSubBus subBus() {
+    return _subBus;
+  }
+  uint8_t deviceAddress() {
+    return _deviceAddress;
+  }
@@ -293 +303 @@ public:
-private:
+ private:
@@ -295 +305 @@ private:
-  void toHex(const uint8_t value, char *buffer);
+  void toHex(const uint8_t value, char* buffer);
@@ -300 +310 @@ struct I2CAddress {
-private:
+ private:
@@ -303 +313,2 @@ private:
-public:
+
+ public:
@@ -318 +329,2 @@ public:
-  I2CAddress() : I2CAddress(0) {}
+  I2CAddress() : I2CAddress(0) {
+  }
@@ -322 +334,3 @@ public:
-  operator uint8_t () const { return _deviceAddress; }
+  operator uint8_t() const {
+    return _deviceAddress;
+  }
@@ -324 +338 @@ public:
-  // Conversion from I2CAddress to char* (uses static storage so only 
+  // Conversion from I2CAddress to char* (uses static storage so only
@@ -327,2 +341,2 @@ public:
-  const char* toString () { 
-    char *ptr = addressBuffer;
+  const char* toString() {
+    char* ptr = addressBuffer;
@@ -332 +346 @@ public:
-    *ptr = 0; // terminate string
+    *ptr = 0;  // terminate string
@@ -337,4 +351,4 @@ public:
-  int operator == (I2CAddress &a) const {
-    if (_deviceAddress != a._deviceAddress) 
-      return false; // Different device address so no match
-    return true;  // Same address on same mux and same subbus
+  int operator==(I2CAddress& a) const {
+    if (_deviceAddress != a._deviceAddress)
+      return false;  // Different device address so no match
+    return true;     // Same address on same mux and same subbus
@@ -342 +356,2 @@ public:
-private:
+
+ private:
@@ -344 +359 @@ private:
-  void toHex(const uint8_t value, char *buffer);
+  void toHex(const uint8_t value, char* buffer);
@@ -350 +365 @@ private:
-  }    
+  }
@@ -353,2 +368 @@ private:
-#endif // I2C_EXTENDED_ADDRESS
-
+#endif  // I2C_EXTENDED_ADDRESS
@@ -359,5 +373,5 @@ enum : uint8_t {
-  I2C_STATUS_OK=0,
-  I2C_STATUS_TRUNCATED=1,
-  I2C_STATUS_NEGATIVE_ACKNOWLEDGE=2,
-  I2C_STATUS_TRANSMIT_ERROR=3,
-  I2C_STATUS_TIMEOUT=5,
+  I2C_STATUS_OK = 0,
+  I2C_STATUS_TRUNCATED = 1,
+  I2C_STATUS_NEGATIVE_ACKNOWLEDGE = 2,
+  I2C_STATUS_TRANSMIT_ERROR = 3,
+  I2C_STATUS_TIMEOUT = 5,
@@ -365 +379 @@ enum : uint8_t {
-  I2C_STATUS_OTHER_TWI_ERROR=4, // catch-all error
+  I2C_STATUS_OTHER_TWI_ERROR = 4,  // catch-all error
@@ -367,4 +381,4 @@ enum : uint8_t {
-  I2C_STATUS_ARBITRATION_LOST=6,
-  I2C_STATUS_BUS_ERROR=7,
-  I2C_STATUS_UNEXPECTED_ERROR=8,
-  I2C_STATUS_PENDING=253,
+  I2C_STATUS_ARBITRATION_LOST = 6,
+  I2C_STATUS_BUS_ERROR = 7,
+  I2C_STATUS_UNEXPECTED_ERROR = 8,
+  I2C_STATUS_PENDING = 253,
@@ -375,4 +389,4 @@ enum : uint8_t {
-  I2C_STATE_ACTIVE=253,
-  I2C_STATE_FREE=254,
-  I2C_STATE_CLOSING=255,
-  I2C_STATE_COMPLETED=252,
+  I2C_STATE_ACTIVE = 253,
+  I2C_STATE_FREE = 254,
+  I2C_STATE_CLOSING = 255,
+  I2C_STATE_COMPLETED = 252,
@@ -381,2 +395 @@ enum : uint8_t {
-typedef enum : uint8_t
-{
+typedef enum : uint8_t {
@@ -388 +401 @@ typedef enum : uint8_t
-  OPERATION_MASK = 0x7f,  // mask for extracting the operation code
+  OPERATION_MASK = 0x7f,     // mask for extracting the operation code
@@ -391 +403,0 @@ typedef enum : uint8_t
-
@@ -394 +406 @@ typedef enum : uint8_t
-#define I2C_FREQ    400000L
+#define I2C_FREQ 400000L
@@ -399,3 +411,3 @@ class I2CRB {
-public:
-  volatile uint8_t status; // Completion status, or pending flag (updated from IRC)
-  volatile uint8_t nBytes; // Number of bytes read (updated from IRC)
+ public:
+  volatile uint8_t status;  // Completion status, or pending flag (updated from IRC)
+  volatile uint8_t nBytes;  // Number of bytes read (updated from IRC)
@@ -403 +415,3 @@ public:
-  inline I2CRB() { status = I2C_STATUS_OK; };
+  inline I2CRB() {
+    status = I2C_STATUS_OK;
+  };
@@ -407,3 +421,3 @@ public:
-  void setReadParams(I2CAddress i2cAddress, uint8_t *readBuffer, uint8_t readLen);
-  void setRequestParams(I2CAddress i2cAddress, uint8_t *readBuffer, uint8_t readLen, const uint8_t *writeBuffer, uint8_t writeLen);
-  void setWriteParams(I2CAddress i2cAddress, const uint8_t *writeBuffer, uint8_t writeLen);
+  void setReadParams(I2CAddress i2cAddress, uint8_t* readBuffer, uint8_t readLen);
+  void setRequestParams(I2CAddress i2cAddress, uint8_t* readBuffer, uint8_t readLen, const uint8_t* writeBuffer, uint8_t writeLen);
+  void setWriteParams(I2CAddress i2cAddress, const uint8_t* writeBuffer, uint8_t writeLen);
@@ -416,2 +430,2 @@ public:
-  uint8_t *readBuffer;
-  const uint8_t *writeBuffer;
+  uint8_t* readBuffer;
+  const uint8_t* writeBuffer;
@@ -419 +433 @@ public:
-  I2CRB *nextRequest;  // Used by non-blocking devices for I2CRB queue management.
+  I2CRB* nextRequest;  // Used by non-blocking devices for I2CRB queue management.
@@ -425,2 +439 @@ class I2CManagerClass {
-public:
-
+ public:
@@ -431 +444 @@ public:
-  // Force clock speed 
+  // Force clock speed
@@ -438 +451 @@ public:
-    return checkAddress(address)==I2C_STATUS_OK;
+    return checkAddress(address) == I2C_STATUS_OK;
@@ -447 +460 @@ public:
-  uint8_t write(I2CAddress address, const uint8_t buffer[], uint8_t size, I2CRB *rb);
+  uint8_t write(I2CAddress address, const uint8_t buffer[], uint8_t size, I2CRB* rb);
@@ -450 +463 @@ public:
-  uint8_t write_P(I2CAddress address, const uint8_t buffer[], uint8_t size, I2CRB *rb);
+  uint8_t write_P(I2CAddress address, const uint8_t buffer[], uint8_t size, I2CRB* rb);
@@ -454,4 +467,2 @@ public:
-  uint8_t read(I2CAddress address, uint8_t readBuffer[], uint8_t readSize, 
-    const uint8_t writeBuffer[]=NULL, uint8_t writeSize=0);
-  uint8_t read(I2CAddress address, uint8_t readBuffer[], uint8_t readSize, 
-    const uint8_t writeBuffer[], uint8_t writeSize, I2CRB *rb);
+  uint8_t read(I2CAddress address, uint8_t readBuffer[], uint8_t readSize, const uint8_t writeBuffer[] = NULL, uint8_t writeSize = 0);
+  uint8_t read(I2CAddress address, uint8_t readBuffer[], uint8_t readSize, const uint8_t writeBuffer[], uint8_t writeSize, I2CRB* rb);
@@ -459,3 +470,2 @@ public:
-  uint8_t read(I2CAddress address, uint8_t readBuffer[], uint8_t readSize, 
-    uint8_t writeSize, ...);
-  void queueRequest(I2CRB *req);
+  uint8_t read(I2CAddress address, uint8_t readBuffer[], uint8_t readSize, uint8_t writeSize, ...);
+  void queueRequest(I2CRB* req);
@@ -469 +479 @@ public:
-  // Expand error codes into text.  Note that they are in flash so 
+  // Expand error codes into text.  Note that they are in flash so
@@ -471 +481 @@ public:
-  static const FSH *getErrorMessage(uint8_t status);
+  static const FSH* getErrorMessage(uint8_t status);
@@ -473 +483 @@ public:
-private:
+ private:
@@ -480 +490 @@ private:
-  uint32_t _clockSpeed = I2C_FREQ;  
+  uint32_t _clockSpeed = I2C_FREQ;
@@ -483 +493 @@ private:
-  // so this value allows lots of headroom.  
+  // so this value allows lots of headroom.
@@ -489 +499 @@ private:
-    
+
@@ -491 +501 @@ private:
-  uint8_t finishRB(I2CRB *rb, uint8_t status);
+  uint8_t finishRB(I2CRB* rb, uint8_t status);
@@ -497,5 +507,5 @@ private:
-// Count of I2C multiplexers found when initialising.  If there is only one
-// MUX then the subbus does not need de-selecting after use; however, if there
-// are two or more, then the subbus must be deselected to avoid multiple
-// sub-bus legs on different multiplexers being accessible simultaneously.
-private:
+  // Count of I2C multiplexers found when initialising.  If there is only one
+  // MUX then the subbus does not need de-selecting after use; however, if there
+  // are two or more, then the subbus must be deselected to avoid multiple
+  // sub-bus legs on different multiplexers being accessible simultaneously.
+ private:
@@ -503,2 +513,5 @@ private:
-public:
-  uint8_t getMuxCount() { return _muxCount; }
+
+ public:
+  uint8_t getMuxCount() {
+    return _muxCount;
+  }
@@ -508,51 +521,51 @@ public:
-    // I2CRB structs are queued on the following two links.
-    // If there are no requests, both are NULL.
-    // If there is only one request, then queueHead and queueTail both point to it.
-    // Otherwise, queueHead is the pointer to the first request in the queue and
-    // queueTail is the pointer to the last request in the queue.
-    // Within the queue, each request's nextRequest field points to the 
-    // next request, or NULL.
-    // Mark volatile as they are updated by IRC and read/written elsewhere.
-private:
-    I2CRB * volatile queueHead = NULL;
-    I2CRB * volatile queueTail = NULL;
-
-    // State is set to I2C_STATE_FREE when the interrupt handler has finished
-    // the current request and is ready to complete.
-    uint8_t state = I2C_STATE_FREE;
-
-    // CompletionStatus may be set by the interrupt handler at any time but is
-    // not written to the I2CRB until the state is I2C_STATE_FREE.
-    uint8_t completionStatus = I2C_STATUS_OK;
-    uint8_t overallStatus = I2C_STATUS_OK;
-
-    I2CRB * currentRequest = NULL;
-    uint8_t txCount = 0;
-    uint8_t rxCount = 0;
-    uint8_t bytesToSend = 0;
-    uint8_t bytesToReceive = 0;
-    uint8_t operation = 0;
-    uint32_t startTime = 0;
-    uint8_t muxPhase = 0;
-    uint8_t muxAddress = 0;
-    uint8_t muxData[1];
-    uint8_t deviceAddress;
-    const uint8_t *sendBuffer;
-    uint8_t *receiveBuffer;
-    uint8_t transactionState = 0;
-  
-    volatile uint32_t pendingClockSpeed = 0;
-
-    void startTransaction();
-    
-    // Low-level hardware manipulation functions.
-    void I2C_init();
-    void I2C_setClock(unsigned long i2cClockSpeed);
-    void I2C_handleInterrupt();
-    void I2C_sendStart();
-    void I2C_sendStop();
-    void I2C_close();
-    
-  public:
-    // handleInterrupt needs to be public to be called from the ISR function!
-    void handleInterrupt();
+  // I2CRB structs are queued on the following two links.
+  // If there are no requests, both are NULL.
+  // If there is only one request, then queueHead and queueTail both point to it.
+  // Otherwise, queueHead is the pointer to the first request in the queue and
+  // queueTail is the pointer to the last request in the queue.
+  // Within the queue, each request's nextRequest field points to the
+  // next request, or NULL.
+  // Mark volatile as they are updated by IRC and read/written elsewhere.
+ private:
+  I2CRB* volatile queueHead = NULL;
+  I2CRB* volatile queueTail = NULL;
+
+  // State is set to I2C_STATE_FREE when the interrupt handler has finished
+  // the current request and is ready to complete.
+  uint8_t state = I2C_STATE_FREE;
+
+  // CompletionStatus may be set by the interrupt handler at any time but is
+  // not written to the I2CRB until the state is I2C_STATE_FREE.
+  uint8_t completionStatus = I2C_STATUS_OK;
+  uint8_t overallStatus = I2C_STATUS_OK;
+
+  I2CRB* currentRequest = NULL;
+  uint8_t txCount = 0;
+  uint8_t rxCount = 0;
+  uint8_t bytesToSend = 0;
+  uint8_t bytesToReceive = 0;
+  uint8_t operation = 0;
+  uint32_t startTime = 0;
+  uint8_t muxPhase = 0;
+  uint8_t muxAddress = 0;
+  uint8_t muxData[1];
+  uint8_t deviceAddress;
+  const uint8_t* sendBuffer;
+  uint8_t* receiveBuffer;
+  uint8_t transactionState = 0;
+
+  volatile uint32_t pendingClockSpeed = 0;
+
+  void startTransaction();
+
+  // Low-level hardware manipulation functions.
+  void I2C_init();
+  void I2C_setClock(unsigned long i2cClockSpeed);
+  void I2C_handleInterrupt();
+  void I2C_sendStart();
+  void I2C_sendStop();
+  void I2C_close();
+
+ public:
+  // handleInterrupt needs to be public to be called from the ISR function!
+  void handleInterrupt();
@@ -560,2 +572,0 @@ private:
-
-
@@ -569 +579,0 @@ extern I2CManagerClass I2CManager;
-
diff --git a/I2CManager_AVR.h b/I2CManager_AVR.h
index 567fdc3..a557569 100644
--- a/I2CManager_AVR.h
+++ b/I2CManager_AVR.h
@@ -25 +25 @@
-#include "I2CManager_NonBlocking.h"   // to satisfy intellisense
+#include "I2CManager_NonBlocking.h"  // to satisfy intellisense
@@ -33,16 +33,16 @@
-// General TWI Master staus codes                      
-#define TWI_START                  0x08  // START has been transmitted  
-#define TWI_REP_START              0x10  // Repeated START has been transmitted
-#define TWI_ARB_LOST               0x38  // Arbitration lost
-
-// TWI Master Transmitter staus codes                      
-#define TWI_MTX_ADR_ACK            0x18  // SLA+W has been tramsmitted and ACK received
-#define TWI_MTX_ADR_NACK           0x20  // SLA+W has been tramsmitted and NACK received 
-#define TWI_MTX_DATA_ACK           0x28  // Data byte has been tramsmitted and ACK received
-#define TWI_MTX_DATA_NACK          0x30  // Data byte has been tramsmitted and NACK received 
-
-// TWI Master Receiver staus codes  
-#define TWI_MRX_ADR_ACK            0x40  // SLA+R has been tramsmitted and ACK received
-#define TWI_MRX_ADR_NACK           0x48  // SLA+R has been tramsmitted and NACK received
-#define TWI_MRX_DATA_ACK           0x50  // Data byte has been received and ACK tramsmitted
-#define TWI_MRX_DATA_NACK          0x58  // Data byte has been received and NACK tramsmitted
+// General TWI Master staus codes
+#define TWI_START 0x08      // START has been transmitted
+#define TWI_REP_START 0x10  // Repeated START has been transmitted
+#define TWI_ARB_LOST 0x38   // Arbitration lost
+
+// TWI Master Transmitter staus codes
+#define TWI_MTX_ADR_ACK 0x18    // SLA+W has been tramsmitted and ACK received
+#define TWI_MTX_ADR_NACK 0x20   // SLA+W has been tramsmitted and NACK received
+#define TWI_MTX_DATA_ACK 0x28   // Data byte has been tramsmitted and ACK received
+#define TWI_MTX_DATA_NACK 0x30  // Data byte has been tramsmitted and NACK received
+
+// TWI Master Receiver staus codes
+#define TWI_MRX_ADR_ACK 0x40    // SLA+R has been tramsmitted and ACK received
+#define TWI_MRX_ADR_NACK 0x48   // SLA+R has been tramsmitted and NACK received
+#define TWI_MRX_DATA_ACK 0x50   // Data byte has been received and ACK tramsmitted
+#define TWI_MRX_DATA_NACK 0x58  // Data byte has been received and NACK tramsmitted
@@ -51,2 +51,2 @@
-#define TWI_NO_STATE               0xF8  // No relevant state information available
-#define TWI_BUS_ERROR              0x00  // Bus error due to an illegal START or STOP condition
+#define TWI_NO_STATE 0xF8   // No relevant state information available
+#define TWI_BUS_ERROR 0x00  // Bus error due to an illegal START or STOP condition
@@ -54 +54 @@
-#define TWI_TWBR  ((F_CPU / I2C_FREQ) - 16) / 2 // TWI Bit rate Register setting.
+#define TWI_TWBR ((F_CPU / I2C_FREQ) - 16) / 2  // TWI Bit rate Register setting.
@@ -57 +57 @@
-#define ENABLE_TWI_INTERRUPT (1<<TWIE)
+#define ENABLE_TWI_INTERRUPT (1 << TWIE)
@@ -67 +67 @@ void I2CManagerClass::I2C_setClock(unsigned long i2cClockSpeed) {
-  for (uint8_t preScaler = 0; preScaler<=3; preScaler++) {
+  for (uint8_t preScaler = 0; preScaler <= 3; preScaler++) {
@@ -72 +72 @@ void I2CManagerClass::I2C_setClock(unsigned long i2cClockSpeed) {
-    } else 
+    } else
@@ -83,2 +83 @@ void I2CManagerClass::I2C_setClock(unsigned long i2cClockSpeed) {
-void I2CManagerClass::I2C_init()
-{
+void I2CManagerClass::I2C_init() {
@@ -86,4 +85,4 @@ void I2CManagerClass::I2C_init()
-  TWBR = TWI_TWBR;                                  // Set bit rate register (Baudrate). Defined in header file.
-  TWDR = 0xFF;                                      // Default content = SDA released.
-  TWCR = (1<<TWINT);                                // Clear interrupt flag
- 
+  TWBR = TWI_TWBR;      // Set bit rate register (Baudrate). Defined in header file.
+  TWDR = 0xFF;          // Default content = SDA released.
+  TWCR = (1 << TWINT);  // Clear interrupt flag
+
@@ -103,2 +102 @@ void I2CManagerClass::I2C_sendStart() {
-  TWCR |= (1<<TWEN)|ENABLE_TWI_INTERRUPT|(1<<TWINT)|(1<<TWEA)|(1<<TWSTA);  // Send Start
-
+  TWCR |= (1 << TWEN) | ENABLE_TWI_INTERRUPT | (1 << TWINT) | (1 << TWEA) | (1 << TWSTA);  // Send Start
@@ -111,2 +109,2 @@ void I2CManagerClass::I2C_sendStop() {
-  TWDR = 0xff;  // Default condition = SDA released
-  TWCR = (1<<TWEN)|(1<<TWINT)|(1<<TWSTO);  // Send Stop
+  TWDR = 0xff;                                       // Default condition = SDA released
+  TWCR = (1 << TWEN) | (1 << TWINT) | (1 << TWSTO);  // Send Stop
@@ -120 +118 @@ void I2CManagerClass::I2C_close() {
-  TWCR = (1<<TWINT);                 // clear any interrupt and stop twi.
+  TWCR = (1 << TWINT);    // clear any interrupt and stop twi.
@@ -131 +129,2 @@ void I2CManagerClass::I2C_handleInterrupt() {
-  if (!(TWCR & (1<<TWINT))) return;  // Nothing to do.
+  if (!(TWCR & (1 << TWINT)))
+    return;  // Nothing to do.
@@ -135 +133,0 @@ void I2CManagerClass::I2C_handleInterrupt() {
-
@@ -144 +142 @@ void I2CManagerClass::I2C_handleInterrupt() {
-  // 
+  //
@@ -147,3 +145,3 @@ void I2CManagerClass::I2C_handleInterrupt() {
-    case TWI_MTX_DATA_ACK:      // Data byte has been transmitted and ACK received
-    case TWI_MTX_ADR_ACK:       // SLA+W has been transmitted and ACK received
-      if (bytesToSend) {  // Send first.
+    case TWI_MTX_DATA_ACK:  // Data byte has been transmitted and ACK received
+    case TWI_MTX_ADR_ACK:   // SLA+W has been transmitted and ACK received
+      if (bytesToSend) {    // Send first.
@@ -155 +153 @@ void I2CManagerClass::I2C_handleInterrupt() {
-        TWCR = (1<<TWEN)|ENABLE_TWI_INTERRUPT|(1<<TWINT);
+        TWCR = (1 << TWEN) | ENABLE_TWI_INTERRUPT | (1 << TWINT);
@@ -159,4 +157,4 @@ void I2CManagerClass::I2C_handleInterrupt() {
-        TWCR = (1<<TWEN)|ENABLE_TWI_INTERRUPT|(1<<TWINT)|(1<<TWSTA);  // Send Start
-      } else {  
-         // Nothing left to send or receive
-        TWCR = (1<<TWEN)|(1<<TWINT)|(1<<TWEA)|(1<<TWSTO);  // Send Stop
+        TWCR = (1 << TWEN) | ENABLE_TWI_INTERRUPT | (1 << TWINT) | (1 << TWSTA);  // Send Start
+      } else {
+        // Nothing left to send or receive
+        TWCR = (1 << TWEN) | (1 << TWINT) | (1 << TWEA) | (1 << TWSTO);  // Send Stop
@@ -167 +165 @@ void I2CManagerClass::I2C_handleInterrupt() {
-    case TWI_MRX_DATA_ACK:      // Data byte has been received and ACK transmitted
+    case TWI_MRX_DATA_ACK:  // Data byte has been received and ACK transmitted
@@ -174 +172 @@ void I2CManagerClass::I2C_handleInterrupt() {
-    case TWI_MRX_ADR_ACK:      // SLA+R has been sent and ACK received
+    case TWI_MRX_ADR_ACK:  // SLA+R has been sent and ACK received
@@ -176 +174 @@ void I2CManagerClass::I2C_handleInterrupt() {
-        TWCR = (1<<TWEN)|ENABLE_TWI_INTERRUPT|(1<<TWINT); // Send NACK after next reception
+        TWCR = (1 << TWEN) | ENABLE_TWI_INTERRUPT | (1 << TWINT);  // Send NACK after next reception
@@ -179 +177 @@ void I2CManagerClass::I2C_handleInterrupt() {
-        TWCR = (1<<TWEN)|ENABLE_TWI_INTERRUPT|(1<<TWINT)|(1<<TWEA);
+        TWCR = (1 << TWEN) | ENABLE_TWI_INTERRUPT | (1 << TWINT) | (1 << TWEA);
@@ -183 +181 @@ void I2CManagerClass::I2C_handleInterrupt() {
-    case TWI_MRX_DATA_NACK:     // Data byte has been received and NACK transmitted
+    case TWI_MRX_DATA_NACK:  // Data byte has been received and NACK transmitted
@@ -188 +186 @@ void I2CManagerClass::I2C_handleInterrupt() {
-      TWCR = (1<<TWEN)|(1<<TWINT)|(1<<TWEA)|(1<<TWSTO);  // Send Stop
+      TWCR = (1 << TWEN) | (1 << TWINT) | (1 << TWEA) | (1 << TWSTO);  // Send Stop
@@ -192,2 +190,2 @@ void I2CManagerClass::I2C_handleInterrupt() {
-    case TWI_START:             // START has been transmitted  
-    case TWI_REP_START:         // Repeated START has been transmitted
+    case TWI_START:      // START has been transmitted
+    case TWI_REP_START:  // Repeated START has been transmitted
@@ -195,2 +193,2 @@ void I2CManagerClass::I2C_handleInterrupt() {
-      if (operation == OPERATION_READ || (operation==OPERATION_REQUEST && !bytesToSend))
-        TWDR = (deviceAddress << 1) | 1; // SLA+R
+      if (operation == OPERATION_READ || (operation == OPERATION_REQUEST && !bytesToSend))
+        TWDR = (deviceAddress << 1) | 1;  // SLA+R
@@ -198,2 +196,2 @@ void I2CManagerClass::I2C_handleInterrupt() {
-        TWDR = (deviceAddress << 1) | 0; // SLA+W
-      TWCR = (1<<TWEN)|ENABLE_TWI_INTERRUPT|(1<<TWINT)|(1<<TWEA);
+        TWDR = (deviceAddress << 1) | 0;  // SLA+W
+      TWCR = (1 << TWEN) | ENABLE_TWI_INTERRUPT | (1 << TWINT) | (1 << TWEA);
@@ -202,4 +200,4 @@ void I2CManagerClass::I2C_handleInterrupt() {
-    case TWI_MTX_ADR_NACK:      // SLA+W has been transmitted and NACK received
-    case TWI_MRX_ADR_NACK:      // SLA+R has been transmitted and NACK received
-    case TWI_MTX_DATA_NACK:     // Data byte has been transmitted and NACK received
-      TWCR = (1<<TWEN)|(1<<TWINT)|(1<<TWEA)|(1<<TWSTO);  // Send Stop
+    case TWI_MTX_ADR_NACK:                                             // SLA+W has been transmitted and NACK received
+    case TWI_MRX_ADR_NACK:                                             // SLA+R has been transmitted and NACK received
+    case TWI_MTX_DATA_NACK:                                            // Data byte has been transmitted and NACK received
+      TWCR = (1 << TWEN) | (1 << TWINT) | (1 << TWEA) | (1 << TWSTO);  // Send Stop
@@ -210 +208 @@ void I2CManagerClass::I2C_handleInterrupt() {
-    case TWI_ARB_LOST:          // Arbitration lost
+    case TWI_ARB_LOST:  // Arbitration lost
@@ -215 +213 @@ void I2CManagerClass::I2C_handleInterrupt() {
-    case TWI_BUS_ERROR:         // Bus error due to an illegal START or STOP condition
+    case TWI_BUS_ERROR:  // Bus error due to an illegal START or STOP condition
@@ -217,2 +215,2 @@ void I2CManagerClass::I2C_handleInterrupt() {
-      TWDR = 0xff;  // Default condition = SDA released
-      TWCR = (1<<TWEN)|(1<<TWINT)|(1<<TWEA)|(1<<TWSTO);  // Send Stop
+      TWDR = 0xff;                                                     // Default condition = SDA released
+      TWCR = (1 << TWEN) | (1 << TWINT) | (1 << TWEA) | (1 << TWSTO);  // Send Stop
diff --git a/I2CManager_Mega4809.h b/I2CManager_Mega4809.h
index 6eed0e8..cd784da 100644
--- a/I2CManager_Mega4809.h
+++ b/I2CManager_Mega4809.h
@@ -42,4 +42,4 @@ void I2CManagerClass::I2C_setClock(unsigned long i2cClockSpeed) {
-  
-  uint32_t baud = (F_CPU_CORRECTED / i2cClockSpeed - F_CPU_CORRECTED / 1000 / 1000
-    * t_rise / 1000 - 10) / 2;
-  if (baud > 255) baud = 255;  // ~30kHz
+
+  uint32_t baud = (F_CPU_CORRECTED / i2cClockSpeed - F_CPU_CORRECTED / 1000 / 1000 * t_rise / 1000 - 10) / 2;
+  if (baud > 255)
+    baud = 255;  // ~30kHz
@@ -52,2 +52 @@ void I2CManagerClass::I2C_setClock(unsigned long i2cClockSpeed) {
-void I2CManagerClass::I2C_init()
-{ 
+void I2CManagerClass::I2C_init() {
@@ -92,2 +91 @@ void I2CManagerClass::I2C_close() {
-
-  TWI0.MCTRLA &= ~(TWI_RIEN_bm | TWI_WIEN_bm | TWI_ENABLE_bm);        // Switch off I2C
+  TWI0.MCTRLA &= ~(TWI_RIEN_bm | TWI_WIEN_bm | TWI_ENABLE_bm);  // Switch off I2C
@@ -102 +99,0 @@ void I2CManagerClass::I2C_handleInterrupt() {
-  
@@ -107,2 +104,2 @@ void I2CManagerClass::I2C_handleInterrupt() {
-    TWI0.MSTATUS = currentStatus; // clear all flags
-    I2C_sendStart();   // Reinitiate request
+    TWI0.MSTATUS = currentStatus;  // clear all flags
+    I2C_sendStart();               // Reinitiate request
@@ -113 +110 @@ void I2CManagerClass::I2C_handleInterrupt() {
-    TWI0.MSTATUS = currentStatus; // clear all flags
+    TWI0.MSTATUS = currentStatus;  // clear all flags
@@ -139 +136 @@ void I2CManagerClass::I2C_handleInterrupt() {
-    } 
+    }
@@ -151 +147,0 @@ void I2CManagerClass::I2C_handleInterrupt() {
-
diff --git a/I2CManager_NonBlocking.h b/I2CManager_NonBlocking.h
index 83e1a2f..aa7cc17 100644
--- a/I2CManager_NonBlocking.h
+++ b/I2CManager_NonBlocking.h
@@ -29 +29 @@
-// E.g. 
+// E.g.
@@ -36 +36 @@
-// (This should really be defined in an include file somewhere more global, so 
+// (This should really be defined in an include file somewhere more global, so
@@ -43,2 +43,3 @@ static inline uint8_t _deferInterrupts(void) {
-static inline void _conditionalEnableInterrupts(bool *wasEnabled) {
-  if (*wasEnabled) interrupts();
+static inline void _conditionalEnableInterrupts(bool* wasEnabled) {
+  if (*wasEnabled)
+    interrupts();
@@ -46,3 +47,3 @@ static inline void _conditionalEnableInterrupts(bool *wasEnabled) {
-#define ATOMIC_BLOCK(x) \
-for (bool _int_saved __attribute__((__cleanup__(_conditionalEnableInterrupts))) \
-            =_getInterruptState(),_ToDo=_deferInterrupts(); _ToDo; _ToDo=0)
+#define ATOMIC_BLOCK(x)                                                                                                                      \
+  for (bool _int_saved __attribute__((__cleanup__(_conditionalEnableInterrupts))) = _getInterruptState(), _ToDo = _deferInterrupts(); _ToDo; \
+       _ToDo = 0)
@@ -50,4 +51,4 @@ for (bool _int_saved __attribute__((__cleanup__(_conditionalEnableInterrupts)))
-#if defined(__AVR__) // Nano, Uno, Mega2580, NanoEvery, etc.
-  static inline bool _getInterruptState(void) {
-    return bitRead(SREG, SREG_I);  // true if enabled, false if disabled
-  }
+#if defined(__AVR__)  // Nano, Uno, Mega2580, NanoEvery, etc.
+static inline bool _getInterruptState(void) {
+  return bitRead(SREG, SREG_I);  // true if enabled, false if disabled
+}
@@ -55,5 +56,5 @@ for (bool _int_saved __attribute__((__cleanup__(_conditionalEnableInterrupts)))
-  static inline bool _getInterruptState( void ) {
-    uint32_t reg;
-    __asm__ __volatile__ ("MRS %0, primask" : "=r" (reg) );
-    return !(reg & 1);  // true if interrupts enabled, false otherwise
-  }
+static inline bool _getInterruptState(void) {
+  uint32_t reg;
+  __asm__ __volatile__("MRS %0, primask" : "=r"(reg));
+  return !(reg & 1);  // true if interrupts enabled, false otherwise
+}
@@ -61,5 +62,5 @@ for (bool _int_saved __attribute__((__cleanup__(_conditionalEnableInterrupts)))
-  #warning "ATOMIC_BLOCK() not defined for this target type, I2C interrupts disabled"
-  #define ATOMIC_BLOCK(x) // expand to nothing.
-  #ifdef I2C_USE_INTERRUPTS
-    #undef I2C_USE_INTERRUPTS
-  #endif
+#warning "ATOMIC_BLOCK() not defined for this target type, I2C interrupts disabled"
+#define ATOMIC_BLOCK(x)  // expand to nothing.
+#ifdef I2C_USE_INTERRUPTS
+#undef I2C_USE_INTERRUPTS
+#endif
@@ -67 +67,0 @@ for (bool _int_saved __attribute__((__cleanup__(_conditionalEnableInterrupts)))
-
@@ -75 +75 @@ for (bool _int_saved __attribute__((__cleanup__(_conditionalEnableInterrupts)))
-enum MuxPhase: uint8_t {
+enum MuxPhase : uint8_t {
@@ -80,2 +80 @@ enum MuxPhase: uint8_t {
-} ;
-
+};
@@ -86,2 +85 @@ enum MuxPhase: uint8_t {
-void I2CManagerClass::_initialise()
-{
+void I2CManagerClass::_initialise() {
@@ -108 +106 @@ void I2CManagerClass::_setClock(unsigned long i2cClockSpeed) {
- * If there's an I2C clock speed change pending, then implement it before 
+ * If there's an I2C clock speed change pending, then implement it before
@@ -132,2 +130,3 @@ void I2CManagerClass::startTransaction() {
-        muxData[0] = (subBus == SubBus_All) ? 0xff :
-                     (subBus == SubBus_None) ? 0x00 :
+        muxData[0] = (subBus == SubBus_All)    ? 0xff
+                     : (subBus == SubBus_None) ? 0x00
+                                               :
@@ -135 +134 @@ void I2CManagerClass::startTransaction() {
-                      0x08 | subBus;
+                                               0x08 | subBus;
@@ -137 +136 @@ void I2CManagerClass::startTransaction() {
-                      0x04 | subBus;   // NB Only 2 or 4 subbuses respectively
+                                               0x04 | subBus;  // NB Only 2 or 4 subbuses respectively
@@ -139,3 +138,3 @@ void I2CManagerClass::startTransaction() {
-                      // Default behaviour for most MUXs is to use a mask
-                      // with a bit set for the subBus to be enabled
-                      1 << subBus;
+                                               // Default behaviour for most MUXs is to use a mask
+                                               // with a bit set for the subBus to be enabled
+                         1 << subBus;
@@ -157 +156 @@ void I2CManagerClass::startTransaction() {
-      } 
+      }
@@ -174,2 +173 @@ void I2CManagerClass::startTransaction() {
-void I2CManagerClass::queueRequest(I2CRB *req) {
-
+void I2CManagerClass::queueRequest(I2CRB* req) {
@@ -182 +180 @@ void I2CManagerClass::queueRequest(I2CRB *req) {
-    if (!queueTail) 
+    if (!queueTail)
@@ -185 +183 @@ void I2CManagerClass::queueRequest(I2CRB *req) {
-      queueTail = queueTail->nextRequest = req; // Add to end
+      queueTail = queueTail->nextRequest = req;  // Add to end
@@ -188 +185,0 @@ void I2CManagerClass::queueRequest(I2CRB *req) {
-
@@ -191 +187,0 @@ void I2CManagerClass::queueRequest(I2CRB *req) {
-
@@ -195 +191 @@ void I2CManagerClass::queueRequest(I2CRB *req) {
-uint8_t I2CManagerClass::write(I2CAddress i2cAddress, const uint8_t *writeBuffer, uint8_t writeLen, I2CRB *req) {
+uint8_t I2CManagerClass::write(I2CAddress i2cAddress, const uint8_t* writeBuffer, uint8_t writeLen, I2CRB* req) {
@@ -206 +202 @@ uint8_t I2CManagerClass::write(I2CAddress i2cAddress, const uint8_t *writeBuffer
-uint8_t I2CManagerClass::write_P(I2CAddress i2cAddress, const uint8_t * writeBuffer, uint8_t writeLen, I2CRB *req) {
+uint8_t I2CManagerClass::write_P(I2CAddress i2cAddress, const uint8_t* writeBuffer, uint8_t writeLen, I2CRB* req) {
@@ -216 +212 @@ uint8_t I2CManagerClass::write_P(I2CAddress i2cAddress, const uint8_t * writeBuf
- *  Initiate a read from the I2C device, optionally preceded by a write 
+ *  Initiate a read from the I2C device, optionally preceded by a write
@@ -219,3 +215 @@ uint8_t I2CManagerClass::write_P(I2CAddress i2cAddress, const uint8_t * writeBuf
-uint8_t I2CManagerClass::read(I2CAddress i2cAddress, uint8_t *readBuffer, uint8_t readLen, 
-    const uint8_t *writeBuffer, uint8_t writeLen, I2CRB *req)
-{
+uint8_t I2CManagerClass::read(I2CAddress i2cAddress, uint8_t* readBuffer, uint8_t readLen, const uint8_t* writeBuffer, uint8_t writeLen, I2CRB* req) {
@@ -234,2 +228,2 @@ uint8_t I2CManagerClass::read(I2CAddress i2cAddress, uint8_t *readBuffer, uint8_
-void I2CManagerClass::setTimeout(unsigned long value) { 
-  _timeout = value; 
+void I2CManagerClass::setTimeout(unsigned long value) {
+  _timeout = value;
@@ -245,2 +239,2 @@ void I2CManagerClass::checkForTimeout() {
-    I2CRB *t = queueHead;
-    if (state==I2C_STATE_ACTIVE && t!=0 && t==currentRequest && _timeout > 0) {
+    I2CRB* t = queueHead;
+    if (state == I2C_STATE_ACTIVE && t != 0 && t == currentRequest && _timeout > 0) {
@@ -249 +243 @@ void I2CManagerClass::checkForTimeout() {
-      if (elapsed > (int32_t)_timeout) { 
+      if (elapsed > (int32_t)_timeout) {
@@ -251 +245 @@ void I2CManagerClass::checkForTimeout() {
-        //DIAG(F("I2CManager Timeout on %s"), t->i2cAddress.toString());
+        // DIAG(F("I2CManager Timeout on %s"), t->i2cAddress.toString());
@@ -255 +249,2 @@ void I2CManagerClass::checkForTimeout() {
-        if (!queueHead) queueTail = NULL;
+        if (!queueHead)
+          queueTail = NULL;
@@ -267,6 +262,6 @@ void I2CManagerClass::checkForTimeout() {
-        for (int i=0; !digitalRead(SDA) && i<9; i++) {
-          digitalWrite(SCL, 0); 
-          pinMode(SCL, OUTPUT);         // Force clock low
-          delayMicroseconds(10);        // ... for 5us
-          pinMode(SCL, INPUT_PULLUP);   // ... then high
-          delayMicroseconds(10);        // ... for 5us (100kHz Clock)
+        for (int i = 0; !digitalRead(SDA) && i < 9; i++) {
+          digitalWrite(SCL, 0);
+          pinMode(SCL, OUTPUT);        // Force clock low
+          delayMicroseconds(10);       // ... for 5us
+          pinMode(SCL, INPUT_PULLUP);  // ... then high
+          delayMicroseconds(10);       // ... for 5us (100kHz Clock)
@@ -278 +273 @@ void I2CManagerClass::checkForTimeout() {
-        
+
@@ -302 +296,0 @@ void I2CManagerClass::handleInterrupt() {
-
@@ -310,3 +304 @@ void I2CManagerClass::handleInterrupt() {
-    if (completionStatus == I2C_STATUS_OK || ++retryCounter > MAX_I2C_RETRIES
-      || currentRequest->operation & OPERATION_NORETRY) 
-    {
+    if (completionStatus == I2C_STATUS_OK || ++retryCounter > MAX_I2C_RETRIES || currentRequest->operation & OPERATION_NORETRY) {
@@ -315 +307 @@ void I2CManagerClass::handleInterrupt() {
-      if (muxPhase == MuxPhase_PROLOG ) {
+      if (muxPhase == MuxPhase_PROLOG) {
@@ -330 +322 @@ void I2CManagerClass::handleInterrupt() {
-        } 
+        }
@@ -359 +351 @@ void I2CManagerClass::handleInterrupt() {
-          
+
@@ -361 +353 @@ void I2CManagerClass::handleInterrupt() {
-      I2CRB * t = queueHead;
+      I2CRB* t = queueHead;
@@ -364 +356,2 @@ void I2CManagerClass::handleInterrupt() {
-        if (!queueHead) queueTail = queueHead;
+        if (!queueHead)
+          queueTail = queueHead;
@@ -366 +359 @@ void I2CManagerClass::handleInterrupt() {
-        
+
@@ -375 +368 @@ void I2CManagerClass::handleInterrupt() {
-      state = I2C_STATE_FREE;  
+      state = I2C_STATE_FREE;
@@ -381 +374 @@ void I2CManagerClass::handleInterrupt() {
-    //interrupts();
+    // interrupts();
diff --git a/I2CManager_SAMD.h b/I2CManager_SAMD.h
index 76774a9..a90e8fc 100644
--- a/I2CManager_SAMD.h
+++ b/I2CManager_SAMD.h
@@ -28,2 +28,2 @@
-//#include <avr/io.h>
-//#include <avr/interrupt.h>
+// #include <avr/io.h>
+// #include <avr/interrupt.h>
@@ -37 +37 @@
- *  bus on the SAMD architecture 
+ *  bus on the SAMD architecture
@@ -46 +46 @@ void SERCOM3_Handler() {
-Sercom *s = SERCOM3;
+Sercom* s = SERCOM3;
@@ -50 +50 @@ Sercom *s = SERCOM3;
- *  a transmission.  The I2CManagerClass::_setClock() function ensures 
+ *  a transmission.  The I2CManagerClass::_setClock() function ensures
@@ -54 +53,0 @@ void I2CManagerClass::I2C_setClock(uint32_t i2cClockSpeed) {
-
@@ -58 +57 @@ void I2CManagerClass::I2C_setClock(uint32_t i2cClockSpeed) {
-    i2cClockSpeed = 100000L;    // NB: this overrides a "force clock" of lower than 100KHz!
+    i2cClockSpeed = 100000L;  // NB: this overrides a "force clock" of lower than 100KHz!
@@ -75 +74 @@ void I2CManagerClass::I2C_setClock(uint32_t i2cClockSpeed) {
-  s->I2CM.CTRLA.bit.ENABLE = 0 ;
+  s->I2CM.CTRLA.bit.ENABLE = 0;
@@ -82 +81 @@ void I2CManagerClass::I2C_setClock(uint32_t i2cClockSpeed) {
-  s->I2CM.CTRLA.bit.ENABLE = 1 ;
+  s->I2CM.CTRLA.bit.ENABLE = 1;
@@ -86 +85 @@ void I2CManagerClass::I2C_setClock(uint32_t i2cClockSpeed) {
-  s->I2CM.STATUS.bit.BUSSTATE = 1 ;
+  s->I2CM.STATUS.bit.BUSSTATE = 1;
@@ -93,6 +92,5 @@ void I2CManagerClass::I2C_setClock(uint32_t i2cClockSpeed) {
-void I2CManagerClass::I2C_init()
-{
-  //Setting clock
-  GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(GCM_SERCOM3_CORE) | // Generic Clock 0 (SERCOM3)
-                      GCLK_CLKCTRL_GEN_GCLK0 | // Generic Clock Generator 0 is source
-                      GCLK_CLKCTRL_CLKEN ;
+void I2CManagerClass::I2C_init() {
+  // Setting clock
+  GCLK->CLKCTRL.reg = GCLK_CLKCTRL_ID(GCM_SERCOM3_CORE) |  // Generic Clock 0 (SERCOM3)
+                      GCLK_CLKCTRL_GEN_GCLK0 |             // Generic Clock Generator 0 is source
+                      GCLK_CLKCTRL_CLKEN;
@@ -101 +99 @@ void I2CManagerClass::I2C_init()
-  while ( GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY );
+  while (GCLK->STATUS.reg & GCLK_STATUS_SYNCBUSY);
@@ -106,2 +104,2 @@ void I2CManagerClass::I2C_init()
-  //Wait both bits Software Reset from CTRLA and SYNCBUSY are equal to 0
-  while(s->I2CM.CTRLA.bit.SWRST || s->I2CM.SYNCBUSY.bit.SWRST);
+  // Wait both bits Software Reset from CTRLA and SYNCBUSY are equal to 0
+  while (s->I2CM.CTRLA.bit.SWRST || s->I2CM.SYNCBUSY.bit.SWRST);
@@ -110,2 +108,3 @@ void I2CManagerClass::I2C_init()
-  s->I2CM.CTRLA.reg =  SERCOM_I2CM_CTRLA_MODE( I2C_MASTER_OPERATION )/* |
-                            SERCOM_I2CM_CTRLA_SCLSM*/ ;
+  s->I2CM.CTRLA.reg = SERCOM_I2CM_CTRLA_MODE(I2C_MASTER_OPERATION) /* |
+                          SERCOM_I2CM_CTRLA_SCLSM*/
+      ;
@@ -114 +113 @@ void I2CManagerClass::I2C_init()
-  s->I2CM.CTRLB.reg =  SERCOM_I2CM_CTRLB_SMEN;
+  s->I2CM.CTRLB.reg = SERCOM_I2CM_CTRLB_SMEN;
@@ -119,2 +118,2 @@ void I2CManagerClass::I2C_init()
-  NVIC_SetPriority (SERCOM3_IRQn, SERCOM_NVIC_PRIORITY);  // Match default SERCOM priorities
-//  NVIC_SetPriority (SERCOM3_IRQn, 0);  // Set highest priority
+  NVIC_SetPriority(SERCOM3_IRQn, SERCOM_NVIC_PRIORITY);  // Match default SERCOM priorities
+                                                         //  NVIC_SetPriority (SERCOM3_IRQn, 0);  // Set highest priority
@@ -127 +126 @@ void I2CManagerClass::I2C_init()
-  s->I2CM.BAUD.bit.BAUD = SystemCoreClock / ( 2 * I2C_FREQ) - 7 / (2 * 1000);
+  s->I2CM.BAUD.bit.BAUD = SystemCoreClock / (2 * I2C_FREQ) - 7 / (2 * 1000);
@@ -130 +129 @@ void I2CManagerClass::I2C_init()
-  s->I2CM.CTRLA.bit.ENABLE = 1 ;
+  s->I2CM.CTRLA.bit.ENABLE = 1;
@@ -134 +133 @@ void I2CManagerClass::I2C_init()
-  s->I2CM.STATUS.bit.BUSSTATE = 1 ;
+  s->I2CM.STATUS.bit.BUSSTATE = 1;
@@ -144,4 +143,4 @@ void I2CManagerClass::I2C_init()
-	PORT->Group[g_APinDescription[PIN_WIRE_SCL].ulPort].PINCFG[g_APinDescription[PIN_WIRE_SCL].ulPin].reg =  
-		PORT_PINCFG_DRVSTR | PORT_PINCFG_PULLEN | PORT_PINCFG_PMUXEN;  
-  PORT->Group[g_APinDescription[PIN_WIRE_SDA].ulPort].PINCFG[g_APinDescription[PIN_WIRE_SDA].ulPin].reg = 
-	  PORT_PINCFG_DRVSTR | PORT_PINCFG_PULLEN | PORT_PINCFG_PMUXEN;
+  PORT->Group[g_APinDescription[PIN_WIRE_SCL].ulPort].PINCFG[g_APinDescription[PIN_WIRE_SCL].ulPin].reg =
+      PORT_PINCFG_DRVSTR | PORT_PINCFG_PULLEN | PORT_PINCFG_PMUXEN;
+  PORT->Group[g_APinDescription[PIN_WIRE_SDA].ulPort].PINCFG[g_APinDescription[PIN_WIRE_SDA].ulPin].reg =
+      PORT_PINCFG_DRVSTR | PORT_PINCFG_PULLEN | PORT_PINCFG_PMUXEN;
@@ -154 +152,0 @@ void I2CManagerClass::I2C_sendStart() {
-
@@ -159,3 +157,3 @@ void I2CManagerClass::I2C_sendStart() {
-  // On a single-master I2C bus, the start bit won't be sent until the bus 
-  // state goes to IDLE so we can request it without waiting.  On a 
-  // multi-master bus, the bus may be BUSY under control of another master, 
+  // On a single-master I2C bus, the start bit won't be sent until the bus
+  // state goes to IDLE so we can request it without waiting.  On a
+  // multi-master bus, the bus may be BUSY under control of another master,
@@ -166,2 +164 @@ void I2CManagerClass::I2C_sendStart() {
-  if (operation == OPERATION_READ || ((operation == OPERATION_REQUEST) && !bytesToSend))
-  {
+  if (operation == OPERATION_READ || ((operation == OPERATION_REQUEST) && !bytesToSend)) {
@@ -170,2 +167 @@ void I2CManagerClass::I2C_sendStart() {
-  }
-  else {
+  } else {
@@ -181 +177 @@ void I2CManagerClass::I2C_sendStop() {
-  s->I2CM.CTRLB.bit.CMD = 3; // Stop condition
+  s->I2CM.CTRLB.bit.CMD = 3;  // Stop condition
@@ -190 +186 @@ void I2CManagerClass::I2C_close() {
-  s->I2CM.CTRLA.bit.ENABLE = 0 ;
+  s->I2CM.CTRLA.bit.ENABLE = 0;
@@ -194 +190,2 @@ void I2CManagerClass::I2C_close() {
-    if (micros() - startTime >= 500UL) break;
+    if (micros() - startTime >= 500UL)
+      break;
@@ -204 +200,0 @@ void I2CManagerClass::I2C_handleInterrupt() {
-
@@ -207 +203 @@ void I2CManagerClass::I2C_handleInterrupt() {
-    I2C_sendStart();   // Reinitiate request
+    I2C_sendStart();  // Reinitiate request
@@ -234,2 +230,2 @@ void I2CManagerClass::I2C_handleInterrupt() {
-      s->I2CM.CTRLB.bit.ACKACT = 1;  // NAK final byte
-      I2C_sendStop();  // send stop
+      s->I2CM.CTRLB.bit.ACKACT = 1;                      // NAK final byte
+      I2C_sendStop();                                    // send stop
@@ -240 +236 @@ void I2CManagerClass::I2C_handleInterrupt() {
-      s->I2CM.CTRLB.bit.ACKACT = 0;  // ACK all but final byte
+      s->I2CM.CTRLB.bit.ACKACT = 0;                      // ACK all but final byte
diff --git a/I2CManager_STM32.h b/I2CManager_STM32.h
index 45c924f..7431d71 100644
--- a/I2CManager_STM32.h
+++ b/I2CManager_STM32.h
@@ -27 +27 @@
-#include "I2CManager_NonBlocking.h"   // to satisfy intellisense
+#include "I2CManager_NonBlocking.h"  // to satisfy intellisense
@@ -34 +34 @@
- * 
+ *
@@ -37 +37 @@
- *  I2C bus, or more than one I2C bus on the STM32 architecture 
+ *  I2C bus, or more than one I2C bus on the STM32 architecture
@@ -40,3 +40,3 @@
-#if defined(ARDUINO_NUCLEO_F401RE) || defined(ARDUINO_NUCLEO_F411RE) || defined(ARDUINO_NUCLEO_F446RE) \
-    || defined(ARDUINO_NUCLEO_F412ZG) || defined(ARDUINO_NUCLEO_F413ZH) || defined(ARDUINO_NUCLEO_F446ZE) \
-    || defined(ARDUINO_NUCLEO_F429ZI) || defined(ARDUINO_NUCLEO_F439ZI) || defined(ARDUINO_NUCLEO_F4X9ZI)
+#if defined(ARDUINO_NUCLEO_F401RE) || defined(ARDUINO_NUCLEO_F411RE) || defined(ARDUINO_NUCLEO_F446RE) || defined(ARDUINO_NUCLEO_F412ZG) || \
+    defined(ARDUINO_NUCLEO_F413ZH) || defined(ARDUINO_NUCLEO_F446ZE) || defined(ARDUINO_NUCLEO_F429ZI) || defined(ARDUINO_NUCLEO_F439ZI) || \
+    defined(ARDUINO_NUCLEO_F4X9ZI)
@@ -46 +46 @@
-I2C_TypeDef *s = I2C1;
+I2C_TypeDef* s = I2C1;
@@ -49,2 +49,2 @@ I2C_TypeDef *s = I2C1;
-uint32_t APB1clk1; // Peripheral Input Clock speed in Hz.
-uint32_t i2c_MHz;  // Peripheral Input Clock speed in MHz.
+uint32_t APB1clk1;  // Peripheral Input Clock speed in Hz.
+uint32_t i2c_MHz;   // Peripheral Input Clock speed in MHz.
@@ -52 +52 @@ uint32_t i2c_MHz;  // Peripheral Input Clock speed in MHz.
-// IRQ handler for I2C1, replacing the weak definition in the STM32 HAL 
+// IRQ handler for I2C1, replacing the weak definition in the STM32 HAL
@@ -102,2 +102 @@ extern "C" void I2C1_ER_IRQHandler(void) {
-enum {TS_IDLE,TS_START,TS_W_ADDR,TS_W_DATA,TS_W_STOP,TS_R_ADDR,TS_R_DATA,TS_R_STOP};
-
+enum { TS_IDLE, TS_START, TS_W_ADDR, TS_W_DATA, TS_W_STOP, TS_R_ADDR, TS_R_DATA, TS_R_STOP };
@@ -107 +106 @@ enum {TS_IDLE,TS_START,TS_W_ADDR,TS_W_DATA,TS_W_STOP,TS_R_ADDR,TS_R_DATA,TS_R_ST
- *  a transmission.  The I2CManagerClass::_setClock() function ensures 
+ *  a transmission.  The I2CManagerClass::_setClock() function ensures
@@ -119,4 +118,4 @@ void I2CManagerClass::I2C_setClock(uint32_t i2cClockSpeed) {
-  s->CR1 &= ~(I2C_CR1_PE);  // Disable I2C
-  s->CR1 |= I2C_CR1_SWRST;  // reset the I2C
-  asm("nop");    // wait a bit... suggestion from online!
-  s->CR1 &= ~(I2C_CR1_SWRST); // Normal operation
+  s->CR1 &= ~(I2C_CR1_PE);     // Disable I2C
+  s->CR1 |= I2C_CR1_SWRST;     // reset the I2C
+  asm("nop");                  // wait a bit... suggestion from online!
+  s->CR1 &= ~(I2C_CR1_SWRST);  // Normal operation
@@ -124,2 +123 @@ void I2CManagerClass::I2C_setClock(uint32_t i2cClockSpeed) {
-  if (i2cClockSpeed > 100000UL)
-  {
+  if (i2cClockSpeed > 100000UL) {
@@ -130,3 +128 @@ void I2CManagerClass::I2C_setClock(uint32_t i2cClockSpeed) {
-  }
-  else
-  {
+  } else {
@@ -149,6 +145,6 @@ void I2CManagerClass::I2C_setClock(uint32_t i2cClockSpeed) {
-    // In standard and fast mode, I2C period is 2 * CCR * TPCLK1
-    s->CCR &= ~(0x3000); // Clear all bits except 12 and 13 which must remain per reset value
-    s->CCR |= (APB1clk1 / 2 / i2cClockSpeed); // Set I2C clockspeed to start!
-    // s->CCR |= (i2c_MHz * 500 / (i2cClockSpeed / 1000)); // Set I2C clockspeed to start!
-    // if (i2cClockSpeed > 100000UL)
-    //     s->CCR |= 0xC000; // We need Fast Mode bits set as well
+  // In standard and fast mode, I2C period is 2 * CCR * TPCLK1
+  s->CCR &= ~(0x3000);                       // Clear all bits except 12 and 13 which must remain per reset value
+  s->CCR |= (APB1clk1 / 2 / i2cClockSpeed);  // Set I2C clockspeed to start!
+  // s->CCR |= (i2c_MHz * 500 / (i2cClockSpeed / 1000)); // Set I2C clockspeed to start!
+  // if (i2cClockSpeed > 100000UL)
+  //     s->CCR |= 0xC000; // We need Fast Mode bits set as well
@@ -168,2 +164 @@ void I2CManagerClass::I2C_setClock(uint32_t i2cClockSpeed) {
-void I2CManagerClass::I2C_init()
-{
+void I2CManagerClass::I2C_init() {
@@ -175 +170 @@ void I2CManagerClass::I2C_init()
-  RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;//(1 << 21); // Enable I2C CLOCK
+  RCC->APB1ENR |= RCC_APB1ENR_I2C1EN;  //(1 << 21); // Enable I2C CLOCK
@@ -177,2 +172,2 @@ void I2CManagerClass::I2C_init()
-  RCC->APB1RSTR |=  RCC_APB1RSTR_I2C1RST;
-	RCC->APB1RSTR &= ~RCC_APB1RSTR_I2C1RST;
+  RCC->APB1RSTR |= RCC_APB1RSTR_I2C1RST;
+  RCC->APB1RSTR &= ~RCC_APB1RSTR_I2C1RST;
@@ -180 +175 @@ void I2CManagerClass::I2C_init()
-  RCC->AHB1ENR |= (1<<1);   // Enable GPIOB CLOCK for PB8/PB9
+  RCC->AHB1ENR |= (1 << 1);  // Enable GPIOB CLOCK for PB8/PB9
@@ -183,5 +178,5 @@ void I2CManagerClass::I2C_init()
-  GPIOB->MODER &= ~((3<<(8*2)) | (3<<(9*2)));    // Clear all MODER bits for PB8 and PB9
-  GPIOB->MODER |= (2<<(8*2)) | (2<<(9*2));    // PB8 and PB9 set to ALT function
-  GPIOB->OTYPER |= (1<<8) | (1<<9);           // PB8 and PB9 set to open drain output capability
-  GPIOB->OSPEEDR |= (3<<(8*2)) | (3<<(9*2));  // PB8 and PB9 set to High Speed mode
-  GPIOB->PUPDR &= ~((3<<(8*2)) | (3<<(9*2))); // Clear all PUPDR bits for PB8 and PB9
+  GPIOB->MODER &= ~((3 << (8 * 2)) | (3 << (9 * 2)));  // Clear all MODER bits for PB8 and PB9
+  GPIOB->MODER |= (2 << (8 * 2)) | (2 << (9 * 2));     // PB8 and PB9 set to ALT function
+  GPIOB->OTYPER |= (1 << 8) | (1 << 9);                // PB8 and PB9 set to open drain output capability
+  GPIOB->OSPEEDR |= (3 << (8 * 2)) | (3 << (9 * 2));   // PB8 and PB9 set to High Speed mode
+  GPIOB->PUPDR &= ~((3 << (8 * 2)) | (3 << (9 * 2)));  // Clear all PUPDR bits for PB8 and PB9
@@ -192,2 +187,2 @@ void I2CManagerClass::I2C_init()
-  GPIOB->AFR[1] &= ~((15<<0) | (15<<4));      // Clear all AFR bits for PB8 on low nibble, PB9 on next nibble up
-  GPIOB->AFR[1] |= (4<<0) | (4<<4);           // PB8 on low nibble, PB9 on next nibble up
+  GPIOB->AFR[1] &= ~((15 << 0) | (15 << 4));  // Clear all AFR bits for PB8 on low nibble, PB9 on next nibble up
+  GPIOB->AFR[1] |= (4 << 0) | (4 << 4);       // PB8 on low nibble, PB9 on next nibble up
@@ -196,4 +191,4 @@ void I2CManagerClass::I2C_init()
-  I2C1->CR1 &= ~I2C_CR1_PE; // Disable I2C1 peripheral
-  s->CR1 |= I2C_CR1_SWRST;  // reset the I2C
-  asm("nop");    // wait a bit... suggestion from online!
-  s->CR1 &= ~(I2C_CR1_SWRST); // Normal operation
+  I2C1->CR1 &= ~I2C_CR1_PE;    // Disable I2C1 peripheral
+  s->CR1 |= I2C_CR1_SWRST;     // reset the I2C
+  asm("nop");                  // wait a bit... suggestion from online!
+  s->CR1 &= ~(I2C_CR1_SWRST);  // Normal operation
@@ -210 +205 @@ void I2CManagerClass::I2C_init()
-  I2C1->OAR1 = (1 << 14); // bit 14 should be kept at 1 according to the datasheet
+  I2C1->OAR1 = (1 << 14);  // bit 14 should be kept at 1 according to the datasheet
@@ -228 +223 @@ void I2CManagerClass::I2C_init()
-  s->CR2 |= (I2C_CR2_ITBUFEN | I2C_CR2_ITEVTEN | I2C_CR2_ITERREN);   // Enable Buffer, Event and Error interrupts
+  s->CR2 |= (I2C_CR2_ITBUFEN | I2C_CR2_ITEVTEN | I2C_CR2_ITERREN);  // Enable Buffer, Event and Error interrupts
@@ -238,2 +233,2 @@ void I2CManagerClass::I2C_init()
-  s->CCR &= ~(0x3000); // Clear all bits except 12 and 13 which must remain per reset value
-  s->CCR |= (APB1clk1 / 2 / 100000UL); // Set a default of 100KHz I2C clockspeed to start!
+  s->CCR &= ~(0x3000);                  // Clear all bits except 12 and 13 which must remain per reset value
+  s->CCR |= (APB1clk1 / 2 / 100000UL);  // Set a default of 100KHz I2C clockspeed to start!
@@ -256 +250,0 @@ void I2CManagerClass::I2C_sendStart() {
-
@@ -265 +259 @@ void I2CManagerClass::I2C_sendStart() {
-  //while (s->SR2 & I2C_SR2_BUSY) {}
+  // while (s->SR2 & I2C_SR2_BUSY) {}
@@ -269 +263,2 @@ void I2CManagerClass::I2C_sendStart() {
-  while (s->CR1 & I2C_CR1_STOP) {}  // Wait for STOP bit to reset
+  while (s->CR1 & I2C_CR1_STOP) {
+  }  // Wait for STOP bit to reset
@@ -272,3 +267,3 @@ void I2CManagerClass::I2C_sendStart() {
-  s->CR2 &= ~I2C_CR2_ITBUFEN;     // Don't enable buffer interupts yet.
-  s->CR1 &= ~I2C_CR1_POS;   // Clear the POS bit
-  s->CR1 |= (I2C_CR1_ACK | I2C_CR1_START);   // Enable the ACK and generate START
+  s->CR2 &= ~I2C_CR2_ITBUFEN;                     // Don't enable buffer interupts yet.
+  s->CR1 &= ~I2C_CR1_POS;                         // Clear the POS bit
+  s->CR1 |= (I2C_CR1_ACK | I2C_CR1_START);        // Enable the ACK and generate START
@@ -282 +277 @@ void I2CManagerClass::I2C_sendStop() {
-  s->CR1 |= I2C_CR1_STOP; // Stop I2C
+  s->CR1 |= I2C_CR1_STOP;  // Stop I2C
@@ -295 +290,2 @@ void I2CManagerClass::I2C_close() {
-    if ((int32_t)(micros() - startTime) >= 500) break;
+    if ((int32_t)(micros() - startTime) >= 500)
+      break;
@@ -314,4 +310,3 @@ void I2CManagerClass::I2C_handleInterrupt() {
-    if (temp_sr1 & I2C_SR1_AF)
-    {
-      s->SR1 &= ~(I2C_SR1_AF); // Clear AF
-      I2C_sendStop(); // Clear the bus
+    if (temp_sr1 & I2C_SR1_AF) {
+      s->SR1 &= ~(I2C_SR1_AF);  // Clear AF
+      I2C_sendStop();           // Clear the bus
@@ -321,3 +316 @@ void I2CManagerClass::I2C_handleInterrupt() {
-    }
-    else if (temp_sr1 & I2C_SR1_ARLO)
-    {
+    } else if (temp_sr1 & I2C_SR1_ARLO) {
@@ -325,2 +318,2 @@ void I2CManagerClass::I2C_handleInterrupt() {
-      s->SR1 &= ~(I2C_SR1_ARLO); // Clear ARLO
-      I2C_sendStart(); // Reinitiate request
+      s->SR1 &= ~(I2C_SR1_ARLO);  // Clear ARLO
+      I2C_sendStart();            // Reinitiate request
@@ -328,3 +321 @@ void I2CManagerClass::I2C_handleInterrupt() {
-    }
-    else if (temp_sr1 & I2C_SR1_BERR)
-    {
+    } else if (temp_sr1 & I2C_SR1_BERR) {
@@ -332,2 +323,2 @@ void I2CManagerClass::I2C_handleInterrupt() {
-      s->SR1 &= ~(I2C_SR1_BERR); // Clear BERR
-      I2C_sendStop(); // Clear the bus
+      s->SR1 &= ~(I2C_SR1_BERR);  // Clear BERR
+      I2C_sendStop();             // Clear the bus
@@ -338,2 +329 @@ void I2CManagerClass::I2C_handleInterrupt() {
-  } 
-  else {
+  } else {
@@ -362 +352 @@ void I2CManagerClass::I2C_handleInterrupt() {
-          temp_sr2 = s->SR2; // read SR2 to complete clearing the ADDR bit
+          temp_sr2 = s->SR2;  // read SR2 to complete clearing the ADDR bit
@@ -381 +371 @@ void I2CManagerClass::I2C_handleInterrupt() {
-              // The TXE interrupt occurs when the DR is empty, and the BTF interrupt 
+              // The TXE interrupt occurs when the DR is empty, and the BTF interrupt
@@ -407 +397 @@ void I2CManagerClass::I2C_handleInterrupt() {
-        } 
+        }
@@ -421 +411 @@ void I2CManagerClass::I2C_handleInterrupt() {
-            //while (s->SR1 && I2C_SR1_BTF) {}
+            // while (s->SR1 && I2C_SR1_BTF) {}
@@ -437 +427 @@ void I2CManagerClass::I2C_handleInterrupt() {
-          // The next bit is different depending on whether there are 
+          // The next bit is different depending on whether there are
@@ -443 +433 @@ void I2CManagerClass::I2C_handleInterrupt() {
-            temp_sr2 = s->SR2; // read SR2 to complete clearing the ADDR bit
+            temp_sr2 = s->SR2;       // read SR2 to complete clearing the ADDR bit
@@ -450 +440 @@ void I2CManagerClass::I2C_handleInterrupt() {
-            s->CR1 |= I2C_CR1_POS;  // set POS flag to delay effect of ACK flag
+            s->CR1 |= I2C_CR1_POS;   // set POS flag to delay effect of ACK flag
@@ -453 +443 @@ void I2CManagerClass::I2C_handleInterrupt() {
-            temp_sr2 = s->SR2; // read SR2 to complete clearing the ADDR bit
+            temp_sr2 = s->SR2;  // read SR2 to complete clearing the ADDR bit
@@ -460 +450 @@ void I2CManagerClass::I2C_handleInterrupt() {
-            temp_sr2 = s->SR2; // read SR2 to complete clearing the ADDR bit
+            temp_sr2 = s->SR2;  // read SR2 to complete clearing the ADDR bit
@@ -465 +455 @@ void I2CManagerClass::I2C_handleInterrupt() {
-      
+
@@ -477 +467 @@ void I2CManagerClass::I2C_handleInterrupt() {
-        } 
+        }
@@ -479 +469 @@ void I2CManagerClass::I2C_handleInterrupt() {
-        
+
@@ -487 +477 @@ void I2CManagerClass::I2C_handleInterrupt() {
-            if (bytesToReceive > 1) 
+            if (bytesToReceive > 1)
@@ -489 +479 @@ void I2CManagerClass::I2C_handleInterrupt() {
-            while(bytesToReceive) {
+            while (bytesToReceive) {
@@ -502 +492 @@ void I2CManagerClass::I2C_handleInterrupt() {
-            receiveBuffer[rxCount++] = s->DR; // Store received byte
+            receiveBuffer[rxCount++] = s->DR;  // Store received byte
@@ -517 +506,0 @@ void I2CManagerClass::I2C_handleInterrupt() {
-  
diff --git a/I2CManager_Wire.h b/I2CManager_Wire.h
index 8324919..5e51e55 100644
--- a/I2CManager_Wire.h
+++ b/I2CManager_Wire.h
@@ -43 +43 @@ void I2CManagerClass::_initialise() {
-#if defined(WIRE_HAS_TIMEOUT) 
+#if defined(WIRE_HAS_TIMEOUT)
@@ -63 +63 @@ void I2CManagerClass::setTimeout(unsigned long value) {
-#if defined(WIRE_HAS_TIMEOUT) 
+#if defined(WIRE_HAS_TIMEOUT)
@@ -77,3 +77,4 @@ static uint8_t muxSelect(I2CAddress address) {
-    Wire.beginTransmission(I2C_MUX_BASE_ADDRESS+muxNo); 
-    uint8_t data =  (subBus == SubBus_All) ? 0xff :
-                    (subBus == SubBus_None) ? 0x00 :
+    Wire.beginTransmission(I2C_MUX_BASE_ADDRESS + muxNo);
+    uint8_t data = (subBus == SubBus_All)    ? 0xff
+                   : (subBus == SubBus_None) ? 0x00
+                                             :
@@ -81 +82 @@ static uint8_t muxSelect(I2CAddress address) {
-                    0x08 | subBus;
+                                             0x08 | subBus;
@@ -83 +84 @@ static uint8_t muxSelect(I2CAddress address) {
-                    0x04 | subBus;   // NB Only 2 or 4 subbuses respectively
+                                             0x04 | subBus;  // NB Only 2 or 4 subbuses respectively
@@ -85,3 +86,3 @@ static uint8_t muxSelect(I2CAddress address) {
-                    // Default behaviour for most MUXs is to use a mask
-                    // with a bit set for the subBus to be enabled
-                    1 << subBus;
+                                             // Default behaviour for most MUXs is to use a mask
+                                             // with a bit set for the subBus to be enabled
+                       1 << subBus;
@@ -96 +96,0 @@ static uint8_t muxSelect(I2CAddress address) {
-
@@ -100 +100 @@ static uint8_t muxSelect(I2CAddress address) {
-uint8_t I2CManagerClass::write(I2CAddress address, const uint8_t buffer[], uint8_t size, I2CRB *rb) {
+uint8_t I2CManagerClass::write(I2CAddress address, const uint8_t buffer[], uint8_t size, I2CRB* rb) {
@@ -114 +114,2 @@ uint8_t I2CManagerClass::write(I2CAddress address, const uint8_t buffer[], uint8
-      if (size > 0) Wire.write(buffer, size);
+      if (size > 0)
+        Wire.write(buffer, size);
@@ -119,2 +120 @@ uint8_t I2CManagerClass::write(I2CAddress address, const uint8_t buffer[], uint8
-    if (_muxCount > 1 && muxStatus == I2C_STATUS_OK 
-          && address.deviceAddress() != 0 && address.muxNumber() != I2CMux_None) {
+    if (_muxCount > 1 && muxStatus == I2C_STATUS_OK && address.deviceAddress() != 0 && address.muxNumber() != I2CMux_None) {
@@ -123 +123,2 @@ uint8_t I2CManagerClass::write(I2CAddress address, const uint8_t buffer[], uint8
-    if (muxStatus != I2C_STATUS_OK) status = muxStatus;
+    if (muxStatus != I2C_STATUS_OK)
+      status = muxStatus;
@@ -125,2 +126 @@ uint8_t I2CManagerClass::write(I2CAddress address, const uint8_t buffer[], uint8
-  } while (!(status == I2C_STATUS_OK
-    || ++retryCount > MAX_I2C_RETRIES || rb->operation & OPERATION_NORETRY));
+  } while (!(status == I2C_STATUS_OK || ++retryCount > MAX_I2C_RETRIES || rb->operation & OPERATION_NORETRY));
@@ -134 +134 @@ uint8_t I2CManagerClass::write(I2CAddress address, const uint8_t buffer[], uint8
-uint8_t I2CManagerClass::write_P(I2CAddress address, const uint8_t buffer[], uint8_t size, I2CRB *rb) {
+uint8_t I2CManagerClass::write_P(I2CAddress address, const uint8_t buffer[], uint8_t size, I2CRB* rb) {
@@ -136,3 +136,2 @@ uint8_t I2CManagerClass::write_P(I2CAddress address, const uint8_t buffer[], uin
-  const uint8_t *p1 = buffer;
-  for (uint8_t i=0; i<size; i++)
-    ramBuffer[i] = GETFLASH(p1++);
+  const uint8_t* p1 = buffer;
+  for (uint8_t i = 0; i < size; i++) ramBuffer[i] = GETFLASH(p1++);
@@ -146,3 +145 @@ uint8_t I2CManagerClass::write_P(I2CAddress address, const uint8_t buffer[], uin
-uint8_t I2CManagerClass::read(I2CAddress address, uint8_t readBuffer[], uint8_t readSize,
-                              const uint8_t writeBuffer[], uint8_t writeSize, I2CRB *rb)
-{
+uint8_t I2CManagerClass::read(I2CAddress address, uint8_t readBuffer[], uint8_t readSize, const uint8_t writeBuffer[], uint8_t writeSize, I2CRB* rb) {
@@ -166 +163 @@ uint8_t I2CManagerClass::read(I2CAddress address, uint8_t readBuffer[], uint8_t
-        status = Wire.endTransmission(false); // Don't free bus yet
+        status = Wire.endTransmission(false);  // Don't free bus yet
@@ -173,3 +170,3 @@ uint8_t I2CManagerClass::read(I2CAddress address, uint8_t readBuffer[], uint8_t
-          while (Wire.available() && nBytes < readSize) 
-            readBuffer[nBytes++] = Wire.read();
-          if (nBytes < readSize) status = I2C_STATUS_TRUNCATED;
+          while (Wire.available() && nBytes < readSize) readBuffer[nBytes++] = Wire.read();
+          if (nBytes < readSize)
+            status = I2C_STATUS_TRUNCATED;
@@ -181,3 +178,3 @@ uint8_t I2CManagerClass::read(I2CAddress address, uint8_t readBuffer[], uint8_t
-          while (Wire.available() && nBytes < readSize) 
-            readBuffer[nBytes++] = Wire.read();
-          if (nBytes < readSize) status = I2C_STATUS_TRUNCATED;
+        while (Wire.available() && nBytes < readSize) readBuffer[nBytes++] = Wire.read();
+        if (nBytes < readSize)
+          status = I2C_STATUS_TRUNCATED;
@@ -192 +189,2 @@ uint8_t I2CManagerClass::read(I2CAddress address, uint8_t readBuffer[], uint8_t
-    if (muxStatus != I2C_STATUS_OK) status = muxStatus;
+    if (muxStatus != I2C_STATUS_OK)
+      status = muxStatus;
@@ -195,2 +193 @@ uint8_t I2CManagerClass::read(I2CAddress address, uint8_t readBuffer[], uint8_t
-  } while (!((status == I2C_STATUS_OK) 
-    || ++retryCount > MAX_I2C_RETRIES || rb->operation & OPERATION_NORETRY));
+  } while (!((status == I2C_STATUS_OK) || ++retryCount > MAX_I2C_RETRIES || rb->operation & OPERATION_NORETRY));
@@ -203 +199,0 @@ uint8_t I2CManagerClass::read(I2CAddress address, uint8_t readBuffer[], uint8_t
-
@@ -206 +202 @@ uint8_t I2CManagerClass::read(I2CAddress address, uint8_t readBuffer[], uint8_t
- * 
+ *
@@ -208 +204 @@ uint8_t I2CManagerClass::read(I2CAddress address, uint8_t readBuffer[], uint8_t
- * The read/write/write_P functions return I2C_STATUS_OK always, and the 
+ * The read/write/write_P functions return I2C_STATUS_OK always, and the
@@ -212 +208 @@ uint8_t I2CManagerClass::read(I2CAddress address, uint8_t readBuffer[], uint8_t
-void I2CManagerClass::queueRequest(I2CRB *req) {
+void I2CManagerClass::queueRequest(I2CRB* req) {
@@ -232 +228,2 @@ void I2CManagerClass::queueRequest(I2CRB *req) {
-void I2CManagerClass::loop() {}
+void I2CManagerClass::loop() {
+}
diff --git a/IODevice.cpp b/IODevice.cpp
index 2a990bf..3476517 100644
--- a/IODevice.cpp
+++ b/IODevice.cpp
@@ -5 +5 @@
- *  
+ *
@@ -22 +21,0 @@
-
@@ -25 +24 @@
-#include "DIAG.h" 
+#include "DIAG.h"
@@ -44 +43 @@ extern __attribute__((weak)) bool exrailHalSetup();
-// Static method to initialise the IODevice subsystem.  
+// Static method to initialise the IODevice subsystem.
@@ -48 +47 @@ extern __attribute__((weak)) bool exrailHalSetup();
-// Create any standard device instances that may be required, such as the Arduino pins 
+// Create any standard device instances that may be required, such as the Arduino pins
@@ -52 +51 @@ void IODevice::begin() {
-  ArduinoPins::create(2, NUM_DIGITAL_PINS-2);  // Reserve pins for direct access
+  ArduinoPins::create(2, NUM_DIGITAL_PINS - 2);  // Reserve pins for direct access
@@ -58 +57 @@ void IODevice::begin() {
-  // create something that conflicts with the user's vpin definitions. 
+  // create something that conflicts with the user's vpin definitions.
@@ -62,2 +61,2 @@ void IODevice::begin() {
-  // include any HAL devices defined in exrail. 
-  bool ignoreDefaults=false;
+  // include any HAL devices defined in exrail.
+  bool ignoreDefaults = false;
@@ -65,3 +64,4 @@ void IODevice::begin() {
-    ignoreDefaults=exrailHalSetup();
-  if (ignoreDefaults) return;
-  
+    ignoreDefaults = exrailHalSetup();
+  if (ignoreDefaults)
+    return;
+
@@ -70 +70 @@ void IODevice::begin() {
-  const bool silent=true; // no message if these conflict
+  const bool silent = true;  // no message if these conflict
@@ -73 +73 @@ void IODevice::begin() {
-  } 
+  }
@@ -77,2 +77,2 @@ void IODevice::begin() {
-  } 
-  
+  }
+
@@ -83 +83 @@ void IODevice::begin() {
-  } 
+  }
@@ -87 +87 @@ void IODevice::begin() {
-  } 
+  }
@@ -93 +93 @@ void IODevice::reset() {
-  for (IODevice *dev = _firstDevice; dev != NULL; dev = dev->_nextDevice) {
+  for (IODevice* dev = _firstDevice; dev != NULL; dev = dev->_nextDevice) {
@@ -95 +95 @@ void IODevice::reset() {
-    // First ensure that _loop isn't delaying 
+    // First ensure that _loop isn't delaying
@@ -104 +104 @@ void IODevice::reset() {
-// Devices may or may not implement this, but if they do it is useful for things like animations 
+// Devices may or may not implement this, but if they do it is useful for things like animations
@@ -110,2 +110,2 @@ void IODevice::loop() {
-  
-  IODevice *lastLoopDevice = _nextLoopDevice;  // So we know when to stop...
+
+  IODevice* lastLoopDevice = _nextLoopDevice;  // So we know when to stop...
@@ -114 +114,2 @@ void IODevice::loop() {
-    if (!_nextLoopDevice) _nextLoopDevice = _firstDevice;
+    if (!_nextLoopDevice)
+      _nextLoopDevice = _firstDevice;
@@ -116,2 +117 @@ void IODevice::loop() {
-      if (_nextLoopDevice->_deviceState != DEVSTATE_FAILED 
-            && ((long)(currentMicros - _nextLoopDevice->_nextEntryTime)) >= 0) {
+      if (_nextLoopDevice->_deviceState != DEVSTATE_FAILED && ((long)(currentMicros - _nextLoopDevice->_nextEntryTime)) >= 0) {
@@ -127,2 +127,2 @@ void IODevice::loop() {
-  } while (_nextLoopDevice != lastLoopDevice); // Stop looking when we've done all.
-  
+  } while (_nextLoopDevice != lastLoopDevice);  // Stop looking when we've done all.
+
@@ -141 +141 @@ void IODevice::loop() {
-  const unsigned long interval = (unsigned long)5 * 1000 * 1000; // 5 seconds in microsec
+  const unsigned long interval = (unsigned long)5 * 1000 * 1000;  // 5 seconds in microsec
@@ -145,2 +145,4 @@ void IODevice::loop() {
-    if (elapsed > maxElapsed) maxElapsed = elapsed;
-    if (halElapsed > maxHalElapsed) maxHalElapsed = halElapsed;
+    if (elapsed > maxElapsed)
+      maxElapsed = elapsed;
+    if (halElapsed > maxHalElapsed)
+      maxHalElapsed = halElapsed;
@@ -152,3 +154,2 @@ void IODevice::loop() {
-    if (lastOutputTime > 0) 
-      DIAG(F("Loop Total:%lus (%lus max) HAL:%lus (%lus max)"), 
-        total/count, maxElapsed, halTotal/count, maxHalElapsed);
+    if (lastOutputTime > 0)
+      DIAG(F("Loop Total:%lus (%lus max) HAL:%lus (%lus max)"), total / count, maxElapsed, halTotal / count, maxHalElapsed);
@@ -166 +167 @@ void IODevice::DumpAll() {
-  for (IODevice *dev = _firstDevice; dev != 0; dev = dev->_nextDevice) {
+  for (IODevice* dev = _firstDevice; dev != 0; dev = dev->_nextDevice) {
@@ -178,2 +179,3 @@ uint8_t IODevice::getStatus(VPIN vpin) {
-  IODevice *dev = findDevice(vpin);
-  if (!dev) return false;
+  IODevice* dev = findDevice(vpin);
+  if (!dev)
+    return false;
@@ -185,2 +187,3 @@ bool IODevice::hasCallback(VPIN vpin) {
-  IODevice *dev = findDevice(vpin);
-  if (!dev) return false;
+  IODevice* dev = findDevice(vpin);
+  if (!dev)
+    return false;
@@ -192,2 +195 @@ void IODevice::_display() {
-  DIAG(F("Unknown device Vpins:%u-%u %S"), 
-    (int)_firstVpin, (int)_firstVpin+_nPins-1, _deviceState==DEVSTATE_FAILED ? F("OFFLINE") : F(""));
+  DIAG(F("Unknown device Vpins:%u-%u %S"), (int)_firstVpin, (int)_firstVpin + _nPins - 1, _deviceState == DEVSTATE_FAILED ? F("OFFLINE") : F(""));
@@ -199,2 +201,3 @@ bool IODevice::configure(VPIN vpin, ConfigTypeEnum configType, int paramCount, i
-  IODevice *dev = findDevice(vpin);
-  if (dev) return dev->_configure(vpin, configType, paramCount, params);
+  IODevice* dev = findDevice(vpin);
+  if (dev)
+    return dev->_configure(vpin, configType, paramCount, params);
@@ -209,2 +212,2 @@ int IODevice::read(VPIN vpin) {
-  for (IODevice *dev = _firstDevice; dev != 0; dev = dev->_nextDevice) {
-    if (dev->owns(vpin)) 
+  for (IODevice* dev = _firstDevice; dev != 0; dev = dev->_nextDevice) {
+    if (dev->owns(vpin))
@@ -221,2 +224,2 @@ int IODevice::readAnalogue(VPIN vpin) {
-  for (IODevice *dev = _firstDevice; dev != 0; dev = dev->_nextDevice) {
-    if (dev->owns(vpin)) 
+  for (IODevice* dev = _firstDevice; dev != 0; dev = dev->_nextDevice) {
+    if (dev->owns(vpin))
@@ -231,2 +234,2 @@ int IODevice::configureAnalogIn(VPIN vpin) {
-  for (IODevice *dev = _firstDevice; dev != 0; dev = dev->_nextDevice) {
-    if (dev->owns(vpin)) 
+  for (IODevice* dev = _firstDevice; dev != 0; dev = dev->_nextDevice) {
+    if (dev->owns(vpin))
@@ -244 +247 @@ void IODevice::write(VPIN vpin, int value) {
-  IODevice *dev = findDevice(vpin);
+  IODevice* dev = findDevice(vpin);
@@ -255,4 +258,3 @@ void IODevice::write(VPIN vpin, int value) {
-// these may be within one driver or separated over several drivers 
-void IODevice::writeRange(VPIN vpin, int value, int count) {  
-  
-  while(count) {  
+// these may be within one driver or separated over several drivers
+void IODevice::writeRange(VPIN vpin, int value, int count) {
+  while (count) {
@@ -261 +263 @@ void IODevice::writeRange(VPIN vpin, int value, int count) {
-      auto vpinBefore=vpin; 
+      auto vpinBefore = vpin;
@@ -263,4 +265,3 @@ void IODevice::writeRange(VPIN vpin, int value, int count) {
-      vpin=dev->_writeRange(vpin, value,count);
-      count-= vpin-vpinBefore;  // decrement by number of vpins changed
-    }
-    else {
+      vpin = dev->_writeRange(vpin, value, count);
+      count -= vpin - vpinBefore;  // decrement by number of vpins changed
+    } else {
@@ -283 +284 @@ void IODevice::writeAnalogue(VPIN vpin, int value, uint8_t param1, uint16_t para
-  IODevice *dev = findDevice(vpin);
+  IODevice* dev = findDevice(vpin);
@@ -294,2 +295,2 @@ void IODevice::writeAnalogue(VPIN vpin, int value, uint8_t param1, uint16_t para
-void IODevice::writeAnalogueRange(VPIN vpin, int value, uint8_t param1, uint16_t param2,int count) {
-  while(count) {  
+void IODevice::writeAnalogueRange(VPIN vpin, int value, uint8_t param1, uint16_t param2, int count) {
+  while (count) {
@@ -298 +299 @@ void IODevice::writeAnalogueRange(VPIN vpin, int value, uint8_t param1, uint16_t
-      auto vpinBefore=vpin; 
+      auto vpinBefore = vpin;
@@ -300,4 +301,3 @@ void IODevice::writeAnalogueRange(VPIN vpin, int value, uint8_t param1, uint16_t
-      vpin=dev->_writeAnalogueRange(vpin, value, param1, param2,count);
-      count-= vpin-vpinBefore;  // decrement by number of vpins changed
-    }
-    else {
+      vpin = dev->_writeAnalogueRange(vpin, value, param1, param2, count);
+      count -= vpin - vpinBefore;  // decrement by number of vpins changed
+    } else {
@@ -315,2 +315,2 @@ bool IODevice::isBusy(VPIN vpin) {
-  IODevice *dev = findDevice(vpin);
-  if (dev) 
+  IODevice* dev = findDevice(vpin);
+  if (dev)
@@ -328 +328 @@ void IODevice::setGPIOInterruptPin(int16_t pinNumber) {
-// Helper function to add a new device to the device chain.  If 
+// Helper function to add a new device to the device chain.  If
@@ -334 +334 @@ void IODevice::setGPIOInterruptPin(int16_t pinNumber) {
-void IODevice::addDevice(IODevice *newDevice, IODevice *slaveDevice /* = NULL */) {
+void IODevice::addDevice(IODevice* newDevice, IODevice* slaveDevice /* = NULL */) {
@@ -339 +339 @@ void IODevice::addDevice(IODevice *newDevice, IODevice *slaveDevice /* = NULL */
-    for (IODevice *dev = _firstDevice; dev != 0; dev = dev->_nextDevice) {
+    for (IODevice* dev = _firstDevice; dev != 0; dev = dev->_nextDevice) {
@@ -341 +341 @@ void IODevice::addDevice(IODevice *newDevice, IODevice *slaveDevice /* = NULL */
-          // Link new device between dev and slaveDevice (or at end of chain)
+        // Link new device between dev and slaveDevice (or at end of chain)
@@ -353,2 +353,2 @@ void IODevice::addDevice(IODevice *newDevice, IODevice *slaveDevice /* = NULL */
-IODevice *IODevice::findDevice(VPIN vpin) { 
-  for (IODevice *dev = _firstDevice; dev != 0; dev = dev->_nextDevice) {
+IODevice* IODevice::findDevice(VPIN vpin) {
+  for (IODevice* dev = _firstDevice; dev != 0; dev = dev->_nextDevice) {
@@ -356 +356 @@ IODevice *IODevice::findDevice(VPIN vpin) {
-    if (vpin >= firstVpin && vpin < firstVpin+dev->_nPins)
+    if (vpin >= firstVpin && vpin < firstVpin + dev->_nPins)
@@ -362 +362 @@ IODevice *IODevice::findDevice(VPIN vpin) {
-// Instance helper function for filter devices (layered over others).  Looks for 
+// Instance helper function for filter devices (layered over others).  Looks for
@@ -364,2 +364,2 @@ IODevice *IODevice::findDevice(VPIN vpin) {
-IODevice *IODevice::findDeviceFollowing(VPIN vpin) {
-  for (IODevice *dev = _nextDevice; dev != 0; dev = dev->_nextDevice) {
+IODevice* IODevice::findDeviceFollowing(VPIN vpin) {
+  for (IODevice* dev = _nextDevice; dev != 0; dev = dev->_nextDevice) {
@@ -367 +367 @@ IODevice *IODevice::findDeviceFollowing(VPIN vpin) {
-    if (vpin >= firstVpin && vpin < firstVpin+dev->_nPins)
+    if (vpin >= firstVpin && vpin < firstVpin + dev->_nPins)
@@ -377 +377 @@ IODevice *IODevice::findDeviceFollowing(VPIN vpin) {
-// Silent is used by the default setup so that there is no message if the default 
+// Silent is used by the default setup so that there is no message if the default
@@ -379,2 +379 @@ IODevice *IODevice::findDeviceFollowing(VPIN vpin) {
-bool IODevice::checkNoOverlap(VPIN firstPin, uint8_t nPins, 
-      I2CAddress i2cAddress, bool silent) {
+bool IODevice::checkNoOverlap(VPIN firstPin, uint8_t nPins, I2CAddress i2cAddress, bool silent) {
@@ -382 +381 @@ bool IODevice::checkNoOverlap(VPIN firstPin, uint8_t nPins,
-  DIAG(F("Check no overlap %u %u %s"), firstPin,nPins,i2cAddress.toString());
+  DIAG(F("Check no overlap %u %u %s"), firstPin, nPins, i2cAddress.toString());
@@ -384,3 +383,2 @@ bool IODevice::checkNoOverlap(VPIN firstPin, uint8_t nPins,
-  VPIN lastPin=firstPin+nPins-1;
-  for (IODevice *dev = _firstDevice; dev != 0; dev = dev->_nextDevice) {
-    
+  VPIN lastPin = firstPin + nPins - 1;
+  for (IODevice* dev = _firstDevice; dev != 0; dev = dev->_nextDevice) {
@@ -388,4 +386,4 @@ bool IODevice::checkNoOverlap(VPIN firstPin, uint8_t nPins,
-      // check for pin range overlaps (verbose but compiler will fix that)  
-      VPIN firstDevPin=dev->_firstVpin;
-      VPIN lastDevPin=firstDevPin+dev->_nPins-1;
-      bool noOverlap= firstPin>lastDevPin || lastPin<firstDevPin;
+      // check for pin range overlaps (verbose but compiler will fix that)
+      VPIN firstDevPin = dev->_firstVpin;
+      VPIN lastDevPin = firstDevPin + dev->_nPins - 1;
+      bool noOverlap = firstPin > lastDevPin || lastPin < firstDevPin;
@@ -393,4 +391,4 @@ bool IODevice::checkNoOverlap(VPIN firstPin, uint8_t nPins,
-          if (!silent) DIAG(F("WARNING HAL Overlap, redefinition of Vpins %u to %u ignored."),
-              firstPin, lastPin);
-          return false;
-      } 
+        if (!silent)
+          DIAG(F("WARNING HAL Overlap, redefinition of Vpins %u to %u ignored."), firstPin, lastPin);
+        return false;
+      }
@@ -399,2 +397,3 @@ bool IODevice::checkNoOverlap(VPIN firstPin, uint8_t nPins,
-    if (i2cAddress && dev->_I2CAddress==i2cAddress) {
-      if (!silent) DIAG(F("WARNING HAL Overlap. i2c Addr %s ignored."),i2cAddress.toString());
+    if (i2cAddress && dev->_I2CAddress == i2cAddress) {
+      if (!silent)
+        DIAG(F("WARNING HAL Overlap. i2c Addr %s ignored."), i2cAddress.toString());
@@ -402 +401 @@ bool IODevice::checkNoOverlap(VPIN firstPin, uint8_t nPins,
-    } 
+    }
@@ -406 +404,0 @@ bool IODevice::checkNoOverlap(VPIN firstPin, uint8_t nPins,
-  
@@ -413 +411 @@ bool IODevice::checkNoOverlap(VPIN firstPin, uint8_t nPins,
-IONotifyCallback *IONotifyCallback::first = 0;
+IONotifyCallback* IONotifyCallback::first = 0;
@@ -416 +414 @@ IONotifyCallback *IONotifyCallback::first = 0;
-IODevice *IODevice::_firstDevice = 0;
+IODevice* IODevice::_firstDevice = 0;
@@ -419,2 +417 @@ IODevice *IODevice::_firstDevice = 0;
-IODevice *IODevice::_nextLoopDevice = 0;
-
+IODevice* IODevice::_nextLoopDevice = 0;
@@ -431,2 +428 @@ bool IODevice::owns(VPIN id) {
-
-#else // !defined(IO_NO_HAL)
+#else  // !defined(IO_NO_HAL)
@@ -436 +432,3 @@ bool IODevice::owns(VPIN id) {
-void IODevice::begin() { DIAG(F("NO HAL CONFIGURED!")); }
+void IODevice::begin() {
+  DIAG(F("NO HAL CONFIGURED!"));
+}
@@ -438,2 +436,3 @@ bool IODevice::configure(VPIN pin, ConfigTypeEnum configType, int nParams, int p
-  if (configType!=CONFIGURE_INPUT || nParams!=1 || pin >= NUM_DIGITAL_PINS) return false;
-  #ifdef DIAG_IO
+  if (configType != CONFIGURE_INPUT || nParams != 1 || pin >= NUM_DIGITAL_PINS)
+    return false;
+#ifdef DIAG_IO
@@ -441 +440 @@ bool IODevice::configure(VPIN pin, ConfigTypeEnum configType, int nParams, int p
-  #endif
+#endif
@@ -446 +445,2 @@ void IODevice::write(VPIN vpin, int value) {
-  if (vpin >= NUM_DIGITAL_PINS) return;
+  if (vpin >= NUM_DIGITAL_PINS)
+    return;
@@ -450,5 +450,11 @@ void IODevice::write(VPIN vpin, int value) {
-void IODevice::writeAnalogue(VPIN, int, uint8_t, uint16_t) {}
-bool IODevice::isBusy(VPIN) { return false; }
-bool IODevice::hasCallback(VPIN) { return false; }
-int IODevice::read(VPIN vpin) { 
-  if (vpin >= NUM_DIGITAL_PINS) return 0;
+void IODevice::writeAnalogue(VPIN, int, uint8_t, uint16_t) {
+}
+bool IODevice::isBusy(VPIN) {
+  return false;
+}
+bool IODevice::hasCallback(VPIN) {
+  return false;
+}
+int IODevice::read(VPIN vpin) {
+  if (vpin >= NUM_DIGITAL_PINS)
+    return 0;
@@ -463 +469,2 @@ int IODevice::configureAnalogIn(VPIN vpin) {
-void IODevice::loop() {}
+void IODevice::loop() {
+}
@@ -467,2 +474,5 @@ void IODevice::DumpAll() {
-bool IODevice::exists(VPIN vpin) { return (vpin > 2 && vpin < NUM_DIGITAL_PINS); }
-void IODevice::setGPIOInterruptPin(int16_t) {}
+bool IODevice::exists(VPIN vpin) {
+  return (vpin > 2 && vpin < NUM_DIGITAL_PINS);
+}
+void IODevice::setGPIOInterruptPin(int16_t) {
+}
@@ -472,3 +482 @@ void IODevice::setGPIOInterruptPin(int16_t) {}
-IONotifyCallback *IONotifyCallback::first = 0;
-
-#endif // IO_NO_HAL
+IONotifyCallback* IONotifyCallback::first = 0;
@@ -475,0 +484 @@ IONotifyCallback *IONotifyCallback::first = 0;
+#endif  // IO_NO_HAL
@@ -483,2 +492,2 @@ ArduinoPins::ArduinoPins(VPIN firstVpin, int nPins) {
-  int arrayLen = (_nPins+7)/8;
-  _pinPullups = (uint8_t *)calloc(3, arrayLen);
+  int arrayLen = (_nPins + 7) / 8;
+  _pinPullups = (uint8_t*)calloc(3, arrayLen);
@@ -486,2 +495,2 @@ ArduinoPins::ArduinoPins(VPIN firstVpin, int nPins) {
-  _pinInUse = (&_pinPullups[0]) + 2*arrayLen;
-  for (int i=0; i<arrayLen; i++) {
+  _pinInUse = (&_pinPullups[0]) + 2 * arrayLen;
+  for (int i = 0; i < arrayLen; i++) {
@@ -494 +503 @@ ArduinoPins::ArduinoPins(VPIN firstVpin, int nPins) {
-// Device-specific pin configuration.  Configure should be called infrequently so simplify 
+// Device-specific pin configuration.  Configure should be called infrequently so simplify
@@ -497,2 +506,4 @@ bool ArduinoPins::_configure(VPIN vpin, ConfigTypeEnum configType, int paramCoun
-  if (configType != CONFIGURE_INPUT) return false;
-  if (paramCount != 1) return false;
+  if (configType != CONFIGURE_INPUT)
+    return false;
+  if (paramCount != 1)
+    return false;
@@ -502 +513 @@ bool ArduinoPins::_configure(VPIN vpin, ConfigTypeEnum configType, int paramCoun
-  #ifdef DIAG_IO
+#ifdef DIAG_IO
@@ -504,3 +515,3 @@ bool ArduinoPins::_configure(VPIN vpin, ConfigTypeEnum configType, int paramCoun
-  #endif
-  uint8_t mask = 1 << ((pin-_firstVpin) % 8);
-  uint8_t index = (pin-_firstVpin) / 8;
+#endif
+  uint8_t mask = 1 << ((pin - _firstVpin) % 8);
+  uint8_t index = (pin - _firstVpin) / 8;
@@ -522 +533 @@ void ArduinoPins::_write(VPIN vpin, int value) {
-  #ifdef DIAG_IO
+#ifdef DIAG_IO
@@ -524,3 +535,3 @@ void ArduinoPins::_write(VPIN vpin, int value) {
-  #endif
-  uint8_t mask = 1 << ((pin-_firstVpin) % 8);
-  uint8_t index = (pin-_firstVpin) / 8;
+#endif
+  uint8_t mask = 1 << ((pin - _firstVpin) % 8);
+  uint8_t index = (pin - _firstVpin) / 8;
@@ -541,2 +552,2 @@ int ArduinoPins::_read(VPIN vpin) {
-  uint8_t mask = 1 << ((pin-_firstVpin) % 8);
-  uint8_t index = (pin-_firstVpin) / 8;
+  uint8_t mask = 1 << ((pin - _firstVpin) % 8);
+  uint8_t index = (pin - _firstVpin) / 8;
@@ -547 +558 @@ int ArduinoPins::_read(VPIN vpin) {
-    if (_pinPullups[index] & mask) 
+    if (_pinPullups[index] & mask)
@@ -553 +564 @@ int ArduinoPins::_read(VPIN vpin) {
-  int value = !fastReadDigital(pin); // Invert (5v=0, 0v=1)
+  int value = !fastReadDigital(pin);  // Invert (5v=0, 0v=1)
@@ -555,3 +566,3 @@ int ArduinoPins::_read(VPIN vpin) {
-  #ifdef DIAG_IO
-  //DIAG(F("Arduino Read Pin:%d Value:%d"), pin, value);
-  #endif
+#ifdef DIAG_IO
+// DIAG(F("Arduino Read Pin:%d Value:%d"), pin, value);
+#endif
@@ -563 +574,2 @@ int ArduinoPins::_readAnalogue(VPIN vpin) {
-  if (vpin > 255) return -1023;
+  if (vpin > 255)
+    return -1023;
@@ -567 +579 @@ int ArduinoPins::_readAnalogue(VPIN vpin) {
-  #ifdef DIAG_IO
+#ifdef DIAG_IO
@@ -569 +581 @@ int ArduinoPins::_readAnalogue(VPIN vpin) {
-  #endif
+#endif
@@ -573 +585,2 @@ int ArduinoPins::_configureAnalogIn(VPIN vpin) {
-  if (vpin > 255) return -1023;
+  if (vpin > 255)
+    return -1023;
@@ -575,2 +588,2 @@ int ArduinoPins::_configureAnalogIn(VPIN vpin) {
-  uint8_t mask = 1 << ((pin-_firstVpin) % 8);
-  uint8_t index = (pin-_firstVpin) / 8;
+  uint8_t mask = 1 << ((pin - _firstVpin) % 8);
+  uint8_t index = (pin - _firstVpin) / 8;
@@ -581 +594 @@ int ArduinoPins::_configureAnalogIn(VPIN vpin) {
-    if (_pinPullups[index] & mask) 
+    if (_pinPullups[index] & mask)
@@ -587 +600 @@ int ArduinoPins::_configureAnalogIn(VPIN vpin) {
-  #ifdef DIAG_IO
+#ifdef DIAG_IO
@@ -589 +602 @@ int ArduinoPins::_configureAnalogIn(VPIN vpin) {
-  #endif
+#endif
@@ -594 +607 @@ void ArduinoPins::_display() {
-  DIAG(F("Arduino Vpins:%u-%u"), (int)_firstVpin, (int)_firstVpin+_nPins-1);
+  DIAG(F("Arduino Vpins:%u-%u"), (int)_firstVpin, (int)_firstVpin + _nPins - 1);
@@ -599 +611,0 @@ void ArduinoPins::_display() {
-
@@ -602 +614,2 @@ void ArduinoPins::fastWriteDigital(uint8_t pin, uint8_t value) {
-  if (pin >= NUM_DIGITAL_PINS) return;
+  if (pin >= NUM_DIGITAL_PINS)
+    return;
@@ -605 +618 @@ void ArduinoPins::fastWriteDigital(uint8_t pin, uint8_t value) {
-  volatile uint8_t *outPortAdr = portOutputRegister(port);
+  volatile uint8_t* outPortAdr = portOutputRegister(port);
@@ -607 +620 @@ void ArduinoPins::fastWriteDigital(uint8_t pin, uint8_t value) {
-  if (value) 
+  if (value)
@@ -619 +632,2 @@ bool ArduinoPins::fastReadDigital(uint8_t pin) {
-  if (pin >= NUM_DIGITAL_PINS) return false;
+  if (pin >= NUM_DIGITAL_PINS)
+    return false;
@@ -622 +636 @@ bool ArduinoPins::fastReadDigital(uint8_t pin) {
-  volatile uint8_t *inPortAdr = portInputRegister(port);
+  volatile uint8_t* inPortAdr = portInputRegister(port);
@@ -624 +638 @@ bool ArduinoPins::fastReadDigital(uint8_t pin) {
-  bool result = (*inPortAdr & mask) != 0;  
+  bool result = (*inPortAdr & mask) != 0;
diff --git a/IODevice.h b/IODevice.h
index 08b7370..1c24af7 100644
--- a/IODevice.h
+++ b/IODevice.h
@@ -4 +4 @@
- *  
+ *
@@ -25 +25 @@
-//#define DIAG_IO Y
+// #define DIAG_IO Y
@@ -28 +28 @@
-//#define DIAG_LOOPTIMES
+// #define DIAG_LOOPTIMES
@@ -30,3 +30,3 @@
-// Define symbol IO_SWITCH_OFF_SERVO to set the PCA9685 output to 0 when an 
-// animation has completed.  This switches off the servo motor, preventing 
-// the continuous buzz sometimes found on servos, and reducing the 
+// Define symbol IO_SWITCH_OFF_SERVO to set the PCA9685 output to 0 when an
+// animation has completed.  This switches off the servo motor, preventing
+// the continuous buzz sometimes found on servos, and reducing the
@@ -46 +46 @@ typedef uint16_t VPIN;
-#define VPIN_MAX 32767  
+#define VPIN_MAX 32767
@@ -49,2 +49,2 @@ typedef uint16_t VPIN;
-/* 
- * Callback support for state change notification from an IODevice subclass to a 
+/*
+ * Callback support for state change notification from an IODevice subclass to a
@@ -55 +55 @@ class IONotifyCallback {
-public: 
+ public:
@@ -57,3 +57,4 @@ public:
-  static void add(IONotifyCallbackFunction *function) {
-    IONotifyCallback *blk = new IONotifyCallback(function);
-    if (first) blk->next = first;
+  static void add(IONotifyCallbackFunction* function) {
+    IONotifyCallback* blk = new IONotifyCallback(function);
+    if (first)
+      blk->next = first;
@@ -63,2 +64 @@ public:
-    for (IONotifyCallback *blk = first; blk != NULL; blk = blk->next)
-      blk->invoke(vpin, value);
+    for (IONotifyCallback* blk = first; blk != NULL; blk = blk->next) blk->invoke(vpin, value);
@@ -69,5 +69,8 @@ public:
-private:
-  IONotifyCallback(IONotifyCallbackFunction *function) { invoke = function; };
-  IONotifyCallback *next = 0;
-  IONotifyCallbackFunction *invoke = 0;
-  static IONotifyCallback *first;
+
+ private:
+  IONotifyCallback(IONotifyCallbackFunction* function) {
+    invoke = function;
+  };
+  IONotifyCallback* next = 0;
+  IONotifyCallbackFunction* invoke = 0;
+  static IONotifyCallback* first;
@@ -78 +81 @@ private:
- * 
+ *
@@ -81 +84 @@ private:
- * 
+ *
@@ -85,2 +88 @@ class IODevice {
-public:
-
+ public:
@@ -125 +127,2 @@ public:
-  inline static bool configureServo(VPIN vpin, uint16_t activePosition, uint16_t inactivePosition, uint8_t profile=0, uint16_t duration=0, uint8_t initialState=0) {
+  inline static bool configureServo(VPIN vpin, uint16_t activePosition, uint16_t inactivePosition, uint8_t profile = 0, uint16_t duration = 0,
+                                    uint8_t initialState = 0) {
@@ -132 +135 @@ public:
-  static void writeRange(VPIN vpin, int value,int count);
+  static void writeRange(VPIN vpin, int value, int count);
@@ -135 +138 @@ public:
-  static void writeAnalogue(VPIN vpin, int value, uint8_t profile=0, uint16_t duration=0);
+  static void writeAnalogue(VPIN vpin, int value, uint8_t profile = 0, uint16_t duration = 0);
@@ -165 +168 @@ public:
-  // Without the shared interrupt, input states are scanned periodically to detect changes on 
+  // Without the shared interrupt, input states are scanned periodically to detect changes on
@@ -171,3 +174,2 @@ public:
-  // Method to check if pins will overlap before creating new device. 
-  static bool checkNoOverlap(VPIN firstPin, uint8_t nPins=1, 
-                  I2CAddress i2cAddress=0, bool silent=false);
+  // Method to check if pins will overlap before creating new device.
+  static bool checkNoOverlap(VPIN firstPin, uint8_t nPins = 1, I2CAddress i2cAddress = 0, bool silent = false);
@@ -176,2 +178,2 @@ public:
-  // pin range.  
-  IODevice *findDeviceFollowing(VPIN vpin);
+  // pin range.
+  IODevice* findDeviceFollowing(VPIN vpin);
@@ -181 +183,2 @@ public:
-    (void)vpin; (void)value;
+    (void)vpin;
+    (void)value;
@@ -183,4 +186,4 @@ public:
- 
- // Method to write new state (optionally implemented within device class)
- // This will, by default just write to one vpin and return whet to do next.
- // the real power comes where a single driver can update many vpins in one call.
+
+  // Method to write new state (optionally implemented within device class)
+  // This will, by default just write to one vpin and return whet to do next.
+  // the real power comes where a single driver can update many vpins in one call.
@@ -189,2 +192,2 @@ public:
-    _write(vpin,value); 
-    return vpin+1; // try next vpin 
+    _write(vpin, value);
+    return vpin + 1;  // try next vpin
@@ -194,2 +197,5 @@ public:
-  virtual void _writeAnalogue(VPIN vpin, int value, uint8_t param1=0, uint16_t param2=0) {
-    (void)vpin; (void)value; (void) param1; (void)param2;
+  virtual void _writeAnalogue(VPIN vpin, int value, uint8_t param1 = 0, uint16_t param2 = 0) {
+    (void)vpin;
+    (void)value;
+    (void)param1;
+    (void)param2;
@@ -197 +203 @@ public:
-  
+
@@ -202,3 +208,3 @@ public:
-    (void) count;
-    _writeAnalogue(vpin, value,  param1, param2);
-    return vpin+1; 
+    (void)count;
+    _writeAnalogue(vpin, value, param1, param2);
+    return vpin + 1;
@@ -208,2 +214,2 @@ public:
-  virtual int _read(VPIN vpin) { 
-    (void)vpin; 
+  virtual int _read(VPIN vpin) {
+    (void)vpin;
@@ -214,2 +220,2 @@ public:
-  virtual int _readAnalogue(VPIN vpin) { 
-    (void)vpin; 
+  virtual int _readAnalogue(VPIN vpin) {
+    (void)vpin;
@@ -219,2 +225 @@ public:
-protected:
-  
+ protected:
@@ -222 +227 @@ protected:
-  IODevice(VPIN firstVpin=0, int nPins=0) {
+  IODevice(VPIN firstVpin = 0, int nPins = 0) {
@@ -226 +231 @@ protected:
-    _I2CAddress=0;
+    _I2CAddress = 0;
@@ -230 +235,2 @@ protected:
-  virtual void _begin() {}
+  virtual void _begin() {
+  }
@@ -236,2 +242,5 @@ protected:
-  virtual bool _configure(VPIN vpin, ConfigTypeEnum configType, int paramCount, int params[]) { 
-    (void)vpin; (void)configType; (void)paramCount; (void)params; // Suppress compiler warning.
+  virtual bool _configure(VPIN vpin, ConfigTypeEnum configType, int paramCount, int params[]) {
+    (void)vpin;
+    (void)configType;
+    (void)paramCount;
+    (void)params;  // Suppress compiler warning.
@@ -241,2 +250,2 @@ protected:
-  virtual int _configureAnalogIn(VPIN vpin) { 
-    (void)vpin; 
+  virtual int _configureAnalogIn(VPIN vpin) {
+    (void)vpin;
@@ -248 +257 @@ protected:
-    delayUntil(currentMicros + 0x7fffffff); // Largest time in the future!  Effectively disable _loop calls.
+    delayUntil(currentMicros + 0x7fffffff);  // Largest time in the future!  Effectively disable _loop calls.
@@ -261 +270 @@ protected:
-  
+
@@ -272 +281 @@ protected:
-    
+
@@ -274 +283 @@ protected:
-  static void addDevice(IODevice *newDevice, IODevice *slaveDevice = NULL);
+  static void addDevice(IODevice* newDevice, IODevice* slaveDevice = NULL);
@@ -277 +286 @@ protected:
-  static IODevice *findDevice(VPIN vpin);
+  static IODevice* findDevice(VPIN vpin);
@@ -282,2 +291,2 @@ protected:
-private:
-  IODevice *_nextDevice = 0;
+ private:
+  IODevice* _nextDevice = 0;
@@ -285 +294 @@ private:
-  static IODevice *_firstDevice;
+  static IODevice* _firstDevice;
@@ -287 +296 @@ private:
-  static IODevice *_nextLoopDevice;
+  static IODevice* _nextLoopDevice;
@@ -290 +298,0 @@ private:
-
@@ -295 +303 @@ private:
- 
+
@@ -297 +305 @@ class PCA9685 : public IODevice {
-public:
+ public:
@@ -300,7 +308,7 @@ public:
-    Instant = 0,  // Moves immediately between positions (if duration not specified)
-    UseDuration = 0, // Use specified duration
-    Fast = 1,     // Takes around 500ms end-to-end
-    Medium = 2,   // 1 second end-to-end
-    Slow = 3,     // 2 seconds end-to-end
-    Bounce = 4,   // For semaphores/turnouts with a bit of bounce!!
-    NoPowerOff = 0x80, // Flag to be ORed in to suppress power off after move.
+    Instant = 0,        // Moves immediately between positions (if duration not specified)
+    UseDuration = 0,    // Use specified duration
+    Fast = 1,           // Takes around 500ms end-to-end
+    Medium = 2,         // 1 second end-to-end
+    Slow = 3,           // 2 seconds end-to-end
+    Bounce = 4,         // For semaphores/turnouts with a bit of bounce!!
+    NoPowerOff = 0x80,  // Flag to be ORed in to suppress power off after move.
@@ -309 +317 @@ public:
-private:
+ private:
@@ -318 +326 @@ private:
-  int _read(VPIN vpin) override; // returns the digital state or busy status of the device
+  int _read(VPIN vpin) override;  // returns the digital state or busy status of the device
@@ -323 +330,0 @@ private:
-  
@@ -326,2 +333,2 @@ private:
-    uint16_t activePosition : 12; // Config parameter
-    uint16_t inactivePosition : 12; // Config parameter
+    uint16_t activePosition : 12;    // Config parameter
+    uint16_t inactivePosition : 12;  // Config parameter
@@ -330,11 +337,11 @@ private:
-    uint16_t toPosition : 12; 
-    uint8_t profile;  // Config parameter
-    uint16_t stepNumber; // Index of current step (starting from 0)
-    uint16_t numSteps;  // Number of steps in animation, or 0 if none in progress.
-    uint8_t currentProfile; // profile being used for current animation.
-    uint16_t duration; // time (tenths of a second) for animation to complete.
-  }; // 14 bytes per element, i.e. per pin in use
-  
-  struct ServoData *_servoData [16];
-
-  static const uint8_t _catchupSteps = 5; // number of steps to wait before switching servo off
+    uint16_t toPosition : 12;
+    uint8_t profile;         // Config parameter
+    uint16_t stepNumber;     // Index of current step (starting from 0)
+    uint16_t numSteps;       // Number of steps in animation, or 0 if none in progress.
+    uint8_t currentProfile;  // profile being used for current animation.
+    uint16_t duration;       // time (tenths of a second) for animation to complete.
+  };  // 14 bytes per element, i.e. per pin in use
+
+  struct ServoData* _servoData[16];
+
+  static const uint8_t _catchupSteps = 5;  // number of steps to wait before switching servo off
@@ -343 +350 @@ private:
-  const unsigned int refreshInterval = 50; // refresh every 50ms
+  const unsigned int refreshInterval = 50;  // refresh every 50ms
@@ -348 +355 @@ private:
-  uint8_t prescaler; // clock prescaler for setting PWM frequency
+  uint8_t prescaler;  // clock prescaler for setting PWM frequency
@@ -355,3 +362,3 @@ private:
- 
-class DCCAccessoryDecoder: public IODevice {
-public:
+
+class DCCAccessoryDecoder : public IODevice {
+ public:
@@ -360 +367 @@ public:
-private:
+ private:
@@ -370 +376,0 @@ private:
-
@@ -372 +378 @@ private:
-/* 
+/*
@@ -375,3 +381,3 @@ private:
- 
-class ArduinoPins: public IODevice {
-public:
+
+class ArduinoPins : public IODevice {
+ public:
@@ -381 +387 @@ public:
-  
+
@@ -385 +391 @@ public:
-private:
+ private:
@@ -399,4 +405,3 @@ private:
-
-  uint8_t *_pinPullups;
-  uint8_t *_pinModes; // each bit is 1 for output, 0 for input
-  uint8_t *_pinInUse; 
+  uint8_t* _pinPullups;
+  uint8_t* _pinModes;  // each bit is 1 for output, 0 for input
+  uint8_t* _pinInUse;
@@ -410 +415 @@ private:
- 
+
@@ -412 +417 @@ class EXTurntable : public IODevice {
-public:
+ public:
@@ -417,10 +422,10 @@ public:
-    Turn = 0,             // Rotate turntable, maintain phase
-    Turn_PInvert = 1,     // Rotate turntable, invert phase
-    Home = 2,             // Initiate homing
-    Calibrate = 3,        // Initiate calibration sequence
-    LED_On = 4,           // Turn LED on
-    LED_Slow = 5,         // Set LED to a slow blink
-    LED_Fast = 6,         // Set LED to a fast blink
-    LED_Off = 7,          // Turn LED off
-    Acc_On = 8,           // Turn accessory pin on
-    Acc_Off = 9,          // Turn accessory pin off
+    Turn = 0,          // Rotate turntable, maintain phase
+    Turn_PInvert = 1,  // Rotate turntable, invert phase
+    Home = 2,          // Initiate homing
+    Calibrate = 3,     // Initiate calibration sequence
+    LED_On = 4,        // Turn LED on
+    LED_Slow = 5,      // Set LED to a slow blink
+    LED_Fast = 6,      // Set LED to a fast blink
+    LED_Off = 7,       // Turn LED off
+    Acc_On = 8,        // Turn accessory pin on
+    Acc_Off = 9,       // Turn accessory pin off
@@ -429 +434 @@ public:
-private:
+ private:
@@ -434 +439 @@ private:
-  void _broadcastStatus (VPIN vpin, uint8_t status, uint8_t activity);
+  void _broadcastStatus(VPIN vpin, uint8_t status, uint8_t activity);
@@ -445 +449,0 @@ private:
-
@@ -448 +452 @@ private:
-// invoked, and then create an instance of UserAddin.  
+// invoked, and then create an instance of UserAddin.
@@ -451 +455 @@ private:
-// 
+//
@@ -469 +473 @@ class UserAddin : public IODevice {
-private:
+ private:
@@ -471,2 +475,2 @@ private:
-  int _delay; // milliseconds
-public:
+  int _delay;  // milliseconds
+ public:
@@ -474,3 +478,3 @@ public:
-    _invokeUserFunction = func; 
-    _delay = delay; 
-    addDevice(this); 
+    _invokeUserFunction = func;
+    _delay = delay;
+    addDevice(this);
@@ -482,2 +486,5 @@ public:
-protected:
-  void _begin() { _display(); }
+
+ protected:
+  void _begin() {
+    _display();
+  }
@@ -495 +502 @@ protected:
-// 
+//
@@ -502 +509 @@ protected:
-// 
+//
@@ -504 +511 @@ protected:
-// 
+//
@@ -506 +513 @@ protected:
-// 
+//
@@ -508 +515 @@ protected:
-//  
+//
@@ -510 +517 @@ protected:
-// 
+//
@@ -512 +519 @@ protected:
-// 
+//
@@ -516,2 +523,2 @@ class FLAGS : IODevice {
-private:
-  uint8_t *_states = NULL;
+ private:
+  uint8_t* _states = NULL;
@@ -519 +526 @@ private:
-public:
+ public:
@@ -522 +529 @@ public:
-        new FLAGS(firstVpin, nPins);
+      new FLAGS(firstVpin, nPins);
@@ -525 +532 @@ public:
-protected:
+ protected:
@@ -527 +534 @@ protected:
-  FLAGS (VPIN firstVpin, int nPins) {
+  FLAGS(VPIN firstVpin, int nPins) {
@@ -530 +537 @@ protected:
-    _states = (uint8_t *)calloc(1, (_nPins+7)/8);
+    _states = (uint8_t*)calloc(1, (_nPins + 7) / 8);
@@ -541 +548,2 @@ protected:
-    if (pin >= _nPins || pin < 0) return 0;
+    if (pin >= _nPins || pin < 0)
+      return 0;
@@ -543 +551 @@ protected:
-    return (_states[pin>>3] & mask) ? 1 : 0;
+    return (_states[pin >> 3] & mask) ? 1 : 0;
@@ -548 +556,2 @@ protected:
-    if (pin >= _nPins || pin < 0) return;
+    if (pin >= _nPins || pin < 0)
+      return;
@@ -550,2 +559,2 @@ protected:
-    if (value) 
-      _states[pin>>3] |= mask;
+    if (value)
+      _states[pin >> 3] |= mask;
@@ -553 +562 @@ protected:
-      _states[pin>>3] &= ~mask;
+      _states[pin >> 3] &= ~mask;
@@ -557,2 +566 @@ protected:
-    DIAG(F("FLAGS configured on VPINs %u-%u"),
-      _firstVpin, _firstVpin+_nPins-1);
+    DIAG(F("FLAGS configured on VPINs %u-%u"), _firstVpin, _firstVpin + _nPins - 1);
@@ -560 +567,0 @@ protected:
-
@@ -577 +584 @@ protected:
-#endif // iodevice_h
+#endif  // iodevice_h
diff --git a/IO_AnalogueInputs.h b/IO_AnalogueInputs.h
index e9d25a7..aa9a41a 100644
--- a/IO_AnalogueInputs.h
+++ b/IO_AnalogueInputs.h
@@ -3 +3 @@
- *  
+ *
@@ -25 +25 @@
-//#define IO_ANALOGUE_SLOW
+// #define IO_ANALOGUE_SLOW
@@ -34,2 +34,2 @@
- * 
- * ADS1113 and ADS1114 are restricted to 1 input.  ADS1115 has a multiplexer which allows 
+ *
+ * ADS1113 and ADS1114 are restricted to 1 input.  ADS1115 has a multiplexer which allows
@@ -37 +37 @@
- * 
+ *
@@ -42 +42 @@
- * 
+ *
@@ -48 +48 @@
- * The gain means that the maximum input voltage of 5V (when Vss=5V) gives a reading 
+ * The gain means that the maximum input voltage of 5V (when Vss=5V) gives a reading
@@ -50 +50 @@
- * 
+ *
@@ -56 +56 @@
- * 
+ *
@@ -60,2 +60,2 @@
-class ADS111x: public IODevice { 
-public:
+class ADS111x : public IODevice {
+ public:
@@ -63 +63,2 @@ public:
-    if (checkNoOverlap(firstVpin,nPins,i2cAddress)) new ADS111x(firstVpin, nPins, i2cAddress);
+    if (checkNoOverlap(firstVpin, nPins, i2cAddress))
+      new ADS111x(firstVpin, nPins, i2cAddress);
@@ -65 +66,2 @@ public:
-private:
+
+ private:
@@ -71,2 +73 @@ private:
-    for (int8_t i=0; i<_nPins; i++)
-      _value[i] = -1;
+    for (int8_t i = 0; i < _nPins; i++) _value[i] = -1;
@@ -93 +93,0 @@ private:
-
@@ -96 +96,2 @@ private:
-    if (status == I2C_STATUS_PENDING) return;  // Busy, so don't do anything.
+    if (status == I2C_STATUS_PENDING)
+      return;  // Busy, so don't do anything.
@@ -102,3 +103,3 @@ private:
-          _outBuffer[0] = 0x01; // Config register address
-          _outBuffer[1] = 0xC0 + (_currentPin << 4); // Trigger single-shot, channel n
-          _outBuffer[2] = 0xA3;           // 250 samples/sec, comparator off
+          _outBuffer[0] = 0x01;                       // Config register address
+          _outBuffer[1] = 0xC0 + (_currentPin << 4);  // Trigger single-shot, channel n
+          _outBuffer[2] = 0xA3;                       // 250 samples/sec, comparator off
@@ -114,2 +115,2 @@ private:
-          _outBuffer[0] = 0x00;  // Conversion register address
-          I2CManager.read(_I2CAddress, _inBuffer, 2, _outBuffer, 1, &_i2crb); // Read register
+          _outBuffer[0] = 0x00;                                                // Conversion register address
+          I2CManager.read(_I2CAddress, _inBuffer, 2, _outBuffer, 1, &_i2crb);  // Read register
@@ -121 +122 @@ private:
-          #ifdef IO_ANALOGUE_SLOW
+#ifdef IO_ANALOGUE_SLOW
@@ -123 +124 @@ private:
-          #endif
+#endif
@@ -126 +127,2 @@ private:
-          if (++_currentPin >= _nPins) _currentPin = 0;
+          if (++_currentPin >= _nPins)
+            _currentPin = 0;
@@ -129 +131 @@ private:
-        
+
@@ -133 +135 @@ private:
-    } else { // error status
+    } else {  // error status
@@ -143 +145 @@ private:
-  
+
@@ -145,2 +147,2 @@ private:
-    DIAG(F("ADS111x I2C:%s Configured on Vpins:%u-%u %S"), _I2CAddress.toString(), _firstVpin, _firstVpin+_nPins-1,
-      _deviceState == DEVSTATE_FAILED ? F("OFFLINE") : F(""));
+    DIAG(F("ADS111x I2C:%s Configured on Vpins:%u-%u %S"), _I2CAddress.toString(), _firstVpin, _firstVpin + _nPins - 1,
+         _deviceState == DEVSTATE_FAILED ? F("OFFLINE") : F(""));
@@ -149,3 +151,3 @@ private:
-  // ADC conversion rate is 250SPS, or 4ms per conversion.  Set the period between updates to 10ms. 
-  // This is enough to allow the conversion to reliably complete in time.
-  #ifndef IO_ANALOGUE_SLOW
+// ADC conversion rate is 250SPS, or 4ms per conversion.  Set the period between updates to 10ms.
+// This is enough to allow the conversion to reliably complete in time.
+#ifndef IO_ANALOGUE_SLOW
@@ -153 +155 @@ private:
-  #else
+#else
@@ -155 +157 @@ private:
-  #endif
+#endif
@@ -158 +160 @@ private:
-    STATE_STARTREAD, 
+    STATE_STARTREAD,
@@ -169 +171 @@ private:
-#endif // io_analogueinputs_h
+#endif  // io_analogueinputs_h
diff --git a/IO_DCCAccessory.cpp b/IO_DCCAccessory.cpp
index e138da5..88114d9 100644
--- a/IO_DCCAccessory.cpp
+++ b/IO_DCCAccessory.cpp
@@ -3 +3 @@
- *  
+ *
@@ -25 +25 @@
-#define PACKEDADDRESS(addr, subaddr) (((addr) << 2)  + (subaddr))
+#define PACKEDADDRESS(addr, subaddr) (((addr) << 2) + (subaddr))
@@ -30 +30,2 @@ void DCCAccessoryDecoder::create(VPIN firstVpin, int nPins, int DCCAddress, int
-  if (checkNoOverlap(firstVpin,nPins)) new DCCAccessoryDecoder(firstVpin, nPins, DCCAddress, DCCSubaddress);
+  if (checkNoOverlap(firstVpin, nPins))
+    new DCCAccessoryDecoder(firstVpin, nPins, DCCAddress, DCCSubaddress);
@@ -35 +36 @@ DCCAccessoryDecoder::DCCAccessoryDecoder(VPIN vpin, int nPins, int DCCAddress, i
-   _firstVpin = vpin;
+  _firstVpin = vpin;
@@ -65,2 +66,2 @@ void DCCAccessoryDecoder::_display() {
-  DIAG(F("DCCAccessoryDecoder Configured on Vpins:%u-%u Addresses %d/%d-%d/%d)"), _firstVpin, _firstVpin+_nPins-1,
-      ADDRESS(_packedAddress), SUBADDRESS(_packedAddress), ADDRESS(endAddress), SUBADDRESS(endAddress));
+  DIAG(F("DCCAccessoryDecoder Configured on Vpins:%u-%u Addresses %d/%d-%d/%d)"), _firstVpin, _firstVpin + _nPins - 1, ADDRESS(_packedAddress),
+       SUBADDRESS(_packedAddress), ADDRESS(endAddress), SUBADDRESS(endAddress));
diff --git a/IO_DFPlayer.h b/IO_DFPlayer.h
index edd416d..0eecd8d 100644
--- a/IO_DFPlayer.h
+++ b/IO_DFPlayer.h
@@ -3 +3 @@
- *  
+ *
@@ -23,2 +23,2 @@
- * 
- * This driver allows the device to be controlled through IODevice::write() and 
+ *
+ * This driver allows the device to be controlled through IODevice::write() and
@@ -26 +26 @@
- * 
+ *
@@ -28 +28 @@
- * 
+ *
@@ -30 +30 @@
- * 
+ *
@@ -34 +34 @@
- * 
+ *
@@ -40 +40 @@
- * 
+ *
@@ -49 +49 @@
- * 
+ *
@@ -58,2 +58,2 @@
- * 
- * NB The DFPlayer's serial lines are not 5V safe, so connecting the Arduino TX directly 
+ *
+ * NB The DFPlayer's serial lines are not 5V safe, so connecting the Arduino TX directly
@@ -62,3 +62,3 @@
- * 
- * Files on the SD card are numbered according to their order in the directory on the 
- * card (as listed by the DIR command in Windows).  This may not match the order of the files 
+ *
+ * Files on the SD card are numbered according to their order in the directory on the
+ * card (as listed by the DIR command in Windows).  This may not match the order of the files
@@ -67 +67 @@
- * 
+ *
@@ -79,3 +79,3 @@ class DFPlayer : public IODevice {
-private: 
-  const uint8_t MAXVOLUME=30;
-  HardwareSerial *_serial;
+ private:
+  const uint8_t MAXVOLUME = 30;
+  HardwareSerial* _serial;
@@ -84 +84 @@ private:
-  unsigned long _commandSendTime; // Time (us) that last transmit took place.
+  unsigned long _commandSendTime;  // Time (us) that last transmit took place.
@@ -91,5 +91,5 @@ private:
-  
-public:
- 
-  static void create(VPIN firstVpin, int nPins, HardwareSerial &serial) {
-    if (checkNoOverlap(firstVpin,nPins)) new DFPlayer(firstVpin, nPins, serial);
+
+ public:
+  static void create(VPIN firstVpin, int nPins, HardwareSerial& serial) {
+    if (checkNoOverlap(firstVpin, nPins))
+      new DFPlayer(firstVpin, nPins, serial);
@@ -98 +98 @@ public:
-protected:
+ protected:
@@ -100,4 +100 @@ protected:
-  DFPlayer(VPIN firstVpin, int nPins, HardwareSerial &serial) :
-    IODevice(firstVpin, nPins),
-    _serial(&serial) 
-  {
+  DFPlayer(VPIN firstVpin, int nPins, HardwareSerial& serial) : IODevice(firstVpin, nPins), _serial(&serial) {
@@ -108 +105 @@ protected:
-    _serial->begin(9600, SERIAL_8N1); // 9600baud, no parity, 1 stop bit
+    _serial->begin(9600, SERIAL_8N1);  // 9600baud, no parity, 1 stop bit
@@ -114 +111 @@ protected:
-    sendPacket(0x42); 
+    sendPacket(0x42);
@@ -120 +116,0 @@ protected:
-
@@ -135 +131 @@ protected:
-    delayUntil(currentMicros + 10000); // Only enter every 10ms
+    delayUntil(currentMicros + 10000);  // Only enter every 10ms
@@ -146 +142,2 @@ protected:
-          if (c == 0x7E) ok = true;
+          if (c == 0x7E)
+            ok = true;
@@ -149 +146,2 @@ protected:
-          if (c == 0xFF) ok = true;
+          if (c == 0xFF)
+            ok = true;
@@ -152 +150,2 @@ protected:
-          if (c== 0x06) ok = true;
+          if (c == 0x06)
+            ok = true;
@@ -155 +154 @@ protected:
-          _recvCMD = c; // CMD byte
+          _recvCMD = c;  // CMD byte
@@ -164 +163 @@ protected:
-              if (_deviceState==DEVSTATE_INITIALISING) {
+              if (_deviceState == DEVSTATE_INITIALISING) {
@@ -166 +165 @@ protected:
-                #ifdef DIAG_IO
+#ifdef DIAG_IO
@@ -168 +167 @@ protected:
-                #endif
+#endif
@@ -175 +174 @@ protected:
-                #ifdef DIAG_IO
+#ifdef DIAG_IO
@@ -177 +176 @@ protected:
-                #endif
+#endif
@@ -189 +188,4 @@ protected:
-        case 4: case 5: case 7: case 8: 
+        case 4:
+        case 5:
+        case 7:
+        case 8:
@@ -193 +195 @@ protected:
-          if (c==0xef) {
+          if (c == 0xef) {
@@ -209,2 +211 @@ protected:
-
-    // When two commands are sent in quick succession, the device will often fail to 
+    // When two commands are sent in quick succession, the device will often fail to
@@ -233 +234 @@ protected:
-        sendPacket(0x42); 
+        sendPacket(0x42);
@@ -245 +246,2 @@ protected:
-    if (_deviceState == DEVSTATE_FAILED) return;
+    if (_deviceState == DEVSTATE_FAILED)
+      return;
@@ -248,5 +250,5 @@ protected:
-      // Value 1, start playing
-      #ifdef DIAG_IO
-      DIAG(F("DFPlayer: Play %d"), pin+1);
-      #endif
-      _requestedSong = pin+1;
+// Value 1, start playing
+#ifdef DIAG_IO
+      DIAG(F("DFPlayer: Play %d"), pin + 1);
+#endif
+      _requestedSong = pin + 1;
@@ -255,2 +257,2 @@ protected:
-      // Value 0, stop playing
-      #ifdef DIAG_IO
+// Value 0, stop playing
+#ifdef DIAG_IO
@@ -258 +260 @@ protected:
-      #endif
+#endif
@@ -266 +268 @@ protected:
-  // If value is zero, the player stops playing.  
+  // If value is zero, the player stops playing.
@@ -269,2 +271,3 @@ protected:
-  void _writeAnalogue(VPIN vpin, int value, uint8_t volume=0, uint16_t=0) override { 
-    if (_deviceState == DEVSTATE_FAILED) return;
+  void _writeAnalogue(VPIN vpin, int value, uint8_t volume = 0, uint16_t = 0) override {
+    if (_deviceState == DEVSTATE_FAILED)
+      return;
@@ -272,2 +275,2 @@ protected:
- 
-    #ifdef DIAG_IO
+
+#ifdef DIAG_IO
@@ -275 +278 @@ protected:
-    #endif
+#endif
@@ -278 +281,2 @@ protected:
-    if (volume > MAXVOLUME) volume = MAXVOLUME;
+    if (volume > MAXVOLUME)
+      volume = MAXVOLUME;
@@ -281 +285 @@ protected:
-      // Play track 
+      // Play track
@@ -288 +292 @@ protected:
-        _requestedSong = 0; // stop playing
+        _requestedSong = 0;  // stop playing
@@ -293 +297 @@ protected:
-      _requestedVolumeLevel = value;  
+      _requestedVolumeLevel = value;
@@ -299 +303,2 @@ protected:
-    if (_deviceState == DEVSTATE_FAILED) return false;
+    if (_deviceState == DEVSTATE_FAILED)
+      return false;
@@ -304,2 +309 @@ protected:
-    DIAG(F("DFPlayer Configured on Vpins:%u-%u %S"), _firstVpin, _firstVpin+_nPins-1,
-      (_deviceState==DEVSTATE_FAILED) ? F("OFFLINE") : F(""));
+    DIAG(F("DFPlayer Configured on Vpins:%u-%u %S"), _firstVpin, _firstVpin + _nPins - 1, (_deviceState == DEVSTATE_FAILED) ? F("OFFLINE") : F(""));
@@ -307,2 +311,2 @@ protected:
-  
-private:
+
+ private:
@@ -319,12 +323,2 @@ private:
-  void sendPacket(uint8_t command, uint16_t arg = 0)
-  {
-    uint8_t out[] = { 0x7E,
-        0xFF,
-        06,
-        command,
-        00,
-        static_cast<uint8_t>(arg >> 8),
-        static_cast<uint8_t>(arg & 0x00ff),
-        00,
-        00,
-        0xEF };
+  void sendPacket(uint8_t command, uint16_t arg = 0) {
+    uint8_t out[] = {0x7E, 0xFF, 06, command, 00, static_cast<uint8_t>(arg >> 8), static_cast<uint8_t>(arg & 0x00ff), 00, 00, 0xEF};
@@ -340,2 +334 @@ private:
-  uint16_t calcChecksum(uint8_t* packet)
-  {
+  uint16_t calcChecksum(uint8_t* packet) {
@@ -343,2 +336 @@ private:
-    for (int i = 1; i < 7; i++)
-    {
+    for (int i = 1; i < 7; i++) {
@@ -350,2 +342 @@ private:
-  void setChecksum(uint8_t* out)
-  {
+  void setChecksum(uint8_t* out) {
@@ -359 +350 @@ private:
-#endif // IO_DFPlayer_h
+#endif  // IO_DFPlayer_h
diff --git a/IO_EXFastclock.h b/IO_EXFastclock.h
index 11aaea7..8105c41 100644
--- a/IO_EXFastclock.h
+++ b/IO_EXFastclock.h
@@ -18 +18 @@
-*/
+ */
@@ -21,6 +21,6 @@
-* The IO_EXFastclock device driver is used to interface the standalone fast clock and receive time data.
-*
-* The EX-fastClock code lives in a separate repo (https://github.com/DCC-EX/EX-Fastclock) and contains the clock logic.
-*
-*
-*/
+ * The IO_EXFastclock device driver is used to interface the standalone fast clock and receive time data.
+ *
+ * The EX-fastClock code lives in a separate repo (https://github.com/DCC-EX/EX-Fastclock) and contains the clock logic.
+ *
+ *
+ */
@@ -31 +30,0 @@
-
@@ -41 +40 @@ class EXFastClock : public IODevice {
-public:
+ public:
@@ -43 +42 @@ public:
-    EXFastClock(I2CAddress i2cAddress){
+  EXFastClock(I2CAddress i2cAddress) {
@@ -48,11 +47,10 @@ public:
-static void create(I2CAddress i2cAddress) {
-
-  DIAG(F("Checking for Clock"));
-  // Start by assuming we will find the clock
-  // Check if specified I2C address is responding (blocking operation)
-  // Returns I2C_STATUS_OK (0) if OK, or error code.
-  I2CManager.begin();
-  uint8_t _checkforclock = I2CManager.checkAddress(i2cAddress);
-  DIAG(F("Clock check result - %d"), _checkforclock);
-  // XXXX change thistosave2 bytes
-  if (_checkforclock == 0) {
+  static void create(I2CAddress i2cAddress) {
+    DIAG(F("Checking for Clock"));
+    // Start by assuming we will find the clock
+    // Check if specified I2C address is responding (blocking operation)
+    // Returns I2C_STATUS_OK (0) if OK, or error code.
+    I2CManager.begin();
+    uint8_t _checkforclock = I2CManager.checkAddress(i2cAddress);
+    DIAG(F("Clock check result - %d"), _checkforclock);
+    // XXXX change thistosave2 bytes
+    if (_checkforclock == 0) {
@@ -60,4 +58,3 @@ static void create(I2CAddress i2cAddress) {
-      //DIAG(F("I2C Fast Clock found at %s"), i2cAddress.toString());
-      new EXFastClock(i2cAddress); 
-    }
-    else {
+      // DIAG(F("I2C Fast Clock found at %s"), i2cAddress.toString());
+      new EXFastClock(i2cAddress);
+    } else {
@@ -65,2 +62,2 @@ static void create(I2CAddress i2cAddress) {
-      //DIAG(F("No Fast Clock found"));
-      LCD(6,F("CLOCK NOT FOUND"));
+      // DIAG(F("No Fast Clock found"));
+      LCD(6, F("CLOCK NOT FOUND"));
@@ -68 +64,0 @@ static void create(I2CAddress i2cAddress) {
-    
@@ -70,3 +65,0 @@ static void create(I2CAddress i2cAddress) {
-    
-private:
-  
@@ -74,8 +67,8 @@ private:
-// Initialisation of Fastclock
-void _begin() override {
-  
-  if (FAST_CLOCK_EXISTS == true) {
-    I2CManager.begin();
-    if (I2CManager.exists(_I2CAddress)) {
-      _deviceState = DEVSTATE_NORMAL;
-      #ifdef DIAG_IO
+ private:
+  // Initialisation of Fastclock
+  void _begin() override {
+    if (FAST_CLOCK_EXISTS == true) {
+      I2CManager.begin();
+      if (I2CManager.exists(_I2CAddress)) {
+        _deviceState = DEVSTATE_NORMAL;
+#ifdef DIAG_IO
@@ -83,5 +76,6 @@ void _begin() override {
-      #endif
-    } else {
-    _deviceState = DEVSTATE_FAILED;
-    //LCD(6,F("CLOCK NOT FOUND")); 
-    DIAG(F("Fast Clock Not Found at address %s"), _I2CAddress.toString());
+#endif
+      } else {
+        _deviceState = DEVSTATE_FAILED;
+        // LCD(6,F("CLOCK NOT FOUND"));
+        DIAG(F("Fast Clock Not Found at address %s"), _I2CAddress.toString());
+      }
@@ -90 +83,0 @@ void _begin() override {
-}
@@ -92 +85 @@ void _begin() override {
-// Processing loop to obtain clock time
+  // Processing loop to obtain clock time
@@ -94,3 +87,2 @@ void _begin() override {
-void _loop(unsigned long currentMicros) override{ 
-  
-  if (FAST_CLOCK_EXISTS==true) {
+  void _loop(unsigned long currentMicros) override {
+    if (FAST_CLOCK_EXISTS == true) {
@@ -98,8 +90,11 @@ void _loop(unsigned long currentMicros) override{
-      byte a,b;
-      #ifdef EXRAIL_ACTIVE
-        I2CManager.read(_I2CAddress, readBuffer, 3);
-        // XXXX change this to save a few bytes
-        a = readBuffer[0];
-        b = readBuffer[1];
-        //_clocktime = (a << 8) + b;
-        //_clockrate = readBuffer[2];
+      byte a, b;
+#ifdef EXRAIL_ACTIVE
+      I2CManager.read(_I2CAddress, readBuffer, 3);
+      // XXXX change this to save a few bytes
+      a = readBuffer[0];
+      b = readBuffer[1];
+      //_clocktime = (a << 8) + b;
+      //_clockrate = readBuffer[2];
+
+      CommandDistributor::setClockTime(((a << 8) + b), readBuffer[2], 1);
+      // setClockTime(int16_t clocktime, int8_t clockrate, byte opt);
@@ -107,9 +102,6 @@ void _loop(unsigned long currentMicros) override{
-        CommandDistributor::setClockTime(((a << 8) + b), readBuffer[2], 1);
-        //setClockTime(int16_t clocktime, int8_t clockrate, byte opt);
-        
-        // As the minimum clock increment is 2 seconds delay a bit - say 1 sec.
-        // Clock interval is 60/ clockspeed i.e 60/b seconds
-        delayUntil(currentMicros + ((60/b) * 1000000));  
-     
-      #endif
-    
+      // As the minimum clock increment is 2 seconds delay a bit - say 1 sec.
+      // Clock interval is 60/ clockspeed i.e 60/b seconds
+      delayUntil(currentMicros + ((60 / b) * 1000000));
+
+#endif
+    }
@@ -117 +108,0 @@ void _loop(unsigned long currentMicros) override{
-}
@@ -121 +112 @@ void _loop(unsigned long currentMicros) override{
-    DIAG(F("FastCLock on I2C:%s - %S"), _I2CAddress.toString(),  (_deviceState==DEVSTATE_FAILED) ? F("OFFLINE") : F(""));
+    DIAG(F("FastCLock on I2C:%s - %S"), _I2CAddress.toString(), (_deviceState == DEVSTATE_FAILED) ? F("OFFLINE") : F(""));
@@ -123 +113,0 @@ void _loop(unsigned long currentMicros) override{
-  
diff --git a/IO_EXIOExpander.h b/IO_EXIOExpander.h
index 2e83eb7..36f7ca9 100644
--- a/IO_EXIOExpander.h
+++ b/IO_EXIOExpander.h
@@ -19 +19 @@
-*/
+ */
@@ -22,18 +22,18 @@
-* The IO_EXIOExpander.h device driver integrates with one or more EX-IOExpander devices.
-* This device driver will configure the device on startup, along with
-* interacting with the device for all input/output duties.
-*
-* To create EX-IOExpander devices, these are defined in myAutomation.h:
-* (Note the device driver is included by default)
-*
-* HAL(EXIOExpander,800,18,0x65)
-* 
-* All pins on an EX-IOExpander device are allocated according to the pin map for the specific
-* device in use. There is no way for the device driver to sanity check pins are used for the
-* correct purpose, however the EX-IOExpander device's pin map will prevent pins being used
-* incorrectly (eg. A6/7 on Nano cannot be used for digital input/output).
-*
-* The total number of pins cannot exceed 256 because of the communications packet format.
-* The number of analogue inputs cannot exceed 16 because of a limit on the maximum
-* I2C packet size of 32 bytes (in the Wire library).
-*/
+ * The IO_EXIOExpander.h device driver integrates with one or more EX-IOExpander devices.
+ * This device driver will configure the device on startup, along with
+ * interacting with the device for all input/output duties.
+ *
+ * To create EX-IOExpander devices, these are defined in myAutomation.h:
+ * (Note the device driver is included by default)
+ *
+ * HAL(EXIOExpander,800,18,0x65)
+ *
+ * All pins on an EX-IOExpander device are allocated according to the pin map for the specific
+ * device in use. There is no way for the device driver to sanity check pins are used for the
+ * correct purpose, however the EX-IOExpander device's pin map will prevent pins being used
+ * incorrectly (eg. A6/7 on Nano cannot be used for digital input/output).
+ *
+ * The total number of pins cannot exceed 256 because of the communications packet format.
+ * The number of analogue inputs cannot exceed 16 because of a limit on the maximum
+ * I2C packet size of 32 bytes (in the Wire library).
+ */
@@ -54,2 +54 @@ class EXIOExpander : public IODevice {
-public:
-
+ public:
@@ -57,7 +56,7 @@ public:
-    Instant = 0,  // Moves immediately between positions (if duration not specified)
-    UseDuration = 0, // Use specified duration
-    Fast = 1,     // Takes around 500ms end-to-end
-    Medium = 2,   // 1 second end-to-end
-    Slow = 3,     // 2 seconds end-to-end
-    Bounce = 4,   // For semaphores/turnouts with a bit of bounce!!
-    NoPowerOff = 0x80, // Flag to be ORed in to suppress power off after move.
+    Instant = 0,        // Moves immediately between positions (if duration not specified)
+    UseDuration = 0,    // Use specified duration
+    Fast = 1,           // Takes around 500ms end-to-end
+    Medium = 2,         // 1 second end-to-end
+    Slow = 3,           // 2 seconds end-to-end
+    Bounce = 4,         // For semaphores/turnouts with a bit of bounce!!
+    NoPowerOff = 0x80,  // Flag to be ORed in to suppress power off after move.
@@ -67 +66,2 @@ public:
-    if (checkNoOverlap(vpin, nPins, i2cAddress)) new EXIOExpander(vpin, nPins, i2cAddress);
+    if (checkNoOverlap(vpin, nPins, i2cAddress))
+      new EXIOExpander(vpin, nPins, i2cAddress);
@@ -70 +70 @@ public:
-private:
+ private:
@@ -75 +75,2 @@ private:
-    if (nPins > 256) nPins = 256;
+    if (nPins > 256)
+      nPins = 256;
@@ -99 +100 @@ private:
-          if (_numDigitalPins>0) {
+          if (_numDigitalPins > 0) {
@@ -103,2 +104,3 @@ private:
-              if (_digitalPinBytes > 0) free(_digitalInputStates);
-              if ((_digitalInputStates = (byte*) calloc(digitalBytesNeeded, 1)) != NULL) {
+              if (_digitalPinBytes > 0)
+                free(_digitalInputStates);
+              if ((_digitalInputStates = (byte*)calloc(digitalBytesNeeded, 1)) != NULL) {
@@ -114,2 +116,2 @@ private:
-          
-          if (_numAnaloguePins>0) {
+
+          if (_numAnaloguePins > 0) {
@@ -124,13 +126,11 @@ private:
-              _analogueInputStates = (uint8_t*) calloc(analogueBytesNeeded, 1);
-              _analogueInputBuffer = (uint8_t*) calloc(analogueBytesNeeded, 1);
-              _analoguePinMap = (uint8_t*) calloc(_numAnaloguePins, 1);
-	      if (_analogueInputStates  != NULL &&
-		  _analogueInputBuffer != NULL &&
-		  _analoguePinMap != NULL) {
-		_analoguePinBytes = analogueBytesNeeded;
-	      } else {
-		DIAG(F("EX-IOExpander I2C:%s ERROR alloc analog pin bytes"), _I2CAddress.toString());
-		_deviceState = DEVSTATE_FAILED;
-		_analoguePinBytes = 0;
-		return;
-	      }
+              _analogueInputStates = (uint8_t*)calloc(analogueBytesNeeded, 1);
+              _analogueInputBuffer = (uint8_t*)calloc(analogueBytesNeeded, 1);
+              _analoguePinMap = (uint8_t*)calloc(_numAnaloguePins, 1);
+              if (_analogueInputStates != NULL && _analogueInputBuffer != NULL && _analoguePinMap != NULL) {
+                _analoguePinBytes = analogueBytesNeeded;
+              } else {
+                DIAG(F("EX-IOExpander I2C:%s ERROR alloc analog pin bytes"), _I2CAddress.toString());
+                _deviceState = DEVSTATE_FAILED;
+                _analoguePinBytes = 0;
+                return;
+              }
@@ -144 +144 @@ private:
-      } 
+      }
@@ -146 +146 @@ private:
-      if (status == I2C_STATUS_OK && _numAnaloguePins>0) {
+      if (status == I2C_STATUS_OK && _numAnaloguePins > 0) {
@@ -159,2 +159 @@ private:
-        DIAG(F("EX-IOExpander device found, I2C:%s, Version v%d.%d.%d"),
-            _I2CAddress.toString(), _majorVer, _minorVer, _patchVer);
+        DIAG(F("EX-IOExpander device found, I2C:%s, Version v%d.%d.%d"), _I2CAddress.toString(), _majorVer, _minorVer, _patchVer);
@@ -179 +178,2 @@ private:
-    if (paramCount != 1) return false;
+    if (paramCount != 1)
+      return false;
@@ -185,2 +185 @@ private:
-      uint8_t status = I2CManager.read(_I2CAddress, responseBuffer, sizeof(responseBuffer),
-                                outBuffer, sizeof(outBuffer));
+      uint8_t status = I2CManager.read(_I2CAddress, responseBuffer, sizeof(responseBuffer), outBuffer, sizeof(outBuffer));
@@ -211,2 +210 @@ private:
-    uint8_t status = I2CManager.read(_I2CAddress, responseBuffer, sizeof(responseBuffer),
-                                  commandBuffer, sizeof(commandBuffer));
+    uint8_t status = I2CManager.read(_I2CAddress, responseBuffer, sizeof(responseBuffer), commandBuffer, sizeof(commandBuffer));
@@ -227 +225,2 @@ private:
-    if (_deviceState == DEVSTATE_FAILED) return;    // If device failed, return
+    if (_deviceState == DEVSTATE_FAILED)
+      return;  // If device failed, return
@@ -233 +232,2 @@ private:
-      if (_i2crb.isBusy()) return;                // If I2C operation still in progress, return
+      if (_i2crb.isBusy())
+        return;  // If I2C operation still in progress, return
@@ -236 +236 @@ private:
-      if (status == I2C_STATUS_OK) {             // If device request ok, read input data
+      if (status == I2C_STATUS_OK) {  // If device request ok, read input data
@@ -241 +241 @@ private:
-          // Here we need to copy the values from input buffer to the analogue value array.  We need to 
+          // Here we need to copy the values from input buffer to the analogue value array.  We need to
@@ -244 +244 @@ private:
-          memcpy(_analogueInputStates, _analogueInputBuffer, _analoguePinBytes); // Copy I2C input buffer to states
+          memcpy(_analogueInputStates, _analogueInputBuffer, _analoguePinBytes);  // Copy I2C input buffer to states
@@ -247,2 +247,2 @@ private:
-          // Read of digital states was in progress, so process received values 
-          // The received digital states are placed directly into the digital buffer on receipt, 
+          // Read of digital states was in progress, so process received values
+          // The received digital states are placed directly into the digital buffer on receipt,
@@ -253 +253 @@ private:
-        reportError(status, false);   // report eror but don't go offline.
+        reportError(status, false);  // report eror but don't go offline.
@@ -260 +260 @@ private:
-      if (_numDigitalPins>0 && currentMicros - _lastDigitalRead > _digitalRefresh) { // Delay for digital read refresh
+      if (_numDigitalPins > 0 && currentMicros - _lastDigitalRead > _digitalRefresh) {  // Delay for digital read refresh
@@ -264,2 +264,2 @@ private:
-        I2CManager.read(_I2CAddress, _digitalInputStates, (_numDigitalPins+7)/8, _readCommandBuffer, 1, &_i2crb);
-                                                                // non-blocking read
+        I2CManager.read(_I2CAddress, _digitalInputStates, (_numDigitalPins + 7) / 8, _readCommandBuffer, 1, &_i2crb);
+        // non-blocking read
@@ -268 +268 @@ private:
-      } else if (_numAnaloguePins>0 && currentMicros - _lastAnalogueRead > _analogueRefresh) { // Delay for analogue read refresh
+      } else if (_numAnaloguePins > 0 && currentMicros - _lastAnalogueRead > _analogueRefresh) {  // Delay for analogue read refresh
@@ -271,2 +271 @@ private:
-        I2CManager.read(_I2CAddress, _analogueInputBuffer,
-            _numAnaloguePins * 2, _readCommandBuffer, 1, &_i2crb);
+        I2CManager.read(_I2CAddress, _analogueInputBuffer, _numAnaloguePins * 2, _readCommandBuffer, 1, &_i2crb);
@@ -280 +279 @@ private:
-  // pin map.  
+  // pin map.
@@ -283 +282,2 @@ private:
-    if (_deviceState == DEVSTATE_FAILED) return 0;
+    if (_deviceState == DEVSTATE_FAILED)
+      return 0;
@@ -297 +297,2 @@ private:
-    if (_deviceState == DEVSTATE_FAILED) return 0;
+    if (_deviceState == DEVSTATE_FAILED)
+      return 0;
@@ -306,2 +307,2 @@ private:
-  // if lots of output requests are being made.  We could also cache the last value 
-  // sent so that we don't write the same value over and over to the output.  
+  // if lots of output requests are being made.  We could also cache the last value
+  // sent so that we don't write the same value over and over to the output.
@@ -314 +315,2 @@ private:
-    if (_deviceState == DEVSTATE_FAILED) return;
+    if (_deviceState == DEVSTATE_FAILED)
+      return;
@@ -336 +338,2 @@ private:
-    if (_deviceState == DEVSTATE_FAILED) return;
+    if (_deviceState == DEVSTATE_FAILED)
+      return;
@@ -339,2 +342,2 @@ private:
-    DIAG(F("Servo: WriteAnalogue Vpin:%u Value:%d Profile:%d Duration:%d %S"), 
-      vpin, value, profile, duration, _deviceState == DEVSTATE_FAILED?F("DEVSTATE_FAILED"):F(""));
+    DIAG(F("Servo: WriteAnalogue Vpin:%u Value:%d Profile:%d Duration:%d %S"), vpin, value, profile, duration,
+         _deviceState == DEVSTATE_FAILED ? F("DEVSTATE_FAILED") : F(""));
@@ -362,4 +365,2 @@ private:
-    DIAG(F("EX-IOExpander I2C:%s v%d.%d.%d Vpins %u-%u %S"),
-              _I2CAddress.toString(), _majorVer, _minorVer, _patchVer,
-              (int)_firstVpin, (int)_firstVpin+_nPins-1,
-              _deviceState == DEVSTATE_FAILED ? F("OFFLINE") : F(""));
+    DIAG(F("EX-IOExpander I2C:%s v%d.%d.%d Vpins %u-%u %S"), _I2CAddress.toString(), _majorVer, _minorVer, _patchVer, (int)_firstVpin,
+         (int)_firstVpin + _nPins - 1, _deviceState == DEVSTATE_FAILED ? F("OFFLINE") : F(""));
@@ -369,3 +370,2 @@ private:
-  void reportError(uint8_t status, bool fail=true) {
-    DIAG(F("EX-IOExpander I2C:%s Error:%d (%S)"), _I2CAddress.toString(), 
-      status, I2CManager.getErrorMessage(status));
+  void reportError(uint8_t status, bool fail = true) {
+    DIAG(F("EX-IOExpander I2C:%s Error:%d (%S)"), _I2CAddress.toString(), status, I2CManager.getErrorMessage(status));
@@ -373 +373 @@ private:
-    _deviceState = DEVSTATE_FAILED;
+      _deviceState = DEVSTATE_FAILED;
@@ -383 +383 @@ private:
-  uint8_t* _digitalInputStates  = NULL;
+  uint8_t* _digitalInputStates = NULL;
@@ -393 +393 @@ private:
-  enum {RDS_IDLE, RDS_DIGITAL, RDS_ANALOGUE};  // Read operation states
+  enum { RDS_IDLE, RDS_DIGITAL, RDS_ANALOGUE };  // Read operation states
@@ -395 +395 @@ private:
-  
+
@@ -398,2 +398,2 @@ private:
-  const unsigned long _digitalRefresh = 10000UL;    // Delay refreshing digital inputs for 10ms
-  const unsigned long _analogueRefresh = 50000UL;   // Delay refreshing analogue inputs for 50ms
+  const unsigned long _digitalRefresh = 10000UL;   // Delay refreshing digital inputs for 10ms
+  const unsigned long _analogueRefresh = 50000UL;  // Delay refreshing analogue inputs for 50ms
@@ -403,10 +403,10 @@ private:
-    EXIOINIT = 0xE0,    // Flag to initialise setup procedure
-    EXIORDY = 0xE1,     // Flag we have completed setup procedure, also for EX-IO to ACK setup
-    EXIODPUP = 0xE2,    // Flag we're sending digital pin pullup configuration
-    EXIOVER = 0xE3,     // Flag to get version
-    EXIORDAN = 0xE4,    // Flag to read an analogue input
-    EXIOWRD = 0xE5,     // Flag for digital write
-    EXIORDD = 0xE6,     // Flag to read digital input
-    EXIOENAN = 0xE7,    // Flag to enable an analogue pin
-    EXIOINITA = 0xE8,   // Flag we're receiving analogue pin mappings
-    EXIOPINS = 0xE9,    // Flag we're receiving pin counts for buffers
+    EXIOINIT = 0xE0,   // Flag to initialise setup procedure
+    EXIORDY = 0xE1,    // Flag we have completed setup procedure, also for EX-IO to ACK setup
+    EXIODPUP = 0xE2,   // Flag we're sending digital pin pullup configuration
+    EXIOVER = 0xE3,    // Flag to get version
+    EXIORDAN = 0xE4,   // Flag to read an analogue input
+    EXIOWRD = 0xE5,    // Flag for digital write
+    EXIORDD = 0xE6,    // Flag to read digital input
+    EXIOENAN = 0xE7,   // Flag to enable an analogue pin
+    EXIOINITA = 0xE8,  // Flag we're receiving analogue pin mappings
+    EXIOPINS = 0xE9,   // Flag we're receiving pin counts for buffers
@@ -414 +414 @@ private:
-    EXIOERR = 0xEF,     // Flag we've received an error
+    EXIOERR = 0xEF,    // Flag we've received an error
diff --git a/IO_EXSensorCAM.h b/IO_EXSensorCAM.h
index f91248d..ff41851 100644
--- a/IO_EXSensorCAM.h
+++ b/IO_EXSensorCAM.h
@@ -1,2 +1,2 @@
-/*  2024/08/14 
- *  Â© 2024, Barry Daniel ESP32-CAM revision 
+/*  2024/08/14
+ *  Â© 2024, Barry Daniel ESP32-CAM revision
@@ -18 +18 @@
-*/
+ */
@@ -21 +21 @@
-// v304 static oldb0;  t(##[,%%]; 
+// v304 static oldb0;  t(##[,%%];
@@ -23,2 +23,2 @@
-// v302 SEND=StringFormatter::send, remove Sp(), add 'q', memcpy( .8) -> .7); 
-// v301 improved 'f','p'&'q' code and driver version calc. Correct bsNo calc. for 'a'							 
+// v302 SEND=StringFormatter::send, remove Sp(), add 'q', memcpy( .8) -> .7);
+// v301 improved 'f','p'&'q' code and driver version calc. Correct bsNo calc. for 'a'
@@ -30 +30 @@
-// v200 rewrite reduces need for double reads of ESP32 slave CAM. Deleted ESP32CAP. 
+// v200 rewrite reduces need for double reads of ESP32 slave CAM. Deleted ESP32CAP.
@@ -34 +34 @@
- * It is modelled on the IO_EXIOExpander.h device driver to include specific needs of the ESP32 sensorCAM 
+ * It is modelled on the IO_EXIOExpander.h device driver to include specific needs of the ESP32 sensorCAM
@@ -49 +49 @@
- * 
+ *
@@ -51,2 +51,2 @@
-*/
-# define DIGITALREFRESH 20000UL      // min uSec delay between digital reads of digitalInputStates
+ */
+#define DIGITALREFRESH 20000UL  // min uSec delay between digital reads of digitalInputStates
@@ -65 +65 @@
-*/
+ */
@@ -67,3 +67,3 @@ class EXSensorCAM : public IODevice {
-  public:
-    static void create(VPIN vpin, int nPins, I2CAddress i2cAddress) {
-      if (checkNoOverlap(vpin, nPins, i2cAddress)) 
+ public:
+  static void create(VPIN vpin, int nPins, I2CAddress i2cAddress) {
+    if (checkNoOverlap(vpin, nPins, i2cAddress))
@@ -71,16 +71,17 @@ class EXSensorCAM : public IODevice {
-    }
-  																
-    static VPIN CAMBaseVpin;					   
-
-  private:
-   // Constructor
-    EXSensorCAM(VPIN firstVpin, int nPins, I2CAddress i2cAddress) {
-      _firstVpin = firstVpin;
-     // Number of pins cannot exceed 255 (1 byte) because of I2C message structure.
-      if (nPins > 80) nPins = 80;
-      _nPins = nPins;
-      _I2CAddress = i2cAddress;
-      addDevice(this);
-    }
-//*************************
-void _begin() {
+  }
+
+  static VPIN CAMBaseVpin;
+
+ private:
+  // Constructor
+  EXSensorCAM(VPIN firstVpin, int nPins, I2CAddress i2cAddress) {
+    _firstVpin = firstVpin;
+    // Number of pins cannot exceed 255 (1 byte) because of I2C message structure.
+    if (nPins > 80)
+      nPins = 80;
+    _nPins = nPins;
+    _I2CAddress = i2cAddress;
+    addDevice(this);
+  }
+  //*************************
+  void _begin() {
@@ -94,4 +95,4 @@ void _begin() {
-    }else {
-      uint8_t commandBuffer[4]={EXIOINIT,(uint8_t)_nPins,(uint8_t)(_firstVpin & 0xFF),(uint8_t)(_firstVpin>>8)};                                                                                 
-      status = I2CManager.read(_I2CAddress,_inputBuf,sizeof(_inputBuf),commandBuffer,sizeof(commandBuffer));
-        //EXIOINIT needed to trigger and send firstVpin to CAM
+    } else {
+      uint8_t commandBuffer[4] = {EXIOINIT, (uint8_t)_nPins, (uint8_t)(_firstVpin & 0xFF), (uint8_t)(_firstVpin >> 8)};
+      status = I2CManager.read(_I2CAddress, _inputBuf, sizeof(_inputBuf), commandBuffer, sizeof(commandBuffer));
+      // EXIOINIT needed to trigger and send firstVpin to CAM
@@ -100,5 +101,3 @@ void _begin() {
-        // Attempt to get version, non-blocking results in poor placement of response.  Can be blocking here! 
-        commandBuffer[0] = '^';    //new version code
-    
-        status = I2CManager.read(_I2CAddress, _inputBuf, sizeof(_inputBuf), commandBuffer, 1); 
-         // for ESP32 CAM, read again for good immediate response version data
+        // Attempt to get version, non-blocking results in poor placement of response.  Can be blocking here!
+        commandBuffer[0] = '^';  // new version code
+
@@ -106 +105,3 @@ void _begin() {
-        
+        // for ESP32 CAM, read again for good immediate response version data
+        status = I2CManager.read(_I2CAddress, _inputBuf, sizeof(_inputBuf), commandBuffer, 1);
+
@@ -108,6 +109,5 @@ void _begin() {
-          _majorVer= _inputBuf[1]/10;	
-          _minorVer= _inputBuf[1]%10;
-          _patchVer= _inputBuf[2];				
-          DIAG(F("EX-SensorCAM device found, I2C:%s, Version v%d.%d.%d"),
-                       _I2CAddress.toString(),_majorVer, _minorVer,_patchVer);
-        }  	
+          _majorVer = _inputBuf[1] / 10;
+          _minorVer = _inputBuf[1] % 10;
+          _patchVer = _inputBuf[2];
+          DIAG(F("EX-SensorCAM device found, I2C:%s, Version v%d.%d.%d"), _I2CAddress.toString(), _majorVer, _minorVer, _patchVer);
+        }
@@ -117,27 +117,32 @@ void _begin() {
-    } 
-}
-//*************************
-// Digital input pin configuration, used to enable on EX-IOExpander device and set pullups if requested.
-// Configuration isn't done frequently so we can use blocking I2C calls here, and so buffers can
-// be allocated from the stack to reduce RAM allocation.
-bool _configure(VPIN vpin, ConfigTypeEnum configType, int paramCount, int params[]) override { 
-  (void)configType; (void)params; // unused
-  if(_verPrint) DIAG(F("_configure() driver IO_EXSensorCAM v0.%d.%d vpin: %d "), driverVer/100,driverVer%100,vpin);
-  _verPrint=false;           //only give driver versions once
-  if (paramCount != 1) return false;
-  return true; //at least confirm that CAM is (always) configured (no vpin check!)
-}
-//*************************															 
-// Analogue input pin configuration, used to enable an EX-IOExpander device.
-int _configureAnalogIn(VPIN vpin) override { 
-  DIAG(F("_configureAnalogIn() IO_EXSensorCAM vpin %d"),vpin); 
-  return true;     // NOTE: use of EXRAIL IFGTE() etc use "analog" reads.
-}
-//*************************
-// Main loop, collect both digital and "analog" pin states continuously (faster sensor/input reads)
-void _loop(unsigned long currentMicros) override {
-    if (_deviceState == DEVSTATE_FAILED) return;    
-      // Request block is used for "analogue" (cmd. data) and digital reads from the sensorCAM, which 
-      // are performed on a cyclic basis.  Writes are performed synchronously as and when requested.
-    if (_readState != RDS_IDLE) {                  //expecting a return packet
-      if (_i2crb.isBusy()) return;                 // If I2C operation still in progress, return
+    }
+  }
+  //*************************
+  // Digital input pin configuration, used to enable on EX-IOExpander device and set pullups if requested.
+  // Configuration isn't done frequently so we can use blocking I2C calls here, and so buffers can
+  // be allocated from the stack to reduce RAM allocation.
+  bool _configure(VPIN vpin, ConfigTypeEnum configType, int paramCount, int params[]) override {
+    (void)configType;
+    (void)params;  // unused
+    if (_verPrint)
+      DIAG(F("_configure() driver IO_EXSensorCAM v0.%d.%d vpin: %d "), driverVer / 100, driverVer % 100, vpin);
+    _verPrint = false;  // only give driver versions once
+    if (paramCount != 1)
+      return false;
+    return true;  // at least confirm that CAM is (always) configured (no vpin check!)
+  }
+  //*************************
+  // Analogue input pin configuration, used to enable an EX-IOExpander device.
+  int _configureAnalogIn(VPIN vpin) override {
+    DIAG(F("_configureAnalogIn() IO_EXSensorCAM vpin %d"), vpin);
+    return true;  // NOTE: use of EXRAIL IFGTE() etc use "analog" reads.
+  }
+  //*************************
+  // Main loop, collect both digital and "analog" pin states continuously (faster sensor/input reads)
+  void _loop(unsigned long currentMicros) override {
+    if (_deviceState == DEVSTATE_FAILED)
+      return;
+    // Request block is used for "analogue" (cmd. data) and digital reads from the sensorCAM, which
+    // are performed on a cyclic basis.  Writes are performed synchronously as and when requested.
+    if (_readState != RDS_IDLE) {  // expecting a return packet
+      if (_i2crb.isBusy())
+        return;  // If I2C operation still in progress, return
@@ -145,9 +150,10 @@ void _loop(unsigned long currentMicros) override {
-      if (status == I2C_STATUS_OK) {               // If device request ok, read input data
-        //apparently the above checks do not guarantee a good packet! error rate about 1 pkt per 1000
-        //there should be a packet in _CAMresponseBuff[32]            
-        if ((_CAMresponseBuff[0] & 0x60) >= 0x60) {   //Buff[0] seems to have ascii cmd header (bit6 high) (o06)    
-            int error = processIncomingPkt( _CAMresponseBuff, _CAMresponseBuff[0]);   // '~' 'i' 'm' 'n' 't' etc
-              if (error>0) DIAG(F("CAM packet header(0x%x) not recognised"),_CAMresponseBuff[0]);                   
-        }else{ // Header not valid - typically replaced by bank 0 data!  To avoid any bad responses set S06 to 0  
-               // Versions of sensorCAM.h after v300 should return header for '@' of '`'(0x60) (not 0xE6)  
-               // followed by digitalInputStates sensor state array
+      if (status == I2C_STATUS_OK) {  // If device request ok, read input data
+        // apparently the above checks do not guarantee a good packet! error rate about 1 pkt per 1000
+        // there should be a packet in _CAMresponseBuff[32]
+        if ((_CAMresponseBuff[0] & 0x60) >= 0x60) {                               // Buff[0] seems to have ascii cmd header (bit6 high) (o06)
+          int error = processIncomingPkt(_CAMresponseBuff, _CAMresponseBuff[0]);  // '~' 'i' 'm' 'n' 't' etc
+          if (error > 0)
+            DIAG(F("CAM packet header(0x%x) not recognised"), _CAMresponseBuff[0]);
+        } else {  // Header not valid - typically replaced by bank 0 data!  To avoid any bad responses set S06 to 0
+                  // Versions of sensorCAM.h after v300 should return header for '@' of '`'(0x60) (not 0xE6)
+                  // followed by digitalInputStates sensor state array
@@ -155 +161,2 @@ void _loop(unsigned long currentMicros) override {
-      }else   reportError(status, false);   // report i2c eror but don't go offline.
+      } else
+        reportError(status, false);  // report i2c eror but don't go offline.
@@ -157,2 +164,2 @@ void _loop(unsigned long currentMicros) override {
-    }      
-  
+    }
+
@@ -160,6 +167,6 @@ void _loop(unsigned long currentMicros) override {
-    if (_readState == RDS_IDLE) {    //check if time for digitalRefresh   
-      if ( currentMicros - _lastDigitalRead > _digitalRefresh) { 
-        // Issue new read request for digital states.  
-             
-        _readCommandBuffer[0] = '@';  //start new read of digitalInputStates Table     // non-blocking read 
-        I2CManager.read(_I2CAddress,_CAMresponseBuff, 32,_readCommandBuffer, 1, &_i2crb);     
+    if (_readState == RDS_IDLE) {  // check if time for digitalRefresh
+      if (currentMicros - _lastDigitalRead > _digitalRefresh) {
+        // Issue new read request for digital states.
+
+        _readCommandBuffer[0] = '@';  // start new read of digitalInputStates Table     // non-blocking read
+        I2CManager.read(_I2CAddress, _CAMresponseBuff, 32, _readCommandBuffer, 1, &_i2crb);
@@ -168,2 +175,2 @@ void _loop(unsigned long currentMicros) override {
-        
-      }else{    //slip in a repeat <NT n> if pending
+
+      } else {                                                 // slip in a repeat <NT n> if pending
@@ -171,10 +178,11 @@ void _loop(unsigned long currentMicros) override {
-         if (_savedCmd[2]>1) {   //repeat a 't' command         
-          for (int i=0;i<7;i++)  _readCommandBuffer[i] =_savedCmd[i];
-          int errors = ioESP32(_I2CAddress, _CAMresponseBuff, 32, _readCommandBuffer, 7);    
-          _lasttStateRead = currentMicros;
-          _savedCmd[2] -= 1;     //decrement repeats                  
-          if (errors==0) return;
-          DIAG(F("ioESP32 error %d header 0x%x"),errors,_CAMresponseBuff[0]);  
-          _readState = RDS_TSTATE;  //this should stop further cmd requests until packet read (or timeout)
-        }
-      }   //end repeat 't'
+          if (_savedCmd[2] > 1) {                              // repeat a 't' command
+            for (int i = 0; i < 7; i++) _readCommandBuffer[i] = _savedCmd[i];
+            int errors = ioESP32(_I2CAddress, _CAMresponseBuff, 32, _readCommandBuffer, 7);
+            _lasttStateRead = currentMicros;
+            _savedCmd[2] -= 1;  // decrement repeats
+            if (errors == 0)
+              return;
+            DIAG(F("ioESP32 error %d header 0x%x"), errors, _CAMresponseBuff[0]);
+            _readState = RDS_TSTATE;  // this should stop further cmd requests until packet read (or timeout)
+          }
+      }  // end repeat 't'
@@ -182,36 +189,0 @@ void _loop(unsigned long currentMicros) override {
-  }   
-//*************************
-// Obtain the bank of 8 sensors as an "analog" value
-// can be used to track the position through a sequential sensor bank
-int _readAnalogue(VPIN vpin) override {
-  if (_deviceState == DEVSTATE_FAILED) return 0;        
-  return _digitalInputStates[(vpin - _firstVpin) / 8];
-}
-//*************************
-// Obtain the correct digital sensor input value
-int _read(VPIN vpin) override {
-  if (_deviceState == DEVSTATE_FAILED) return 0;
-  int pin = vpin - _firstVpin;
-  return bitRead(_digitalInputStates[pin / 8], pin % 8);
-}
-//*************************
-// Write digital value.  
-void _write(VPIN vpin, int value) override { 
-  DIAG(F("**_write() vpin %d = %d"),vpin,value);
-  return ;
-}
-//*************************
-// i2cAddr of ESP32 CAM
-// rBuf   buffer for return packet 
-// inbytes number of bytes to request from CAM
-// outBuff holds outbytes to be sent to CAM  
-int ioESP32(uint8_t i2cAddr,uint8_t *rBuf,int inbytes,uint8_t *outBuff,int outbytes) {
-  uint8_t status = _i2crb.status;
-
- while( _i2crb.status != I2C_STATUS_OK){status = _i2crb.status;}   //wait until bus free
-
-  status = I2CManager.read(i2cAddr, rBuf, inbytes, outBuff, outbytes);
-        
-  if (status != I2C_STATUS_OK){ 
-    DIAG(F("EX-SensorCAM I2C:%s Error:%d %S"), _I2CAddress.toString(), status, I2CManager.getErrorMessage(status));
-    reportError(status); return status;
@@ -219,92 +191,122 @@ int ioESP32(uint8_t i2cAddr,uint8_t *rBuf,int inbytes,uint8_t *outBuff,int outby
-  return 0;  // 0 for no error != 0 for error number.
-}
-//*************************
-//function to interpret packet from sensorCAM.ino
-//i2cAddr to identify CAM# (if # >1)
-//rBuf contains packet of up to 32 bytes usually with (ascii) cmd header in rBuf[0]
-//sensorCmd command header byte from CAM (in rBuf[0]?)
-int processIncomingPkt(uint8_t *rBuf,uint8_t sensorCmd) {
-//static uint8_t oldb0;   //for debug only
-  int k; 
-  int b;
-  char str[] = "11111111";
- // if (sensorCmd <= '~') DIAG(F("processIncomingPkt %c %d %d %d"),rBuf[0],rBuf[1],rBuf[2],rBuf[3]);
-  switch (sensorCmd){
-    case '`':      //response to request for digitalInputStates[] table  '@'=>'`'  
-      memcpy(_digitalInputStates, rBuf+1, digitalBytesNeeded);
-//      if ( _digitalInputStates[0]!=oldb0) { oldb0=_digitalInputStates[0];  //debug
-//        for (k=0;k<5;k++) {Serial.print(" ");Serial.print(_digitalInputStates[k],HEX);}
-//      }
-      break;                                                 
-
-    case EXIORDY:  //some commands give back acknowledgement only
-      break;
-
-    case CAMERR:   //cmd format error code from CAM
-      DIAG(F("CAM cmd error 0xFE 0x%x"),rBuf[1]); 
-      break;
-
-    case '~':      //information from '^' version request <N v[er]>
-      DIAG(F("EX-SensorCAM device found, I2C:%s,CAM Version v%d.%d.%d vpins %u-%u"),
-              _I2CAddress.toString(), rBuf[1]/10, rBuf[1]%10, rBuf[2],(int) _firstVpin, (int) _firstVpin +_nPins-1);
-      DIAG(F("IO_EXSensorCAM driver  v0.%d.%d vpin: %d "), driverVer/100,driverVer%100,_firstVpin);
-      break;
- 
-    case 'f':
-      DIAG(F("(f %%%%) frame header 'f' for bsNo %d/%d - showing Quarter sample (1 row) only"), rBuf[1]/8,rBuf[1]%8);  
-      SEND(&USB_SERIAL,F("<n  row: %d  Ref bytes: "),rBuf[2]);
-      for(k=3;k<15;k++)
-        SEND(&USB_SERIAL,F("%x%x%s"), rBuf[k]>>4, rBuf[k]&15, k%3==2 ? "  " : " "); 
-      Serial.print(" latest grab: "); 
-      for(k=16;k<28;k++)
-        SEND(&USB_SERIAL,F("%x%x%s"), rBuf[k]>>4, rBuf[k]&15, (k%3==0) ? "  " : " ");
-      Serial.print(" n>\n");
-      break; 
-
-    case 'i':      //information from i%%
-      k=256*rBuf[5]+rBuf[4];
-      DIAG(F("(i%%%%[,$$]) Info: Sensor 0%o(%d) enabled:%d status:%d row=%d x=%d Twin=0%o pvtThreshold=%d A~%d")
-              ,rBuf[1],rBuf[1],rBuf[3],rBuf[2],rBuf[6],k,rBuf[7],rBuf[9],int(rBuf[8])*16);	 
-      break;
-
-    case 'm':
-      DIAG(F("(m$[,##]) Min/max: $ frames min2flip (trip) %d, maxSensors 0%o, minSensors 0%o, nLED %d,"
-              " threshold %d, TWOIMAGE_MAXBS 0%o"),rBuf[1],rBuf[3],rBuf[2],rBuf[4],rBuf[5],rBuf[6]);
-      break;
-
-    case 'n':
-      DIAG(F("(n$[,##]) Nominate: $ nLED %d, ## minSensors 0%o (maxSensors 0%o threshold %d)")
-                                       ,rBuf[4],rBuf[2],rBuf[3],rBuf[5]);                                                               
-      break;
-
-    case 'p':
-      b=rBuf[1]-2;  
-      if(b<4) { Serial.print("<n (p%%) Bank empty  n>\n"); break; }
-      SEND(&USB_SERIAL,F("<n (p%%) Bank: %d "),(0x7F&rBuf[2])/8);
-      for (int j=2; j<b; j+=3)  
-        SEND(&USB_SERIAL,F(" S[%d%d]: r=%d x=%d"),0x7F&rBuf[j]/8,0x7F&rBuf[j]%8,rBuf[j+1],rBuf[j+2]+2*(rBuf[j]&0x80));
-      Serial.print("  n>\n");
-      break;
-
-    case 'q':
-      for (int i =0; i<8; i++) str[i] = ((rBuf[2] << i) & 0x80 ? '1' : '0');
-      DIAG(F("(q $) Query bank %c ENABLED sensors(S%c7-%c0): %s "), rBuf[1], rBuf[1], rBuf[1], str);
-      break;
-
-    case 't':      //threshold etc. from t##           //bad pkt if 't' FF's
-      if(rBuf[1]==0xFF) {Serial.println("<n bad CAM 't' packet: 74 FF  n>");_savedCmd[2] +=1; return 0;}
-      SEND(&USB_SERIAL,F("<n (t[##[,%%%%]]) Threshold:%d sensor S00:-%d"),rBuf[1],min(rBuf[2]&0x7F,99));
-      if(rBuf[2]>127) Serial.print("##* "); 
-      else{ 
-        if(rBuf[2]>rBuf[1]) Serial.print("-?* "); 
-        else Serial.print("--* ");
-      }
-      for(int i=3;i<31;i+=2){
-        uint8_t valu=rBuf[i];        //get bsn
-        if(valu==80) break;          //80 = end flag
-        else{ 
-          SEND(&USB_SERIAL,F("%d%d:"), (valu&0x7F)/8,(valu&0x7F)%8);
-          if(valu>=128) Serial.print("?-"); 
-          else {if(rBuf[i+1]>=128) Serial.print("oo");else Serial.print("--");}
-          valu=rBuf[i+1]; 
-          SEND(&USB_SERIAL,F("%d%s"),min(valu&0x7F,99),(valu<128) ? "--* ":"##* ");
+  //*************************
+  // Obtain the bank of 8 sensors as an "analog" value
+  // can be used to track the position through a sequential sensor bank
+  int _readAnalogue(VPIN vpin) override {
+    if (_deviceState == DEVSTATE_FAILED)
+      return 0;
+    return _digitalInputStates[(vpin - _firstVpin) / 8];
+  }
+  //*************************
+  // Obtain the correct digital sensor input value
+  int _read(VPIN vpin) override {
+    if (_deviceState == DEVSTATE_FAILED)
+      return 0;
+    int pin = vpin - _firstVpin;
+    return bitRead(_digitalInputStates[pin / 8], pin % 8);
+  }
+  //*************************
+  // Write digital value.
+  void _write(VPIN vpin, int value) override {
+    DIAG(F("**_write() vpin %d = %d"), vpin, value);
+    return;
+  }
+  //*************************
+  // i2cAddr of ESP32 CAM
+  // rBuf   buffer for return packet
+  // inbytes number of bytes to request from CAM
+  // outBuff holds outbytes to be sent to CAM
+  int ioESP32(uint8_t i2cAddr, uint8_t* rBuf, int inbytes, uint8_t* outBuff, int outbytes) {
+    uint8_t status = _i2crb.status;
+
+    while (_i2crb.status != I2C_STATUS_OK) {
+      status = _i2crb.status;
+    }  // wait until bus free
+
+    status = I2CManager.read(i2cAddr, rBuf, inbytes, outBuff, outbytes);
+
+    if (status != I2C_STATUS_OK) {
+      DIAG(F("EX-SensorCAM I2C:%s Error:%d %S"), _I2CAddress.toString(), status, I2CManager.getErrorMessage(status));
+      reportError(status);
+      return status;
+    }
+    return 0;  // 0 for no error != 0 for error number.
+  }
+  //*************************
+  // function to interpret packet from sensorCAM.ino
+  // i2cAddr to identify CAM# (if # >1)
+  // rBuf contains packet of up to 32 bytes usually with (ascii) cmd header in rBuf[0]
+  // sensorCmd command header byte from CAM (in rBuf[0]?)
+  int processIncomingPkt(uint8_t* rBuf, uint8_t sensorCmd) {
+    // static uint8_t oldb0;   //for debug only
+    int k;
+    int b;
+    char str[] = "11111111";
+    // if (sensorCmd <= '~') DIAG(F("processIncomingPkt %c %d %d %d"),rBuf[0],rBuf[1],rBuf[2],rBuf[3]);
+    switch (sensorCmd) {
+      case '`':  // response to request for digitalInputStates[] table  '@'=>'`'
+        memcpy(_digitalInputStates, rBuf + 1, digitalBytesNeeded);
+        //      if ( _digitalInputStates[0]!=oldb0) { oldb0=_digitalInputStates[0];  //debug
+        //        for (k=0;k<5;k++) {Serial.print(" ");Serial.print(_digitalInputStates[k],HEX);}
+        //      }
+        break;
+
+      case EXIORDY:  // some commands give back acknowledgement only
+        break;
+
+      case CAMERR:  // cmd format error code from CAM
+        DIAG(F("CAM cmd error 0xFE 0x%x"), rBuf[1]);
+        break;
+
+      case '~':  // information from '^' version request <N v[er]>
+        DIAG(F("EX-SensorCAM device found, I2C:%s,CAM Version v%d.%d.%d vpins %u-%u"), _I2CAddress.toString(), rBuf[1] / 10, rBuf[1] % 10, rBuf[2],
+             (int)_firstVpin, (int)_firstVpin + _nPins - 1);
+        DIAG(F("IO_EXSensorCAM driver  v0.%d.%d vpin: %d "), driverVer / 100, driverVer % 100, _firstVpin);
+        break;
+
+      case 'f':
+        DIAG(F("(f %%%%) frame header 'f' for bsNo %d/%d - showing Quarter sample (1 row) only"), rBuf[1] / 8, rBuf[1] % 8);
+        SEND(&USB_SERIAL, F("<n  row: %d  Ref bytes: "), rBuf[2]);
+        for (k = 3; k < 15; k++) SEND(&USB_SERIAL, F("%x%x%s"), rBuf[k] >> 4, rBuf[k] & 15, k % 3 == 2 ? "  " : " ");
+        Serial.print(" latest grab: ");
+        for (k = 16; k < 28; k++) SEND(&USB_SERIAL, F("%x%x%s"), rBuf[k] >> 4, rBuf[k] & 15, (k % 3 == 0) ? "  " : " ");
+        Serial.print(" n>\n");
+        break;
+
+      case 'i':  // information from i%%
+        k = 256 * rBuf[5] + rBuf[4];
+        DIAG(F("(i%%%%[,$$]) Info: Sensor 0%o(%d) enabled:%d status:%d row=%d x=%d Twin=0%o pvtThreshold=%d A~%d"), rBuf[1], rBuf[1], rBuf[3],
+             rBuf[2], rBuf[6], k, rBuf[7], rBuf[9], int(rBuf[8]) * 16);
+        break;
+
+      case 'm':
+        DIAG(F("(m$[,##]) Min/max: $ frames min2flip (trip) %d, maxSensors 0%o, minSensors 0%o, nLED %d,"
+               " threshold %d, TWOIMAGE_MAXBS 0%o"),
+             rBuf[1], rBuf[3], rBuf[2], rBuf[4], rBuf[5], rBuf[6]);
+        break;
+
+      case 'n':
+        DIAG(F("(n$[,##]) Nominate: $ nLED %d, ## minSensors 0%o (maxSensors 0%o threshold %d)"), rBuf[4], rBuf[2], rBuf[3], rBuf[5]);
+        break;
+
+      case 'p':
+        b = rBuf[1] - 2;
+        if (b < 4) {
+          Serial.print("<n (p%%) Bank empty  n>\n");
+          break;
+        }
+        SEND(&USB_SERIAL, F("<n (p%%) Bank: %d "), (0x7F & rBuf[2]) / 8);
+        for (int j = 2; j < b; j += 3)
+          SEND(&USB_SERIAL, F(" S[%d%d]: r=%d x=%d"), 0x7F & rBuf[j] / 8, 0x7F & rBuf[j] % 8, rBuf[j + 1], rBuf[j + 2] + 2 * (rBuf[j] & 0x80));
+        Serial.print("  n>\n");
+        break;
+
+      case 'q':
+        for (int i = 0; i < 8; i++) str[i] = ((rBuf[2] << i) & 0x80 ? '1' : '0');
+        DIAG(F("(q $) Query bank %c ENABLED sensors(S%c7-%c0): %s "), rBuf[1], rBuf[1], rBuf[1], str);
+        break;
+
+      case 't':  // threshold etc. from t##           //bad pkt if 't' FF's
+        if (rBuf[1] == 0xFF) {
+          Serial.println("<n bad CAM 't' packet: 74 FF  n>");
+          _savedCmd[2] += 1;
+          return 0;
@@ -312,13 +314,39 @@ int processIncomingPkt(uint8_t *rBuf,uint8_t sensorCmd) {
-      } 
-      Serial.print(" >\n");
-      break;
-
-    default:        //header not a recognised cmd character
-      DIAG(F("CAM packet header not valid (0x%x) (0x%x) (0x%x)"),rBuf[0],rBuf[1],rBuf[2]);
-      return 1;
-  }			 
-  return 0;  
-}
-//*************************											  
-// Write (analogue) 8bit (command) values.  Write the parameters to the sensorCAM
-void _writeAnalogue(VPIN vpin, int param1, uint8_t camop, uint16_t param3) override {
+        SEND(&USB_SERIAL, F("<n (t[##[,%%%%]]) Threshold:%d sensor S00:-%d"), rBuf[1], min(rBuf[2] & 0x7F, 99));
+        if (rBuf[2] > 127)
+          Serial.print("##* ");
+        else {
+          if (rBuf[2] > rBuf[1])
+            Serial.print("-?* ");
+          else
+            Serial.print("--* ");
+        }
+        for (int i = 3; i < 31; i += 2) {
+          uint8_t valu = rBuf[i];  // get bsn
+          if (valu == 80)
+            break;  // 80 = end flag
+          else {
+            SEND(&USB_SERIAL, F("%d%d:"), (valu & 0x7F) / 8, (valu & 0x7F) % 8);
+            if (valu >= 128)
+              Serial.print("?-");
+            else {
+              if (rBuf[i + 1] >= 128)
+                Serial.print("oo");
+              else
+                Serial.print("--");
+            }
+            valu = rBuf[i + 1];
+            SEND(&USB_SERIAL, F("%d%s"), min(valu & 0x7F, 99), (valu < 128) ? "--* " : "##* ");
+          }
+        }
+        Serial.print(" >\n");
+        break;
+
+      default:  // header not a recognised cmd character
+        DIAG(F("CAM packet header not valid (0x%x) (0x%x) (0x%x)"), rBuf[0], rBuf[1], rBuf[2]);
+        return 1;
+    }
+    return 0;
+  }
+  //*************************
+  // Write (analogue) 8bit (command) values.  Write the parameters to the sensorCAM
+  void _writeAnalogue(VPIN vpin, int param1, uint8_t camop, uint16_t param3) override {
@@ -326,2 +354,2 @@ void _writeAnalogue(VPIN vpin, int param1, uint8_t camop, uint16_t param3) overr
-    int errors=0;
-    outputBuffer[0] = camop;  
+    int errors = 0;
+    outputBuffer[0] = camop;
@@ -330,3 +358,3 @@ void _writeAnalogue(VPIN vpin, int param1, uint8_t camop, uint16_t param3) overr
-    if(camop >= 0x80) {   //case "a" (4p) also (3p) e.g. <N 713 210 310> 
-      camop=param1;        //put row (0-236) in expected place 
-      param1=param3;        //put column in expected place
+    if (camop >= 0x80) {  // case "a" (4p) also (3p) e.g. <N 713 210 310>
+      camop = param1;     // put row (0-236) in expected place
+      param1 = param3;    // put column in expected place
@@ -334,5 +362,6 @@ void _writeAnalogue(VPIN vpin, int param1, uint8_t camop, uint16_t param3) overr
-      pin = (pin/8)*10 + pin%8;   //restore bsNo. as integer
-    }   
-    if (_deviceState == DEVSTATE_FAILED) return;
-   
-    outputBuffer[1] = pin;          //vpin => bsn
+      pin = (pin / 8) * 10 + pin % 8;  // restore bsNo. as integer
+    }
+    if (_deviceState == DEVSTATE_FAILED)
+      return;
+
+    outputBuffer[1] = pin;  // vpin => bsn
@@ -341 +370 @@ void _writeAnalogue(VPIN vpin, int param1, uint8_t camop, uint16_t param3) overr
-    outputBuffer[4] = camop;        //command code
+    outputBuffer[4] = camop;  // command code
@@ -345,4 +374,7 @@ void _writeAnalogue(VPIN vpin, int param1, uint8_t camop, uint16_t param3) overr
-    int count=param1+1;
-    if(camop=='Q'){
-      if(param3<=10) {count=param3; camop='B';}
-      //if(param1<10) outputBuffer[2] = param1*10;
+    int count = param1 + 1;
+    if (camop == 'Q') {
+      if (param3 <= 10) {
+        count = param3;
+        camop = 'B';
+      }
+      // if(param1<10) outputBuffer[2] = param1*10;
@@ -350,5 +382,7 @@ void _writeAnalogue(VPIN vpin, int param1, uint8_t camop, uint16_t param3) overr
-    if(camop=='B'){   //then 'b'(b%) cmd - can totally deal with that here. (but can't do b%,# (brightSF))
-      if(param1>97) return;
-      if(param1>9) param1 = param1/10;  //accept a bsNo
-      for(int bnk=param1;bnk<count;bnk++) {
-        uint8_t b=_digitalInputStates[bnk];
+    if (camop == 'B') {  // then 'b'(b%) cmd - can totally deal with that here. (but can't do b%,# (brightSF))
+      if (param1 > 97)
+        return;
+      if (param1 > 9)
+        param1 = param1 / 10;  // accept a bsNo
+      for (int bnk = param1; bnk < count; bnk++) {
+        uint8_t b = _digitalInputStates[bnk];
@@ -356,2 +390,4 @@ void _writeAnalogue(VPIN vpin, int param1, uint8_t camop, uint16_t param3) overr
-        for (int i=0;i<8;i++) if(((b<<i)&0x80) == 0) str[i]='0';
-        DIAG(F("(b $) Bank: %d activated byte: 0x%x%x (sensors S%d7->%d0) %s"), bnk,b>>4,b&15,bnk,bnk,str ); 
+        for (int i = 0; i < 8; i++)
+          if (((b << i) & 0x80) == 0)
+            str[i] = '0';
+        DIAG(F("(b $) Bank: %d activated byte: 0x%x%x (sensors S%d7->%d0) %s"), bnk, b >> 4, b & 15, bnk, bnk, str);
@@ -360,14 +395,0 @@ void _writeAnalogue(VPIN vpin, int param1, uint8_t camop, uint16_t param3) overr
-    } 
-    if (outputBuffer[4]=='T') {   //then 't' cmd
-      if(param1<31) {   //repeated calls if param < 31
-          //for (int i=0;i<7;i++) _savedCmd[i]=outputBuffer[i];
-        memcpy( _savedCmd, outputBuffer, 7);
-      }else _savedCmd[2] = 0;   //no repeats if ##>30 
-    }else _savedCmd[2] = 0;       //no repeats unless 't'
-  
-    _lasttStateRead = micros();    //don't repeat until _tStateRefresh mSec
-
-    errors = ioESP32(_I2CAddress, _CAMresponseBuff, 32 , outputBuffer, 7);  //send to esp32-CAM
-    if (errors==0) return;
-    else {    //       if (_CAMresponseBuff[0] != EXIORDY)   //can't be sure what is inBuff[0] !
-      DIAG(F("ioESP32 i2c error %d header 0x%x"),errors,_CAMresponseBuff[0]);  
@@ -375,3 +397,20 @@ void _writeAnalogue(VPIN vpin, int param1, uint8_t camop, uint16_t param3) overr
-}
-//*************************
- // Display device information and status.
+    if (outputBuffer[4] == 'T') {  // then 't' cmd
+      if (param1 < 31) {           // repeated calls if param < 31
+        // for (int i=0;i<7;i++) _savedCmd[i]=outputBuffer[i];
+        memcpy(_savedCmd, outputBuffer, 7);
+      } else
+        _savedCmd[2] = 0;  // no repeats if ##>30
+    } else
+      _savedCmd[2] = 0;  // no repeats unless 't'
+
+    _lasttStateRead = micros();  // don't repeat until _tStateRefresh mSec
+
+    errors = ioESP32(_I2CAddress, _CAMresponseBuff, 32, outputBuffer, 7);  // send to esp32-CAM
+    if (errors == 0)
+      return;
+    else {  //       if (_CAMresponseBuff[0] != EXIORDY)   //can't be sure what is inBuff[0] !
+      DIAG(F("ioESP32 i2c error %d header 0x%x"), errors, _CAMresponseBuff[0]);
+    }
+  }
+  //*************************
+  // Display device information and status.
@@ -379,4 +418,2 @@ void _writeAnalogue(VPIN vpin, int param1, uint8_t camop, uint16_t param3) overr
-    DIAG(F("EX-SensorCAM I2C:%s v%d.%d.%d Vpins %u-%u %S"),
-              _I2CAddress.toString(), _majorVer, _minorVer, _patchVer,
-              (int)_firstVpin, (int)_firstVpin+_nPins-1,
-              _deviceState == DEVSTATE_FAILED ? F("OFFLINE") : F(""));
+    DIAG(F("EX-SensorCAM I2C:%s v%d.%d.%d Vpins %u-%u %S"), _I2CAddress.toString(), _majorVer, _minorVer, _patchVer, (int)_firstVpin,
+         (int)_firstVpin + _nPins - 1, _deviceState == DEVSTATE_FAILED ? F("OFFLINE") : F(""));
@@ -384,10 +421,10 @@ void _writeAnalogue(VPIN vpin, int param1, uint8_t camop, uint16_t param3) overr
-//*************************
-// Helper function for error handling
-void reportError(uint8_t status, bool fail=true) {
-  DIAG(F("EX-SensorCAM I2C:%s Error:%d (%S)"), _I2CAddress.toString(), 
-        status, I2CManager.getErrorMessage(status));
-  if (fail)  _deviceState = DEVSTATE_FAILED;
-}
-//************************* 
-  uint8_t _numDigitalPins = 80;   
-  size_t  digitalBytesNeeded=10;
+  //*************************
+  // Helper function for error handling
+  void reportError(uint8_t status, bool fail = true) {
+    DIAG(F("EX-SensorCAM I2C:%s Error:%d (%S)"), _I2CAddress.toString(), status, I2CManager.getErrorMessage(status));
+    if (fail)
+      _deviceState = DEVSTATE_FAILED;
+  }
+  //*************************
+  uint8_t _numDigitalPins = 80;
+  size_t digitalBytesNeeded = 10;
@@ -395 +432 @@ void reportError(uint8_t status, bool fail=true) {
-  
+
@@ -405 +442 @@ void reportError(uint8_t status, bool fail=true) {
-  bool    _verPrint=true;
+  bool _verPrint = true;
@@ -408,2 +445,2 @@ void reportError(uint8_t status, bool fail=true) {
-  uint8_t _savedCmd[8];           //for repeat 't' command
-  //uint8_t _digitalPinBytes = 10;  // Size of allocated memory buffer (may be longer than needed)
+  uint8_t _savedCmd[8];  // for repeat 't' command
+  // uint8_t _digitalPinBytes = 10;  // Size of allocated memory buffer (may be longer than needed)
@@ -411 +448 @@ void reportError(uint8_t status, bool fail=true) {
-  enum {RDS_IDLE, RDS_DIGITAL, RDS_TSTATE};  // Read operation states
+  enum { RDS_IDLE, RDS_DIGITAL, RDS_TSTATE };  // Read operation states
@@ -413 +450 @@ void reportError(uint8_t status, bool fail=true) {
-  //uint8_t cmdBuffer[7]={0,0,0,0,0,0,0};
+  // uint8_t cmdBuffer[7]={0,0,0,0,0,0,0};
@@ -420,2 +457,2 @@ void reportError(uint8_t status, bool fail=true) {
-    EXIOINIT = 0xE0,    // Flag to initialise setup procedure
-    EXIORDY = 0xE1,     // Flag we have completed setup procedure, also for EX-IO to ACK setup
+    EXIOINIT = 0xE0,  // Flag to initialise setup procedure
+    EXIORDY = 0xE1,   // Flag we have completed setup procedure, also for EX-IO to ACK setup
diff --git a/IO_EXTurntable.cpp b/IO_EXTurntable.cpp
index 0e134d4..70a4b85 100644
--- a/IO_EXTurntable.cpp
+++ b/IO_EXTurntable.cpp
@@ -18 +18 @@
-*/
+ */
@@ -21,9 +21,9 @@
-* The IO_EXTurntable device driver is used to control a turntable via an Arduino with a stepper motor over I2C.
-*
-* The EX-Turntable code lives in a separate repo (https://github.com/DCC-EX/EX-Turntable) and contains the stepper motor logic.
-*
-* This device driver sends a step position to EX-Turntable to indicate the step position to move to using either of these commands:
-* <D TT vpin steps activity> in the serial console
-* MOVETT(vpin, steps, activity) in EX-RAIL
-* Refer to the documentation for further information including the valid activities.
-*/
+ * The IO_EXTurntable device driver is used to control a turntable via an Arduino with a stepper motor over I2C.
+ *
+ * The EX-Turntable code lives in a separate repo (https://github.com/DCC-EX/EX-Turntable) and contains the stepper motor logic.
+ *
+ * This device driver sends a step position to EX-Turntable to indicate the step position to move to using either of these commands:
+ * <D TT vpin steps activity> in the serial console
+ * MOVETT(vpin, steps, activity) in EX-RAIL
+ * Refer to the documentation for further information including the valid activities.
+ */
@@ -74,2 +74,2 @@ void EXTurntable::_loop(unsigned long currentMicros) {
-  if (_stepperStatus != _previousStatus && _stepperStatus == 0) { // Broadcast when a rotation finishes
-    if ( _currentActivity < 4) {
+  if (_stepperStatus != _previousStatus && _stepperStatus == 0) {  // Broadcast when a rotation finishes
+    if (_currentActivity < 4) {
@@ -86,2 +86,3 @@ int EXTurntable::_read(VPIN vpin) {
-  (void)vpin; // surpress warning
-  if (_deviceState == DEVSTATE_FAILED) return 0;
+  (void)vpin;  // surpress warning
+  if (_deviceState == DEVSTATE_FAILED)
+    return 0;
@@ -96,2 +97,2 @@ int EXTurntable::_read(VPIN vpin) {
-void EXTurntable::_broadcastStatus (VPIN vpin, uint8_t status, uint8_t activity) {
-  Turntable *tto = Turntable::getByVpin(vpin);
+void EXTurntable::_broadcastStatus(VPIN vpin, uint8_t status, uint8_t activity) {
+  Turntable* tto = Turntable::getByVpin(vpin);
@@ -110 +111 @@ void EXTurntable::_broadcastStatus (VPIN vpin, uint8_t status, uint8_t activity)
-// 
+//
@@ -122,2 +123,4 @@ void EXTurntable::_writeAnalogue(VPIN vpin, int value, uint8_t activity, uint16_
-  if (_deviceState == DEVSTATE_FAILED) return;
-  if (value < 0) return;
+  if (_deviceState == DEVSTATE_FAILED)
+    return;
+  if (value < 0)
+    return;
@@ -127,4 +130,2 @@ void EXTurntable::_writeAnalogue(VPIN vpin, int value, uint8_t activity, uint16_
-  DIAG(F("EX-Turntable WriteAnalogue VPIN:%u Value:%d Activity:%d Duration:%d"),
-    vpin, value, activity, duration);
-  DIAG(F("I2CManager write I2C Address:%d stepsMSB:%d stepsLSB:%d activity:%d"),
-    _I2CAddress.toString(), stepsMSB, stepsLSB, activity);
+  DIAG(F("EX-Turntable WriteAnalogue VPIN:%u Value:%d Activity:%d Duration:%d"), vpin, value, activity, duration);
+  DIAG(F("I2CManager write I2C Address:%d stepsMSB:%d stepsLSB:%d activity:%d"), _I2CAddress.toString(), stepsMSB, stepsLSB, activity);
@@ -134 +135,2 @@ void EXTurntable::_writeAnalogue(VPIN vpin, int value, uint8_t activity, uint16_
-  if (activity < 4) _stepperStatus = 1;     // Tell the device driver Turntable-EX is busy
+  if (activity < 4)
+    _stepperStatus = 1;  // Tell the device driver Turntable-EX is busy
@@ -137 +139 @@ void EXTurntable::_writeAnalogue(VPIN vpin, int value, uint8_t activity, uint16_
-  _broadcastStatus(vpin, _stepperStatus, activity); // Broadcast when the rotation starts
+  _broadcastStatus(vpin, _stepperStatus, activity);  // Broadcast when the rotation starts
@@ -143,2 +145,2 @@ void EXTurntable::_display() {
-  DIAG(F("EX-Turntable I2C:%s Configured on Vpins:%u-%u %S"), _I2CAddress.toString(), (int)_firstVpin, 
-    (int)_firstVpin+_nPins-1, (_deviceState==DEVSTATE_FAILED) ? F("OFFLINE") : F(""));
+  DIAG(F("EX-Turntable I2C:%s Configured on Vpins:%u-%u %S"), _I2CAddress.toString(), (int)_firstVpin, (int)_firstVpin + _nPins - 1,
+       (_deviceState == DEVSTATE_FAILED) ? F("OFFLINE") : F(""));
diff --git a/IO_EncoderThrottle.cpp b/IO_EncoderThrottle.cpp
index e6019a8..1ce2e9c 100644
--- a/IO_EncoderThrottle.cpp
+++ b/IO_EncoderThrottle.cpp
@@ -18 +18 @@
-*/
+ */
@@ -21,4 +21,4 @@
-* The IO_EncoderThrottle device driver uses a rotary encoder connected to vpins
-* to drive a loco.
-*  Loco id is selected by writeAnalog.
-*/
+ * The IO_EncoderThrottle device driver uses a rotary encoder connected to vpins
+ * to drive a loco.
+ *  Loco id is selected by writeAnalog.
+ */
@@ -30 +30 @@
-const byte _DIR_CW = 0x10;  // Clockwise step
+const byte _DIR_CW = 0x10;   // Clockwise step
@@ -33,6 +33,6 @@ const byte _DIR_CCW = 0x20;  // Counter-clockwise step
-const byte transition_table[5][4]= {
-    {0,1,3,0},            // 0: 00
-    {1,1,1,2 | _DIR_CW},  // 1: 00->01
-    {2,2,0,2},            // 2: 00->01->11
-    {3,3,3,4 | _DIR_CCW}, // 3: 00->10
-    {4,0,4,4}             // 4: 00->10->11
+const byte transition_table[5][4] = {
+    {0, 1, 3, 0},             // 0: 00
+    {1, 1, 1, 2 | _DIR_CW},   // 1: 00->01
+    {2, 2, 0, 2},             // 2: 00->01->11
+    {3, 3, 3, 4 | _DIR_CCW},  // 3: 00->10
+    {4, 0, 4, 4}              // 4: 00->10->11
@@ -43,0 +44,4 @@ const byte _DIR_MASK = 0x30;
+void EncoderThrottle::create(VPIN firstVpin, int dtPin, int clkPin, int clickPin, byte notch) {
+  if (checkNoOverlap(firstVpin))
+    new EncoderThrottle(firstVpin, dtPin, clkPin, clickPin, notch);
+}
@@ -44,0 +49,19 @@ const byte _DIR_MASK = 0x30;
+// Constructor
+EncoderThrottle::EncoderThrottle(VPIN firstVpin, int dtPin, int clkPin, int clickPin, byte notch) {
+  _firstVpin = firstVpin;
+  _nPins = 1;
+  _I2CAddress = 0;
+  _dtPin = dtPin;
+  _clkPin = clkPin;
+  _clickPin = clickPin;
+  _notch = notch;
+  _locoid = 0;
+  _stopState = xrSTOP;
+  _rocoState = 0;
+  _prevpinstate = 4;  // not 01..11
+  IODevice::configureInput(dtPin, true);
+  IODevice::configureInput(clkPin, true);
+  IODevice::configureInput(clickPin, true);
+  addDevice(this);
+  _display();
+}
@@ -46,26 +69,3 @@ const byte _DIR_MASK = 0x30;
-  void EncoderThrottle::create(VPIN firstVpin, int dtPin, int clkPin, int clickPin, byte notch) {
-    if (checkNoOverlap(firstVpin)) new EncoderThrottle(firstVpin, dtPin,clkPin,clickPin,notch);
-  }
-
-
-  // Constructor
-  EncoderThrottle::EncoderThrottle(VPIN firstVpin, int dtPin, int clkPin, int clickPin, byte notch){
-    _firstVpin = firstVpin;
-    _nPins = 1;
-    _I2CAddress = 0;
-    _dtPin=dtPin;
-    _clkPin=clkPin;
-    _clickPin=clickPin;
-    _notch=notch;
-    _locoid=0;
-    _stopState=xrSTOP;
-    _rocoState=0; 
-    _prevpinstate=4; // not 01..11 
-    IODevice::configureInput(dtPin,true);
-    IODevice::configureInput(clkPin,true);
-    IODevice::configureInput(clickPin,true);
-    addDevice(this);
-    _display();
-  }
-
-  
+void EncoderThrottle::_loop(unsigned long currentMicros) {
+  if (_locoid == 0)
+    return;  // not in use
@@ -73,4 +73 @@ const byte _DIR_MASK = 0x30;
-  void EncoderThrottle::_loop(unsigned long currentMicros)  {
-    if (_locoid==0) return;  // not in use
-    
-    // Clicking down on the roco, stops the loco and sets the direction as unknown.
+  // Clicking down on the roco, stops the loco and sets the direction as unknown.
@@ -78,5 +75,6 @@ const byte _DIR_MASK = 0x30;
-    if (_stopState==xrSTOP) return; // debounced multiple stops
-    DCC::setThrottle(_locoid,1,DCC::getThrottleDirection(_locoid));
-    _stopState=xrSTOP;
-    DIAG(F("DRIVE %d STOP"),_locoid);
-    return; 
+    if (_stopState == xrSTOP)
+      return;  // debounced multiple stops
+    DCC::setThrottle(_locoid, 1, DCC::getThrottleDirection(_locoid));
+    _stopState = xrSTOP;
+    DIAG(F("DRIVE %d STOP"), _locoid);
+    return;
@@ -85 +83 @@ const byte _DIR_MASK = 0x30;
-  // read roco pins and detect state change 
+  // read roco pins and detect state change
@@ -87,2 +85,3 @@ const byte _DIR_MASK = 0x30;
-  if (pinstate==_prevpinstate) return;
-  _prevpinstate=pinstate;
+  if (pinstate == _prevpinstate)
+    return;
+  _prevpinstate = pinstate;
@@ -91 +90,2 @@ const byte _DIR_MASK = 0x30;
-  if ((_rocoState & _DIR_MASK) == 0) return; // no value change 
+  if ((_rocoState & _DIR_MASK) == 0)
+    return;  // no value change
@@ -93 +93 @@ const byte _DIR_MASK = 0x30;
-  int change=(_rocoState & _DIR_CW)?+1:-1;
+  int change = (_rocoState & _DIR_CW) ? +1 : -1;
@@ -95,5 +94,0 @@ const byte _DIR_MASK = 0x30;
-  
-  if (_stopState==xrSTOP) {
-      // first move after button press sets the direction. (clockwise=fwd)
-      _stopState=change>0?xrFWD:xrREV;
-    }
@@ -101,17 +96,23 @@ const byte _DIR_MASK = 0x30;
-    // when going fwd, clockwise increases speed. 
-    // but when reversing, anticlockwise increases speed.
-    // This is similar to a center-zero pot control but with
-    // the added safety that you cant panic-spin into the other
-    // direction.
-    if (_stopState==xrREV) change=-change; 
-    //  manage limits
-    int oldspeed=DCC::getThrottleSpeed(_locoid);
-    if (oldspeed==1)oldspeed=0; // break out of estop
-    int  newspeed=change>0 ?  (min((oldspeed+_notch),126)) : (max(0,(oldspeed-_notch)));
-    if (newspeed==1) newspeed=0; // normal decelereated stop. 
-    if (oldspeed!=newspeed) {
-        DIAG(F("DRIVE %d notch %S %d %S"),_locoid,
-             change>0?F("UP"):F("DOWN"),_notch,
-             _stopState==xrFWD?F("FWD"):F("REV"));
-        DCC::setThrottle(_locoid,newspeed,_stopState==xrFWD);
-        }
+  if (_stopState == xrSTOP) {
+    // first move after button press sets the direction. (clockwise=fwd)
+    _stopState = change > 0 ? xrFWD : xrREV;
+  }
+
+  // when going fwd, clockwise increases speed.
+  // but when reversing, anticlockwise increases speed.
+  // This is similar to a center-zero pot control but with
+  // the added safety that you cant panic-spin into the other
+  // direction.
+  if (_stopState == xrREV)
+    change = -change;
+  //  manage limits
+  int oldspeed = DCC::getThrottleSpeed(_locoid);
+  if (oldspeed == 1)
+    oldspeed = 0;  // break out of estop
+  int newspeed = change > 0 ? (min((oldspeed + _notch), 126)) : (max(0, (oldspeed - _notch)));
+  if (newspeed == 1)
+    newspeed = 0;  // normal decelereated stop.
+  if (oldspeed != newspeed) {
+    DIAG(F("DRIVE %d notch %S %d %S"), _locoid, change > 0 ? F("UP") : F("DOWN"), _notch, _stopState == xrFWD ? F("FWD") : F("REV"));
+    DCC::setThrottle(_locoid, newspeed, _stopState == xrFWD);
+  }
@@ -120,16 +121,16 @@ const byte _DIR_MASK = 0x30;
-  // Selocoid as analog value to start drive
-  // use <z vpin locoid [notch]>
-  void EncoderThrottle::_writeAnalogue(VPIN vpin, int value, uint8_t param1, uint16_t param2)  {  
-    (void) param2;
-    _locoid=value;
-    if (param1>0) _notch=param1;
-    _rocoState=0;
-    
-    // If loco is moving, we inherit direction from it.
-    _stopState=xrSTOP;
-    if (_locoid>0) {
-        auto speedbyte=DCC::getThrottleSpeedByte(_locoid);
-        if ((speedbyte & 0x7f) >1) {
-            // loco is moving
-            _stopState= (speedbyte & 0x80)?xrFWD:xrREV;
-        } 
+// Selocoid as analog value to start drive
+// use <z vpin locoid [notch]>
+void EncoderThrottle::_writeAnalogue(VPIN vpin, int value, uint8_t param1, uint16_t param2) {
+  (void)param2;
+  _locoid = value;
+  if (param1 > 0)
+    _notch = param1;
+  _rocoState = 0;
+
+  // If loco is moving, we inherit direction from it.
+  _stopState = xrSTOP;
+  if (_locoid > 0) {
+    auto speedbyte = DCC::getThrottleSpeedByte(_locoid);
+    if ((speedbyte & 0x7f) > 1) {
+      // loco is moving
+      _stopState = (speedbyte & 0x80) ? xrFWD : xrREV;
@@ -137 +137,0 @@ const byte _DIR_MASK = 0x30;
-    _display();
@@ -138,0 +139,2 @@ const byte _DIR_MASK = 0x30;
+  _display();
+}
@@ -140,4 +142,3 @@ const byte _DIR_MASK = 0x30;
-  
-  void EncoderThrottle::_display() {
-    DIAG(F("DRIVE vpin %d loco %d notch %d"),_firstVpin,_locoid,_notch);
-  }
+void EncoderThrottle::_display() {
+  DIAG(F("DRIVE vpin %d loco %d notch %d"), _firstVpin, _locoid, _notch);
+}
diff --git a/IO_EncoderThrottle.h b/IO_EncoderThrottle.h
index 05ce2eb..e3e52df 100644
--- a/IO_EncoderThrottle.h
+++ b/IO_EncoderThrottle.h
@@ -18 +18 @@
-*/
+ */
@@ -21,4 +21,4 @@
-* The IO_EncoderThrottle device driver uses a rotary encoder connected to vpins
-* to drive a loco.
-*  Loco id is selected by writeAnalog.
-*/
+ * The IO_EncoderThrottle device driver uses a rotary encoder connected to vpins
+ * to drive a loco.
+ *  Loco id is selected by writeAnalog.
+ */
@@ -31,8 +31,7 @@ class EncoderThrottle : public IODevice {
-public:
-  
-  static void create(VPIN firstVpin, int dtPin, int clkPin, int clickPin, byte notch=10);
- 
-private:
-  int _dtPin,_clkPin,_clickPin, _locoid, _notch,_prevpinstate; 
-  enum {xrSTOP,xrFWD,xrREV} _stopState;
-  byte _rocoState;  
+ public:
+  static void create(VPIN firstVpin, int dtPin, int clkPin, int clickPin, byte notch = 10);
+
+ private:
+  int _dtPin, _clkPin, _clickPin, _locoid, _notch, _prevpinstate;
+  enum { xrSTOP, xrFWD, xrREV } _stopState;
+  byte _rocoState;
@@ -42,2 +41,2 @@ private:
-  
-  void _loop(unsigned long currentMicros) override ;
+
+  void _loop(unsigned long currentMicros) override;
@@ -48,2 +46,0 @@ private:
-  
-  void _display() override ;
@@ -51 +48,2 @@ private:
- };
+  void _display() override;
+};
diff --git a/IO_ExampleSerial.h b/IO_ExampleSerial.h
index 8ecdb83..bf316fe 100644
--- a/IO_ExampleSerial.h
+++ b/IO_ExampleSerial.h
@@ -3 +3 @@
- *  
+ *
@@ -21 +21 @@
- * To declare a device instance, 
+ * To declare a device instance,
@@ -25 +25 @@
- * 
+ *
@@ -27 +27 @@
- * 
+ *
@@ -29 +29 @@
- * 
+ *
@@ -38,3 +38,3 @@ class IO_ExampleSerial : public IODevice {
-private:
-  // Here we define the device-specific variables.  
-  HardwareSerial *_serial;
+ private:
+  // Here we define the device-specific variables.
+  HardwareSerial* _serial;
@@ -44 +44 @@ private:
-  uint16_t *_pinValues; // Pointer to block of memory containing pin values
+  uint16_t* _pinValues;  // Pointer to block of memory containing pin values
@@ -47 +47 @@ private:
-public:
+ public:
@@ -49,3 +49,4 @@ public:
-  static void create(VPIN firstVpin, int nPins, HardwareSerial *serial, unsigned long baud) {
-    if (checkNoOverlap(firstVpin,nPins)) new IO_ExampleSerial(firstVpin, nPins, serial, baud);
-  } 
+  static void create(VPIN firstVpin, int nPins, HardwareSerial* serial, unsigned long baud) {
+    if (checkNoOverlap(firstVpin, nPins))
+      new IO_ExampleSerial(firstVpin, nPins, serial, baud);
+  }
@@ -53 +54 @@ public:
-protected:
+ protected:
@@ -58 +59 @@ protected:
-  IO_ExampleSerial(VPIN firstVpin, int nPins, HardwareSerial *serial, unsigned long baud) {
+  IO_ExampleSerial(VPIN firstVpin, int nPins, HardwareSerial* serial, unsigned long baud) {
@@ -61 +62 @@ protected:
-    _pinValues = (uint16_t *)calloc(_nPins, sizeof(uint16_t));
+    _pinValues = (uint16_t*)calloc(_nPins, sizeof(uint16_t));
@@ -63 +64 @@ protected:
-    
+
@@ -78,2 +79 @@ protected:
-    for (uint8_t i=0; i<3; i++)
-      _serial->write('#');
+    for (uint8_t i = 0; i < 3; i++) _serial->write('#');
@@ -81 +81 @@ protected:
-  
+
@@ -85,2 +85,2 @@ protected:
-    int pin = vpin -_firstVpin;
-    #ifdef DIAG_IO
+    int pin = vpin - _firstVpin;
+#ifdef DIAG_IO
@@ -88 +88 @@ protected:
-    #endif
+#endif
@@ -101 +100,0 @@ protected:
-
@@ -103 +102 @@ protected:
-    int result = _pinValues[vpin-_firstVpin];
+    int result = _pinValues[vpin - _firstVpin];
@@ -108 +107 @@ protected:
-  // Loop function to do background scanning of the input port.  State 
+  // Loop function to do background scanning of the input port.  State
@@ -117 +116 @@ protected:
-        case 0: // Waiting for start of command
+        case 0:          // Waiting for start of command
@@ -121,2 +120,2 @@ protected:
-        case 1: // Expecting command character
-          if (c == 'N') { // 'Notify' character received
+        case 1:            // Expecting command character
+          if (c == 'N') {  // 'Notify' character received
@@ -126 +125 @@ protected:
-            _inputState = 0; // Unexpected char, reset
+            _inputState = 0;  // Unexpected char, reset
@@ -128 +127 @@ protected:
-        case 2: // reading first parameter (index)
+        case 2:  // reading first parameter (index)
@@ -130,2 +129,2 @@ protected:
-            _inputIndex = _inputIndex * 10 + (c-'0');
-          else if (c==',') 
+            _inputIndex = _inputIndex * 10 + (c - '0');
+          else if (c == ',')
@@ -134 +133 @@ protected:
-            _inputState = 0; // Unexpected char, reset
+            _inputState = 0;  // Unexpected char, reset
@@ -136,4 +135,4 @@ protected:
-        case 3: // reading reading second parameter (value)
-          if (isdigit(c)) 
-            _inputValue = _inputValue * 10 - (c-'0');
-          else if (c=='#') { // End of command
+        case 3:  // reading reading second parameter (value)
+          if (isdigit(c))
+            _inputValue = _inputValue * 10 - (c - '0');
+          else if (c == '#') {  // End of command
@@ -142 +141 @@ protected:
-            if (_inputIndex >= 0 && _inputIndex < _nPins) { // Store value
+            if (_inputIndex >= 0 && _inputIndex < _nPins) {  // Store value
@@ -145 +144 @@ protected:
-            _inputState = 0; // Done, start again.
+            _inputState = 0;  // Done, start again.
@@ -147 +146 @@ protected:
-            _inputState = 0; // Unexpected char, reset
+            _inputState = 0;  // Unexpected char, reset
@@ -156,4 +155,2 @@ protected:
-    DIAG(F("IO_ExampleSerial Configured on Vpins:%u-%u"), (int)_firstVpin, 
-      (int)_firstVpin+_nPins-1);
-    for (int i=0; i<_nPins; i++)
-      DIAG(F("  VPin %2u: %d"), _firstVpin+i, _pinValues[i]);
+    DIAG(F("IO_ExampleSerial Configured on Vpins:%u-%u"), (int)_firstVpin, (int)_firstVpin + _nPins - 1);
+    for (int i = 0; i < _nPins; i++) DIAG(F("  VPin %2u: %d"), _firstVpin + i, _pinValues[i]);
@@ -161,2 +157,0 @@ protected:
-
-
@@ -165 +160 @@ protected:
-#endif // IO_EXAMPLESERIAL_H
+#endif  // IO_EXAMPLESERIAL_H
diff --git a/IO_GPIOBase.h b/IO_GPIOBase.h
index 94265c3..d0db0a4 100644
--- a/IO_GPIOBase.h
+++ b/IO_GPIOBase.h
@@ -3 +3 @@
- *  
+ *
@@ -34,2 +34 @@ class GPIOBase : public IODevice {
-
-protected:
+ protected:
@@ -37 +36 @@ protected:
-  GPIOBase(FSH *deviceName, VPIN firstVpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin);
+  GPIOBase(FSH* deviceName, VPIN firstVpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin);
@@ -40 +39 @@ protected:
-  // Device-specific pin configuration function.  
+  // Device-specific pin configuration function.
@@ -50 +49 @@ protected:
- 
+
@@ -52,5 +51,5 @@ protected:
-  T _portInputState; // 1=high (inactive), 0=low (activated)
-  T _portOutputState; // 1 =high, 0=low
-  T _portMode;  // 0=input, 1=output
-  T _portPullup; // 0=nopullup, 1=pullup
-  T _portInUse;  // 0=not in use, 1=in use
+  T _portInputState;   // 1=high (inactive), 0=low (activated)
+  T _portOutputState;  // 1 =high, 0=low
+  T _portMode;         // 0=input, 1=output
+  T _portPullup;       // 0=nopullup, 1=pullup
+  T _portInUse;        // 0=not in use, 1=in use
@@ -58 +57 @@ protected:
-  static const int _portTickTime = 4000; // 4ms
+  static const int _portTickTime = 4000;  // 4ms
@@ -62 +61 @@ protected:
-  virtual void _readGpioPort(bool immediate=true) = 0;
+  virtual void _readGpioPort(bool immediate = true) = 0;
@@ -67 +66 @@ protected:
-    (void)status; // Suppress compiler warning
+    (void)status;  // Suppress compiler warning
@@ -71 +70 @@ protected:
-  FSH *_deviceName;
+  FSH* _deviceName;
@@ -79,4 +78,3 @@ template <class T>
-GPIOBase<T>::GPIOBase(FSH *deviceName, VPIN firstVpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin) :
-  IODevice(firstVpin, nPins)
-{
-  if (_nPins > (int)sizeof(T)*8) _nPins = sizeof(T)*8;  // Ensure nPins is consistent with the number of bits in T
+GPIOBase<T>::GPIOBase(FSH* deviceName, VPIN firstVpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin) : IODevice(firstVpin, nPins) {
+  if (_nPins > (int)sizeof(T) * 8)
+    _nPins = sizeof(T) * 8;  // Ensure nPins is consistent with the number of bits in T
@@ -90,2 +88,2 @@ GPIOBase<T>::GPIOBase(FSH *deviceName, VPIN firstVpin, uint8_t nPins, I2CAddress
-  _portMode = 0;  // default to input mode
-  _portPullup = -1; // default to pullup enabled
+  _portMode = 0;         // default to input mode
+  _portPullup = -1;      // default to pullup enabled
@@ -93 +91 @@ GPIOBase<T>::GPIOBase(FSH *deviceName, VPIN firstVpin, uint8_t nPins, I2CAddress
-  _portInUse = 0;  // No ports in use initially.
+  _portInUse = 0;        // No ports in use initially.
@@ -99 +97 @@ void GPIOBase<T>::_begin() {
-  if (_gpioInterruptPin >= 0) 
+  if (_gpioInterruptPin >= 0)
@@ -116 +114 @@ void GPIOBase<T>::_begin() {
-// Configuration parameters for inputs: 
+// Configuration parameters for inputs:
@@ -120,2 +118,4 @@ bool GPIOBase<T>::_configure(VPIN vpin, ConfigTypeEnum configType, int paramCoun
-  if (configType != CONFIGURE_INPUT) return false;
-  if (paramCount == 0 || paramCount > 1) return false;
+  if (configType != CONFIGURE_INPUT)
+    return false;
+  if (paramCount == 0 || paramCount > 1)
+    return false;
@@ -124 +124 @@ bool GPIOBase<T>::_configure(VPIN vpin, ConfigTypeEnum configType, int paramCoun
-  #ifdef DIAG_IO
+#ifdef DIAG_IO
@@ -126 +126 @@ bool GPIOBase<T>::_configure(VPIN vpin, ConfigTypeEnum configType, int paramCoun
-  #endif
+#endif
@@ -128 +128 @@ bool GPIOBase<T>::_configure(VPIN vpin, ConfigTypeEnum configType, int paramCoun
-  if (pullup) 
+  if (pullup)
@@ -155,2 +155 @@ void GPIOBase<T>::_loop(unsigned long currentMicros) {
-      DIAG(F("%S I2C:%s Error:%d %S"), _deviceName, _I2CAddress.toString(), status, 
-        I2CManager.getErrorMessage(status));
+      DIAG(F("%S I2C:%s Error:%d %S"), _deviceName, _I2CAddress.toString(), status, I2CManager.getErrorMessage(status));
@@ -159 +158 @@ void GPIOBase<T>::_loop(unsigned long currentMicros) {
-  // Set unused pin and write mode pin value to 1
+    // Set unused pin and write mode pin value to 1
@@ -167 +166 @@ void GPIOBase<T>::_loop(unsigned long currentMicros) {
-      for (int pin=0; pin<_nPins; pin++) {
+      for (int pin = 0; pin < _nPins; pin++) {
@@ -170 +169 @@ void GPIOBase<T>::_loop(unsigned long currentMicros) {
-          IONotifyCallback::invokeAll(_firstVpin+pin, (_portInputState & mask) == 0);
+          IONotifyCallback::invokeAll(_firstVpin + pin, (_portInputState & mask) == 0);
@@ -176 +175 @@ void GPIOBase<T>::_loop(unsigned long currentMicros) {
-    #ifdef DIAG_IO
+#ifdef DIAG_IO
@@ -179 +178 @@ void GPIOBase<T>::_loop(unsigned long currentMicros) {
-    #endif
+#endif
@@ -190 +189 @@ void GPIOBase<T>::_loop(unsigned long currentMicros) {
-      _deviceState= DEVSTATE_SCANNING;
+      _deviceState = DEVSTATE_SCANNING;
@@ -199,2 +198,2 @@ void GPIOBase<T>::_display() {
-  DIAG(F("%S I2C:%s Configured on Vpins:%u-%u %S"), _deviceName, _I2CAddress.toString(), 
-    _firstVpin, _firstVpin+_nPins-1, (_deviceState==DEVSTATE_FAILED) ? F("OFFLINE") : F(""));
+  DIAG(F("%S I2C:%s Configured on Vpins:%u-%u %S"), _deviceName, _I2CAddress.toString(), _firstVpin, _firstVpin + _nPins - 1,
+       (_deviceState == DEVSTATE_FAILED) ? F("OFFLINE") : F(""));
@@ -207 +206 @@ void GPIOBase<T>::_write(VPIN vpin, int value) {
-  #ifdef DIAG_IO
+#ifdef DIAG_IO
@@ -209 +208 @@ void GPIOBase<T>::_write(VPIN vpin, int value) {
-  #endif
+#endif
@@ -219 +218 @@ void GPIOBase<T>::_write(VPIN vpin, int value) {
-  if (value) 
+  if (value)
@@ -241 +240 @@ int GPIOBase<T>::_read(VPIN vpin) {
-  // Set unused pin and write mode pin value to 1
+    // Set unused pin and write mode pin value to 1
@@ -243 +242 @@ int GPIOBase<T>::_read(VPIN vpin) {
-    #ifdef DIAG_IO
+#ifdef DIAG_IO
@@ -245 +244 @@ int GPIOBase<T>::_read(VPIN vpin) {
-    #endif
+#endif
diff --git a/IO_HALDisplay.h b/IO_HALDisplay.h
index 5bf16a1..a7ec3a6 100644
--- a/IO_HALDisplay.h
+++ b/IO_HALDisplay.h
@@ -5 +5 @@
- *  
+ *
@@ -22 +22 @@
-/* 
+/*
@@ -26,3 +26,3 @@
- * without waiting for the next 2.5 second refresh.  However, if the line 
- * specified is off the screen then the text in the bottom line will be 
- * overwritten.  There is however a special case that if line 255 is specified, 
+ * without waiting for the next 2.5 second refresh.  However, if the line
+ * specified is off the screen then the text in the bottom line will be
+ * overwritten.  There is however a special case that if line 255 is specified,
@@ -31 +31 @@
- * 
+ *
@@ -35 +35 @@
- * 
+ *
@@ -38,2 +38,2 @@
- * 
- * Valid width and height are 128x32 (SSD1306 controller), 
+ *
+ * Valid width and height are 128x32 (SSD1306 controller),
@@ -42 +42 @@
- * 
+ *
@@ -44 +44 @@
- * 
+ *
@@ -46 +46 @@
- * 
+ *
@@ -52 +51,0 @@
-
@@ -63 +62 @@ typedef SSD1306AsciiWire OLED;
-typedef LiquidCrystal_I2C LiquidCrystal; 
+typedef LiquidCrystal_I2C LiquidCrystal;
@@ -65 +64 @@ typedef LiquidCrystal_I2C LiquidCrystal;
-template <class T> 
+template <class T>
@@ -67,6 +66,6 @@ class HALDisplay : public IODevice, public DisplayInterface {
-private:
-  // Here we define the device-specific variables.  
-  uint8_t _height; // in pixels
-  uint8_t _width;  // in pixels
-  T *_displayDriver;
-  uint8_t _rowNo = 0;   // Row number being written by caller
+ private:
+  // Here we define the device-specific variables.
+  uint8_t _height;  // in pixels
+  uint8_t _width;   // in pixels
+  T* _displayDriver;
+  uint8_t _rowNo = 0;  // Row number being written by caller
@@ -76,4 +75,4 @@ private:
-  char *_buffer = NULL;
-  uint8_t *_rowGeneration = NULL;
-  uint8_t *_lastRowGeneration = NULL;
-  uint8_t _rowNoToScreen = 0; 
+  char* _buffer = NULL;
+  uint8_t* _rowGeneration = NULL;
+  uint8_t* _lastRowGeneration = NULL;
+  uint8_t _rowNoToScreen = 0;
@@ -82 +81 @@ private:
-  DisplayInterface *_nextDisplay = NULL;
+  DisplayInterface* _nextDisplay = NULL;
@@ -84 +83 @@ private:
-public:
+ public:
@@ -87,2 +86,3 @@ public:
-    if (checkNoOverlap(0, 0, i2cAddress)) new HALDisplay(0, i2cAddress, width, height);
-  } 
+    if (checkNoOverlap(0, 0, i2cAddress))
+      new HALDisplay(0, i2cAddress, width, height);
+  }
@@ -90,2 +90,3 @@ public:
-    if (checkNoOverlap(0, 0, i2cAddress)) new HALDisplay(displayNo, i2cAddress, width, height);
-  } 
+    if (checkNoOverlap(0, 0, i2cAddress))
+      new HALDisplay(displayNo, i2cAddress, width, height);
+  }
@@ -93 +94 @@ public:
-protected:
+ protected:
@@ -97 +98,2 @@ protected:
-    if (!_displayDriver) return;  // Check for memory allocation failure
+    if (!_displayDriver)
+      return;  // Check for memory allocation failure
@@ -107,6 +109,9 @@ protected:
-    _buffer = (char *)calloc(_numRows*_numCols, sizeof(char));
-    if (!_buffer) return;  // Check for memory allocation failure
-    _rowGeneration = (uint8_t *)calloc(_numRows, sizeof(uint8_t));
-    if (!_rowGeneration) return;  // Check for memory allocation failure
-    _lastRowGeneration = (uint8_t *)calloc(_numRows, sizeof(uint8_t));
-    if (!_lastRowGeneration) return;  // Check for memory allocation failure
+    _buffer = (char*)calloc(_numRows * _numCols, sizeof(char));
+    if (!_buffer)
+      return;  // Check for memory allocation failure
+    _rowGeneration = (uint8_t*)calloc(_numRows, sizeof(uint8_t));
+    if (!_rowGeneration)
+      return;  // Check for memory allocation failure
+    _lastRowGeneration = (uint8_t*)calloc(_numRows, sizeof(uint8_t));
+    if (!_lastRowGeneration)
+      return;  // Check for memory allocation failure
@@ -115 +120 @@ protected:
-    memset(_buffer, ' ', _numCols*_numRows);
+    memset(_buffer, ' ', _numCols * _numRows);
@@ -138,2 +143 @@ protected:
-  
-  
+
@@ -143 +147 @@ protected:
-    // characters from the buffer, one character per entry, 
+    // characters from the buffer, one character per entry,
@@ -146 +150 @@ protected:
-    // First check if the OLED driver is still busy from a previous 
+    // First check if the OLED driver is still busy from a previous
@@ -153 +157 @@ protected:
-          _rowNoToScreen = 0; // Wrap to first row
+          _rowNoToScreen = 0;  // Wrap to first row
@@ -167,2 +171,2 @@ protected:
-        _displayDriver->writeNative(_buffer[_rowNoToScreen*_numCols+_charPosToScreen++]);
-      }  
+        _displayDriver->writeNative(_buffer[_rowNoToScreen * _numCols + _charPosToScreen++]);
+      }
@@ -181 +184,0 @@ protected:
-
@@ -185,4 +188,3 @@ protected:
-      for (uint8_t row=0; row<_numRows; row++)
-        _rowGeneration[row]++;
-      
-      // Start with top line (looks better).  
+      for (uint8_t row = 0; row < _numRows; row++) _rowGeneration[row]++;
+
+      // Start with top line (looks better).
@@ -198 +200 @@ protected:
-  
+
@@ -203 +205 @@ protected:
-  
+
@@ -206 +208 @@ protected:
-  // 
+  //
@@ -208,2 +210,2 @@ protected:
-  
-public:
+
+ public:
@@ -220 +222 @@ public:
-      // LCD(255,"xxx") or SCREEN(displayNo,255, "xxx") - 
+      // LCD(255,"xxx") or SCREEN(displayNo,255, "xxx") -
@@ -223,3 +225,3 @@ public:
-      for (int row=1; row<_numRows; row++) {
-        strncpy(&_buffer[(row-1)*_numCols], &_buffer[row*_numCols], _numCols);
-        _rowGeneration[row-1]++;
+      for (int row = 1; row < _numRows; row++) {
+        strncpy(&_buffer[(row - 1) * _numCols], &_buffer[row * _numCols], _numCols);
+        _rowGeneration[row - 1]++;
@@ -227,2 +229,2 @@ public:
-      line = _numRows-1;
-    } else if (line >= _numRows) 
+      line = _numRows - 1;
+    } else if (line >= _numRows)
@@ -233,2 +235 @@ public:
-    for (_colNo = 0; _colNo < _numCols; _colNo++)
-      _buffer[_rowNo*_numCols+_colNo] = ' ';
+    for (_colNo = 0; _colNo < _numCols; _colNo++) _buffer[_rowNo * _numCols + _colNo] = ' ';
@@ -236 +237 @@ public:
-    // Mark that the buffer has been touched.  It will start being 
+    // Mark that the buffer has been touched.  It will start being
@@ -250 +251 @@ public:
-      _buffer[_rowNo*_numCols+_colNo++] = c;
+      _buffer[_rowNo * _numCols + _colNo++] = c;
@@ -258 +259 @@ public:
-    memset(_buffer, ' ', _numCols*_numRows);
+    memset(_buffer, ' ', _numCols * _numRows);
@@ -262 +262,0 @@ public:
-
@@ -265 +265 @@ public:
-#endif // IO_HALDisplay_H
+#endif  // IO_HALDisplay_H
diff --git a/IO_HCSR04.h b/IO_HCSR04.h
index be1d303..6fab5f3 100644
--- a/IO_HCSR04.h
+++ b/IO_HCSR04.h
@@ -3 +3 @@
- *  
+ *
@@ -51 +51 @@
- * 
+ *
@@ -54 +54 @@
- * 
+ *
@@ -60 +60 @@
- * 
+ *
@@ -64 +64 @@
- * 
+ *
@@ -73,2 +73 @@ class HCSR04 : public IODevice {
-
-private:
+ private:
@@ -79,2 +78,2 @@ private:
-  uint8_t _onThreshold;  // cm
-  uint8_t _offThreshold; // cm
+  uint8_t _onThreshold;   // cm
+  uint8_t _offThreshold;  // cm
@@ -83 +82 @@ private:
-  // Active=1/inactive=0 _state 
+  // Active=1/inactive=0 _state
@@ -87 +86 @@ private:
-  const uint16_t factor = 58; // us/cm
+  const uint16_t factor = 58;  // us/cm
@@ -90 +89 @@ private:
-  const uint16_t maxPermittedLoopTime = 10 * factor; // max in us
+  const uint16_t maxPermittedLoopTime = 10 * factor;  // max in us
@@ -93 +92 @@ private:
-  enum {DORMANT, MEASURING}; // _state values
+  enum { DORMANT, MEASURING };  // _state values
@@ -98 +97 @@ private:
-public:
+ public:
@@ -102 +101 @@ public:
- 
+
@@ -106 +105 @@ public:
-        new HCSR04(vpin, trigPin, echoPin, onThreshold, offThreshold, options);
+      new HCSR04(vpin, trigPin, echoPin, onThreshold, offThreshold, options);
@@ -109 +108 @@ public:
-protected:
+ protected:
@@ -111 +110 @@ protected:
-  HCSR04 (VPIN vpin, int trigPin, int echoPin, uint16_t onThreshold, uint16_t offThreshold, uint16_t options) {
+  HCSR04(VPIN vpin, int trigPin, int echoPin, uint16_t onThreshold, uint16_t offThreshold, uint16_t options) {
@@ -121 +120 @@ protected:
- // _begin function called to perform dynamic initialisation of the device
+  // _begin function called to perform dynamic initialisation of the device
@@ -139 +138 @@ protected:
-    (void)vpin; // avoid compiler warning
+    (void)vpin;  // avoid compiler warning
@@ -146,2 +145,2 @@ protected:
-    switch(_state) {
-      case DORMANT: // Issue pulse
+    switch (_state) {
+      case DORMANT:  // Issue pulse
@@ -149 +148,2 @@ protected:
-        if (ArduinoPins::fastReadDigital(_echoPin)) return;
+        if (ArduinoPins::fastReadDigital(_echoPin))
+          return;
@@ -157 +157 @@ protected:
-        // Measured time delay is just under 500us, so 
+        // Measured time delay is just under 500us, so
@@ -176 +176 @@ protected:
-        // If maximum measurement time is high, then skip until next loop entry before 
+        // If maximum measurement time is high, then skip until next loop entry before
@@ -178 +178 @@ protected:
-        // This gives better accuracy at shorter distance thresholds but without extending 
+        // This gives better accuracy at shorter distance thresholds but without extending
@@ -182 +182,2 @@ protected:
-        if (!(_options & LOOP) && _maxTime > maxPermittedLoopTime) break;
+        if (!(_options & LOOP) && _maxTime > maxPermittedLoopTime)
+          break;
@@ -185 +186 @@ protected:
-      case MEASURING: // Check if echo pulse has finished
+      case MEASURING:  // Check if echo pulse has finished
@@ -197 +198 @@ protected:
-              if (estimatedDistance < _distance) 
+              if (estimatedDistance < _distance)
@@ -202 +203 @@ protected:
-              //DIAG(F("HCSR04: Pulse Len=%l Distance=%d"), waitTime, _distance);
+              // DIAG(F("HCSR04: Pulse Len=%l Distance=%d"), waitTime, _distance);
@@ -219 +220 @@ protected:
-              _state = DORMANT; // start again
+              _state = DORMANT;  // start again
@@ -226,2 +227,3 @@ protected:
-          if (!(_options & LOOP) && remainingTime < maxPermittedLoopTime) return;
-        } while (_state == MEASURING) ;
+          if (!(_options & LOOP) && remainingTime < maxPermittedLoopTime)
+            return;
+        } while (_state == MEASURING);
@@ -232,2 +234 @@ protected:
-      delayUntil(currentMicros+60000UL); // wait 60ms till next measurement
-
+      delayUntil(currentMicros + 60000UL);  // wait 60ms till next measurement
@@ -237,2 +238 @@ protected:
-    DIAG(F("HCSR04 Configured on VPIN:%u TrigPin:%d EchoPin:%d On:%dcm Off:%dcm"),
-      _firstVpin, _trigPin, _echoPin, _onThreshold, _offThreshold);
+    DIAG(F("HCSR04 Configured on VPIN:%u TrigPin:%d EchoPin:%d On:%dcm Off:%dcm"), _firstVpin, _trigPin, _echoPin, _onThreshold, _offThreshold);
@@ -240 +239,0 @@ protected:
-
@@ -243 +242 @@ protected:
-#endif //IO_HCSR04_H
+#endif  // IO_HCSR04_H
diff --git a/IO_I2CDFPlayer.h b/IO_I2CDFPlayer.h
index c291b56..78e4dcc 100644
--- a/IO_I2CDFPlayer.h
+++ b/IO_I2CDFPlayer.h
@@ -1 +1 @@
-   /*
+/*
@@ -3 +3 @@
- *  
+ *
@@ -25 +25 @@
- * 
+ *
@@ -29,5 +29,5 @@
- * needed as the RX Fifo holds the reply 
- * 
- * Jan 2024, Issue with using both UARTs simultaniously, the secod uart seems to work  but the first transmit 
- * corrupt data. This need more analysis and experimenatation. 
- * Will push this driver to the dev branch with the uart fixed to 0 
+ * needed as the RX Fifo holds the reply
+ *
+ * Jan 2024, Issue with using both UARTs simultaniously, the secod uart seems to work  but the first transmit
+ * corrupt data. This need more analysis and experimenatation.
+ * Will push this driver to the dev branch with the uart fixed to 0
@@ -35 +35 @@
- * 
+ *
@@ -37 +37 @@
- * 
+ *
@@ -39 +39 @@
- * 
+ *
@@ -46 +46 @@
- * 
+ *
@@ -59,4 +59,4 @@
-//#define DIAG_I2CDFplayer
-//#define DIAG_I2CDFplayer_data
-//#define DIAG_I2CDFplayer_reg
-//#define DIAG_I2CDFplayer_playing
+// #define DIAG_I2CDFplayer
+// #define DIAG_I2CDFplayer_data
+// #define DIAG_I2CDFplayer_reg
+// #define DIAG_I2CDFplayer_playing
@@ -65,2 +65,2 @@ class I2CDFPlayer : public IODevice {
-private: 
-  const uint8_t MAXVOLUME=30;
+ private:
+  const uint8_t MAXVOLUME = 30;
@@ -70 +70 @@ private:
-  unsigned long _commandSendTime; // Time (us) that last transmit took place.
+  unsigned long _commandSendTime;  // Time (us) that last transmit took place.
@@ -73,2 +73,2 @@ private:
-  bool _awaitingResponse = false;  
-  uint8_t _retryCounter = RETRYCOUNT; // Max retries before timing out
+  bool _awaitingResponse = false;
+  uint8_t _retryCounter = RETRYCOUNT;  // Max retries before timing out
@@ -78 +78 @@ private:
-  bool _repeat = false; // audio file is repeat playing
+  bool _repeat = false;     // audio file is repeat playing
@@ -83 +83 @@ private:
-  uint8_t _UART_CH=0x00;  // Fix uart ch to 0 for now
+  uint8_t _UART_CH = 0x00;  // Fix uart ch to 0 for now
@@ -85,4 +85,4 @@ private:
-  uint8_t WORD_LEN = 0x03;    // Value LCR bit 0,1
-  uint8_t STOP_BIT = 0x00;    // Value LCR bit 2 
-  uint8_t PARITY_ENA = 0x00;  // Value LCR bit 3
-  uint8_t PARITY_TYPE = 0x00; // Value LCR bit 4
+  uint8_t WORD_LEN = 0x03;     // Value LCR bit 0,1
+  uint8_t STOP_BIT = 0x00;     // Value LCR bit 2
+  uint8_t PARITY_ENA = 0x00;   // Value LCR bit 3
+  uint8_t PARITY_TYPE = 0x00;  // Value LCR bit 4
@@ -90 +90 @@ private:
-  uint8_t PRESCALER = 0x01;   // Value MCR bit 7
+  uint8_t PRESCALER = 0x01;  // Value MCR bit 7
@@ -93,2 +93,2 @@ private:
-  uint8_t RX_BUFFER = 0x00; // nr of bytes copied into _inbuffer
-  uint8_t FIFO_TX_LEVEL = 0x00;  
+  uint8_t RX_BUFFER = 0x00;  // nr of bytes copied into _inbuffer
+  uint8_t FIFO_TX_LEVEL = 0x00;
@@ -98,2 +98,2 @@ private:
-  uint8_t _requestedFolder = 0x01; // default to folder 01
-  uint8_t _currentFolder = 0x01; // default to folder 01
+  uint8_t _requestedFolder = 0x01;  // default to folder 01
+  uint8_t _currentFolder = 0x01;    // default to folder 01
@@ -105 +105 @@ private:
-  uint8_t _currentEQvalue = DF_NORMAL; // start equalizer value
+  uint8_t _currentEQvalue = DF_NORMAL;  // start equalizer value
@@ -107,5 +107,5 @@ private:
-  uint8_t _audioMixer = 0x01; // Default to output amplifier 1
-  bool _setamCmd = false; // Set the Audio mixer channel
-  uint8_t _outbuffer [11]; // DFPlayer command is 10 bytes + 1 byte register address & UART channel
-  uint8_t _inbuffer[10]; // expected DFPlayer return 10 bytes
-   
+  uint8_t _audioMixer = 0x01;  // Default to output amplifier 1
+  bool _setamCmd = false;      // Set the Audio mixer channel
+  uint8_t _outbuffer[11];      // DFPlayer command is 10 bytes + 1 byte register address & UART channel
+  uint8_t _inbuffer[10];       // expected DFPlayer return 10 bytes
+
@@ -113,4 +113,4 @@ private:
-  unsigned long SC16IS752_XTAL_FREQ_LOW = 1843200; // To support cheap eBay/AliExpress SC16IS752 boards
-  unsigned long SC16IS752_XTAL_FREQ_HIGH = 14745600; // Support for higher baud rates, standard for modular EX-IO system
-   
-public:
+  unsigned long SC16IS752_XTAL_FREQ_LOW = 1843200;    // To support cheap eBay/AliExpress SC16IS752 boards
+  unsigned long SC16IS752_XTAL_FREQ_HIGH = 14745600;  // Support for higher baud rates, standard for modular EX-IO system
+
+ public:
@@ -118 +118 @@ public:
-   I2CDFPlayer(VPIN firstVpin, int nPins, I2CAddress i2cAddress, uint8_t xtal){
+  I2CDFPlayer(VPIN firstVpin, int nPins, I2CAddress i2cAddress, uint8_t xtal) {
@@ -122 +122 @@ public:
-    if (xtal == 0){
+    if (xtal == 0) {
@@ -124,3 +124,3 @@ public:
-    } else { // should be 1
-        _sc16is752_xtal_freq = SC16IS752_XTAL_FREQ_HIGH;
-      }
+    } else {  // should be 1
+      _sc16is752_xtal_freq = SC16IS752_XTAL_FREQ_HIGH;
+    }
@@ -128,3 +128,3 @@ public:
-   } 
-  
-public:
+  }
+
+ public:
@@ -132,2 +132,3 @@ public:
-    if (checkNoOverlap(firstVpin, nPins, i2cAddress)) new I2CDFPlayer(firstVpin, nPins, i2cAddress, xtal); 
-    }
+    if (checkNoOverlap(firstVpin, nPins, i2cAddress))
+      new I2CDFPlayer(firstVpin, nPins, i2cAddress, xtal);
+  }
@@ -139 +140 @@ public:
-    if (I2CManager.exists(_I2CAddress)){
+    if (I2CManager.exists(_I2CAddress)) {
@@ -141,2 +142,2 @@ public:
-      Init_SC16IS752(); // Initialize UART
-      if (_deviceState == DEVSTATE_FAILED){
+      Init_SC16IS752();  // Initialize UART
+      if (_deviceState == DEVSTATE_FAILED) {
@@ -144,16 +145,15 @@ public:
-        }
-      } else {
-         DIAG(F("SC16IS752 I2C:%s UART not detected"), _I2CAddress.toString());
-        }
-      #if defined(DIAG_IO)
-      _display();
-      #endif
-      // Now init DFPlayer
-      // Send a query to the device to see if it responds
-      _deviceState = DEVSTATE_INITIALISING; 
-      sendPacket(0x42,0,0);
-      _timeoutTime = micros() + 5000000UL;  // 5 second timeout      
-      _awaitingResponse = true; 
-     }
-  
-  
+      }
+    } else {
+      DIAG(F("SC16IS752 I2C:%s UART not detected"), _I2CAddress.toString());
+    }
+#if defined(DIAG_IO)
+    _display();
+#endif
+    // Now init DFPlayer
+    // Send a query to the device to see if it responds
+    _deviceState = DEVSTATE_INITIALISING;
+    sendPacket(0x42, 0, 0);
+    _timeoutTime = micros() + 5000000UL;  // 5 second timeout
+    _awaitingResponse = true;
+  }
+
@@ -163,2 +163,3 @@ public:
-    if (status == I2C_STATUS_PENDING) return;  // Busy, so don't do anything
-    if (status == I2C_STATUS_OK) { 
+    if (status == I2C_STATUS_PENDING)
+      return;  // Busy, so don't do anything
+    if (status == I2C_STATUS_OK) {
@@ -166,4 +167,4 @@ public:
-          // Check if a command sent to device has timed out.  Allow 0.5 second for response
-          // added retry counter, sometimes we do not sent keep alive due to other commands sent to DFPlayer
-      if (_awaitingResponse && (int32_t)(currentMicros - _timeoutTime) > 0) { // timeout triggered
-        if(_retryCounter == 0){ // retry counter out of luck, must take the device to failed state     
+      // Check if a command sent to device has timed out.  Allow 0.5 second for response
+      // added retry counter, sometimes we do not sent keep alive due to other commands sent to DFPlayer
+      if (_awaitingResponse && (int32_t)(currentMicros - _timeoutTime) > 0) {  // timeout triggered
+        if (_retryCounter == 0) {                                              // retry counter out of luck, must take the device to failed state
@@ -175,10 +176,10 @@ public:
-        } else { // timeout and retry protection and recovery of corrupt data frames from DFPlayer
-            #ifdef DIAG_I2CDFplayer_playing
-              DIAG(F("I2CDFPlayer: %s, DFPlayer timout, retry counter: %d on UART channel: 0x%x"), _I2CAddress.toString(), _retryCounter, _UART_CH);
-            #endif
-            _timeoutTime = currentMicros + 5000000UL;  // Timeout if no response within 5 seconds// reset timeout
-            _awaitingResponse = false; // trigger sending a keep alive 0x42 in processOutgoing()
-            _retryCounter --; // decrement retry counter                        
-            resetRX_fifo(); // reset the RX fifo as it has corrupt data            
-          }
-      }      
+        } else {  // timeout and retry protection and recovery of corrupt data frames from DFPlayer
+#ifdef DIAG_I2CDFplayer_playing
+          DIAG(F("I2CDFPlayer: %s, DFPlayer timout, retry counter: %d on UART channel: 0x%x"), _I2CAddress.toString(), _retryCounter, _UART_CH);
+#endif
+          _timeoutTime = currentMicros + 5000000UL;  // Timeout if no response within 5 seconds// reset timeout
+          _awaitingResponse = false;                 // trigger sending a keep alive 0x42 in processOutgoing()
+          _retryCounter--;                           // decrement retry counter
+          resetRX_fifo();                            // reset the RX fifo as it has corrupt data
+        }
+      }
@@ -188 +189,2 @@ public:
-    if (status == I2C_STATUS_PENDING) return;  // Busy, try next time
+    if (status == I2C_STATUS_PENDING)
+      return;  // Busy, try next time
@@ -190 +192 @@ public:
-     // Send any commands that need to go.
+      // Send any commands that need to go.
@@ -192,2 +194,2 @@ public:
-     }
-    delayUntil(currentMicros + 10000); // Only enter every 10ms    
+    }
+    delayUntil(currentMicros + 10000);  // Only enter every 10ms
@@ -196 +197,0 @@ public:
- 
@@ -198 +199 @@ public:
- 
+
@@ -202,4 +203,4 @@ public:
-    if (FIFO_RX_LEVEL >= 10) {      
-      #ifdef DIAG_I2CDFplayer
-        DIAG(F("I2CDFPlayer: %s Retrieving data from RX Fifo on UART_CH: 0x%x FIFO_RX_LEVEL: %d"),_I2CAddress.toString(), _UART_CH, FIFO_RX_LEVEL); 
-      #endif
+    if (FIFO_RX_LEVEL >= 10) {
+#ifdef DIAG_I2CDFplayer
+      DIAG(F("I2CDFPlayer: %s Retrieving data from RX Fifo on UART_CH: 0x%x FIFO_RX_LEVEL: %d"), _I2CAddress.toString(), _UART_CH, FIFO_RX_LEVEL);
+#endif
@@ -208,12 +209,7 @@ public:
-      I2CManager.read(_I2CAddress, _inbuffer, 10, _outbuffer, 1); // inbuffer[] has the data now
-      //delayUntil(currentMicros + 10000); // Allow time to get the data
-      RX_BUFFER = 10; // We have copied 10 bytes from RX FIFO to _inbuffer
-        #ifdef DIAG_I2CDFplayer_data
-          DIAG(F("SC16IS752: At I2C: %s, UART channel: 0x%x, RX FIFO Data"), _I2CAddress.toString(), _UART_CH);
-          for (int i = 0; i < sizeof _inbuffer; i++){
-            DIAG(F("SC16IS752: Data _inbuffer[0x%x]: 0x%x"), i, _inbuffer[i]);  
-          }
-        #endif       
-    } else {
-        FIFO_RX_LEVEL = 0; //set to 0, we'll read a fresh FIFO_RX_LEVEL next time
-        return; // No data or not enough data in rx fifo, check again next time around
+      I2CManager.read(_I2CAddress, _inbuffer, 10, _outbuffer, 1);  // inbuffer[] has the data now
+      // delayUntil(currentMicros + 10000); // Allow time to get the data
+      RX_BUFFER = 10;  // We have copied 10 bytes from RX FIFO to _inbuffer
+#ifdef DIAG_I2CDFplayer_data
+      DIAG(F("SC16IS752: At I2C: %s, UART channel: 0x%x, RX FIFO Data"), _I2CAddress.toString(), _UART_CH);
+      for (int i = 0; i < sizeof _inbuffer; i++) {
+        DIAG(F("SC16IS752: Data _inbuffer[0x%x]: 0x%x"), i, _inbuffer[i]);
@@ -220,0 +217,5 @@ public:
+#endif
+    } else {
+      FIFO_RX_LEVEL = 0;  // set to 0, we'll read a fresh FIFO_RX_LEVEL next time
+      return;             // No data or not enough data in rx fifo, check again next time around
+    }
@@ -222 +222,0 @@ public:
-    
@@ -224 +224 @@ public:
-    //DIAG(F("I2CDFPlayer: RX_BUFFER: %d"), RX_BUFFER);
+    // DIAG(F("I2CDFPlayer: RX_BUFFER: %d"), RX_BUFFER);
@@ -226 +226 @@ public:
-      int c = _inbuffer[_inputIndex]; // Start at 0, increment to FIFO_RX_LEVEL
+      int c = _inbuffer[_inputIndex];  // Start at 0, increment to FIFO_RX_LEVEL
@@ -229 +229,2 @@ public:
-          if (c == 0x7E) ok = true;
+          if (c == 0x7E)
+            ok = true;
@@ -232 +233,2 @@ public:
-          if (c == 0xFF) ok = true;
+          if (c == 0xFF)
+            ok = true;
@@ -235 +237,2 @@ public:
-          if (c== 0x06) ok = true;
+          if (c == 0x06)
+            ok = true;
@@ -238 +241 @@ public:
-          _recvCMD = c; // CMD byte
+          _recvCMD = c;  // CMD byte
@@ -243 +246 @@ public:
-            //DIAG(F("I2CDFPlayer: %s, _recvCMD: 0x%x _awaitingResponse: 0x0%x"),_I2CAddress.toString(), _recvCMD, _awaitingResponse);
+            // DIAG(F("I2CDFPlayer: %s, _recvCMD: 0x%x _awaitingResponse: 0x0%x"),_I2CAddress.toString(), _recvCMD, _awaitingResponse);
@@ -246 +249 @@ public:
-              _playing = (c != 0);              
+              _playing = (c != 0);
@@ -248 +251 @@ public:
-              if (_deviceState==DEVSTATE_INITIALISING) {
+              if (_deviceState == DEVSTATE_INITIALISING) {
@@ -250,4 +253,4 @@ public:
-                #ifdef DIAG_I2CDFplayer
-                 DIAG(F("I2CDFPlayer: %s, UART_CH: 0x0%x, _deviceState: 0x0%x"),_I2CAddress.toString(), _UART_CH, _deviceState);
-                #endif 
-                #ifdef DIAG_IO
+#ifdef DIAG_I2CDFplayer
+                DIAG(F("I2CDFPlayer: %s, UART_CH: 0x0%x, _deviceState: 0x0%x"), _I2CAddress.toString(), _UART_CH, _deviceState);
+#endif
+#ifdef DIAG_IO
@@ -255 +258 @@ public:
-                #endif
+#endif
@@ -259 +262 @@ public:
-            case 0x3d:            
+            case 0x3d:
@@ -262,3 +265,3 @@ public:
-                #ifdef DIAG_IO
-                  DIAG(F("I2CDFPlayer: Finished"));
-                #endif
+#ifdef DIAG_IO
+                DIAG(F("I2CDFPlayer: Finished"));
+#endif
@@ -276 +279,4 @@ public:
-        case 4: case 5: case 7: case 8: 
+        case 4:
+        case 5:
+        case 7:
+        case 8:
@@ -280 +286 @@ public:
-          if (c==0xef) {
+          if (c == 0xef) {
@@ -282 +288 @@ public:
-            _retryCounter = RETRYCOUNT; // reset the retry counter as we have received a valid packet
+            _retryCounter = RETRYCOUNT;  // reset the retry counter as we have received a valid packet
@@ -288 +294 @@ public:
-      if (ok){
+      if (ok) {
@@ -290 +296 @@ public:
-        RX_BUFFER --; // Decrease FIFO_RX_LEVEL with each character read from _inbuffer[_inputIndex]
+        RX_BUFFER--;    // Decrease FIFO_RX_LEVEL with each character read from _inbuffer[_inputIndex]
@@ -296 +302 @@ public:
-    RX_BUFFER = 0; //Set to 0, we'll read a new RX FIFO level again
+    RX_BUFFER = 0;  // Set to 0, we'll read a new RX FIFO level again
@@ -299 +304,0 @@ public:
-
@@ -302 +307 @@ public:
-    // When two commands are sent in quick succession, the device will often fail to 
+    // When two commands are sent in quick succession, the device will often fail to
@@ -307,8 +312,8 @@ public:
-      if ( _resetCmd == true){
-          sendPacket(0x0C,0,0);
-          _resetCmd = false;          
-      } else if(_volCmd == true) { // do the volme before palying a track
-         if(_requestedVolumeLevel >= 0 && _requestedVolumeLevel <= 30){         
-         _currentVolume = _requestedVolumeLevel; // If _requestedVolumeLevel is out of range, sent _currentV1olume      
-         }
-         sendPacket(0x06, 0x00, _currentVolume);
+      if (_resetCmd == true) {
+        sendPacket(0x0C, 0, 0);
+        _resetCmd = false;
+      } else if (_volCmd == true) {  // do the volme before palying a track
+        if (_requestedVolumeLevel >= 0 && _requestedVolumeLevel <= 30) {
+          _currentVolume = _requestedVolumeLevel;  // If _requestedVolumeLevel is out of range, sent _currentV1olume
+        }
+        sendPacket(0x06, 0x00, _currentVolume);
@@ -319,5 +324,6 @@ public:
-          #ifdef DIAG_I2CDFplayer_playing
-           DIAG(F("I2CDFPlayer: _requestedVolumeLevel: %u, _requestedSong: %u, _currentFolder: %u _playCmd: 0x%x"), _requestedVolumeLevel, _requestedSong, _currentFolder, _playCmd);
-          #endif               
-          sendPacket(0x0F, _currentFolder, _requestedSong);  // audio file in folder          
-          _requestedSong = -1; 
+#ifdef DIAG_I2CDFplayer_playing
+          DIAG(F("I2CDFPlayer: _requestedVolumeLevel: %u, _requestedSong: %u, _currentFolder: %u _playCmd: 0x%x"), _requestedVolumeLevel,
+               _requestedSong, _currentFolder, _playCmd);
+#endif
+          sendPacket(0x0F, _currentFolder, _requestedSong);  // audio file in folder
+          _requestedSong = -1;
@@ -325,7 +331,7 @@ public:
-        }           
-      } //else if (_requestedSong == 0) {
-        else if (_stopplayCmd == true) {
-          #ifdef DIAG_I2CDFplayer_playing
-           DIAG(F("I2CDFPlayer: Stop playing: _stopplayCmd: 0x%x"), _stopplayCmd);
-          #endif
-        sendPacket(0x16, 0x00, 0x00);  // Stop playing        
+        }
+      }  // else if (_requestedSong == 0) {
+      else if (_stopplayCmd == true) {
+#ifdef DIAG_I2CDFplayer_playing
+        DIAG(F("I2CDFPlayer: Stop playing: _stopplayCmd: 0x%x"), _stopplayCmd);
+#endif
+        sendPacket(0x16, 0x00, 0x00);  // Stop playing
@@ -333 +339 @@ public:
-        _repeat = false; // reset repeat        
+        _repeat = false;  // reset repeat
@@ -335,8 +341,8 @@ public:
-        } else if (_folderCmd == true) {
-          #ifdef DIAG_I2CDFplayer_playing
-           DIAG(F("I2CDFPlayer: Folder: _folderCmd: 0x%x, _requestedFolder: %d"), _stopplayCmd, _requestedFolder);
-          #endif
-          if (_currentFolder != _requestedFolder){
-            _currentFolder = _requestedFolder;
-          }
-          _folderCmd = false;
+      } else if (_folderCmd == true) {
+#ifdef DIAG_I2CDFplayer_playing
+        DIAG(F("I2CDFPlayer: Folder: _folderCmd: 0x%x, _requestedFolder: %d"), _stopplayCmd, _requestedFolder);
+#endif
+        if (_currentFolder != _requestedFolder) {
+          _currentFolder = _requestedFolder;
+        }
+        _folderCmd = false;
@@ -344,5 +350,5 @@ public:
-        if(_repeat == false) { // No repeat play currently
-          #ifdef DIAG_I2CDFplayer_playing
-           DIAG(F("I2CDFPlayer: Repeat: _repeatCmd: 0x%x, _requestedSong: %d, _repeat: 0x0%x"), _repeatCmd, _requestedSong, _repeat);
-          #endif 
-          sendPacket(0x08, 0x00, _requestedSong);  // repeat playing audio file in root folder          
+        if (_repeat == false) {  // No repeat play currently
+#ifdef DIAG_I2CDFplayer_playing
+          DIAG(F("I2CDFPlayer: Repeat: _repeatCmd: 0x%x, _requestedSong: %d, _repeat: 0x0%x"), _repeatCmd, _requestedSong, _repeat);
+#endif
+          sendPacket(0x08, 0x00, _requestedSong);  // repeat playing audio file in root folder
@@ -350 +356 @@ public:
-          _repeat = true; 
+          _repeat = true;
@@ -352,6 +358,6 @@ public:
-        _repeatCmd= false;      
-      } else if (_daconCmd == true) { // Always turn DAC on
-        #ifdef DIAG_I2CDFplayer_playing
-          DIAG(F("I2CDFPlayer: DACON: _daconCmd: 0x%x"), _daconCmd);
-        #endif 
-        sendPacket(0x1A,0,0x00);
+        _repeatCmd = false;
+      } else if (_daconCmd == true) {  // Always turn DAC on
+#ifdef DIAG_I2CDFplayer_playing
+        DIAG(F("I2CDFPlayer: DACON: _daconCmd: 0x%x"), _daconCmd);
+#endif
+        sendPacket(0x1A, 0, 0x00);
@@ -359,5 +365,5 @@ public:
-      } else if (_eqCmd == true){ // Set Equalizer, values 0x00 - 0x05        
-        if (_currentEQvalue != _requestedEQValue){
-          #ifdef DIAG_I2CDFplayer_playing
-           DIAG(F("I2CDFPlayer: EQ: _eqCmd: 0x%x, _currentEQvalue: 0x0%x, _requestedEQValue: 0x0%x"), _eqCmd, _currentEQvalue, _requestedEQValue);
-          #endif 
+      } else if (_eqCmd == true) {  // Set Equalizer, values 0x00 - 0x05
+        if (_currentEQvalue != _requestedEQValue) {
+#ifdef DIAG_I2CDFplayer_playing
+          DIAG(F("I2CDFPlayer: EQ: _eqCmd: 0x%x, _currentEQvalue: 0x0%x, _requestedEQValue: 0x0%x"), _eqCmd, _currentEQvalue, _requestedEQValue);
+#endif
@@ -365 +371 @@ public:
-          sendPacket(0x07,0x00,_currentEQvalue);
+          sendPacket(0x07, 0x00, _currentEQvalue);
@@ -368,21 +374,21 @@ public:
-      } else if (_setamCmd == true){ // Set Audio mixer channel
-         setGPIO(); // Set the audio mixer channel
-         /*        
-          if (_audioMixer == 1){ // set to audio mixer 1       
-            if (_UART_CH == 0){ 
-              TEMP_REG_VAL |= (0x01 << _UART_CH); //Set GPIO pin 0 to high
-            } else { // must be UART 1
-              TEMP_REG_VAL |= (0x01 << _UART_CH); //Set GPIO pin 1 to high
-              }
-           //_setamCmd = false;
-           //UART_WriteRegister(REG_IOSTATE, TEMP_REG_VAL);
-          } else { // set to audio mixer 2
-              if (_UART_CH == 0){ 
-                TEMP_REG_VAL &= (0x00 << _UART_CH); //Set GPIO pin 0 to Low
-              } else { // must be UART 1
-                TEMP_REG_VAL &= (0x00 << _UART_CH); //Set GPIO pin 1 to Low
-                }
-              //_setamCmd = false;
-              //UART_WriteRegister(REG_IOSTATE, TEMP_REG_VAL);
-            }*/
-        _setamCmd = false;        
+      } else if (_setamCmd == true) {  // Set Audio mixer channel
+        setGPIO();                     // Set the audio mixer channel
+                                       /*
+                                        if (_audioMixer == 1){ // set to audio mixer 1
+                                          if (_UART_CH == 0){
+                                            TEMP_REG_VAL |= (0x01 << _UART_CH); //Set GPIO pin 0 to high
+                                          } else { // must be UART 1
+                                            TEMP_REG_VAL |= (0x01 << _UART_CH); //Set GPIO pin 1 to high
+                                            }
+                                         //_setamCmd = false;
+                                         //UART_WriteRegister(REG_IOSTATE, TEMP_REG_VAL);
+                                        } else { // set to audio mixer 2
+                                            if (_UART_CH == 0){
+                                              TEMP_REG_VAL &= (0x00 << _UART_CH); //Set GPIO pin 0 to Low
+                                            } else { // must be UART 1
+                                              TEMP_REG_VAL &= (0x00 << _UART_CH); //Set GPIO pin 1 to Low
+                                              }
+                                            //_setamCmd = false;
+                                            //UART_WriteRegister(REG_IOSTATE, TEMP_REG_VAL);
+                                          }*/
+        _setamCmd = false;
@@ -392,4 +398,4 @@ public:
-          #ifdef DIAG_I2CDFplayer_playing
-           DIAG(F("I2CDFPlayer: Send keepalive") );
-          #endif
-        sendPacket(0x42,0,0); 
+#ifdef DIAG_I2CDFplayer_playing
+        DIAG(F("I2CDFPlayer: Send keepalive"));
+#endif
+        sendPacket(0x42, 0, 0);
@@ -397,3 +403,3 @@ public:
-          #ifdef DIAG_I2CDFplayer_playing
-           DIAG(F("I2CDFPlayer: Send keepalive, _awaitingResponse: 0x0%x"), _awaitingResponse );
-          #endif
+#ifdef DIAG_I2CDFplayer_playing
+          DIAG(F("I2CDFPlayer: Send keepalive, _awaitingResponse: 0x0%x"), _awaitingResponse);
+#endif
@@ -404 +410 @@ public:
-    }  
+    }
@@ -407 +412,0 @@ public:
-
@@ -410,4 +415,5 @@ public:
-    if (_deviceState == DEVSTATE_FAILED) return;
-      #ifdef DIAG_IO
-        DIAG(F("I2CDFPlayer: Writing to any vPin not supported"));
-      #endif
+    if (_deviceState == DEVSTATE_FAILED)
+      return;
+#ifdef DIAG_IO
+    DIAG(F("I2CDFPlayer: Writing to any vPin not supported"));
+#endif
@@ -416 +421,0 @@ public:
-
@@ -419 +424 @@ public:
-  // If value is zero, the player stops playing.  
+  // If value is zero, the player stops playing.
@@ -424,6 +429,7 @@ public:
-  //void _writeAnalogue(VPIN vpin, int value, uint8_t volume=0, uint16_t=0) override { 
-  void _writeAnalogue(VPIN vpin, int value, uint8_t volume=0, uint16_t cmd=0) override { 
-    if (_deviceState == DEVSTATE_FAILED) return;    
-    #ifdef DIAG_IO
-      DIAG(F("I2CDFPlayer: VPIN:%u FileNo:%d Volume:%d Command:0x%x"), vpin, value, volume, cmd);
-    #endif
+  // void _writeAnalogue(VPIN vpin, int value, uint8_t volume=0, uint16_t=0) override {
+  void _writeAnalogue(VPIN vpin, int value, uint8_t volume = 0, uint16_t cmd = 0) override {
+    if (_deviceState == DEVSTATE_FAILED)
+      return;
+#ifdef DIAG_IO
+    DIAG(F("I2CDFPlayer: VPIN:%u FileNo:%d Volume:%d Command:0x%x"), vpin, value, volume, cmd);
+#endif
@@ -431,31 +437,9 @@ public:
-    if (pin == 0) { // Enhanced DFPlayer commands, do nothing if not vPin 0     
-     // Read command and value
-      switch (cmd){
-       //case NONE:
-       // DFPlayerCmd = cmd;
-       // break;
-       case DF_PLAY:
-        _playCmd = true;
-        _volCmd = true;        
-        _requestedSong = value;
-        _requestedVolumeLevel = volume; 
-        _playing = true;        
-        break;
-        case DF_VOL:
-          _volCmd = true;          
-          _requestedVolumeLevel = volume;
-        break;
-       case DF_FOLDER:
-        _folderCmd = true;
-        if (volume <= 0 || volume > 99){ // Range checking, valid values 1-99, else default to 1
-          _requestedFolder = 0x01; // if outside range, default to folder 01  
-        } else {
-          _requestedFolder = volume;
-        }        
-        break;
-       case DF_REPEATPLAY: // Need to check if _repeat == true, if so do nothing        
-        if (_repeat == false) {
-           #ifdef DIAG_I2CDFplayer_playing
-              DIAG(F("I2CDFPlayer: WriteAnalog Repeat: _repeat: 0x0%x, value: %d _repeatCmd: 0x%x"), _repeat, value, _repeatCmd);
-           #endif
-          _repeatCmd = true;          
+    if (pin == 0) {  // Enhanced DFPlayer commands, do nothing if not vPin 0
+                     // Read command and value
+      switch (cmd) {
+        // case NONE:
+        //  DFPlayerCmd = cmd;
+        //  break;
+        case DF_PLAY:
+          _playCmd = true;
+          _volCmd = true;
@@ -464,8 +448,30 @@ public:
-          _playing = true;         
-        }
-        break;
-       case DF_STOPPLAY:
-        _stopplayCmd = true;        
-        break;
-       case DF_EQ:
-        #ifdef DIAG_I2CDFplayer_playing
+          _playing = true;
+          break;
+        case DF_VOL:
+          _volCmd = true;
+          _requestedVolumeLevel = volume;
+          break;
+        case DF_FOLDER:
+          _folderCmd = true;
+          if (volume <= 0 || volume > 99) {  // Range checking, valid values 1-99, else default to 1
+            _requestedFolder = 0x01;         // if outside range, default to folder 01
+          } else {
+            _requestedFolder = volume;
+          }
+          break;
+        case DF_REPEATPLAY:  // Need to check if _repeat == true, if so do nothing
+          if (_repeat == false) {
+#ifdef DIAG_I2CDFplayer_playing
+            DIAG(F("I2CDFPlayer: WriteAnalog Repeat: _repeat: 0x0%x, value: %d _repeatCmd: 0x%x"), _repeat, value, _repeatCmd);
+#endif
+            _repeatCmd = true;
+            _requestedSong = value;
+            _requestedVolumeLevel = volume;
+            _playing = true;
+          }
+          break;
+        case DF_STOPPLAY:
+          _stopplayCmd = true;
+          break;
+        case DF_EQ:
+#ifdef DIAG_I2CDFplayer_playing
@@ -473,6 +479,6 @@ public:
-        #endif
-        _eqCmd = true;        
-        if (volume <= 0 || volume > 5) { // If out of range, default to NORMAL
-          _requestedEQValue = DF_NORMAL;            
-        } else { // Valid EQ parameter range
-          _requestedEQValue = volume;     
+#endif
+          _eqCmd = true;
+          if (volume <= 0 || volume > 5) {  // If out of range, default to NORMAL
+            _requestedEQValue = DF_NORMAL;
+          } else {  // Valid EQ parameter range
+            _requestedEQValue = volume;
@@ -480,6 +486,6 @@ public:
-        break;        
-       case DF_RESET:
-        _resetCmd = true;      
-        break; 
-       case DF_DACON: // Works, but without the DACOFF command limited value, except when not relying on DFPlayer default to turn the DAC on
-        #ifdef DIAG_I2CDFplayer_playing
+          break;
+        case DF_RESET:
+          _resetCmd = true;
+          break;
+        case DF_DACON:  // Works, but without the DACOFF command limited value, except when not relying on DFPlayer default to turn the DAC on
+#ifdef DIAG_I2CDFplayer_playing
@@ -487,4 +493,4 @@ public:
-        #endif
-        _daconCmd = true;
-        break;
-        case DF_SETAM: // Set the audio mixer channel to 1 or 2
+#endif
+          _daconCmd = true;
+          break;
+        case DF_SETAM:  // Set the audio mixer channel to 1 or 2
@@ -492,11 +498,11 @@ public:
-          #ifdef DIAG_I2CDFplayer_playing
-            DIAG(F("I2CDFPlayer: WrtieAnalog SETAM: cmd: 0x%x"), cmd);
-          #endif
-          if (volume <= 0 || volume > 2) { // If out of range, default to 1
-            _audioMixer = 1;            
-          } else { // Valid SETAM parameter in range
-              _audioMixer = volume; // _audioMixer valid values 1 or 2
-            }          
-        break;
-       default:
-        break;
+#ifdef DIAG_I2CDFplayer_playing
+          DIAG(F("I2CDFPlayer: WrtieAnalog SETAM: cmd: 0x%x"), cmd);
+#endif
+          if (volume <= 0 || volume > 2) {  // If out of range, default to 1
+            _audioMixer = 1;
+          } else {                 // Valid SETAM parameter in range
+            _audioMixer = volume;  // _audioMixer valid values 1 or 2
+          }
+          break;
+        default:
+          break;
@@ -504 +510 @@ public:
-    }    
+    }
@@ -509 +515,2 @@ public:
-    if (_deviceState == DEVSTATE_FAILED) return false;
+    if (_deviceState == DEVSTATE_FAILED)
+      return false;
@@ -511,3 +518,2 @@ public:
-      if (pin == 0) { // Do nothing if not vPin 0
-        return _playing;
-      }
+    if (pin == 0) {  // Do nothing if not vPin 0
+      return _playing;
@@ -514,0 +521 @@ public:
+  }
@@ -517,2 +524,2 @@ public:
-    DIAG(F("I2CDFPlayer Configured on Vpins:%u-%u %S"), _firstVpin, _firstVpin+_nPins-1,
-      (_deviceState==DEVSTATE_FAILED) ? F("OFFLINE") : F(""));
+    DIAG(F("I2CDFPlayer Configured on Vpins:%u-%u %S"), _firstVpin, _firstVpin + _nPins - 1,
+         (_deviceState == DEVSTATE_FAILED) ? F("OFFLINE") : F(""));
@@ -520,2 +527,2 @@ public:
-  
-private: 
+
+ private:
@@ -534,14 +541,5 @@ private:
-    FIFO_TX_LEVEL = 0; // Reset FIFO_TX_LEVEL    
-    uint8_t out[] = {
-        0x7E,
-        0xFF,
-        06,
-        command,
-        00,
-        //static_cast<uint8_t>(arg >> 8),
-        //static_cast<uint8_t>(arg & 0x00ff),
-        arg1,
-        arg2,
-        00,
-        00,
-        0xEF };
+    FIFO_TX_LEVEL = 0;  // Reset FIFO_TX_LEVEL
+    uint8_t out[] = {0x7E, 0xFF, 06, command, 00,
+                     // static_cast<uint8_t>(arg >> 8),
+                     // static_cast<uint8_t>(arg & 0x00ff),
+                     arg1, arg2, 00, 00, 0xEF};
@@ -551,5 +549,12 @@ private:
-      // Prepend the DFPlayer command with REG address and UART Channel in _outbuffer
-      _outbuffer[0] = REG_THR << 3 | _UART_CH << 1; //TX FIFO and UART Channel      
-      for ( int i = 1; i < sizeof(out)+1 ; i++){
-        _outbuffer[i] = out[i-1];
-      }
+    // Prepend the DFPlayer command with REG address and UART Channel in _outbuffer
+    _outbuffer[0] = REG_THR << 3 | _UART_CH << 1;  // TX FIFO and UART Channel
+    for (int i = 1; i < sizeof(out) + 1; i++) {
+      _outbuffer[i] = out[i - 1];
+    }
+
+#ifdef DIAG_I2CDFplayer_data
+    DIAG(F("SC16IS752: I2C: %s Sent packet function"), _I2CAddress.toString());
+    for (int i = 0; i < sizeof _outbuffer; i++) {
+      DIAG(F("SC16IS752: Data _outbuffer[0x%x]: 0x%x"), i, _outbuffer[i]);
+    }
+#endif
@@ -557,7 +561,0 @@ private:
-      #ifdef DIAG_I2CDFplayer_data
-       DIAG(F("SC16IS752: I2C: %s Sent packet function"), _I2CAddress.toString());
-       for (int i = 0; i < sizeof _outbuffer; i++){
-        DIAG(F("SC16IS752: Data _outbuffer[0x%x]: 0x%x"), i, _outbuffer[i]);  
-       }
-      #endif
-      
@@ -565 +563 @@ private:
-    if(FIFO_TX_LEVEL > 0){ //FIFO is empty
+    if (FIFO_TX_LEVEL > 0) {  // FIFO is empty
@@ -567,4 +565,4 @@ private:
-      //I2CManager.write(_I2CAddress, _outbuffer, sizeof(_outbuffer));
-      #ifdef DIAG_I2CDFplayer
-       DIAG(F("SC16IS752: I2C: %s data transmit complete on UART: 0x%x"), _I2CAddress.toString(), _UART_CH);
-      #endif
+// I2CManager.write(_I2CAddress, _outbuffer, sizeof(_outbuffer));
+#ifdef DIAG_I2CDFplayer
+      DIAG(F("SC16IS752: I2C: %s data transmit complete on UART: 0x%x"), _I2CAddress.toString(), _UART_CH);
+#endif
@@ -573 +571 @@ private:
-      _deviceState = DEVSTATE_FAILED; // This should not happen      
+      _deviceState = DEVSTATE_FAILED;  // This should not happen
@@ -578,2 +576 @@ private:
-  uint16_t calcChecksum(uint8_t* packet)
-  {
+  uint16_t calcChecksum(uint8_t* packet) {
@@ -581,2 +578 @@ private:
-    for (int i = 1; i < 7; i++)
-    {
+    for (int i = 1; i < 7; i++) {
@@ -588,2 +584 @@ private:
-  void setChecksum(uint8_t* out)
-  {
+  void setChecksum(uint8_t* out) {
@@ -602,2 +597,2 @@ private:
-  // IOSTATE set only bit 0 to 1 for UART 0, or only bit 1 for UART 1  // 
-  // LCR bit 7=0 divisor latch (clock division registers DLH & DLL, they store 16 bit divisor), 
+  // IOSTATE set only bit 0 to 1 for UART 0, or only bit 1 for UART 1  //
+  // LCR bit 7=0 divisor latch (clock division registers DLH & DLL, they store 16 bit divisor),
@@ -610,8 +605,8 @@ private:
-  // 
-  void Init_SC16IS752(){ // Return value is in _deviceState
-    #ifdef DIAG_I2CDFplayer
-      DIAG(F("SC16IS752: Initialize I2C: %s , UART Ch: 0x%x"), _I2CAddress.toString(),  _UART_CH);      
-    #endif
-    //uint16_t _divisor = (SC16IS752_XTAL_FREQ / PRESCALER) / (BAUD_RATE * 16);
-    uint16_t _divisor = (_sc16is752_xtal_freq/PRESCALER)/(BAUD_RATE * 16);  // Calculate _divisor for baudrate
-    TEMP_REG_VAL = 0x08; // UART Software reset
+  //
+  void Init_SC16IS752() {  // Return value is in _deviceState
+#ifdef DIAG_I2CDFplayer
+    DIAG(F("SC16IS752: Initialize I2C: %s , UART Ch: 0x%x"), _I2CAddress.toString(), _UART_CH);
+#endif
+    // uint16_t _divisor = (SC16IS752_XTAL_FREQ / PRESCALER) / (BAUD_RATE * 16);
+    uint16_t _divisor = (_sc16is752_xtal_freq / PRESCALER) / (BAUD_RATE * 16);  // Calculate _divisor for baudrate
+    TEMP_REG_VAL = 0x08;                                                        // UART Software reset
@@ -619 +614 @@ private:
-    TEMP_REG_VAL = 0x00; // Set pins to GPIO mode
+    TEMP_REG_VAL = 0x00;  // Set pins to GPIO mode
@@ -621 +616 @@ private:
-    TEMP_REG_VAL = 0xFF; //Set all pins as output
+    TEMP_REG_VAL = 0xFF;  // Set all pins as output
@@ -623 +618 @@ private:
-    UART_ReadRegister(REG_IOSTATE); // Read current state as not to overwrite the other GPIO pins
+    UART_ReadRegister(REG_IOSTATE);  // Read current state as not to overwrite the other GPIO pins
@@ -625 +620 @@ private:
-    setGPIO(); // Set the audio mixer channel
+    setGPIO();  // Set the audio mixer channel
@@ -634 +629 @@ private:
-    TEMP_REG_VAL = 0x07; // Reset FIFO, clear RX & TX FIFO
+    TEMP_REG_VAL = 0x07;  // Reset FIFO, clear RX & TX FIFO
@@ -636 +631 @@ private:
-    TEMP_REG_VAL = 0x00; // Set MCR to all 0, includes Clock divisor
+    TEMP_REG_VAL = 0x00;  // Set MCR to all 0, includes Clock divisor
@@ -639,3 +634,3 @@ private:
-    UART_WriteRegister(REG_LCR, TEMP_REG_VAL); // Divisor latch enabled
-    UART_WriteRegister(REG_DLL, (uint8_t)_divisor);  // Write DLL
-    UART_WriteRegister(REG_DLH, (uint8_t)(_divisor >> 8)); // Write DLH
+    UART_WriteRegister(REG_LCR, TEMP_REG_VAL);              // Divisor latch enabled
+    UART_WriteRegister(REG_DLL, (uint8_t)_divisor);         // Write DLL
+    UART_WriteRegister(REG_DLH, (uint8_t)(_divisor >> 8));  // Write DLH
@@ -643,2 +638,2 @@ private:
-    TEMP_REG_VAL = _inbuffer[0] & 0x7F; // Disable Divisor latch enabled bit
-    UART_WriteRegister(REG_LCR, TEMP_REG_VAL); // Divisor latch disabled  
+    TEMP_REG_VAL = _inbuffer[0] & 0x7F;         // Disable Divisor latch enabled bit
+    UART_WriteRegister(REG_LCR, TEMP_REG_VAL);  // Divisor latch disabled
@@ -651,4 +646,4 @@ private:
-      #ifdef DIAG_IO
-       DIAG(F("SC16IS752: I2C: %s, _deviceState: %S"), _I2CAddress.toString(), I2CManager.getErrorMessage(status));
-      #endif
-     _deviceState = DEVSTATE_NORMAL; // If I2C state is OK, then proceed to initialize DFPlayer 
+#ifdef DIAG_IO
+      DIAG(F("SC16IS752: I2C: %s, _deviceState: %S"), _I2CAddress.toString(), I2CManager.getErrorMessage(status));
+#endif
+      _deviceState = DEVSTATE_NORMAL;  // If I2C state is OK, then proceed to initialize DFPlayer
@@ -658 +652,0 @@ private:
-  
@@ -663 +657 @@ private:
-  void RX_fifo_lvl(){
+  void RX_fifo_lvl() {
@@ -666,3 +660,3 @@ private:
-    #ifdef DIAG_I2CDFplayer
-     if (FIFO_RX_LEVEL > 0){
-     //if (FIFO_RX_LEVEL > 0 && FIFO_RX_LEVEL < 10){
+#ifdef DIAG_I2CDFplayer
+    if (FIFO_RX_LEVEL > 0) {
+      // if (FIFO_RX_LEVEL > 0 && FIFO_RX_LEVEL < 10){
@@ -671 +665 @@ private:
-    #endif   
+#endif
@@ -675 +669 @@ private:
-  // the following two frames from the DFPlayer are corrupt. This result in the receive buffer being out of sync and the 
+  // the following two frames from the DFPlayer are corrupt. This result in the receive buffer being out of sync and the
@@ -678,6 +672,6 @@ private:
-  // 
-  void resetRX_fifo(){
-    #ifdef DIAG_I2CDFplayer
-      DIAG(F("SC16IS752: At I2C: %s, UART channel: 0x%x, RX fifo reset"), _I2CAddress.toString(), _UART_CH);
-    #endif    
-    TEMP_REG_VAL = 0x03; // Reset RX fifo
+  //
+  void resetRX_fifo() {
+#ifdef DIAG_I2CDFplayer
+    DIAG(F("SC16IS752: At I2C: %s, UART channel: 0x%x, RX fifo reset"), _I2CAddress.toString(), _UART_CH);
+#endif
+    TEMP_REG_VAL = 0x03;  // Reset RX fifo
@@ -690,2 +684,2 @@ private:
-  void setGPIO(){
-    UART_ReadRegister(REG_IOSTATE); // Get the current GPIO pins state from the IOSTATE register
+  void setGPIO() {
+    UART_ReadRegister(REG_IOSTATE);  // Get the current GPIO pins state from the IOSTATE register
@@ -693,13 +687,13 @@ private:
-    if (_audioMixer == 1){ // set to audio mixer 1
-      if (_UART_CH == 0){ 
-        TEMP_REG_VAL |= (0x01 << _UART_CH); //Set GPIO pin 0 to high
-      } else { // must be UART 1
-         TEMP_REG_VAL |= (0x01 << _UART_CH); //Set GPIO pin 1 to high
-        }
-    } else { // set to audio mixer 2
-        if (_UART_CH == 0){ 
-          TEMP_REG_VAL &= ~(0x01 << _UART_CH); //Set GPIO pin 0 to Low
-        } else { // must be UART 1
-           TEMP_REG_VAL &= ~(0x01 << _UART_CH); //Set GPIO pin 1 to Low
-          }
-      }    
+    if (_audioMixer == 1) {  // set to audio mixer 1
+      if (_UART_CH == 0) {
+        TEMP_REG_VAL |= (0x01 << _UART_CH);  // Set GPIO pin 0 to high
+      } else {                               // must be UART 1
+        TEMP_REG_VAL |= (0x01 << _UART_CH);  // Set GPIO pin 1 to high
+      }
+    } else {  // set to audio mixer 2
+      if (_UART_CH == 0) {
+        TEMP_REG_VAL &= ~(0x01 << _UART_CH);  // Set GPIO pin 0 to Low
+      } else {                                // must be UART 1
+        TEMP_REG_VAL &= ~(0x01 << _UART_CH);  // Set GPIO pin 1 to Low
+      }
+    }
@@ -707 +701 @@ private:
-    _setamCmd = false;  
+    _setamCmd = false;
@@ -709 +702,0 @@ private:
-  
@@ -715 +708 @@ private:
-  void TX_fifo_lvl(){
+  void TX_fifo_lvl() {
@@ -718,3 +711,3 @@ private:
-    #ifdef DIAG_I2CDFplayer
-    //  DIAG(F("SC16IS752: At I2C: %s, UART channel: 0x%x, FIFO_TX_LEVEL: 0d%d"), _I2CAddress.toString(), _UART_CH, FIFO_TX_LEVEL);
-    #endif 
+#ifdef DIAG_I2CDFplayer
+//  DIAG(F("SC16IS752: At I2C: %s, UART channel: 0x%x, FIFO_TX_LEVEL: 0d%d"), _I2CAddress.toString(), _UART_CH, FIFO_TX_LEVEL);
+#endif
@@ -723,3 +716,2 @@ private:
-
-  //void UART_WriteRegister(I2CAddress _I2CAddress, uint8_t _UART_CH, uint8_t UART_REG, uint8_t Val, I2CRB &_rb){
-  void UART_WriteRegister(uint8_t UART_REG, uint8_t Val){
+  // void UART_WriteRegister(I2CAddress _I2CAddress, uint8_t _UART_CH, uint8_t UART_REG, uint8_t Val, I2CRB &_rb){
+  void UART_WriteRegister(uint8_t UART_REG, uint8_t Val) {
@@ -728,3 +720,4 @@ private:
-    #ifdef DIAG_I2CDFplayer_reg
-      DIAG(F("SC16IS752: Write register at I2C: %s, UART channel: 0x%x, Register: 0x%x, Data: 0b%b"), _I2CAddress.toString(), _UART_CH, UART_REG, _outbuffer[1]);
-    #endif
+#ifdef DIAG_I2CDFplayer_reg
+    DIAG(F("SC16IS752: Write register at I2C: %s, UART channel: 0x%x, Register: 0x%x, Data: 0b%b"), _I2CAddress.toString(), _UART_CH, UART_REG,
+         _outbuffer[1]);
+#endif
@@ -734,8 +727,8 @@ private:
- 
-  void UART_ReadRegister(uint8_t UART_REG){
-     _outbuffer[0] = UART_REG << 3 | _UART_CH << 1; // _outbuffer[0] has now UART_REG and UART_CH
-     I2CManager.read(_I2CAddress, _inbuffer, 1, _outbuffer, 1);    
-    // _inbuffer has the REG data
-    #ifdef DIAG_I2CDFplayer_reg
-      DIAG(F("SC16IS752: Read register at I2C: %s, UART channel: 0x%x, Register: 0x%x, Data: 0b%b"), _I2CAddress.toString(), _UART_CH, UART_REG, _inbuffer[0]);
-    #endif
+  void UART_ReadRegister(uint8_t UART_REG) {
+    _outbuffer[0] = UART_REG << 3 | _UART_CH << 1;  // _outbuffer[0] has now UART_REG and UART_CH
+    I2CManager.read(_I2CAddress, _inbuffer, 1, _outbuffer, 1);
+// _inbuffer has the REG data
+#ifdef DIAG_I2CDFplayer_reg
+    DIAG(F("SC16IS752: Read register at I2C: %s, UART channel: 0x%x, Register: 0x%x, Data: 0b%b"), _I2CAddress.toString(), _UART_CH, UART_REG,
+         _inbuffer[0]);
+#endif
@@ -744,21 +737,21 @@ private:
-// SC16IS752 General register set (from the datasheet)
-enum : uint8_t{
-    REG_RHR       = 0x00, // FIFO Read
-    REG_THR       = 0x00, // FIFO Write
-    REG_IER       = 0x01, // Interrupt Enable Register R/W
-    REG_FCR       = 0x02, // FIFO Control Register Write
-    REG_IIR       = 0x02, // Interrupt Identification Register Read
-    REG_LCR       = 0x03, // Line Control Register R/W
-    REG_MCR       = 0x04, // Modem Control Register R/W
-    REG_LSR       = 0x05, // Line Status Register Read
-    REG_MSR       = 0x06, // Modem Status Register Read
-    REG_SPR       = 0x07, // Scratchpad Register R/W
-    REG_TCR       = 0x06, // Transmission Control Register R/W
-    REG_TLR       = 0x07, // Trigger Level Register R/W    
-    REG_TXLV      = 0x08, // Transmitter FIFO Level register Read
-    REG_RXLV      = 0x09, // Receiver FIFO Level register Read
-    REG_IODIR     = 0x0A, // Programmable I/O pins Direction register R/W
-    REG_IOSTATE   = 0x0B, // Programmable I/O pins State register R/W
-    REG_IOINTENA  = 0x0C, // I/O Interrupt Enable register R/W
-    REG_IOCONTROL = 0x0E, // I/O Control register R/W
-    REG_EFCR      = 0x0F, // Extra Features Control Register R/W
+  // SC16IS752 General register set (from the datasheet)
+  enum : uint8_t {
+    REG_RHR = 0x00,        // FIFO Read
+    REG_THR = 0x00,        // FIFO Write
+    REG_IER = 0x01,        // Interrupt Enable Register R/W
+    REG_FCR = 0x02,        // FIFO Control Register Write
+    REG_IIR = 0x02,        // Interrupt Identification Register Read
+    REG_LCR = 0x03,        // Line Control Register R/W
+    REG_MCR = 0x04,        // Modem Control Register R/W
+    REG_LSR = 0x05,        // Line Status Register Read
+    REG_MSR = 0x06,        // Modem Status Register Read
+    REG_SPR = 0x07,        // Scratchpad Register R/W
+    REG_TCR = 0x06,        // Transmission Control Register R/W
+    REG_TLR = 0x07,        // Trigger Level Register R/W
+    REG_TXLV = 0x08,       // Transmitter FIFO Level register Read
+    REG_RXLV = 0x09,       // Receiver FIFO Level register Read
+    REG_IODIR = 0x0A,      // Programmable I/O pins Direction register R/W
+    REG_IOSTATE = 0x0B,    // Programmable I/O pins State register R/W
+    REG_IOINTENA = 0x0C,   // I/O Interrupt Enable register R/W
+    REG_IOCONTROL = 0x0E,  // I/O Control register R/W
+    REG_EFCR = 0x0F,       // Extra Features Control Register R/W
@@ -767,4 +760,4 @@ enum : uint8_t{
-// SC16IS752 Special register set
-enum : uint8_t{
-    REG_DLL       = 0x00, // Division registers R/W
-    REG_DLH       = 0x01, // Division registers R/W
+  // SC16IS752 Special register set
+  enum : uint8_t {
+    REG_DLL = 0x00,  // Division registers R/W
+    REG_DLH = 0x01,  // Division registers R/W
@@ -773,7 +766,7 @@ enum : uint8_t{
-// SC16IS752 Enhanced regiter set
-enum : uint8_t{
-    REG_EFR       = 0X02, // Enhanced Features Register R/W
-    REG_XON1      = 0x04, // R/W
-    REG_XON2      = 0x05, // R/W
-    REG_XOFF1     = 0x06, // R/W
-    REG_XOFF2     = 0x07, // R/W
+  // SC16IS752 Enhanced regiter set
+  enum : uint8_t {
+    REG_EFR = 0X02,    // Enhanced Features Register R/W
+    REG_XON1 = 0x04,   // R/W
+    REG_XON2 = 0x05,   // R/W
+    REG_XOFF1 = 0x06,  // R/W
+    REG_XOFF2 = 0x07,  // R/W
@@ -782,19 +775,18 @@ enum : uint8_t{
-
-// DFPlayer commands and values
-// Declared in this scope
-enum  : uint8_t{
-    DF_PLAY          = 0x0F,
-    DF_VOL           = 0x06,
-    DF_FOLDER        = 0x2B, // Not a DFPlayer command, used to set folder nr where audio file is
-    DF_REPEATPLAY    = 0x08,
-    DF_STOPPLAY      = 0x16,
-    DF_EQ            = 0x07, // Set equaliser, require parameter NORMAL, POP, ROCK, JAZZ, CLASSIC or BASS
-    DF_RESET         = 0x0C,
-    DF_DACON         = 0x1A,
-    DF_SETAM         = 0x2A, // Set audio mixer 1 or 2 for this DFPLayer   
-    DF_NORMAL        = 0x00, // Equalizer parameters
-    DF_POP           = 0x01,
-    DF_ROCK          = 0x02,
-    DF_JAZZ          = 0x03,
-    DF_CLASSIC       = 0x04,
-    DF_BASS          = 0x05,    
+  // DFPlayer commands and values
+  // Declared in this scope
+  enum : uint8_t {
+    DF_PLAY = 0x0F,
+    DF_VOL = 0x06,
+    DF_FOLDER = 0x2B,  // Not a DFPlayer command, used to set folder nr where audio file is
+    DF_REPEATPLAY = 0x08,
+    DF_STOPPLAY = 0x16,
+    DF_EQ = 0x07,  // Set equaliser, require parameter NORMAL, POP, ROCK, JAZZ, CLASSIC or BASS
+    DF_RESET = 0x0C,
+    DF_DACON = 0x1A,
+    DF_SETAM = 0x2A,   // Set audio mixer 1 or 2 for this DFPLayer
+    DF_NORMAL = 0x00,  // Equalizer parameters
+    DF_POP = 0x01,
+    DF_ROCK = 0x02,
+    DF_JAZZ = 0x03,
+    DF_CLASSIC = 0x04,
+    DF_BASS = 0x05,
@@ -802 +793,0 @@ enum  : uint8_t{
-
@@ -805 +796 @@ enum  : uint8_t{
-#endif // IO_I2CDFPlayer_h
+#endif  // IO_I2CDFPlayer_h
diff --git a/IO_MCP23008.h b/IO_MCP23008.h
index 277d3ea..3222187 100644
--- a/IO_MCP23008.h
+++ b/IO_MCP23008.h
@@ -4 +4 @@
- *  
+ *
@@ -27,3 +27,4 @@ class MCP23008 : public GPIOBase<uint8_t> {
-public:
-  static void create(VPIN firstVpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin=-1) {
-    if (checkNoOverlap(firstVpin, nPins,i2cAddress)) new MCP23008(firstVpin, nPins, i2cAddress, interruptPin);
+ public:
+  static void create(VPIN firstVpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin = -1) {
+    if (checkNoOverlap(firstVpin, nPins, i2cAddress))
+      new MCP23008(firstVpin, nPins, i2cAddress, interruptPin);
@@ -32 +33 @@ public:
-private:
+ private:
@@ -34,5 +35,3 @@ private:
-  MCP23008(VPIN firstVpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin=-1)
-    : GPIOBase<uint8_t>((FSH *)F("MCP23008"), firstVpin, nPins, i2cAddress, interruptPin) {
-
-    requestBlock.setRequestParams(_I2CAddress, inputBuffer, sizeof(inputBuffer),
-      outputBuffer, sizeof(outputBuffer));
+  MCP23008(VPIN firstVpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin = -1)
+      : GPIOBase<uint8_t>((FSH*)F("MCP23008"), firstVpin, nPins, i2cAddress, interruptPin) {
+    requestBlock.setRequestParams(_I2CAddress, inputBuffer, sizeof(inputBuffer), outputBuffer, sizeof(outputBuffer));
@@ -41 +40 @@ private:
-  
+
@@ -48 +47 @@ private:
-    I2CManager.write(_I2CAddress, 2, REG_GPPU, _portPullup & _portInUse);  
+    I2CManager.write(_I2CAddress, 2, REG_GPPU, _portPullup & _portInUse);
@@ -66 +65 @@ private:
-      requestBlock.wait(); // Wait for preceding operation to complete
+      requestBlock.wait();  // Wait for preceding operation to complete
@@ -73 +72 @@ private:
-    if (status == I2C_STATUS_OK) 
+    if (status == I2C_STATUS_OK)
@@ -75 +74 @@ private:
-    else  
+    else
@@ -85 +84 @@ private:
- 
+
@@ -91,6 +90,6 @@ private:
-    REG_IODIR=0x00,
-    REG_GPINTEN=0x02,
-    REG_INTCON=0x04,
-    REG_IOCON=0x05,
-    REG_GPPU=0x06,
-    REG_GPIO=0x09,
+    REG_IODIR = 0x00,
+    REG_GPINTEN = 0x02,
+    REG_INTCON = 0x04,
+    REG_IOCON = 0x05,
+    REG_GPPU = 0x06,
+    REG_GPIO = 0x09,
@@ -98 +96,0 @@ private:
-
diff --git a/IO_MCP23017.h b/IO_MCP23017.h
index b53d3e3..b467297 100644
--- a/IO_MCP23017.h
+++ b/IO_MCP23017.h
@@ -3 +3 @@
- *  
+ *
@@ -30 +30 @@
- 
+
@@ -32,3 +32,4 @@ class MCP23017 : public GPIOBase<uint16_t> {
-public:
-  static void create(VPIN vpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin=-1) {
-    if (checkNoOverlap(vpin, nPins, i2cAddress)) new MCP23017(vpin, nPins, i2cAddress, interruptPin);
+ public:
+  static void create(VPIN vpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin = -1) {
+    if (checkNoOverlap(vpin, nPins, i2cAddress))
+      new MCP23017(vpin, nPins, i2cAddress, interruptPin);
@@ -37 +38 @@ public:
-private:  
+ private:
@@ -39,5 +40,3 @@ private:
-  MCP23017(VPIN vpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin=-1) 
-    : GPIOBase<uint16_t>((FSH *)F("MCP23017"), vpin, nPins, i2cAddress, interruptPin) 
-  {
-    requestBlock.setRequestParams(_I2CAddress, inputBuffer, sizeof(inputBuffer),
-      outputBuffer, sizeof(outputBuffer));
+  MCP23017(VPIN vpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin = -1)
+      : GPIOBase<uint16_t>((FSH*)F("MCP23017"), vpin, nPins, i2cAddress, interruptPin) {
+    requestBlock.setRequestParams(_I2CAddress, inputBuffer, sizeof(inputBuffer), outputBuffer, sizeof(outputBuffer));
@@ -47 +46 @@ private:
-    I2CManager.write(_I2CAddress, 3, REG_GPIOA, _portOutputState, _portOutputState>>8);
+    I2CManager.write(_I2CAddress, 3, REG_GPIOA, _portOutputState, _portOutputState >> 8);
@@ -53 +52 @@ private:
-    I2CManager.write(_I2CAddress, 3, REG_GPPUA, temp, temp>>8);  
+    I2CManager.write(_I2CAddress, 3, REG_GPPUA, temp, temp >> 8);
@@ -58 +57 @@ private:
-    I2CManager.write(_I2CAddress, 3, REG_IODIRA, temp, temp>>8);
+    I2CManager.write(_I2CAddress, 3, REG_IODIRA, temp, temp >> 8);
@@ -62 +61 @@ private:
-    I2CManager.write(_I2CAddress, 3, REG_GPINTENA, temp, temp>>8);
+    I2CManager.write(_I2CAddress, 3, REG_GPINTENA, temp, temp >> 8);
@@ -68 +67 @@ private:
-      _portInputState = ((uint16_t)buffer[1]<<8) | buffer[0] | _portMode;
+      _portInputState = ((uint16_t)buffer[1] << 8) | buffer[0] | _portMode;
@@ -71 +70 @@ private:
-      requestBlock.wait(); // Wait for preceding operation to complete
+      requestBlock.wait();  // Wait for preceding operation to complete
@@ -78,3 +77,3 @@ private:
-    if (status == I2C_STATUS_OK) 
-      _portInputState = (((uint16_t)inputBuffer[1]<<8) | inputBuffer[0]) | _portMode;
-    else  
+    if (status == I2C_STATUS_OK)
+      _portInputState = (((uint16_t)inputBuffer[1] << 8) | inputBuffer[0]) | _portMode;
+    else
@@ -91 +90 @@ private:
- 
+
@@ -94 +93 @@ private:
- 
+
@@ -108 +106,0 @@ private:
-
diff --git a/IO_NeoPixel.h b/IO_NeoPixel.h
index acd44ea..ddbb44b 100644
--- a/IO_NeoPixel.h
+++ b/IO_NeoPixel.h
@@ -18 +18 @@
-*/
+ */
@@ -21,17 +21,17 @@
-* The IO_NEOPIXEL.h device driver integrates with one or more Adafruit neopixel drivers.
-* This device driver will configure the device on startup, along with
-* interacting with the device for all input/output duties.
-*
-* To create NEOPIXEL devices, these are defined in myAutomation.h:
-* (Note the device driver is included by default)
-*
-* HAL(NEOPIXEL,first vpin, number of pixels,mode, i2c address) 
-* e.g. HAL(NEOPIXEL,1000,64,NEO_RGB,0x60)
-* This gives each pixel in the chain an individual vpin
-* The number of pixels must match the physical pixels in the chain. 
-* 
-* This driver maintains a colour (rgb value in 5,5,5 bits only) plus an ON bit.
-* This can be written/read with an analog write/read call. 
-* The ON bit can be set on and off with a digital write. This allows for 
-* a pixel to be preset a colour and then turned on and off like any other light. 
-*/
+ * The IO_NEOPIXEL.h device driver integrates with one or more Adafruit neopixel drivers.
+ * This device driver will configure the device on startup, along with
+ * interacting with the device for all input/output duties.
+ *
+ * To create NEOPIXEL devices, these are defined in myAutomation.h:
+ * (Note the device driver is included by default)
+ *
+ * HAL(NEOPIXEL,first vpin, number of pixels,mode, i2c address)
+ * e.g. HAL(NEOPIXEL,1000,64,NEO_RGB,0x60)
+ * This gives each pixel in the chain an individual vpin
+ * The number of pixels must match the physical pixels in the chain.
+ *
+ * This driver maintains a colour (rgb value in 5,5,5 bits only) plus an ON bit.
+ * This can be written/read with an analog write/read call.
+ * The ON bit can be set on and off with a digital write. This allows for
+ * a pixel to be preset a colour and then turned on and off like any other light.
+ */
@@ -47 +46,0 @@
-
@@ -49,2 +48,2 @@
-// have been copied from the Adafruit Seesaw Library under the 
-// terms of the GPL. 
+// have been copied from the Adafruit Seesaw Library under the
+// terms of the GPL.
@@ -120,2 +119,2 @@
-#define NEO_KHZ800 0x0000 // 800 KHz datastream
-#define NEO_KHZ400 0x0100 // 400 KHz datastream
+#define NEO_KHZ800 0x0000  // 800 KHz datastream
+#define NEO_KHZ400 0x0100  // 400 KHz datastream
@@ -129,4 +128,4 @@ class NeoPixel : public IODevice {
-public:
-  
-  static void create(VPIN vpin, int nPins, uint16_t mode=(NEO_GRB | NEO_KHZ800), I2CAddress i2cAddress=0x60) {
-    if (checkNoOverlap(vpin, nPins, i2cAddress)) new NeoPixel(vpin, nPins, mode, i2cAddress);
+ public:
+  static void create(VPIN vpin, int nPins, uint16_t mode = (NEO_GRB | NEO_KHZ800), I2CAddress i2cAddress = 0x60) {
+    if (checkNoOverlap(vpin, nPins, i2cAddress))
+      new NeoPixel(vpin, nPins, mode, i2cAddress);
@@ -135,3 +134,2 @@ public:
-private:
-  
-  static const byte SEESAW_NEOPIXEL_BASE=0x0E;
+ private:
+  static const byte SEESAW_NEOPIXEL_BASE = 0x0E;
@@ -142,2 +140,2 @@ private:
-  static const byte SEESAW_NEOPIXEL_BUF=0x04;
-  static const byte SEESAW_NEOPIXEL_SHOW=0x05;
+  static const byte SEESAW_NEOPIXEL_BUF = 0x04;
+  static const byte SEESAW_NEOPIXEL_SHOW = 0x05;
@@ -145,2 +143,2 @@ private:
-  // all adafruit examples say this pin. Presumably its hard wired 
-  // in the adapter anyway. 
+  // all adafruit examples say this pin. Presumably its hard wired
+  // in the adapter anyway.
@@ -148 +146 @@ private:
-  
+
@@ -152 +150 @@ private:
-    _nPins=nPins;
+    _nPins = nPins;
@@ -154 +152 @@ private:
-    
+
@@ -158,9 +156,11 @@ private:
-    _redOffset=4+(mode >> 4 & 0x03);
-    _greenOffset=4+(mode >> 2 & 0x03); 
-    _blueOffset=4+(mode & 0x03); 
-    if (4+(mode >>6 & 0x03) == _redOffset) _bytesPerPixel=3; 
-    else _bytesPerPixel=4; // string has a white byte.
-    
-    _kHz800=(mode & NEO_KHZ400)==0;
-    _showPendimg=false;
-    
+    _redOffset = 4 + (mode >> 4 & 0x03);
+    _greenOffset = 4 + (mode >> 2 & 0x03);
+    _blueOffset = 4 + (mode & 0x03);
+    if (4 + (mode >> 6 & 0x03) == _redOffset)
+      _bytesPerPixel = 3;
+    else
+      _bytesPerPixel = 4;  // string has a white byte.
+
+    _kHz800 = (mode & NEO_KHZ400) == 0;
+    _showPendimg = false;
+
@@ -170,3 +170,3 @@ private:
-    pixelBuffer=(RGB *) malloc(_nPins*sizeof(RGB)); 
-    stateBuffer=(byte *) calloc((_nPins+7)/8,sizeof(byte)); // all pixels off  
-    if (pixelBuffer==nullptr || stateBuffer==nullptr) {
+    pixelBuffer = (RGB*)malloc(_nPins * sizeof(RGB));
+    stateBuffer = (byte*)calloc((_nPins + 7) / 8, sizeof(byte));  // all pixels off
+    if (pixelBuffer == nullptr || stateBuffer == nullptr) {
@@ -177 +177 @@ private:
-    memset(pixelBuffer,0xFF,_nPins*sizeof(RGB));
+    memset(pixelBuffer, 0xFF, _nPins * sizeof(RGB));
@@ -182 +181,0 @@ private:
-    
@@ -190,2 +189,2 @@ private:
-    
-    byte speedBuffer[]={SEESAW_NEOPIXEL_BASE, SEESAW_NEOPIXEL_SPEED,_kHz800};
+
+    byte speedBuffer[] = {SEESAW_NEOPIXEL_BASE, SEESAW_NEOPIXEL_SPEED, _kHz800};
@@ -193 +192 @@ private:
-    
+
@@ -195,3 +194,2 @@ private:
-    auto numBytes=_bytesPerPixel * _nPins; 
-    byte setbuffer[] = {SEESAW_NEOPIXEL_BASE, SEESAW_NEOPIXEL_BUF_LENGTH,
-                  (byte)(numBytes >> 8), (byte)(numBytes & 0xFF)};
+    auto numBytes = _bytesPerPixel * _nPins;
+    byte setbuffer[] = {SEESAW_NEOPIXEL_BASE, SEESAW_NEOPIXEL_BUF_LENGTH, (byte)(numBytes >> 8), (byte)(numBytes & 0xFF)};
@@ -199,2 +197,2 @@ private:
-    
-    const byte pinbuffer[] = {SEESAW_NEOPIXEL_BASE, SEESAW_NEOPIXEL_PIN,SEESAW_PIN15};
+
+    const byte pinbuffer[] = {SEESAW_NEOPIXEL_BASE, SEESAW_NEOPIXEL_PIN, SEESAW_PIN15};
@@ -202,3 +200,3 @@ private:
-    
-    for (auto pin=0;pin<_nPins;pin++) transmit(pin);
-     _display();
+
+    for (auto pin = 0; pin < _nPins; pin++) transmit(pin);
+    _display();
@@ -206,2 +204,2 @@ private:
-  
- // loop called by HAL supervisor 
+
+  // loop called by HAL supervisor
@@ -210,7 +208,7 @@ private:
-    if (!_showPendimg) return;
-    byte showBuffer[]={SEESAW_NEOPIXEL_BASE,SEESAW_NEOPIXEL_SHOW};
-    I2CManager.write(_I2CAddress,showBuffer,sizeof(showBuffer));
-    _showPendimg=false;
-  }  
-  
-  
+    if (!_showPendimg)
+      return;
+    byte showBuffer[] = {SEESAW_NEOPIXEL_BASE, SEESAW_NEOPIXEL_SHOW};
+    I2CManager.write(_I2CAddress, showBuffer, sizeof(showBuffer));
+    _showPendimg = false;
+  }
+
@@ -219,2 +217,3 @@ private:
-    if (_deviceState == DEVSTATE_FAILED) return 0;
-    return isPixelOn(vpin-_firstVpin);
+    if (_deviceState == DEVSTATE_FAILED)
+      return 0;
+    return isPixelOn(vpin - _firstVpin);
@@ -225,2 +224,3 @@ private:
-    if (_deviceState == DEVSTATE_FAILED) return;
-    auto pixel=vpin-_firstVpin;
+    if (_deviceState == DEVSTATE_FAILED)
+      return;
+    auto pixel = vpin - _firstVpin;
@@ -228 +228,2 @@ private:
-      if (isPixelOn(pixel)) return;
+      if (isPixelOn(pixel))
+        return;
@@ -230,3 +231,3 @@ private:
-    }
-    else { // set off
-      if (!isPixelOn(pixel)) return;
+    } else {  // set off
+      if (!isPixelOn(pixel))
+        return;
@@ -234,2 +235,2 @@ private:
-     }
-     transmit(pixel);
+    }
+    transmit(pixel);
@@ -237,2 +238,2 @@ private:
-   
-  VPIN _writeRange(VPIN vpin,int value, int count) {
+
+  VPIN _writeRange(VPIN vpin, int value, int count) {
@@ -241,7 +242,8 @@ private:
-    VPIN nextVpin=vpin +  (count>_nPins ? _nPins : count);
-    if (_deviceState != DEVSTATE_FAILED) while(vpin<nextVpin) {
-      _write(vpin,value);
-      vpin++;
-    }
-    return nextVpin;  // next pin we cant 
-  }  
+    VPIN nextVpin = vpin + (count > _nPins ? _nPins : count);
+    if (_deviceState != DEVSTATE_FAILED)
+      while (vpin < nextVpin) {
+        _write(vpin, value);
+        vpin++;
+      }
+    return nextVpin;  // next pin we cant
+  }
@@ -251 +253 @@ private:
-  // designed for servos and short integers  
+  // designed for servos and short integers
@@ -253,7 +255,12 @@ private:
-    if (_deviceState == DEVSTATE_FAILED) return;
-    RGB newColour={(byte)((colour_RG>>8) & 0xFF), (byte)(colour_RG & 0xFF), (byte)(colour_B & 0xFF)};
-    auto pixel=vpin-_firstVpin;
-    if (pixelBuffer[pixel]==newColour && isPixelOn(pixel)==(bool)onoff) return; // no change  
-      
-    if (onoff) setPixelOn(pixel); else setPixelOff(pixel);
-    pixelBuffer[pixel]=newColour;
+    if (_deviceState == DEVSTATE_FAILED)
+      return;
+    RGB newColour = {(byte)((colour_RG >> 8) & 0xFF), (byte)(colour_RG & 0xFF), (byte)(colour_B & 0xFF)};
+    auto pixel = vpin - _firstVpin;
+    if (pixelBuffer[pixel] == newColour && isPixelOn(pixel) == (bool)onoff)
+      return;  // no change
+
+    if (onoff)
+      setPixelOn(pixel);
+    else
+      setPixelOff(pixel);
+    pixelBuffer[pixel] = newColour;
@@ -262 +269 @@ private:
- VPIN _writeAnalogueRange(VPIN vpin, int colour_RG, uint8_t onoff, uint16_t colour_B, int count) override {
+  VPIN _writeAnalogueRange(VPIN vpin, int colour_RG, uint8_t onoff, uint16_t colour_B, int count) override {
@@ -264,8 +271,9 @@ private:
-    VPIN nextVpin=vpin +  (count>_nPins ? _nPins : count); 
-    if (_deviceState != DEVSTATE_FAILED) while(vpin<nextVpin) {
-      _writeAnalogue(vpin,colour_RG, onoff,colour_B);
-      vpin++;
-    }
-    return nextVpin;  // next pin we cant 
- }
- 
+    VPIN nextVpin = vpin + (count > _nPins ? _nPins : count);
+    if (_deviceState != DEVSTATE_FAILED)
+      while (vpin < nextVpin) {
+        _writeAnalogue(vpin, colour_RG, onoff, colour_B);
+        vpin++;
+      }
+    return nextVpin;  // next pin we cant
+  }
+
@@ -274,4 +282,2 @@ private:
-    DIAG(F("NeoPixel I2C:%s Vpins %u-%u %S"),
-              _I2CAddress.toString(), 
-              (int)_firstVpin, (int)_firstVpin+_nPins-1,
-              _deviceState == DEVSTATE_FAILED ? F("OFFLINE") : F(""));
+    DIAG(F("NeoPixel I2C:%s Vpins %u-%u %S"), _I2CAddress.toString(), (int)_firstVpin, (int)_firstVpin + _nPins - 1,
+         _deviceState == DEVSTATE_FAILED ? F("OFFLINE") : F(""));
@@ -279,0 +286,9 @@ private:
+  bool isPixelOn(int16_t pixel) {
+    return stateBuffer[pixel / 8] & (0x80 >> (pixel % 8));
+  }
+  void setPixelOn(int16_t pixel) {
+    stateBuffer[pixel / 8] |= (0x80 >> (pixel % 8));
+  }
+  void setPixelOff(int16_t pixel) {
+    stateBuffer[pixel / 8] &= ~(0x80 >> (pixel % 8));
+  }
@@ -281,5 +295,0 @@ private:
-  
-  bool isPixelOn(int16_t pixel) {return stateBuffer[pixel/8] & (0x80>>(pixel%8));}
-  void setPixelOn(int16_t pixel) {stateBuffer[pixel/8] |= (0x80>>(pixel%8));}
-  void setPixelOff(int16_t pixel) {stateBuffer[pixel/8] &= ~(0x80>>(pixel%8));}
-  
@@ -287,3 +297,2 @@ private:
-  void reportError(uint8_t status, bool fail=true) {
-    DIAG(F("NeoPixel I2C:%s Error:%d (%S)"), _I2CAddress.toString(), 
-      status, I2CManager.getErrorMessage(status));
+  void reportError(uint8_t status, bool fail = true) {
+    DIAG(F("NeoPixel I2C:%s Error:%d (%S)"), _I2CAddress.toString(), status, I2CManager.getErrorMessage(status));
@@ -291 +300 @@ private:
-    _deviceState = DEVSTATE_FAILED;
+      _deviceState = DEVSTATE_FAILED;
@@ -294,7 +303,6 @@ private:
-  
-  void transmit(uint16_t pixel) { 
-    byte buffer[]={SEESAW_NEOPIXEL_BASE,SEESAW_NEOPIXEL_BUF,0x00,0x00,0x00,0x00,0x00};
-    uint16_t offset= pixel * _bytesPerPixel;
-    buffer[2]=(byte)(offset>>8);
-    buffer[3]=(byte)(offset & 0xFF);
-    
+  void transmit(uint16_t pixel) {
+    byte buffer[] = {SEESAW_NEOPIXEL_BASE, SEESAW_NEOPIXEL_BUF, 0x00, 0x00, 0x00, 0x00, 0x00};
+    uint16_t offset = pixel * _bytesPerPixel;
+    buffer[2] = (byte)(offset >> 8);
+    buffer[3] = (byte)(offset & 0xFF);
+
@@ -302,6 +310,6 @@ private:
-      auto colour=pixelBuffer[pixel];    
-      buffer[_redOffset]=colour.red;
-      buffer[_greenOffset]=colour.green;
-      buffer[_blueOffset]=colour.blue;
-    } // else leave buffer black (in buffer preset to zeros above)
-    
+      auto colour = pixelBuffer[pixel];
+      buffer[_redOffset] = colour.red;
+      buffer[_greenOffset] = colour.green;
+      buffer[_blueOffset] = colour.blue;
+    }  // else leave buffer black (in buffer preset to zeros above)
+
@@ -309,3 +317,2 @@ private:
-    I2CManager.write(_I2CAddress,buffer,4 +_bytesPerPixel);
-    _showPendimg=true;
-  
+    I2CManager.write(_I2CAddress, buffer, 4 + _bytesPerPixel);
+    _showPendimg = true;
@@ -313,8 +320,8 @@ private:
-  struct RGB { 
-      byte red; 
-      byte green; 
-      byte blue; 
-      bool operator==(const RGB& other) const {
-        return red == other.red && green == other.green && blue == other.blue;
-      }
-    };
+  struct RGB {
+    byte red;
+    byte green;
+    byte blue;
+    bool operator==(const RGB& other) const {
+      return red == other.red && green == other.green && blue == other.blue;
+    }
+  };
@@ -322,2 +329,2 @@ private:
-  RGB*   pixelBuffer = nullptr;
-  byte*  stateBuffer = nullptr;  // 1 bit per pixel
+  RGB* pixelBuffer = nullptr;
+  byte* stateBuffer = nullptr;  // 1 bit per pixel
@@ -325 +332 @@ private:
-  
+
@@ -331 +338 @@ private:
-  bool _kHz800; 
+  bool _kHz800;
diff --git a/IO_PCA9555.h b/IO_PCA9555.h
index 75f2c38..a0a6c8b 100644
--- a/IO_PCA9555.h
+++ b/IO_PCA9555.h
@@ -3 +3 @@
- *  
+ *
@@ -30 +30 @@
- 
+
@@ -32,3 +32,4 @@ class PCA9555 : public GPIOBase<uint16_t> {
-public:
-  static void create(VPIN vpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin=-1) {
-    if (checkNoOverlap(vpin, nPins, i2cAddress)) new PCA9555(vpin,nPins, i2cAddress, interruptPin);
+ public:
+  static void create(VPIN vpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin = -1) {
+    if (checkNoOverlap(vpin, nPins, i2cAddress))
+      new PCA9555(vpin, nPins, i2cAddress, interruptPin);
@@ -37 +38 @@ public:
-private:  
+ private:
@@ -39,5 +40,3 @@ private:
-  PCA9555(VPIN vpin, uint8_t nPins, I2CAddress I2CAddress, int interruptPin=-1) 
-    : GPIOBase<uint16_t>((FSH *)F("PCA9555"), vpin, nPins, I2CAddress, interruptPin) 
-  {
-    requestBlock.setRequestParams(_I2CAddress, inputBuffer, sizeof(inputBuffer),
-      outputBuffer, sizeof(outputBuffer));
+  PCA9555(VPIN vpin, uint8_t nPins, I2CAddress I2CAddress, int interruptPin = -1)
+      : GPIOBase<uint16_t>((FSH*)F("PCA9555"), vpin, nPins, I2CAddress, interruptPin) {
+    requestBlock.setRequestParams(_I2CAddress, inputBuffer, sizeof(inputBuffer), outputBuffer, sizeof(outputBuffer));
@@ -47 +46 @@ private:
-    I2CManager.write(_I2CAddress, 3, REG_OUTPUT_P0, _portOutputState, _portOutputState>>8);
+    I2CManager.write(_I2CAddress, 3, REG_OUTPUT_P0, _portOutputState, _portOutputState >> 8);
@@ -52 +50,0 @@ private:
-      
@@ -58 +56 @@ private:
-    I2CManager.write(_I2CAddress, 3, REG_CONF_P0, temp, temp>>8);    
+    I2CManager.write(_I2CAddress, 3, REG_CONF_P0, temp, temp >> 8);
@@ -64,3 +62,3 @@ private:
-      _portInputState = ((uint16_t)buffer[1]<<8) | buffer[0];
-      /* PCA9555 Int bug fix, from PCA9555 datasheet: "must change command byte to something besides 00h 
-       * after a Read operation to the PCA9555 device or before reading from 
+      _portInputState = ((uint16_t)buffer[1] << 8) | buffer[0];
+      /* PCA9555 Int bug fix, from PCA9555 datasheet: "must change command byte to something besides 00h
+       * after a Read operation to the PCA9555 device or before reading from
@@ -69 +67 @@ private:
-       * Issue not seen during testing, uncomment if needed 
+       * Issue not seen during testing, uncomment if needed
@@ -71 +69 @@ private:
-      //I2CManager.read(_I2CAddress, buffer, 2, 1, REG_OUTPUT_P0);
+      // I2CManager.read(_I2CAddress, buffer, 2, 1, REG_OUTPUT_P0);
@@ -74 +72 @@ private:
-      requestBlock.wait(); // Wait for preceding operation to complete
+      requestBlock.wait();  // Wait for preceding operation to complete
@@ -81,3 +79,3 @@ private:
-    if (status == I2C_STATUS_OK) 
-      _portInputState = ((uint16_t)inputBuffer[1]<<8) | inputBuffer[0];
-    else  
+    if (status == I2C_STATUS_OK)
+      _portInputState = ((uint16_t)inputBuffer[1] << 8) | inputBuffer[0];
+    else
@@ -93 +91 @@ private:
- 
+
@@ -96 +93,0 @@ private:
- 
@@ -106 +103 @@ private:
-    REG_CONF_P1 = 0x07,    
+    REG_CONF_P1 = 0x07,
@@ -108 +104,0 @@ private:
-
diff --git a/IO_PCA9685.cpp b/IO_PCA9685.cpp
index 3c8b37a..a56a436 100644
--- a/IO_PCA9685.cpp
+++ b/IO_PCA9685.cpp
@@ -3 +3 @@
- *  
+ *
@@ -25,3 +25,3 @@
-static const byte PCA9685_MODE1=0x00;      // Mode Register 
-static const byte PCA9685_FIRST_SERVO=0x06;  /** low byte first servo register ON*/
-static const byte PCA9685_PRESCALE=0xFE;     /** Prescale register for PWM output frequency */
+static const byte PCA9685_MODE1 = 0x00;       // Mode Register
+static const byte PCA9685_FIRST_SERVO = 0x06; /** low byte first servo register ON*/
+static const byte PCA9685_PRESCALE = 0xFE;    /** Prescale register for PWM output frequency */
@@ -29,3 +29,3 @@ static const byte PCA9685_PRESCALE=0xFE;     /** Prescale register for PWM outpu
-static const byte MODE1_SLEEP=0x10;   /**< Low power mode. Oscillator off */
-static const byte MODE1_AI=0x20;      /**< Auto-Increment enabled */
-static const byte MODE1_RESTART=0x80; /**< Restart enabled */
+static const byte MODE1_SLEEP = 0x10;   /**< Low power mode. Oscillator off */
+static const byte MODE1_AI = 0x20;      /**< Auto-Increment enabled */
+static const byte MODE1_RESTART = 0x80; /**< Restart enabled */
@@ -33,2 +33,2 @@ static const byte MODE1_RESTART=0x80; /**< Restart enabled */
-static const float FREQUENCY_OSCILLATOR=25000000.0; /** Accurate enough for our purposes  */
-static const uint32_t MAX_I2C_SPEED = 1000000L; // PCA9685 rated up to 1MHz I2C clock speed
+static const float FREQUENCY_OSCILLATOR = 25000000.0; /** Accurate enough for our purposes  */
+static const uint32_t MAX_I2C_SPEED = 1000000L;       // PCA9685 rated up to 1MHz I2C clock speed
@@ -41 +41,2 @@ void PCA9685::create(VPIN firstVpin, int nPins, I2CAddress i2cAddress, uint16_t
-  if (checkNoOverlap(firstVpin, nPins,i2cAddress)) new PCA9685(firstVpin, nPins, i2cAddress, frequency);
+  if (checkNoOverlap(firstVpin, nPins, i2cAddress))
+    new PCA9685(firstVpin, nPins, i2cAddress, frequency);
@@ -46,6 +47,7 @@ bool PCA9685::_configure(VPIN vpin, ConfigTypeEnum configType, int paramCount, i
-  if (configType != CONFIGURE_SERVO) return false;
-  if (paramCount != 5) return false;
-  #ifdef DIAG_IO
-  DIAG(F("PCA9685 Configure VPIN:%u Apos:%d Ipos:%d Profile:%d Duration:%d state:%d"), 
-    vpin, params[0], params[1], params[2], params[3], params[4]);
-  #endif
+  if (configType != CONFIGURE_SERVO)
+    return false;
+  if (paramCount != 5)
+    return false;
+#ifdef DIAG_IO
+  DIAG(F("PCA9685 Configure VPIN:%u Apos:%d Ipos:%d Profile:%d Duration:%d state:%d"), vpin, params[0], params[1], params[2], params[3], params[4]);
+#endif
@@ -54,3 +56,3 @@ bool PCA9685::_configure(VPIN vpin, ConfigTypeEnum configType, int paramCount, i
-  struct ServoData *s = _servoData[pin];
-  if (s == NULL) { 
-    _servoData[pin] = (struct ServoData *)calloc(1, sizeof(struct ServoData));
+  struct ServoData* s = _servoData[pin];
+  if (s == NULL) {
+    _servoData[pin] = (struct ServoData*)calloc(1, sizeof(struct ServoData));
@@ -58 +60,2 @@ bool PCA9685::_configure(VPIN vpin, ConfigTypeEnum configType, int paramCount, i
-    if (!s) return false; // Check for failed memory allocation
+    if (!s)
+      return false;  // Check for failed memory allocation
@@ -70 +73 @@ bool PCA9685::_configure(VPIN vpin, ConfigTypeEnum configType, int paramCount, i
-  } 
+  }
@@ -77 +80 @@ PCA9685::PCA9685(VPIN firstVpin, int nPins, I2CAddress i2cAddress, uint16_t freq
-    _nPins = (nPins > 16) ? 16 : nPins;
+  _nPins = (nPins > 16) ? 16 : nPins;
@@ -80,2 +83,4 @@ PCA9685::PCA9685(VPIN firstVpin, int nPins, I2CAddress i2cAddress, uint16_t freq
-  if (frequency > 1526) frequency = 1526;
-  else if (frequency < 24) frequency = 24;
+  if (frequency > 1526)
+    frequency = 1526;
+  else if (frequency < 24)
+    frequency = 24;
@@ -85,2 +90 @@ PCA9685::PCA9685(VPIN firstVpin, int nPins, I2CAddress i2cAddress, uint16_t freq
-  for (int i=0; i<_nPins; i++)
-    _servoData[i] = NULL;
+  for (int i = 0; i < _nPins; i++) _servoData[i] = NULL;
@@ -97,3 +101,3 @@ void PCA9685::_begin() {
-  I2CManager.setClock(1000000); // Nominally able to run up to 1MHz on I2C
-          // In reality, other devices including the Arduino will limit 
-          // the clock speed to a lower rate.
+  I2CManager.setClock(1000000);  // Nominally able to run up to 1MHz on I2C
+                                 // In reality, other devices including the Arduino will limit
+                                 // the clock speed to a lower rate.
@@ -103 +107 @@ void PCA9685::_begin() {
-    writeRegister(_I2CAddress, PCA9685_MODE1, MODE1_SLEEP | MODE1_AI);    
+    writeRegister(_I2CAddress, PCA9685_MODE1, MODE1_SLEEP | MODE1_AI);
@@ -108 +112 @@ void PCA9685::_begin() {
-    // the PWM oscillator to get running.  However, we don't do any specific wait, as there's 
+    // the PWM oscillator to get running.  However, we don't do any specific wait, as there's
@@ -110 +114 @@ void PCA9685::_begin() {
-  #if defined(DIAG_IO)
+#if defined(DIAG_IO)
@@ -112 +116 @@ void PCA9685::_begin() {
-  #endif
+#endif
@@ -117 +121 @@ void PCA9685::_begin() {
-// Device-specific write function, invoked from IODevice::write().  
+// Device-specific write function, invoked from IODevice::write().
@@ -120 +124 @@ void PCA9685::_write(VPIN vpin, int value) {
-  #ifdef DIAG_IO
+#ifdef DIAG_IO
@@ -122 +126 @@ void PCA9685::_write(VPIN vpin, int value) {
-  #endif
+#endif
@@ -124 +128,2 @@ void PCA9685::_write(VPIN vpin, int value) {
-  if (value) value = 1;
+  if (value)
+    value = 1;
@@ -126 +131 @@ void PCA9685::_write(VPIN vpin, int value) {
-  struct ServoData *s = _servoData[pin];
+  struct ServoData* s = _servoData[pin];
@@ -130,4 +135,4 @@ void PCA9685::_write(VPIN vpin, int value) {
-  }  else {
-     /* simulate digital pin on PWM */
-      _writeAnalogue(vpin, value ? 4095 : 0, Instant | NoPowerOff, 0);     
-      }
+  } else {
+    /* simulate digital pin on PWM */
+    _writeAnalogue(vpin, value ? 4095 : 0, Instant | NoPowerOff, 0);
+  }
@@ -145 +150 @@ void PCA9685::_write(VPIN vpin, int value) {
-//            
+//
@@ -147,5 +152,6 @@ void PCA9685::_writeAnalogue(VPIN vpin, int value, uint8_t profile, uint16_t dur
-  #ifdef DIAG_IO
-  DIAG(F("PCA9685 WriteAnalogue VPIN:%u Value:%d Profile:%d Duration:%d %S"), 
-    vpin, value, profile, duration, _deviceState == DEVSTATE_FAILED?F("DEVSTATE_FAILED"):F(""));
-  #endif
-  if (_deviceState == DEVSTATE_FAILED) return;
+#ifdef DIAG_IO
+  DIAG(F("PCA9685 WriteAnalogue VPIN:%u Value:%d Profile:%d Duration:%d %S"), vpin, value, profile, duration,
+       _deviceState == DEVSTATE_FAILED ? F("DEVSTATE_FAILED") : F(""));
+#endif
+  if (_deviceState == DEVSTATE_FAILED)
+    return;
@@ -153,2 +159,4 @@ void PCA9685::_writeAnalogue(VPIN vpin, int value, uint8_t profile, uint16_t dur
-  if (value > 4095) value = 4095;
-  else if (value < 0) value = 0;
+  if (value > 4095)
+    value = 4095;
+  else if (value < 0)
+    value = 0;
@@ -156 +164 @@ void PCA9685::_writeAnalogue(VPIN vpin, int value, uint8_t profile, uint16_t dur
-  struct ServoData *s = _servoData[pin];
+  struct ServoData* s = _servoData[pin];
@@ -159,2 +167,3 @@ void PCA9685::_writeAnalogue(VPIN vpin, int value, uint8_t profile, uint16_t dur
-    s = _servoData[pin] = (struct ServoData *) calloc(sizeof(struct ServoData), 1);
-    if (s == NULL) return;  // Check for memory allocation failure
+    s = _servoData[pin] = (struct ServoData*)calloc(sizeof(struct ServoData), 1);
+    if (s == NULL)
+      return;  // Check for memory allocation failure
@@ -170,5 +179,8 @@ void PCA9685::_writeAnalogue(VPIN vpin, int value, uint8_t profile, uint16_t dur
-  s->numSteps = profileValue==Fast ? 10 :   // 0.5 seconds
-                profileValue==Medium ? 20 : // 1.0 seconds
-                profileValue==Slow ? 40 :   // 2.0 seconds
-                profileValue==Bounce ? sizeof(_bounceProfile)-1 : // ~ 1.5 seconds
-                duration * 2 + 1; // Convert from deciseconds (100ms) to refresh cycles (50ms)
+  s->numSteps = profileValue == Fast ? 10 :      // 0.5 seconds
+                    profileValue == Medium ? 20
+                                           :  // 1.0 seconds
+                    profileValue == Slow ? 40
+                                         :  // 2.0 seconds
+                    profileValue == Bounce ? sizeof(_bounceProfile) - 1
+                                           :  // ~ 1.5 seconds
+                    duration * 2 + 1;         // Convert from deciseconds (100ms) to refresh cycles (50ms)
@@ -180 +192 @@ void PCA9685::_writeAnalogue(VPIN vpin, int value, uint8_t profile, uint16_t dur
-// _read returns true if the device is currently in executing an animation, 
+// _read returns true if the device is currently in executing an animation,
@@ -183 +195,2 @@ int PCA9685::_read(VPIN vpin) {
-  if (_deviceState == DEVSTATE_FAILED) return 0;
+  if (_deviceState == DEVSTATE_FAILED)
+    return 0;
@@ -185,3 +198,3 @@ int PCA9685::_read(VPIN vpin) {
-  struct ServoData *s = _servoData[pin];
-  if (s == NULL) 
-    return false; // No structure means no animation!
+  struct ServoData* s = _servoData[pin];
+  if (s == NULL)
+    return false;  // No structure means no animation!
@@ -193 +206 @@ void PCA9685::_loop(unsigned long currentMicros) {
-  for (int pin=0; pin<_nPins; pin++) {
+  for (int pin = 0; pin < _nPins; pin++) {
@@ -202,3 +215 @@ void PCA9685::updatePosition(uint8_t pin) {
-  struct ServoData *s = _servoData[pin];
-  
-  if (s == NULL) return; // No pin configuration/state data
+  struct ServoData* s = _servoData[pin];
@@ -206 +217,5 @@ void PCA9685::updatePosition(uint8_t pin) {
-  if (s->numSteps == 0) return; // No animation in progress
+  if (s == NULL)
+    return;  // No pin configuration/state data
+
+  if (s->numSteps == 0)
+    return;  // No animation in progress
@@ -210 +225 @@ void PCA9685::updatePosition(uint8_t pin) {
-    s->stepNumber = s->numSteps-1;
+    s->stepNumber = s->numSteps - 1;
@@ -229,2 +244 @@ void PCA9685::updatePosition(uint8_t pin) {
-  } else if (s->stepNumber == s->numSteps + _catchupSteps 
-            && s->currentPosition != 0) {
+  } else if (s->stepNumber == s->numSteps + _catchupSteps && s->currentPosition != 0) {
@@ -244 +258 @@ void PCA9685::writeDevice(uint8_t pin, int value) {
-  #ifdef DIAG_IO
+#ifdef DIAG_IO
@@ -246 +260 @@ void PCA9685::writeDevice(uint8_t pin, int value) {
-  #endif
+#endif
@@ -265,2 +279,2 @@ void PCA9685::_display() {
-  DIAG(F("PCA9685 I2C:%s Configured on Vpins:%u-%u %S"), _I2CAddress.toString(), (int)_firstVpin, 
-    (int)_firstVpin+_nPins-1, (_deviceState==DEVSTATE_FAILED) ? F("OFFLINE") : F(""));
+  DIAG(F("PCA9685 I2C:%s Configured on Vpins:%u-%u %S"), _I2CAddress.toString(), (int)_firstVpin, (int)_firstVpin + _nPins - 1,
+       (_deviceState == DEVSTATE_FAILED) ? F("OFFLINE") : F(""));
@@ -278,2 +292,2 @@ static void writeRegister(byte address, byte reg, byte value) {
-const uint8_t FLASH PCA9685::_bounceProfile[30] = 
-    {0,2,3,7,13,33,50,83,100,83,75,70,65,60,60,65,74,84,100,83,75,70,70,72,75,80,87,92,97,100};
+const uint8_t FLASH PCA9685::_bounceProfile[30] = {0,  2,  3,  7,   13, 33, 50, 83, 100, 83, 75, 70, 65, 60, 60,
+                                                   65, 74, 84, 100, 83, 75, 70, 70, 72,  75, 80, 87, 92, 97, 100};
diff --git a/IO_PCA9685pwm.h b/IO_PCA9685pwm.h
index 98885b8..a3d8fe2 100644
--- a/IO_PCA9685pwm.h
+++ b/IO_PCA9685pwm.h
@@ -3 +3 @@
- *  
+ *
@@ -20,3 +20,3 @@
-/* 
- * This driver performs the basic interface between the HAL and an 
- * I2C-connected PCA9685 16-channel PWM module.  When requested, it 
+/*
+ * This driver performs the basic interface between the HAL and an
+ * I2C-connected PCA9685 16-channel PWM module.  When requested, it
@@ -26 +26 @@
- * 
+ *
@@ -32 +32 @@
- * 
+ *
@@ -34 +34 @@
- * 
+ *
@@ -39 +39 @@
- * 
+ *
@@ -41 +41 @@
- * 
+ *
@@ -54 +54 @@
- 
+
@@ -56 +56 @@ class PCA9685pwm : public IODevice {
-public:
+ public:
@@ -59 +59,2 @@ public:
-    if (checkNoOverlap(firstVpin, nPins, i2cAddress)) new PCA9685pwm(firstVpin, nPins, i2cAddress, frequency);
+    if (checkNoOverlap(firstVpin, nPins, i2cAddress))
+      new PCA9685pwm(firstVpin, nPins, i2cAddress, frequency);
@@ -62,2 +63 @@ public:
-private:
-  
+ private:
@@ -70,3 +70,3 @@ private:
-  const uint8_t PCA9685_MODE1=0x00;      // Mode Register 
-  const uint8_t PCA9685_FIRST_SERVO=0x06;  /** low uint8_t first PWM register ON*/
-  const uint8_t PCA9685_PRESCALE=0xFE;     /** Prescale register for PWM output frequency */
+  const uint8_t PCA9685_MODE1 = 0x00;       // Mode Register
+  const uint8_t PCA9685_FIRST_SERVO = 0x06; /** low uint8_t first PWM register ON*/
+  const uint8_t PCA9685_PRESCALE = 0xFE;    /** Prescale register for PWM output frequency */
@@ -74,3 +74,3 @@ private:
-  const uint8_t MODE1_SLEEP=0x10;   /**< Low power mode. Oscillator off */
-  const uint8_t MODE1_AI=0x20;      /**< Auto-Increment enabled */
-  const uint8_t MODE1_RESTART=0x80; /**< Restart enabled */
+  const uint8_t MODE1_SLEEP = 0x10;   /**< Low power mode. Oscillator off */
+  const uint8_t MODE1_AI = 0x20;      /**< Auto-Increment enabled */
+  const uint8_t MODE1_RESTART = 0x80; /**< Restart enabled */
@@ -78 +78 @@ private:
-  const uint32_t FREQUENCY_OSCILLATOR=25000000; /** Accurate enough for our purposes  */
+  const uint32_t FREQUENCY_OSCILLATOR = 25000000; /** Accurate enough for our purposes  */
@@ -80 +80 @@ private:
-  const uint32_t MAX_I2C_SPEED = 1000000L; // PCA9685 rated up to 1MHz I2C clock speed
+  const uint32_t MAX_I2C_SPEED = 1000000L;  // PCA9685 rated up to 1MHz I2C clock speed
@@ -85 +85 @@ private:
-    _nPins = (nPins>16) ? 16 : nPins;
+    _nPins = (nPins > 16) ? 16 : nPins;
@@ -87,2 +87,4 @@ private:
-    if (frequency > 1526) frequency = 1526;
-    else if (frequency < 24) frequency = 24;
+    if (frequency > 1526)
+      frequency = 1526;
+    else if (frequency < 24)
+      frequency = 24;
@@ -99,3 +101,3 @@ private:
-    I2CManager.setClock(1000000); // Nominally able to run up to 1MHz on I2C
-            // In reality, other devices including the Arduino will limit 
-            // the clock speed to a lower rate.
+    I2CManager.setClock(1000000);  // Nominally able to run up to 1MHz on I2C
+                                   // In reality, other devices including the Arduino will limit
+                                   // the clock speed to a lower rate.
@@ -110 +112 @@ private:
-      // the PWM oscillator to get running.  However, we don't do any specific wait, as there's 
+      // the PWM oscillator to get running.  However, we don't do any specific wait, as there's
@@ -112 +114 @@ private:
-    #if defined(DIAG_IO)
+#if defined(DIAG_IO)
@@ -114 +116 @@ private:
-    #endif
+#endif
@@ -120 +122 @@ private:
-  //            
+  //
@@ -122,6 +124,7 @@ private:
-    (void)param1; (void)param2;  // suppress compiler warning
-    #ifdef DIAG_IO
-    DIAG(F("PCA9685pwm WriteAnalogue VPIN:%u Value:%d %S"), 
-      vpin, value, _deviceState == DEVSTATE_FAILED?F("DEVSTATE_FAILED"):F(""));
-    #endif
-    if (_deviceState == DEVSTATE_FAILED) return;
+    (void)param1;
+    (void)param2;  // suppress compiler warning
+#ifdef DIAG_IO
+    DIAG(F("PCA9685pwm WriteAnalogue VPIN:%u Value:%d %S"), vpin, value, _deviceState == DEVSTATE_FAILED ? F("DEVSTATE_FAILED") : F(""));
+#endif
+    if (_deviceState == DEVSTATE_FAILED)
+      return;
@@ -129,2 +132,4 @@ private:
-    if (value > 4095) value = 4095;
-    else if (value < 0) value = 0;
+    if (value > 4095)
+      value = 4095;
+    else if (value < 0)
+      value = 0;
@@ -137,2 +142,2 @@ private:
-    DIAG(F("PCA9685pwm I2C:%s Configured on Vpins:%u-%u %S"), _I2CAddress.toString(), (int)_firstVpin, 
-      (int)_firstVpin+_nPins-1, (_deviceState==DEVSTATE_FAILED) ? F("OFFLINE") : F(""));
+    DIAG(F("PCA9685pwm I2C:%s Configured on Vpins:%u-%u %S"), _I2CAddress.toString(), (int)_firstVpin, (int)_firstVpin + _nPins - 1,
+         (_deviceState == DEVSTATE_FAILED) ? F("OFFLINE") : F(""));
@@ -144 +149 @@ private:
-    #ifdef DIAG_IO
+#ifdef DIAG_IO
@@ -146 +151 @@ private:
-    #endif
+#endif
@@ -167 +171,0 @@ private:
-
diff --git a/IO_PCF8574.h b/IO_PCF8574.h
index 17241ee..77328ce 100644
--- a/IO_PCF8574.h
+++ b/IO_PCF8574.h
@@ -4 +4 @@
- *  
+ *
@@ -21,3 +21,3 @@
-/* 
- * The PCF8574 is a simple device; it only has one register.  The device 
- * input/output mode and pullup are configured through this, and the 
+/*
+ * The PCF8574 is a simple device; it only has one register.  The device
+ * input/output mode and pullup are configured through this, and the
@@ -25 +25 @@
- * 
+ *
@@ -27 +27 @@
- * and a read-back of the other end of the resistor.  As an output, the 
+ * and a read-back of the other end of the resistor.  As an output, the
@@ -30 +30 @@
- * 
+ *
@@ -34 +34 @@
- * 
+ *
@@ -45,3 +45,4 @@ class PCF8574 : public GPIOBase<uint8_t> {
-public:
-  static void create(VPIN firstVpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin=-1) {
-    if (checkNoOverlap(firstVpin, nPins, i2cAddress)) new PCF8574(firstVpin, nPins, i2cAddress, interruptPin);
+ public:
+  static void create(VPIN firstVpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin = -1) {
+    if (checkNoOverlap(firstVpin, nPins, i2cAddress))
+      new PCF8574(firstVpin, nPins, i2cAddress, interruptPin);
@@ -50,4 +51,3 @@ public:
-private:
-  PCF8574(VPIN firstVpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin=-1)
-    : GPIOBase<uint8_t>((FSH *)F("PCF8574"), firstVpin, nPins, i2cAddress, interruptPin) 
-  {
+ private:
+  PCF8574(VPIN firstVpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin = -1)
+      : GPIOBase<uint8_t>((FSH*)F("PCF8574"), firstVpin, nPins, i2cAddress, interruptPin) {
@@ -56 +56 @@ private:
-  
+
@@ -65 +65 @@ private:
-  // Therefore, writing '1' in _writePortModes is enough to set the module to input mode 
+  // Therefore, writing '1' in _writePortModes is enough to set the module to input mode
@@ -67 +67,2 @@ private:
-  void _writePullups() override { }
+  void _writePullups() override {
+  }
@@ -82 +83 @@ private:
-      requestBlock.wait(); // Wait for preceding operation to complete
+      requestBlock.wait();  // Wait for preceding operation to complete
@@ -90 +91 @@ private:
-    if (status == I2C_STATUS_OK) 
+    if (status == I2C_STATUS_OK)
@@ -92,2 +93,2 @@ private:
-    else  
-      _portInputState = 0xff; 
+    else
+      _portInputState = 0xff;
@@ -97 +98 @@ private:
-  void _setupDevice() override { 
+  void _setupDevice() override {
@@ -100 +101 @@ private:
- 
+
diff --git a/IO_PCF8575.h b/IO_PCF8575.h
index 4d9caa1..883d4cb 100644
--- a/IO_PCF8575.h
+++ b/IO_PCF8575.h
@@ -4 +4 @@
- *  
+ *
@@ -21,3 +21,3 @@
-/* 
- * The PCF8575 is a simple device; it only has one register.  The device 
- * input/output mode and pullup are configured through this, and the 
+/*
+ * The PCF8575 is a simple device; it only has one register.  The device
+ * input/output mode and pullup are configured through this, and the
@@ -25 +25 @@
- * 
+ *
@@ -27 +27 @@
- * and a read-back of the other end of the resistor.  As an output, the 
+ * and a read-back of the other end of the resistor.  As an output, the
@@ -30 +30 @@
- * 
+ *
@@ -34 +34 @@
- * 
+ *
@@ -46,3 +46,4 @@ class PCF8575 : public GPIOBase<uint16_t> {
-public:
-  static void create(VPIN firstVpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin=-1) {
-    if (checkNoOverlap(firstVpin, nPins, i2cAddress)) new PCF8575(firstVpin, nPins, i2cAddress, interruptPin);
+ public:
+  static void create(VPIN firstVpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin = -1) {
+    if (checkNoOverlap(firstVpin, nPins, i2cAddress))
+      new PCF8575(firstVpin, nPins, i2cAddress, interruptPin);
@@ -51,4 +52,3 @@ public:
-private:
-  PCF8575(VPIN firstVpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin=-1)
-    : GPIOBase<uint16_t>((FSH *)F("PCF8575"), firstVpin, nPins, i2cAddress, interruptPin)
-  {
+ private:
+  PCF8575(VPIN firstVpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin = -1)
+      : GPIOBase<uint16_t>((FSH*)F("PCF8575"), firstVpin, nPins, i2cAddress, interruptPin) {
@@ -57 +57 @@ private:
-  
+
@@ -63 +63 @@ private:
-    I2CManager.write(_I2CAddress, 2, bits, bits>>8);
+    I2CManager.write(_I2CAddress, 2, bits, bits >> 8);
@@ -67 +67 @@ private:
-  // Therefore, writing '1' in _writePortModes is enough to set the module to input mode 
+  // Therefore, writing '1' in _writePortModes is enough to set the module to input mode
@@ -69 +69,2 @@ private:
-  void _writePullups() override { }
+  void _writePullups() override {
+  }
@@ -71 +72 @@ private:
-  // The pin state is '1' if the pin is an input or if it is an output set to 1.  Zero otherwise. 
+  // The pin state is '1' if the pin is an input or if it is an output set to 1.  Zero otherwise.
@@ -83 +84 @@ private:
-      _portInputState = (((uint16_t)buffer[1]<<8) | buffer[0]) | _portMode;
+      _portInputState = (((uint16_t)buffer[1] << 8) | buffer[0]) | _portMode;
@@ -85 +86 @@ private:
-      requestBlock.wait(); // Wait for preceding operation to complete
+      requestBlock.wait();  // Wait for preceding operation to complete
@@ -93,3 +94,3 @@ private:
-    if (status == I2C_STATUS_OK) 
-      _portInputState = (((uint16_t)inputBuffer[1]<<8) | inputBuffer[0]) | _portMode;
-    else  
+    if (status == I2C_STATUS_OK)
+      _portInputState = (((uint16_t)inputBuffer[1] << 8) | inputBuffer[0]) | _portMode;
+    else
@@ -100 +101 @@ private:
-  void _setupDevice() override { 
+  void _setupDevice() override {
@@ -105 +106 @@ private:
- 
+
diff --git a/IO_RotaryEncoder.h b/IO_RotaryEncoder.h
index 2e6cfe7..1b4df63 100644
--- a/IO_RotaryEncoder.h
+++ b/IO_RotaryEncoder.h
@@ -19 +19 @@
-*/
+ */
@@ -22,29 +22,29 @@
-* The IO_RotaryEncoder device driver is used to receive positions from a rotary encoder connected to an Arduino via I2C.
-*
-* There is separate code required for the Arduino the rotary encoder is connected to, which is located here:
-* https://github.com/peteGSX-Projects/dcc-ex-rotary-encoder
-*
-* This device driver receives the rotary encoder position when the rotary encoder button is pushed, and these positions
-* can be tested in EX-RAIL with:
-* ONCHANGE(vpin) - flag when the rotary encoder position has changed from the previous position
-* IFRE(vpin, position) - test to see if specified rotary encoder position has been received
-*
-* Feedback can also be sent to the rotary encoder by using 2 Vpins, and sending a SET()/RESET() to the second Vpin.
-* A SET(vpin) will flag that a turntable (or anything else) is in motion, and a RESET(vpin) that the motion has finished.
-*
-* In addition, defining a third Vpin will allow a position number to be sent so that when an EXRAIL automation or some other
-* activity has moved a turntable, the position can be reflected in the rotary encoder software. This can be accomplished
-* using the EXRAIL SERVO(vpin, position, profile) command, where:
-* - vpin = the third defined Vpin (any other is ignored)
-* - position = the defined position in the DCC-EX Rotary Encoder software, 0 (Home) to 255
-* - profile = Must be defined as per the SERVO() command, but is ignored as it has no relevance
-*
-* Defining in myAutomation.h requires the device driver to be included in addition to the HAL() statement. Examples:
-*
-* #include "IO_RotaryEncoder.h"
-* HAL(RotaryEncoder, 700, 1, 0x67)    // Define single Vpin, no feedback or position sent to rotary encoder software
-* HAL(RotaryEncoder, 700, 2, 0x67)    // Define two Vpins, feedback only sent to rotary encoder software
-* HAL(RotaryEncoder, 700, 3, 0x67)    // Define three Vpins, can send feedback and position update to rotary encoder software
-*
-* Refer to the documentation for further information including the valid activities and examples.
-*/
+ * The IO_RotaryEncoder device driver is used to receive positions from a rotary encoder connected to an Arduino via I2C.
+ *
+ * There is separate code required for the Arduino the rotary encoder is connected to, which is located here:
+ * https://github.com/peteGSX-Projects/dcc-ex-rotary-encoder
+ *
+ * This device driver receives the rotary encoder position when the rotary encoder button is pushed, and these positions
+ * can be tested in EX-RAIL with:
+ * ONCHANGE(vpin) - flag when the rotary encoder position has changed from the previous position
+ * IFRE(vpin, position) - test to see if specified rotary encoder position has been received
+ *
+ * Feedback can also be sent to the rotary encoder by using 2 Vpins, and sending a SET()/RESET() to the second Vpin.
+ * A SET(vpin) will flag that a turntable (or anything else) is in motion, and a RESET(vpin) that the motion has finished.
+ *
+ * In addition, defining a third Vpin will allow a position number to be sent so that when an EXRAIL automation or some other
+ * activity has moved a turntable, the position can be reflected in the rotary encoder software. This can be accomplished
+ * using the EXRAIL SERVO(vpin, position, profile) command, where:
+ * - vpin = the third defined Vpin (any other is ignored)
+ * - position = the defined position in the DCC-EX Rotary Encoder software, 0 (Home) to 255
+ * - profile = Must be defined as per the SERVO() command, but is ignored as it has no relevance
+ *
+ * Defining in myAutomation.h requires the device driver to be included in addition to the HAL() statement. Examples:
+ *
+ * #include "IO_RotaryEncoder.h"
+ * HAL(RotaryEncoder, 700, 1, 0x67)    // Define single Vpin, no feedback or position sent to rotary encoder software
+ * HAL(RotaryEncoder, 700, 2, 0x67)    // Define two Vpins, feedback only sent to rotary encoder software
+ * HAL(RotaryEncoder, 700, 3, 0x67)    // Define three Vpins, can send feedback and position update to rotary encoder software
+ *
+ * Refer to the documentation for further information including the valid activities and examples.
+ */
@@ -61,2 +61 @@ class RotaryEncoder : public IODevice {
-public:
-  
+ public:
@@ -64 +63,2 @@ public:
-    if (checkNoOverlap(firstVpin, nPins, i2cAddress)) new RotaryEncoder(firstVpin, nPins, i2cAddress);
+    if (checkNoOverlap(firstVpin, nPins, i2cAddress))
+      new RotaryEncoder(firstVpin, nPins, i2cAddress);
@@ -67 +67 @@ public:
-private:
+ private:
@@ -69 +69 @@ private:
-  RotaryEncoder(VPIN firstVpin, int nPins, I2CAddress i2cAddress){
+  RotaryEncoder(VPIN firstVpin, int nPins, I2CAddress i2cAddress) {
@@ -117,2 +117,4 @@ private:
-    if (_deviceState == DEVSTATE_FAILED) return;  // Return if device has failed
-    if (_i2crb.isBusy()) return;                  // Return if I2C operation still in progress
+    if (_deviceState == DEVSTATE_FAILED)
+      return;  // Return if device has failed
+    if (_i2crb.isBusy())
+      return;  // Return if I2C operation still in progress
@@ -123 +125 @@ private:
-      I2CManager.read(_I2CAddress, _rcvBuffer, 1, _sendBuffer, 1, &_i2crb); // Read position from encoder
+      I2CManager.read(_I2CAddress, _rcvBuffer, 1, _sendBuffer, 1, &_i2crb);  // Read position from encoder
@@ -139 +141,2 @@ private:
-    if (_deviceState == DEVSTATE_FAILED) return 0;
+    if (_deviceState == DEVSTATE_FAILED)
+      return 0;
@@ -146 +149,2 @@ private:
-      if (value != 0) value = 0x01;
+      if (value != 0)
+        value = 0x01;
@@ -164 +168 @@ private:
-  
+
@@ -166,2 +170,2 @@ private:
-    DIAG(F("Rotary Encoder I2C:%s v%d.%d.%d Configured on VPIN:%u-%d %S"), _I2CAddress.toString(), _majorVer, _minorVer, _patchVer,
-      (int)_firstVpin, _firstVpin+_nPins-1, (_deviceState==DEVSTATE_FAILED) ? F("OFFLINE") : F(""));
+    DIAG(F("Rotary Encoder I2C:%s v%d.%d.%d Configured on VPIN:%u-%d %S"), _I2CAddress.toString(), _majorVer, _minorVer, _patchVer, (int)_firstVpin,
+         _firstVpin + _nPins - 1, (_deviceState == DEVSTATE_FAILED) ? F("OFFLINE") : F(""));
@@ -180 +184 @@ private:
-  const unsigned long _positionRefresh = 100000UL;    // Delay refreshing position for 100ms
+  const unsigned long _positionRefresh = 100000UL;  // Delay refreshing position for 100ms
@@ -189 +192,0 @@ private:
-
diff --git a/IO_Servo.cpp b/IO_Servo.cpp
index 841fe68..3cb96b6 100644
--- a/IO_Servo.cpp
+++ b/IO_Servo.cpp
@@ -3 +3 @@
- *  
+ *
@@ -31,2 +31,2 @@
-const uint8_t FLASH Servo::_bounceProfile[30] = 
-    {0,2,3,7,13,33,50,83,100,83,75,70,65,60,60,65,74,84,100,83,75,70,70,72,75,80,87,92,97,100};
+const uint8_t FLASH Servo::_bounceProfile[30] = {0,  2,  3,  7,   13, 33, 50, 83, 100, 83, 75, 70, 65, 60, 60,
+                                                 65, 74, 84, 100, 83, 75, 70, 70, 72,  75, 80, 87, 92, 97, 100};
diff --git a/IO_Servo.h b/IO_Servo.h
index 4e50bf3..7721703 100644
--- a/IO_Servo.h
+++ b/IO_Servo.h
@@ -3 +3 @@
- *  
+ *
@@ -22,2 +22,2 @@
- * device.  The underlying device class is expected to accept writeAnalogue calls 
- * which will normally cause some physical movement of something.  The device may be a servo, 
+ * device.  The underlying device class is expected to accept writeAnalogue calls
+ * which will normally cause some physical movement of something.  The device may be a servo,
@@ -27 +27 @@
- * 
+ *
@@ -29,2 +29,2 @@
- *    In myHal.cpp, 
- * 
+ *    In myHal.cpp,
+ *
@@ -34 +34 @@
- * Servo::create(300,16,100);    // Then create the higher level device which 
+ * Servo::create(300,16,100);    // Then create the higher level device which
@@ -36 +36 @@
- * 
+ *
@@ -39,2 +39,2 @@
- * be substituted with any other driver which provides analogue output 
- * capability, e.g. EX-IOExpander devices, as long as they are capable of interpreting 
+ * be substituted with any other driver which provides analogue output
+ * capability, e.g. EX-IOExpander devices, as long as they are capable of interpreting
@@ -53,2 +53 @@ class Servo : IODevice {
-
-public: 
+ public:
@@ -56,7 +55,7 @@ public:
-    Instant = 0,  // Moves immediately between positions (if duration not specified)
-    UseDuration = 0, // Use specified duration
-    Fast = 1,     // Takes around 500ms end-to-end
-    Medium = 2,   // 1 second end-to-end
-    Slow = 3,     // 2 seconds end-to-end
-    Bounce = 4,   // For semaphores/turnouts with a bit of bounce!!
-    NoPowerOff = 0x80, // Flag to be ORed in to suppress power off after move.
+    Instant = 0,        // Moves immediately between positions (if duration not specified)
+    UseDuration = 0,    // Use specified duration
+    Fast = 1,           // Takes around 500ms end-to-end
+    Medium = 2,         // 1 second end-to-end
+    Slow = 3,           // 2 seconds end-to-end
+    Bounce = 4,         // For semaphores/turnouts with a bit of bounce!!
+    NoPowerOff = 0x80,  // Flag to be ORed in to suppress power off after move.
@@ -66 +65 @@ public:
-  static void create(VPIN firstVpin, int nPins, VPIN firstSlavePin=VPIN_NONE) {
+  static void create(VPIN firstVpin, int nPins, VPIN firstSlavePin = VPIN_NONE) {
@@ -70 +69 @@ public:
-private:
+ private:
@@ -72 +71 @@ private:
-  IODevice *_slaveDevice = NULL;
+  IODevice* _slaveDevice = NULL;
@@ -75,2 +74,2 @@ private:
-    uint16_t activePosition : 12; // Config parameter
-    uint16_t inactivePosition : 12; // Config parameter
+    uint16_t activePosition : 12;    // Config parameter
+    uint16_t inactivePosition : 12;  // Config parameter
@@ -79,12 +78,7 @@ private:
-    uint16_t toPosition : 12; 
-    uint8_t profile;  // Config parameter
-    uint16_t stepNumber; // Index of current step (starting from 0)
-    uint16_t numSteps;  // Number of steps in animation, or 0 if none in progress.
-    uint8_t currentProfile; // profile being used for current animation.
-    uint16_t duration; // time (tenths of a second) for animation to complete.
-  }; // 14 bytes per element, i.e. per pin in use
-  
-  struct ServoData *_servoData [16];
-
-  static const uint8_t _catchupSteps = 5; // number of steps to wait before switching servo off
-  static const uint8_t FLASH _bounceProfile[30];
+    uint16_t toPosition : 12;
+    uint8_t profile;         // Config parameter
+    uint16_t stepNumber;     // Index of current step (starting from 0)
+    uint16_t numSteps;       // Number of steps in animation, or 0 if none in progress.
+    uint8_t currentProfile;  // profile being used for current animation.
+    uint16_t duration;       // time (tenths of a second) for animation to complete.
+  };  // 14 bytes per element, i.e. per pin in use
@@ -92 +86,4 @@ private:
-  const unsigned int refreshInterval = 50; // refresh every 50ms
+  struct ServoData* _servoData[16];
+
+  static const uint8_t _catchupSteps = 5;  // number of steps to wait before switching servo off
+  static const uint8_t FLASH _bounceProfile[30];
@@ -93,0 +91 @@ private:
+  const unsigned int refreshInterval = 50;  // refresh every 50ms
@@ -97,7 +95,9 @@ private:
-    if (_deviceState == DEVSTATE_FAILED) return false;
-    if (configType != CONFIGURE_SERVO) return false;
-    if (paramCount != 5) return false;
-    #ifdef DIAG_IO
-    DIAG(F("Servo: Configure VPIN:%u Apos:%d Ipos:%d Profile:%d Duration:%d state:%d"), 
-      vpin, params[0], params[1], params[2], params[3], params[4]);
-    #endif
+    if (_deviceState == DEVSTATE_FAILED)
+      return false;
+    if (configType != CONFIGURE_SERVO)
+      return false;
+    if (paramCount != 5)
+      return false;
+#ifdef DIAG_IO
+    DIAG(F("Servo: Configure VPIN:%u Apos:%d Ipos:%d Profile:%d Duration:%d state:%d"), vpin, params[0], params[1], params[2], params[3], params[4]);
+#endif
@@ -106,3 +106,3 @@ private:
-    struct ServoData *s = _servoData[pin];
-    if (s == NULL) { 
-      _servoData[pin] = (struct ServoData *)calloc(1, sizeof(struct ServoData));
+    struct ServoData* s = _servoData[pin];
+    if (s == NULL) {
+      _servoData[pin] = (struct ServoData*)calloc(1, sizeof(struct ServoData));
@@ -110 +110,2 @@ private:
-      if (!s) return false; // Check for failed memory allocation
+      if (!s)
+        return false;  // Check for failed memory allocation
@@ -122 +123 @@ private:
-    } 
+    }
@@ -137,2 +138 @@ private:
-    for (int i=0; i<_nPins; i++)
-      _servoData[i] = NULL;
+    for (int i = 0; i < _nPins; i++) _servoData[i] = NULL;
@@ -143,2 +143 @@ private:
-      DIAG(F("Servo: Slave device not found on Vpins %u-%u"), 
-        _firstSlavePin, _firstSlavePin+_nPins-1);
+      DIAG(F("Servo: Slave device not found on Vpins %u-%u"), _firstSlavePin, _firstSlavePin + _nPins - 1);
@@ -146,4 +145,3 @@ private:
-    }      
-    if (_slaveDevice != findDevice(_firstSlavePin+_nPins-1)) {
-      DIAG(F("Servo: Slave device does not cover all Vpins %u-%u"), 
-        _firstSlavePin, _firstSlavePin+_nPins-1);
+    }
+    if (_slaveDevice != findDevice(_firstSlavePin + _nPins - 1)) {
+      DIAG(F("Servo: Slave device does not cover all Vpins %u-%u"), _firstSlavePin, _firstSlavePin + _nPins - 1);
@@ -153 +151 @@ private:
-    addDevice(this, _slaveDevice); // Link device ahead of slave device to intercept requests
+    addDevice(this, _slaveDevice);  // Link device ahead of slave device to intercept requests
@@ -158 +156 @@ private:
-    #if defined(DIAG_IO)
+#if defined(DIAG_IO)
@@ -160 +158 @@ private:
-    #endif
+#endif
@@ -163 +161 @@ private:
-  // Device-specific write function, invoked from IODevice::write().  
+  // Device-specific write function, invoked from IODevice::write().
@@ -166,2 +164,3 @@ private:
-    if (_deviceState == DEVSTATE_FAILED) return;
-    #ifdef DIAG_IO
+    if (_deviceState == DEVSTATE_FAILED)
+      return;
+#ifdef DIAG_IO
@@ -169 +168 @@ private:
-    #endif
+#endif
@@ -171 +170,2 @@ private:
-    if (value) value = 1;
+    if (value)
+      value = 1;
@@ -173 +173 @@ private:
-    struct ServoData *s = _servoData[pin];
+    struct ServoData* s = _servoData[pin];
@@ -177 +177 @@ private:
-    }  else {
+    } else {
@@ -179 +179 @@ private:
-      writeAnalogue(vpin, value ? 4095 : 0, Instant | NoPowerOff, 0);     
+      writeAnalogue(vpin, value ? 4095 : 0, Instant | NoPowerOff, 0);
@@ -192,2 +192,2 @@ private:
-  // Duration is in deciseconds (tenths of a second) and defaults to 0.  
-  //            
+  // Duration is in deciseconds (tenths of a second) and defaults to 0.
+  //
@@ -195,5 +195,6 @@ private:
-    #ifdef DIAG_IO
-    DIAG(F("Servo: WriteAnalogue VPIN:%u Value:%d Profile:%d Duration:%d %S"), 
-      vpin, value, profile, duration, _deviceState == DEVSTATE_FAILED?F("DEVSTATE_FAILED"):F(""));
-    #endif
-    if (_deviceState == DEVSTATE_FAILED) return;
+#ifdef DIAG_IO
+    DIAG(F("Servo: WriteAnalogue VPIN:%u Value:%d Profile:%d Duration:%d %S"), vpin, value, profile, duration,
+         _deviceState == DEVSTATE_FAILED ? F("DEVSTATE_FAILED") : F(""));
+#endif
+    if (_deviceState == DEVSTATE_FAILED)
+      return;
@@ -201,2 +202,4 @@ private:
-    if (value > 4095) value = 4095;
-    else if (value < 0) value = 0;
+    if (value > 4095)
+      value = 4095;
+    else if (value < 0)
+      value = 0;
@@ -204 +207 @@ private:
-    struct ServoData *s = _servoData[pin];
+    struct ServoData* s = _servoData[pin];
@@ -207,2 +210,3 @@ private:
-      s = _servoData[pin] = (struct ServoData *) calloc(sizeof(struct ServoData), 1);
-      if (s == NULL) return;  // Check for memory allocation failure
+      s = _servoData[pin] = (struct ServoData*)calloc(sizeof(struct ServoData), 1);
+      if (s == NULL)
+        return;  // Check for memory allocation failure
@@ -218,5 +222,8 @@ private:
-    s->numSteps = profileValue==Fast ? 10 :   // 0.5 seconds
-                  profileValue==Medium ? 20 : // 1.0 seconds
-                  profileValue==Slow ? 40 :   // 2.0 seconds
-                  profileValue==Bounce ? sizeof(_bounceProfile)-1 : // ~ 1.5 seconds
-                  duration * 2 + 1; // Convert from deciseconds (100ms) to refresh cycles (50ms)
+    s->numSteps = profileValue == Fast ? 10 :      // 0.5 seconds
+                      profileValue == Medium ? 20
+                                             :  // 1.0 seconds
+                      profileValue == Slow ? 40
+                                           :  // 2.0 seconds
+                      profileValue == Bounce ? sizeof(_bounceProfile) - 1
+                                             :  // ~ 1.5 seconds
+                      duration * 2 + 1;         // Convert from deciseconds (100ms) to refresh cycles (50ms)
@@ -228 +235 @@ private:
-  // _read returns true if the device is currently in executing an animation, 
+  // _read returns true if the device is currently in executing an animation,
@@ -231 +238,2 @@ private:
-    if (_deviceState == DEVSTATE_FAILED) return 0;
+    if (_deviceState == DEVSTATE_FAILED)
+      return 0;
@@ -233,3 +241,3 @@ private:
-    struct ServoData *s = _servoData[pin];
-    if (s == NULL) 
-      return false; // No structure means no animation!
+    struct ServoData* s = _servoData[pin];
+    if (s == NULL)
+      return false;  // No structure means no animation!
@@ -241,2 +249,3 @@ private:
-    if (_deviceState == DEVSTATE_FAILED) return;
-    for (int pin=0; pin<_nPins; pin++) {
+    if (_deviceState == DEVSTATE_FAILED)
+      return;
+    for (int pin = 0; pin < _nPins; pin++) {
@@ -251,2 +260,3 @@ private:
-    struct ServoData *s = _servoData[pin];
-    if (s == NULL) return; // No pin configuration/state data
+    struct ServoData* s = _servoData[pin];
+    if (s == NULL)
+      return;  // No pin configuration/state data
@@ -254 +264,2 @@ private:
-    if (s->numSteps == 0) return; // No animation in progress
+    if (s->numSteps == 0)
+      return;  // No animation in progress
@@ -258 +269 @@ private:
-      s->stepNumber = s->numSteps-1;
+      s->stepNumber = s->numSteps - 1;
@@ -273 +284 @@ private:
-      _slaveDevice->_writeAnalogue(_firstSlavePin+pin, s->currentPosition);
+      _slaveDevice->_writeAnalogue(_firstSlavePin + pin, s->currentPosition);
@@ -277,3 +288,2 @@ private:
-    } else if (s->stepNumber == s->numSteps + _catchupSteps 
-              && s->currentPosition != 0) {
-  #ifdef IO_SWITCH_OFF_SERVO
+    } else if (s->stepNumber == s->numSteps + _catchupSteps && s->currentPosition != 0) {
+#ifdef IO_SWITCH_OFF_SERVO
@@ -282 +292 @@ private:
-        _slaveDevice->_writeAnalogue(_firstSlavePin+pin, 0);
+        _slaveDevice->_writeAnalogue(_firstSlavePin + pin, 0);
@@ -284 +294 @@ private:
-  #endif
+#endif
@@ -291,4 +301,2 @@ private:
-    DIAG(F("Servo Configured on Vpins:%u-%u, slave pins:%d-%d %S"),
-      (int)_firstVpin, (int)_firstVpin+_nPins-1,
-      (int)_firstSlavePin, (int)_firstSlavePin+_nPins-1,
-      (_deviceState==DEVSTATE_FAILED) ? F("OFFLINE") : F(""));
+    DIAG(F("Servo Configured on Vpins:%u-%u, slave pins:%d-%d %S"), (int)_firstVpin, (int)_firstVpin + _nPins - 1, (int)_firstSlavePin,
+         (int)_firstSlavePin + _nPins - 1, (_deviceState == DEVSTATE_FAILED) ? F("OFFLINE") : F(""));
diff --git a/IO_TCA8418.h b/IO_TCA8418.h
index f2ff99c..97adf3b 100644
--- a/IO_TCA8418.h
+++ b/IO_TCA8418.h
@@ -4 +4 @@
- *  
+ *
@@ -34 +34 @@
- * 
+ *
@@ -36 +36 @@
- * 
+ *
@@ -42 +42 @@
- * 
+ *
@@ -44 +44 @@
- * 
+ *
@@ -55 +55 @@
- * 
+ *
@@ -57 +57 @@
- * 
+ *
@@ -60 +60 @@
- * 
+ *
@@ -62 +62 @@
- * 
+ *
@@ -65 +65 @@
- * 
+ *
@@ -68 +68 @@
- * 
+ *
@@ -71 +71 @@
- * 
+ *
@@ -76,3 +75,0 @@
- 
-class TCA8418 : public IODevice {
-public:
@@ -80 +77,3 @@ public:
-  static void create(VPIN firstVpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin=-1) {
+class TCA8418 : public IODevice {
+ public:
+  static void create(VPIN firstVpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin = -1) {
@@ -85,2 +84 @@ public:
-private:  
-
+ private:
@@ -90 +88 @@ private:
-  uint8_t _numKeyEvents = 0;            // Number of outsanding key events waiting for us
+  uint8_t _numKeyEvents = 0;  // Number of outsanding key events waiting for us
@@ -93,2 +91,2 @@ private:
-  unsigned long _eventRefresh = 10000UL;    // Delay refreshing events for 10ms
-  const unsigned long _eventRefreshSlow = 100000UL;   // Delay refreshing events for 100ms
+  unsigned long _eventRefresh = 10000UL;             // Delay refreshing events for 10ms
+  const unsigned long _eventRefreshSlow = 100000UL;  // Delay refreshing events for 100ms
@@ -101 +99 @@ private:
-  enum {RDS_IDLE, RDS_EVENT, RDS_KEYCODE};  // Read operation states
+  enum { RDS_IDLE, RDS_EVENT, RDS_KEYCODE };  // Read operation states
@@ -105,3 +103,2 @@ private:
-  TCA8418(VPIN firstVpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin=-1) {
-    if (nPins > 0)
-    {
+  TCA8418(VPIN firstVpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin = -1) {
+    if (nPins > 0) {
@@ -117 +113,0 @@ private:
-
@@ -155 +151 @@ private:
-      // Let's assume an 8x10 matrix for now, and configure 
+      // Let's assume an 8x10 matrix for now, and configure
@@ -157 +153 @@ private:
-      if ((_digitalInputStates = (byte *)calloc(_digitalPinBytes, 1)) == NULL) {
+      if ((_digitalInputStates = (byte*)calloc(_digitalPinBytes, 1)) == NULL) {
@@ -162,11 +158,11 @@ private:
-    // Configure pin used for GPIO extender notification of change (if allocated)
-    // and configure TCA8418 to produce key event interrupts
-    if (_gpioInterruptPin >= 0) {
-      DIAG(F("TCA8418 I2C: interrupt pin configured on %d"), _gpioInterruptPin);
-      _gpioInterruptsEnabled = true;
-      _eventRefresh = _eventRefreshSlow; // Switch to slower manual refreshes in case the INT pin isn't connected!
-      pinMode(_gpioInterruptPin, INPUT_PULLUP);
-      I2CManager.write(_I2CAddress, 2, REG_CFG, REG_CFG_KE_IEN);
-      // Clear any pending interrupts
-      I2CManager.write(_I2CAddress, 2, REG_INT_STAT, REG_STAT_K_INT);
-    }
+      // Configure pin used for GPIO extender notification of change (if allocated)
+      // and configure TCA8418 to produce key event interrupts
+      if (_gpioInterruptPin >= 0) {
+        DIAG(F("TCA8418 I2C: interrupt pin configured on %d"), _gpioInterruptPin);
+        _gpioInterruptsEnabled = true;
+        _eventRefresh = _eventRefreshSlow;  // Switch to slower manual refreshes in case the INT pin isn't connected!
+        pinMode(_gpioInterruptPin, INPUT_PULLUP);
+        I2CManager.write(_I2CAddress, 2, REG_CFG, REG_CFG_KE_IEN);
+        // Clear any pending interrupts
+        I2CManager.write(_I2CAddress, 2, REG_INT_STAT, REG_STAT_K_INT);
+      }
@@ -188 +183,0 @@ private:
-
@@ -191 +186,2 @@ private:
-    if (_deviceState == DEVSTATE_FAILED) return;    // If device failed, return
+    if (_deviceState == DEVSTATE_FAILED)
+      return;  // If device failed, return
@@ -197 +193,2 @@ private:
-      if (_i2crb.isBusy()) return;                // If I2C operation still in progress, return
+      if (_i2crb.isBusy())
+        return;  // If I2C operation still in progress, return
@@ -200 +197 @@ private:
-      if (status == I2C_STATUS_OK) {             // If device request ok, read input data
+      if (status == I2C_STATUS_OK) {  // If device request ok, read input data
@@ -209,3 +206,2 @@ private:
-            _readState = RDS_KEYCODE; // Shift to reading key events!
-          }
-          else // We found no key events waiting, return to IDLE
+            _readState = RDS_KEYCODE;                                                   // Shift to reading key events!
+          } else                                                                        // We found no key events waiting, return to IDLE
@@ -213,2 +209 @@ private:
-        }
-         else {
+        } else {
@@ -219 +214 @@ private:
-          key--; // R0/C0 is key #1, so subtract 1 to create an array offset
+          key--;  // R0/C0 is key #1, so subtract 1 to create an array offset
@@ -227,2 +222 @@ private:
-          }
-          else
+          } else
@@ -230,3 +224,2 @@ private:
-          _numKeyEvents--; // One less key event to get
-          if (_numKeyEvents != 0)
-          {
+          _numKeyEvents--;  // One less key event to get
+          if (_numKeyEvents != 0) {
@@ -237,3 +230,2 @@ private:
-            I2CManager.read(_I2CAddress, _inputBuffer, 1, _commandBuffer, 1, &_i2crb); // non-blocking read
-          }
-          else {
+            I2CManager.read(_I2CAddress, _inputBuffer, 1, _commandBuffer, 1, &_i2crb);  // non-blocking read
+          } else {
@@ -243 +235 @@ private:
-            _readState = RDS_IDLE; // Shift to IDLE
+            _readState = RDS_IDLE;  // Shift to IDLE
@@ -246 +238 @@ private:
-         }
+        }
@@ -248 +240 @@ private:
-        reportError(status, false);   // report eror but don't go offline.
+        reportError(status, false);  // report eror but don't go offline.
@@ -254,3 +246 @@ private:
-      if ((_gpioInterruptsEnabled && !digitalRead(_gpioInterruptPin)) ||
-        ((currentMicros - _lastEventRead) > _eventRefresh))
-      {
+      if ((_gpioInterruptsEnabled && !digitalRead(_gpioInterruptPin)) || ((currentMicros - _lastEventRead) > _eventRefresh)) {
@@ -260 +250 @@ private:
-        _readState = RDS_EVENT; // Shift to looking for key events!
+        _readState = RDS_EVENT;  // Shift to looking for key events!
@@ -267,4 +257,2 @@ private:
-    DIAG(F("TCA8418 I2C:%s Vpins %u-%u%S"),
-              _I2CAddress.toString(),
-              _firstVpin, (_firstVpin+_nPins-1),
-              _deviceState == DEVSTATE_FAILED ? F(" OFFLINE") : F(""));
+    DIAG(F("TCA8418 I2C:%s Vpins %u-%u%S"), _I2CAddress.toString(), _firstVpin, (_firstVpin + _nPins - 1),
+         _deviceState == DEVSTATE_FAILED ? F(" OFFLINE") : F(""));
@@ -276,3 +264,2 @@ private:
-  void reportError(uint8_t status, bool fail=true) {
-    DIAG(F("TCA8418 I2C:%s Error:%d (%S)"), _I2CAddress.toString(), 
-      status, I2CManager.getErrorMessage(status));
+  void reportError(uint8_t status, bool fail = true) {
+    DIAG(F("TCA8418 I2C:%s Error:%d (%S)"), _I2CAddress.toString(), status, I2CManager.getErrorMessage(status));
@@ -280 +267 @@ private:
-    _deviceState = DEVSTATE_FAILED;
+      _deviceState = DEVSTATE_FAILED;
@@ -283,2 +270 @@ private:
-  enum tca8418_registers
-  {
+  enum tca8418_registers {
@@ -286,47 +272,47 @@ private:
-    REG_CFG = 0x01,             // Configuration register
-    REG_INT_STAT = 0x02,        // Interrupt status
-    REG_KEY_LCK_EC = 0x03,      // Key lock and event counter
-    REG_KEY_EVENT_A = 0x04,     // Key event register A
-    REG_KEY_EVENT_B = 0x05,     // Key event register B
-    REG_KEY_EVENT_C = 0x06,     // Key event register C
-    REG_KEY_EVENT_D = 0x07,     // Key event register D
-    REG_KEY_EVENT_E = 0x08,     // Key event register E
-    REG_KEY_EVENT_F = 0x09,     // Key event register F
-    REG_KEY_EVENT_G = 0x0A,     // Key event register G
-    REG_KEY_EVENT_H = 0x0B,     // Key event register H
-    REG_KEY_EVENT_I = 0x0C,     // Key event register I
-    REG_KEY_EVENT_J = 0x0D,     // Key event register J
-    REG_KP_LCK_TIMER = 0x0E,    // Keypad lock1 to lock2 timer
-    REG_UNLOCK_1 = 0x0F,        // Unlock register 1
-    REG_UNLOCK_2 = 0x10,        // Unlock register 2
-    REG_GPIO_INT_STAT_1 = 0x11, // GPIO interrupt status 1
-    REG_GPIO_INT_STAT_2 = 0x12, // GPIO interrupt status 2
-    REG_GPIO_INT_STAT_3 = 0x13, // GPIO interrupt status 3
-    REG_GPIO_DAT_STAT_1 = 0x14, // GPIO data status 1
-    REG_GPIO_DAT_STAT_2 = 0x15, // GPIO data status 2
-    REG_GPIO_DAT_STAT_3 = 0x16, // GPIO data status 3
-    REG_GPIO_DAT_OUT_1 = 0x17,  // GPIO data out 1
-    REG_GPIO_DAT_OUT_2 = 0x18,  // GPIO data out 2
-    REG_GPIO_DAT_OUT_3 = 0x19,  // GPIO data out 3
-    REG_GPIO_INT_EN_1 = 0x1A,   // GPIO interrupt enable 1
-    REG_GPIO_INT_EN_2 = 0x1B,   // GPIO interrupt enable 2
-    REG_GPIO_INT_EN_3 = 0x1C,   // GPIO interrupt enable 3
-    REG_KP_GPIO_1 = 0x1D,       // Keypad/GPIO select 1
-    REG_KP_GPIO_2 = 0x1E,       // Keypad/GPIO select 2
-    REG_KP_GPIO_3 = 0x1F,       // Keypad/GPIO select 3
-    REG_GPI_EM_1 = 0x20,        // GPI event mode 1
-    REG_GPI_EM_2 = 0x21,        // GPI event mode 2
-    REG_GPI_EM_3 = 0x22,        // GPI event mode 3
-    REG_GPIO_DIR_1 = 0x23,      // GPIO data direction 1
-    REG_GPIO_DIR_2 = 0x24,      // GPIO data direction 2
-    REG_GPIO_DIR_3 = 0x25,      // GPIO data direction 3
-    REG_GPIO_INT_LVL_1 = 0x26,  // GPIO edge/level detect 1
-    REG_GPIO_INT_LVL_2 = 0x27,  // GPIO edge/level detect 2
-    REG_GPIO_INT_LVL_3 = 0x28,  // GPIO edge/level detect 3
-    REG_DEBOUNCE_DIS_1 = 0x29,  // Debounce disable 1
-    REG_DEBOUNCE_DIS_2 = 0x2A,  // Debounce disable 2
-    REG_DEBOUNCE_DIS_3 = 0x2B,  // Debounce disable 3
-    REG_GPIO_PULL_1 = 0x2C,     // GPIO pull-up disable 1
-    REG_GPIO_PULL_2 = 0x2D,     // GPIO pull-up disable 2
-    REG_GPIO_PULL_3 = 0x2E,     // GPIO pull-up disable 3
-    // REG_RESERVED = 0x2F
+    REG_CFG = 0x01,              // Configuration register
+    REG_INT_STAT = 0x02,         // Interrupt status
+    REG_KEY_LCK_EC = 0x03,       // Key lock and event counter
+    REG_KEY_EVENT_A = 0x04,      // Key event register A
+    REG_KEY_EVENT_B = 0x05,      // Key event register B
+    REG_KEY_EVENT_C = 0x06,      // Key event register C
+    REG_KEY_EVENT_D = 0x07,      // Key event register D
+    REG_KEY_EVENT_E = 0x08,      // Key event register E
+    REG_KEY_EVENT_F = 0x09,      // Key event register F
+    REG_KEY_EVENT_G = 0x0A,      // Key event register G
+    REG_KEY_EVENT_H = 0x0B,      // Key event register H
+    REG_KEY_EVENT_I = 0x0C,      // Key event register I
+    REG_KEY_EVENT_J = 0x0D,      // Key event register J
+    REG_KP_LCK_TIMER = 0x0E,     // Keypad lock1 to lock2 timer
+    REG_UNLOCK_1 = 0x0F,         // Unlock register 1
+    REG_UNLOCK_2 = 0x10,         // Unlock register 2
+    REG_GPIO_INT_STAT_1 = 0x11,  // GPIO interrupt status 1
+    REG_GPIO_INT_STAT_2 = 0x12,  // GPIO interrupt status 2
+    REG_GPIO_INT_STAT_3 = 0x13,  // GPIO interrupt status 3
+    REG_GPIO_DAT_STAT_1 = 0x14,  // GPIO data status 1
+    REG_GPIO_DAT_STAT_2 = 0x15,  // GPIO data status 2
+    REG_GPIO_DAT_STAT_3 = 0x16,  // GPIO data status 3
+    REG_GPIO_DAT_OUT_1 = 0x17,   // GPIO data out 1
+    REG_GPIO_DAT_OUT_2 = 0x18,   // GPIO data out 2
+    REG_GPIO_DAT_OUT_3 = 0x19,   // GPIO data out 3
+    REG_GPIO_INT_EN_1 = 0x1A,    // GPIO interrupt enable 1
+    REG_GPIO_INT_EN_2 = 0x1B,    // GPIO interrupt enable 2
+    REG_GPIO_INT_EN_3 = 0x1C,    // GPIO interrupt enable 3
+    REG_KP_GPIO_1 = 0x1D,        // Keypad/GPIO select 1
+    REG_KP_GPIO_2 = 0x1E,        // Keypad/GPIO select 2
+    REG_KP_GPIO_3 = 0x1F,        // Keypad/GPIO select 3
+    REG_GPI_EM_1 = 0x20,         // GPI event mode 1
+    REG_GPI_EM_2 = 0x21,         // GPI event mode 2
+    REG_GPI_EM_3 = 0x22,         // GPI event mode 3
+    REG_GPIO_DIR_1 = 0x23,       // GPIO data direction 1
+    REG_GPIO_DIR_2 = 0x24,       // GPIO data direction 2
+    REG_GPIO_DIR_3 = 0x25,       // GPIO data direction 3
+    REG_GPIO_INT_LVL_1 = 0x26,   // GPIO edge/level detect 1
+    REG_GPIO_INT_LVL_2 = 0x27,   // GPIO edge/level detect 2
+    REG_GPIO_INT_LVL_3 = 0x28,   // GPIO edge/level detect 3
+    REG_DEBOUNCE_DIS_1 = 0x29,   // Debounce disable 1
+    REG_DEBOUNCE_DIS_2 = 0x2A,   // Debounce disable 2
+    REG_DEBOUNCE_DIS_3 = 0x2B,   // Debounce disable 3
+    REG_GPIO_PULL_1 = 0x2C,      // GPIO pull-up disable 1
+    REG_GPIO_PULL_2 = 0x2D,      // GPIO pull-up disable 2
+    REG_GPIO_PULL_3 = 0x2E,      // GPIO pull-up disable 3
+                                 // REG_RESERVED = 0x2F
@@ -335,2 +321 @@ private:
-  enum tca8418_config_reg_fields
-  {
+  enum tca8418_config_reg_fields {
@@ -338,8 +323,8 @@ private:
-    REG_CFG_AI = 0x80,           // Auto-increment for read/write
-    REG_CFG_GPI_E_CGF = 0x40,    // Event mode config
-    REG_CFG_OVR_FLOW_M = 0x20,   // Overflow mode enable
-    REG_CFG_INT_CFG = 0x10,      // Interrupt config
-    REG_CFG_OVR_FLOW_IEN = 0x08, // Overflow interrupt enable
-    REG_CFG_K_LCK_IEN = 0x04,    // Keypad lock interrupt enable
-    REG_CFG_GPI_IEN = 0x02,      // GPI interrupt enable
-    REG_CFG_KE_IEN = 0x01,       // Key events interrupt enable
+    REG_CFG_AI = 0x80,            // Auto-increment for read/write
+    REG_CFG_GPI_E_CGF = 0x40,     // Event mode config
+    REG_CFG_OVR_FLOW_M = 0x20,    // Overflow mode enable
+    REG_CFG_INT_CFG = 0x10,       // Interrupt config
+    REG_CFG_OVR_FLOW_IEN = 0x08,  // Overflow interrupt enable
+    REG_CFG_K_LCK_IEN = 0x04,     // Keypad lock interrupt enable
+    REG_CFG_GPI_IEN = 0x02,       // GPI interrupt enable
+    REG_CFG_KE_IEN = 0x01,        // Key events interrupt enable
@@ -348,2 +333 @@ private:
-  enum tca8418_int_status_fields
-  {
+  enum tca8418_int_status_fields {
@@ -351,5 +335,5 @@ private:
-    REG_STAT_CAD_INT = 0x10,      // Ctrl-alt-del seq status
-    REG_STAT_OVR_FLOW_INT = 0x08, // Overflow interrupt status
-    REG_STAT_K_LCK_INT = 0x04,    // Key lock interrupt status
-    REG_STAT_GPI_INT = 0x02,      // GPI interrupt status
-    REG_STAT_K_INT = 0x01,        // Key events interrupt status
+    REG_STAT_CAD_INT = 0x10,       // Ctrl-alt-del seq status
+    REG_STAT_OVR_FLOW_INT = 0x08,  // Overflow interrupt status
+    REG_STAT_K_LCK_INT = 0x04,     // Key lock interrupt status
+    REG_STAT_GPI_INT = 0x02,       // GPI interrupt status
+    REG_STAT_K_INT = 0x01,         // Key events interrupt status
@@ -358,2 +342 @@ private:
-  enum tca8418_lock_ec_fields
-  {
+  enum tca8418_lock_ec_fields {
@@ -361,7 +344,7 @@ private:
-    REG_LCK_EC_K_LCK_EN = 0x40, // Key lock enable
-    REG_LCK_EC_LCK_2 = 0x20,    // Keypad lock status 2
-    REG_LCK_EC_LCK_1 = 0x10,    // Keypad lock status 1
-    REG_LCK_EC_KLEC_3 = 0x08,   // Key event count bit 3
-    REG_LCK_EC_KLEC_2 = 0x04,   // Key event count bit 2
-    REG_LCK_EC_KLEC_1 = 0x02,   // Key event count bit 1
-    REG_LCK_EC_KLEC_0 = 0x01,   // Key event count bit 0
+    REG_LCK_EC_K_LCK_EN = 0x40,  // Key lock enable
+    REG_LCK_EC_LCK_2 = 0x20,     // Keypad lock status 2
+    REG_LCK_EC_LCK_1 = 0x10,     // Keypad lock status 1
+    REG_LCK_EC_KLEC_3 = 0x08,    // Key event count bit 3
+    REG_LCK_EC_KLEC_2 = 0x04,    // Key event count bit 2
+    REG_LCK_EC_KLEC_1 = 0x02,    // Key event count bit 1
+    REG_LCK_EC_KLEC_0 = 0x01,    // Key event count bit 0
diff --git a/IO_TM1638.cpp b/IO_TM1638.cpp
index 48d4602..38e2c9e 100644
--- a/IO_TM1638.cpp
+++ b/IO_TM1638.cpp
@@ -3 +3 @@
- *  
+ *
@@ -22 +21,0 @@
-
@@ -27,31 +26,20 @@
-   
-const uint8_t HIGHFLASH _digits[16]={
-      0b00111111,0b00000110,0b01011011,0b01001111,
-      0b01100110,0b01101101,0b01111101,0b00000111,
-      0b01111111,0b01101111,0b01110111,0b01111100,
-      0b00111001,0b01011110,0b01111001,0b01110001
-    };
-
-  // Constructor
-   TM1638::TM1638(VPIN firstVpin, byte clk_pin,byte dio_pin,byte stb_pin){
-    _firstVpin = firstVpin;
-    _nPins = 8;
-    _clk_pin = clk_pin;
-    _stb_pin = stb_pin;
-    _dio_pin = dio_pin;
-    pinMode(clk_pin,OUTPUT);
-    pinMode(stb_pin,OUTPUT);
-    pinMode(dio_pin,OUTPUT);
-    _pulse = PULSE1_16;
-      
-    _buttons=0;
-    _leds=0;
-    _lastLoop=micros();
-    addDevice(this);
-   } 
-
-    
-  void TM1638::create(VPIN firstVpin, byte clk_pin,byte dio_pin,byte stb_pin) {
-    if (checkNoOverlap(firstVpin,8)) 
-     new TM1638(firstVpin, clk_pin,dio_pin,stb_pin); 
-  }
+const uint8_t HIGHFLASH _digits[16] = {0b00111111, 0b00000110, 0b01011011, 0b01001111, 0b01100110, 0b01101101, 0b01111101, 0b00000111,
+                                       0b01111111, 0b01101111, 0b01110111, 0b01111100, 0b00111001, 0b01011110, 0b01111001, 0b01110001};
+
+// Constructor
+TM1638::TM1638(VPIN firstVpin, byte clk_pin, byte dio_pin, byte stb_pin) {
+  _firstVpin = firstVpin;
+  _nPins = 8;
+  _clk_pin = clk_pin;
+  _stb_pin = stb_pin;
+  _dio_pin = dio_pin;
+  pinMode(clk_pin, OUTPUT);
+  pinMode(stb_pin, OUTPUT);
+  pinMode(dio_pin, OUTPUT);
+  _pulse = PULSE1_16;
+
+  _buttons = 0;
+  _leds = 0;
+  _lastLoop = micros();
+  addDevice(this);
+}
@@ -59,16 +47,15 @@ const uint8_t HIGHFLASH _digits[16]={
-  void TM1638::_begin()  {
-    displayClear();
-    test();
-    _display();
-  }
-  
- 
-  void TM1638::_loop(unsigned long currentMicros)  {
-     if (currentMicros - _lastLoop > (1000000UL/LoopHz)) {
-         _buttons=getButtons();// Read the buttons
-         _lastLoop=currentMicros;   
-     } 
-  }
-           
-  void TM1638::_display()  {
-    DIAG(F("TM1638 Configured on Vpins:%u-%u"), _firstVpin, _firstVpin+_nPins-1);
+void TM1638::create(VPIN firstVpin, byte clk_pin, byte dio_pin, byte stb_pin) {
+  if (checkNoOverlap(firstVpin, 8))
+    new TM1638(firstVpin, clk_pin, dio_pin, stb_pin);
+}
+
+void TM1638::_begin() {
+  displayClear();
+  test();
+  _display();
+}
+
+void TM1638::_loop(unsigned long currentMicros) {
+  if (currentMicros - _lastLoop > (1000000UL / LoopHz)) {
+    _buttons = getButtons();  // Read the buttons
+    _lastLoop = currentMicros;
@@ -75,0 +63 @@ const uint8_t HIGHFLASH _digits[16]={
+}
@@ -77,5 +65,9 @@ const uint8_t HIGHFLASH _digits[16]={
-// digital read gets button state 
-int TM1638::_read(VPIN vpin)  {
-  byte pin=vpin - _firstVpin;
-  bool result=bitRead(_buttons,pin);
-  // DIAG(F("TM1638 read (%d) buttons %x = %d"),pin,_buttons,result);  
+void TM1638::_display() {
+  DIAG(F("TM1638 Configured on Vpins:%u-%u"), _firstVpin, _firstVpin + _nPins - 1);
+}
+
+// digital read gets button state
+int TM1638::_read(VPIN vpin) {
+  byte pin = vpin - _firstVpin;
+  bool result = bitRead(_buttons, pin);
+  // DIAG(F("TM1638 read (%d) buttons %x = %d"),pin,_buttons,result);
@@ -85,5 +77,5 @@ int TM1638::_read(VPIN vpin)  {
-// digital write sets led state 
-void TM1638::_write(VPIN vpin, int value)  {
-  // TODO.. skip if no state change  
-  writeLed(vpin - _firstVpin + 1,value!=0);
-  }
+// digital write sets led state
+void TM1638::_write(VPIN vpin, int value) {
+  // TODO.. skip if no state change
+  writeLed(vpin - _firstVpin + 1, value != 0);
+}
@@ -91,36 +83,36 @@ void TM1638::_write(VPIN vpin, int value)  {
-// Analog write sets digit displays 
-
-void TM1638::_writeAnalogue(VPIN vpin, int lowBytes, uint8_t mode, uint16_t highBytes)  {  
-   // mode is in DataFormat defined above.
-   byte formatLength=mode & 0x0F;  // last 4 bits 
-   byte formatType=mode & 0xF0;         //           
-   int8_t leftDigit=vpin-_firstVpin; // 0..7 from left
-   int8_t rightDigit=leftDigit+formatLength-1; // 0..7 from left
-   
-   // loading is done right to left startDigit first
-   int8_t startDigit=7-rightDigit; // reverse as 7 on left
-   int8_t lastDigit=7-leftDigit; // reverse as 7 on left
-   uint32_t value=highBytes;
-   value<<=16;
-   value |= (uint16_t)lowBytes;
-   
-   //DIAG(F("TM1638 fl=%d ft=%x sd=%d ld=%d v=%l vx=%X"),
-   // formatLength,formatType,startDigit,lastDigit,value,value);
-    while(startDigit<=lastDigit) {
-        switch (formatType) {
-            case _DF_DECIMAL:// decimal (leading zeros)
-                displayDig(startDigit,GETHIGHFLASH(_digits,(value%10))); 
-                value=value/10;
-                break; 
-            case _DF_HEX:// HEX (leading zeros)
-                displayDig(startDigit,GETHIGHFLASH(_digits,(value & 0x0F))); 
-                value>>=4;
-                break;  
-            case _DF_RAW:// Raw 7-segment pattern 
-                displayDig(startDigit,value & 0xFF); 
-                value>>=8;
-                break;
-            default:
-                DIAG(F("TM1368 invalid mode 0x%x"),mode);
-                return;
-            }
+// Analog write sets digit displays
+
+void TM1638::_writeAnalogue(VPIN vpin, int lowBytes, uint8_t mode, uint16_t highBytes) {
+  // mode is in DataFormat defined above.
+  byte formatLength = mode & 0x0F;                   // last 4 bits
+  byte formatType = mode & 0xF0;                     //
+  int8_t leftDigit = vpin - _firstVpin;              // 0..7 from left
+  int8_t rightDigit = leftDigit + formatLength - 1;  // 0..7 from left
+
+  // loading is done right to left startDigit first
+  int8_t startDigit = 7 - rightDigit;  // reverse as 7 on left
+  int8_t lastDigit = 7 - leftDigit;    // reverse as 7 on left
+  uint32_t value = highBytes;
+  value <<= 16;
+  value |= (uint16_t)lowBytes;
+
+  // DIAG(F("TM1638 fl=%d ft=%x sd=%d ld=%d v=%l vx=%X"),
+  //  formatLength,formatType,startDigit,lastDigit,value,value);
+  while (startDigit <= lastDigit) {
+    switch (formatType) {
+      case _DF_DECIMAL:  // decimal (leading zeros)
+        displayDig(startDigit, GETHIGHFLASH(_digits, (value % 10)));
+        value = value / 10;
+        break;
+      case _DF_HEX:  // HEX (leading zeros)
+        displayDig(startDigit, GETHIGHFLASH(_digits, (value & 0x0F)));
+        value >>= 4;
+        break;
+      case _DF_RAW:  // Raw 7-segment pattern
+        displayDig(startDigit, value & 0xFF);
+        value >>= 8;
+        break;
+      default:
+        DIAG(F("TM1368 invalid mode 0x%x"), mode);
+        return;
+    }
@@ -128 +120 @@ void TM1638::_writeAnalogue(VPIN vpin, int lowBytes, uint8_t mode, uint16_t high
-    } 
+  }
@@ -130,2 +122,2 @@ void TM1638::_writeAnalogue(VPIN vpin, int lowBytes, uint8_t mode, uint16_t high
-     
-uint8_t TM1638::getButtons(){
+
+uint8_t TM1638::getButtons() {
@@ -136,2 +128,2 @@ uint8_t TM1638::getButtons(){
-  uint8_t buttons=0;
-  for (uint8_t eachByte=0; eachByte<4;eachByte++) {
+  uint8_t buttons = 0;
+  for (uint8_t eachByte = 0; eachByte < 4; eachByte++) {
@@ -139,6 +131,6 @@ uint8_t TM1638::getButtons(){
-	  for (uint8_t eachBit = 0; eachBit < 8; eachBit++) {
-		  ArduinoPins::fastWriteDigital(_clk_pin, HIGH);
-			value |= ArduinoPins::fastReadDigital(_dio_pin) << eachBit;
-		  ArduinoPins::fastWriteDigital(_clk_pin, LOW);
-	  }
-    buttons |= value << eachByte; 
+    for (uint8_t eachBit = 0; eachBit < 8; eachBit++) {
+      ArduinoPins::fastWriteDigital(_clk_pin, HIGH);
+      value |= ArduinoPins::fastReadDigital(_dio_pin) << eachBit;
+      ArduinoPins::fastWriteDigital(_clk_pin, LOW);
+    }
+    buttons |= value << eachByte;
@@ -152,3 +144,3 @@ uint8_t TM1638::getButtons(){
-
-void TM1638::displayDig(uint8_t digitId, uint8_t pgfedcba){
-  if (digitId>7) return;
+void TM1638::displayDig(uint8_t digitId, uint8_t pgfedcba) {
+  if (digitId > 7)
+    return;
@@ -156,2 +148,2 @@ void TM1638::displayDig(uint8_t digitId, uint8_t pgfedcba){
-  setDataInstruction(INSTRUCTION_WRITE_DATA| INSTRUCTION_ADDRESS_FIXED);
-  writeDataAt(FIRST_DISPLAY_ADDRESS+14-(digitId*2), pgfedcba);
+  setDataInstruction(INSTRUCTION_WRITE_DATA | INSTRUCTION_ADDRESS_FIXED);
+  writeDataAt(FIRST_DISPLAY_ADDRESS + 14 - (digitId * 2), pgfedcba);
@@ -160 +152 @@ void TM1638::displayDig(uint8_t digitId, uint8_t pgfedcba){
-void TM1638::displayClear(){
+void TM1638::displayClear() {
@@ -163,2 +155,2 @@ void TM1638::displayClear(){
-  for (uint8_t i=0;i<15;i+=2){
-    writeDataAt(FIRST_DISPLAY_ADDRESS+i,0x00);
+  for (uint8_t i = 0; i < 15; i += 2) {
+    writeDataAt(FIRST_DISPLAY_ADDRESS + i, 0x00);
@@ -168,2 +160,3 @@ void TM1638::displayClear(){
-void TM1638::writeLed(uint8_t num,bool state){
-  if ((num<1) | (num>8)) return;
+void TM1638::writeLed(uint8_t num, bool state) {
+  if ((num < 1) | (num > 8))
+    return;
@@ -172 +165 @@ void TM1638::writeLed(uint8_t num,bool state){
-  writeDataAt(FIRST_DISPLAY_ADDRESS + (num*2-1), state);
+  writeDataAt(FIRST_DISPLAY_ADDRESS + (num * 2 - 1), state);
@@ -174,0 +168,8 @@ void TM1638::writeLed(uint8_t num,bool state){
+void TM1638::writeData(uint8_t data) {
+  for (uint8_t i = 0; i < 8; i++) {
+    ArduinoPins::fastWriteDigital(_dio_pin, data & 1);
+    data >>= 1;
+    ArduinoPins::fastWriteDigital(_clk_pin, HIGH);
+    ArduinoPins::fastWriteDigital(_clk_pin, LOW);
+  }
+}
@@ -176,15 +177,6 @@ void TM1638::writeLed(uint8_t num,bool state){
-void TM1638::writeData(uint8_t data){
-	for (uint8_t i = 0; i < 8; i++)  {
-		ArduinoPins::fastWriteDigital(_dio_pin, data & 1);
-		data >>= 1;
-		ArduinoPins::fastWriteDigital(_clk_pin, HIGH);
-		ArduinoPins::fastWriteDigital(_clk_pin, LOW);		
-	}
-} 
-
-void TM1638::writeDataAt(uint8_t displayAddress, uint8_t data){
-    ArduinoPins::fastWriteDigital(_stb_pin, LOW);
-    writeData(displayAddress);
-    writeData(data);
-    ArduinoPins::fastWriteDigital(_stb_pin, HIGH);
-    delayMicroseconds(1);
+void TM1638::writeDataAt(uint8_t displayAddress, uint8_t data) {
+  ArduinoPins::fastWriteDigital(_stb_pin, LOW);
+  writeData(displayAddress);
+  writeData(data);
+  ArduinoPins::fastWriteDigital(_stb_pin, HIGH);
+  delayMicroseconds(1);
@@ -193 +185 @@ void TM1638::writeDataAt(uint8_t displayAddress, uint8_t data){
-void TM1638::setDataInstruction(uint8_t dataInstruction){
+void TM1638::setDataInstruction(uint8_t dataInstruction) {
@@ -197 +189 @@ void TM1638::setDataInstruction(uint8_t dataInstruction){
-  delayMicroseconds(1);  
+  delayMicroseconds(1);
@@ -200 +192 @@ void TM1638::setDataInstruction(uint8_t dataInstruction){
-void TM1638::test(){
+void TM1638::test() {
@@ -202,2 +194,2 @@ void TM1638::test(){
-  uint8_t val=0;
-  for(uint8_t i=0;i<5;i++){
+  uint8_t val = 0;
+  for (uint8_t i = 0; i < 5; i++) {
@@ -205 +197 @@ void TM1638::test(){
-    setDataInstruction(INSTRUCTION_WRITE_DATA| INSTRUCTION_ADDRESS_AUTO);
+    setDataInstruction(INSTRUCTION_WRITE_DATA | INSTRUCTION_ADDRESS_AUTO);
@@ -208,2 +200 @@ void TM1638::test(){
-    for(uint8_t i=0;i<16;i++)
-      writeData(val);
+    for (uint8_t i = 0; i < 16; i++) writeData(val);
@@ -214 +204,0 @@ void TM1638::test(){
-
diff --git a/IO_TM1638.h b/IO_TM1638.h
index 9907e6a..5a2f8fa 100644
--- a/IO_TM1638.h
+++ b/IO_TM1638.h
@@ -1 +1 @@
-   /*
+/*
@@ -3 +3 @@
- *  
+ *
@@ -27,28 +27,19 @@ class TM1638 : public IODevice {
-private: 
-      
-    uint8_t _buttons;
-    uint8_t _leds;
-    unsigned long _lastLoop;
-    static const int LoopHz=20; 
-
-    static const byte 
-    INSTRUCTION_WRITE_DATA=0x40,
-    INSTRUCTION_READ_KEY=0x42,
-    INSTRUCTION_ADDRESS_AUTO=0x40,
-    INSTRUCTION_ADDRESS_FIXED=0x44,
-    INSTRUCTION_NORMAL_MODE=0x40,
-    INSTRUCTION_TEST_MODE=0x48,
-
-    FIRST_DISPLAY_ADDRESS=0xC0,
-
-    DISPLAY_TURN_OFF=0x80,
-    DISPLAY_TURN_ON=0x88;
-
-        
-    uint8_t _clk_pin;
-    uint8_t _stb_pin;
-    uint8_t _dio_pin;
-    uint8_t _pulse;
-    bool _isOn;
-
-    
+ private:
+  uint8_t _buttons;
+  uint8_t _leds;
+  unsigned long _lastLoop;
+  static const int LoopHz = 20;
+
+  static const byte INSTRUCTION_WRITE_DATA = 0x40, INSTRUCTION_READ_KEY = 0x42, INSTRUCTION_ADDRESS_AUTO = 0x40, INSTRUCTION_ADDRESS_FIXED = 0x44,
+                    INSTRUCTION_NORMAL_MODE = 0x40, INSTRUCTION_TEST_MODE = 0x48,
+
+                    FIRST_DISPLAY_ADDRESS = 0xC0,
+
+                    DISPLAY_TURN_OFF = 0x80, DISPLAY_TURN_ON = 0x88;
+
+  uint8_t _clk_pin;
+  uint8_t _stb_pin;
+  uint8_t _dio_pin;
+  uint8_t _pulse;
+  bool _isOn;
+
@@ -56 +47 @@ private:
-   TM1638(VPIN firstVpin, byte clk_pin,byte dio_pin,byte stb_pin);
+  TM1638(VPIN firstVpin, byte clk_pin, byte dio_pin, byte stb_pin);
@@ -58 +49 @@ private:
-public:
+ public:
@@ -61,14 +52,29 @@ public:
-    // DF_1.. DF_8 decimal 
-    DF_1=0x01,DF_2=0x02,DF_3=0x03,DF_4=0x04,
-    DF_5=0x05,DF_6=0x06,DF_7=0x07,DF_8=0x08,
-    // DF_1X.. DF_8X HEX 
-    DF_1X=0x11,DF_2X=0x12,DF_3X=0x13,DF_4X=0x14,
-    DF_5X=0x15,DF_6X=0x16,DF_7X=0x17,DF_8X=0x18,
-    // DF_1R .. DF_4R raw 7 segmnent data 
-    // only 4 because HAL analogWrite only passes 4 bytes 
-    DF_1R=0x21,DF_2R=0x22,DF_3R=0x23,DF_4R=0x24,
-    
-    //  bits of data conversion type  (ored with length) 
-    _DF_DECIMAL=0x00,// right adjusted decimal unsigned leading zeros
-    _DF_HEX=0x10,    // right adjusted hex leading zeros 
-    _DF_RAW=0x20 // bytes are raw 7-segment pattern (max length 4)
+    // DF_1.. DF_8 decimal
+    DF_1 = 0x01,
+    DF_2 = 0x02,
+    DF_3 = 0x03,
+    DF_4 = 0x04,
+    DF_5 = 0x05,
+    DF_6 = 0x06,
+    DF_7 = 0x07,
+    DF_8 = 0x08,
+    // DF_1X.. DF_8X HEX
+    DF_1X = 0x11,
+    DF_2X = 0x12,
+    DF_3X = 0x13,
+    DF_4X = 0x14,
+    DF_5X = 0x15,
+    DF_6X = 0x16,
+    DF_7X = 0x17,
+    DF_8X = 0x18,
+    // DF_1R .. DF_4R raw 7 segmnent data
+    // only 4 because HAL analogWrite only passes 4 bytes
+    DF_1R = 0x21,
+    DF_2R = 0x22,
+    DF_3R = 0x23,
+    DF_4R = 0x24,
+
+    //  bits of data conversion type  (ored with length)
+    _DF_DECIMAL = 0x00,  // right adjusted decimal unsigned leading zeros
+    _DF_HEX = 0x10,      // right adjusted hex leading zeros
+    _DF_RAW = 0x20       // bytes are raw 7-segment pattern (max length 4)
@@ -77,2 +83,2 @@ public:
-  static void create(VPIN firstVpin, byte clk_pin,byte dio_pin,byte stb_pin);
-  
+  static void create(VPIN firstVpin, byte clk_pin, byte dio_pin, byte stb_pin);
+
@@ -81 +87 @@ public:
-  void _loop(unsigned long currentMicros) override ;
+  void _loop(unsigned long currentMicros) override;
@@ -83 +89 @@ public:
-  void _display() override ;
+  void _display() override;
@@ -85,14 +91,27 @@ public:
-  void _write(VPIN pin,int value) override;
-
-  // Device driving functions 
-  private:
-   enum pulse_t {
-      PULSE1_16,
-      PULSE2_16,
-      PULSE4_16,
-      PULSE10_16,
-      PULSE11_16,
-      PULSE12_16,
-      PULSE13_16,
-      PULSE14_16
-    };
+  void _write(VPIN pin, int value) override;
+
+  // Device driving functions
+ private:
+  enum pulse_t { PULSE1_16, PULSE2_16, PULSE4_16, PULSE10_16, PULSE11_16, PULSE12_16, PULSE13_16, PULSE14_16 };
+
+  /**
+   * @fn getButtons
+   * @return state of 8 buttons
+   */
+  uint8_t getButtons();
+
+  /**
+   * @fn writeLed
+   * @brief put led ON or OFF
+   * @param num num of led(1-8)
+   * @param state (true or false)
+   */
+  void writeLed(uint8_t num, bool state);
+
+  /**
+   * @fn displayDig
+   * @brief set 7 segment display + dot
+   * @param digitId num of digit(0-7)
+   * @param val value 8 bits
+   */
+  void displayDig(uint8_t digitId, uint8_t pgfedcba);
@@ -101,32 +120,9 @@ public:
-    * @fn getButtons
-    * @return state of 8 buttons
-    */
-    uint8_t getButtons();
-
-    /**
-    * @fn writeLed
-    * @brief put led ON or OFF
-    * @param num num of led(1-8)
-    * @param state (true or false)
-    */
-    void writeLed(uint8_t num, bool state);
-    
-    
-    /**
-    * @fn displayDig
-    * @brief set 7 segment display + dot
-    * @param digitId num of digit(0-7)
-    * @param val value 8 bits
-    */
-    void displayDig(uint8_t digitId, uint8_t pgfedcba);
-
-    /**
-    * @fn displayClear
-    * @brief switch off all leds and segment display
-    */
-    void displayClear();
-    void test();
-    void writeData(uint8_t data);
-    void writeDataAt(uint8_t displayAddress, uint8_t data);
-    void setDisplayMode(uint8_t displayMode);
-    void setDataInstruction(uint8_t dataInstruction);
+   * @fn displayClear
+   * @brief switch off all leds and segment display
+   */
+  void displayClear();
+  void test();
+  void writeData(uint8_t data);
+  void writeDataAt(uint8_t displayAddress, uint8_t data);
+  void setDisplayMode(uint8_t displayMode);
+  void setDataInstruction(uint8_t dataInstruction);
diff --git a/IO_TouchKeypad.h b/IO_TouchKeypad.h
index 0fc7b08..1a023ad 100644
--- a/IO_TouchKeypad.h
+++ b/IO_TouchKeypad.h
@@ -3 +3 @@
- *  
+ *
@@ -20,3 +20,3 @@
-/* 
- * Driver for capacitative touch-pad based on the TTP229-B chip with serial 
- * (not I2C) output.  The touchpad has 16 separate pads in a 4x4 matrix, 
+/*
+ * Driver for capacitative touch-pad based on the TTP229-B chip with serial
+ * (not I2C) output.  The touchpad has 16 separate pads in a 4x4 matrix,
@@ -27,2 +27,2 @@
- * 
- * To use, 
+ *
+ * To use,
@@ -30 +30 @@
- * 
+ *
@@ -32,2 +32,2 @@
- * sixteen pads, locate the area of the board labelled P1 (four pairs of 
- * holes labelled 1 to 4 from the left); solder a jumper link between the pair 
+ * sixteen pads, locate the area of the board labelled P1 (four pairs of
+ * holes labelled 1 to 4 from the left); solder a jumper link between the pair
@@ -36 +36 @@
- * 
+ *
@@ -39,2 +39,2 @@
- * As it stands, we can configure multiple driver instances, one for each keypad, 
- * and it will work fine.  The clock will be driven to all devices but only one 
+ * As it stands, we can configure multiple driver instances, one for each keypad,
+ * and it will work fine.  The clock will be driven to all devices but only one
@@ -50,2 +50,2 @@ class TouchKeypad : public IODevice {
-private:
-  // Here we define the device-specific variables.  
+ private:
+  // Here we define the device-specific variables.
@@ -56 +56 @@ private:
-public:
+ public:
@@ -59,2 +59,3 @@ public:
-    if (checkNoOverlap(firstVpin,nPins)) new TouchKeypad(firstVpin, nPins, clockPin, dataPin);
-  } 
+    if (checkNoOverlap(firstVpin, nPins))
+      new TouchKeypad(firstVpin, nPins, clockPin, dataPin);
+  }
@@ -62,2 +63,2 @@ public:
-protected:
-  // Constructor. 
+ protected:
+  // Constructor.
@@ -78,2 +79,2 @@ protected:
-    // Set clock pin as output, initially high, and data pin as input.  
-    // Enable pullup on the input so that the default (not connected) state is 
+    // Set clock pin as output, initially high, and data pin as input.
+    // Enable pullup on the input so that the default (not connected) state is
@@ -83 +84 @@ protected:
-    pinMode(_dataPin, INPUT_PULLUP); // Force defined state when no connection
+    pinMode(_dataPin, INPUT_PULLUP);  // Force defined state when no connection
@@ -85 +86 @@ protected:
-  
+
@@ -88 +89,2 @@ protected:
-    if (vpin < _firstVpin || vpin >= _firstVpin + _nPins) return 0;
+    if (vpin < _firstVpin || vpin >= _firstVpin + _nPins)
+      return 0;
@@ -91 +93 @@ protected:
-    return _inputStates & (1<<(vpin-_firstVpin)) ? 1 : 0;
+    return _inputStates & (1 << (vpin - _firstVpin)) ? 1 : 0;
@@ -105 +106,0 @@ protected:
-
@@ -108 +109 @@ protected:
-    for (uint8_t pad=0; pad<16; pad++) {
+    for (uint8_t pad = 0; pad < 16; pad++) {
@@ -119 +120,2 @@ protected:
-    if (data != lastData) DIAG(F("KeyPad: %x"), data);
+    if (data != lastData)
+      DIAG(F("KeyPad: %x"), data);
@@ -122 +124 @@ protected:
-    delayUntil(currentMicros + 100000); // read every 100ms
+    delayUntil(currentMicros + 100000);  // read every 100ms
@@ -127,2 +129 @@ protected:
-    DIAG(F("TouchKeypad Configured on Vpins:%u-%u SCL=%d SDO=%d"), (int)_firstVpin, 
-      (int)_firstVpin+_nPins-1, _clockPin, _dataPin);
+    DIAG(F("TouchKeypad Configured on Vpins:%u-%u SCL=%d SDO=%d"), (int)_firstVpin, (int)_firstVpin + _nPins - 1, _clockPin, _dataPin);
@@ -130,2 +130,0 @@ protected:
-
-
@@ -134 +133 @@ protected:
-#endif // IO_TOUCHKEYPAD_H
+#endif  // IO_TOUCHKEYPAD_H
diff --git a/IO_VL53L0X.h b/IO_VL53L0X.h
index 08fe44e..4d3a9c2 100644
--- a/IO_VL53L0X.h
+++ b/IO_VL53L0X.h
@@ -3 +3 @@
- *  
+ *
@@ -24,2 +24,2 @@
- * 
- * For economy of memory and processing time, this driver includes only part of the code 
+ *
+ * For economy of memory and processing time, this driver includes only part of the code
@@ -27 +27 @@
- * to identify what operations are useful and what are not. 
+ * to identify what operations are useful and what are not.
@@ -30 +30 @@
- * 
+ *
@@ -33,3 +33,3 @@
- * or not (0).  An analogue read on the first pin returns the last measured distance (in mm), 
- * the second pin returns the signal strength, and the third pin returns detected 
- * ambient light level.  By default the device takes around 60ms to complete a ranging 
+ * or not (0).  An analogue read on the first pin returns the last measured distance (in mm),
+ * the second pin returns the signal strength, and the third pin returns detected
+ * ambient light level.  By default the device takes around 60ms to complete a ranging
@@ -37 +37 @@
- * 
+ *
@@ -41 +41 @@
- * 
+ *
@@ -44 +44 @@
- * when the device driver starts, the XSHUT pin is set LOW to turn the module off.  Once 
+ * when the device driver starts, the XSHUT pin is set LOW to turn the module off.  Once
@@ -47 +47 @@
- * In this way, many VL53L0X modules can be connected to the one I2C bus, each one 
+ * In this way, many VL53L0X modules can be connected to the one I2C bus, each one
@@ -50,2 +50,2 @@
- * 
- * WARNING:  If the device's XSHUT pin is not connected, then it may be prone to noise, 
+ *
+ * WARNING:  If the device's XSHUT pin is not connected, then it may be prone to noise,
@@ -53 +53 @@
- * on its allocated address.  If you're not using XSHUT, then tie it to +5V via a resistor 
+ * on its allocated address.  If you're not using XSHUT, then tie it to +5V via a resistor
@@ -56 +56 @@
- * 
+ *
@@ -58 +58 @@
- * 
+ *
@@ -66 +66 @@
- * 
+ *
@@ -78 +78 @@
- * 
+ *
@@ -83,2 +83,2 @@
- * 
- *   When an object comes within 200mm of the sensor, a message 
+ *
+ *   When an object comes within 200mm of the sensor, a message
@@ -86 +86 @@
- *   will be sent over the serial USB, and when the object moves more than 250mm from the sensor, 
+ *   will be sent over the serial USB, and when the object moves more than 250mm from the sensor,
@@ -89,2 +89,2 @@
- *   will be sent. 
- * 
+ *   will be sent.
+ *
@@ -99 +99 @@ class VL53L0X : public IODevice {
-private: 
+ private:
@@ -128,5 +128,5 @@ private:
-    VL53L0X_REG_SYSRANGE_START=0x00,
-    VL53L0X_REG_RESULT_INTERRUPT_STATUS=0x13,
-    VL53L0X_REG_RESULT_RANGE_STATUS=0x14,
-    VL53L0X_CONFIG_PAD_SCL_SDA__EXTSUP_HV=0x89,
-    VL53L0X_REG_I2C_SLAVE_DEVICE_ADDRESS=0x8A,
+    VL53L0X_REG_SYSRANGE_START = 0x00,
+    VL53L0X_REG_RESULT_INTERRUPT_STATUS = 0x13,
+    VL53L0X_REG_RESULT_RANGE_STATUS = 0x14,
+    VL53L0X_CONFIG_PAD_SCL_SDA__EXTSUP_HV = 0x89,
+    VL53L0X_REG_I2C_SLAVE_DEVICE_ADDRESS = 0x8A,
@@ -134,2 +134 @@ private:
-  const uint8_t VL53L0X_I2C_DEFAULT_ADDRESS=0x29;
-
+  const uint8_t VL53L0X_I2C_DEFAULT_ADDRESS = 0x29;
@@ -137 +136 @@ private:
-  public:
+ public:
@@ -139 +138,2 @@ private:
-     if (checkNoOverlap(firstVpin, nPins,i2cAddress)) new VL53L0X(firstVpin, nPins, i2cAddress, onThreshold, offThreshold, xshutPin);
+    if (checkNoOverlap(firstVpin, nPins, i2cAddress))
+      new VL53L0X(firstVpin, nPins, i2cAddress, onThreshold, offThreshold, xshutPin);
@@ -142 +142 @@ private:
-protected:
+ protected:
@@ -154,3 +154,3 @@ protected:
-    // If there's only one device, then the XSHUT pin need not be connected.  However, 
-    //  the device will not respond on its default address if it has 
-    //  already been changed.  Therefore, we skip the address configuration if the 
+    // If there's only one device, then the XSHUT pin need not be connected.  However,
+    //  the device will not respond on its default address if it has
+    //  already been changed.  Therefore, we skip the address configuration if the
@@ -173 +173,2 @@ protected:
-          if (_xshutPin != VPIN_NONE) IODevice::write(_xshutPin, 0);
+          if (_xshutPin != VPIN_NONE)
+            IODevice::write(_xshutPin, 0);
@@ -175 +176 @@ protected:
-          delayUntil(currentMicros+10000);
+          delayUntil(currentMicros + 10000);
@@ -180,2 +181,2 @@ protected:
-        // I've observed that the device tends to randomly reset if the XSHUT 
-        // pin is set high from a 5V arduino, even through a pullup resistor.  
+        // I've observed that the device tends to randomly reset if the XSHUT
+        // pin is set high from a 5V arduino, even through a pullup resistor.
@@ -191 +192,2 @@ protected:
-          if (_xshutPin != VPIN_NONE) IODevice::configureInput(_xshutPin, false);
+          if (_xshutPin != VPIN_NONE)
+            IODevice::configureInput(_xshutPin, false);
@@ -193 +195 @@ protected:
-          delayUntil(currentMicros+10000);
+          delayUntil(currentMicros + 10000);
@@ -201 +203 @@ protected:
-          #if defined(I2C_EXTENDED_ADDRESS)
+#if defined(I2C_EXTENDED_ADDRESS)
@@ -205 +207 @@ protected:
-          #else
+#else
@@ -207 +209 @@ protected:
-          #endif
+#endif
@@ -212 +214 @@ protected:
-        delayUntil(currentMicros+10000);
+        delayUntil(currentMicros + 10000);
@@ -220 +222 @@ protected:
-          #ifdef DIAG_IO
+#ifdef DIAG_IO
@@ -222 +224 @@ protected:
-          #endif
+#endif
@@ -224,2 +226 @@ protected:
-          status = write_reg(VL53L0X_CONFIG_PAD_SCL_SDA__EXTSUP_HV, 
-            read_reg(VL53L0X_CONFIG_PAD_SCL_SDA__EXTSUP_HV) | 0x01);
+          status = write_reg(VL53L0X_CONFIG_PAD_SCL_SDA__EXTSUP_HV, read_reg(VL53L0X_CONFIG_PAD_SCL_SDA__EXTSUP_HV) | 0x01);
@@ -245 +246,2 @@ protected:
-        if (status == I2C_STATUS_PENDING) return; // try next time
+        if (status == I2C_STATUS_PENDING)
+          return;  // try next time
@@ -250 +252 @@ protected:
-        delayUntil(currentMicros + 95000); // wait for 95 ms before checking.
+        delayUntil(currentMicros + 95000);  // wait for 95 ms before checking.
@@ -256 +258 @@ protected:
-        delayUntil(currentMicros + 5000); // Allow 5ms to get data
+        delayUntil(currentMicros + 5000);  // Allow 5ms to get data
@@ -262 +264,2 @@ protected:
-        if (status == I2C_STATUS_PENDING) return; // try again next time
+        if (status == I2C_STATUS_PENDING)
+          return;  // try again next time
@@ -264 +267,2 @@ protected:
-          if (!(_inBuffer[0] & 1)) return; // device still busy
+          if (!(_inBuffer[0] & 1))
+            return;  // device still busy
@@ -271 +275 @@ protected:
-            if (_distance <= _onThreshold) 
+            if (_distance <= _onThreshold)
@@ -273 +277 @@ protected:
-            else if (_distance > _offThreshold) 
+            else if (_distance > _offThreshold)
@@ -284 +288 @@ protected:
-        delayUntil(currentMicros+1000000UL);
+        delayUntil(currentMicros + 1000000UL);
@@ -322,3 +326,2 @@ protected:
-    DIAG(F("VL53L0X I2C:%s Configured on Vpins:%u-%u On:%dmm Off:%dmm %S"),
-      _I2CAddress.toString(), _firstVpin, _firstVpin+_nPins-1, _onThreshold, _offThreshold,
-      (_deviceState==DEVSTATE_FAILED) ? F("OFFLINE") : F(""));
+    DIAG(F("VL53L0X I2C:%s Configured on Vpins:%u-%u On:%dmm Off:%dmm %S"), _I2CAddress.toString(), _firstVpin, _firstVpin + _nPins - 1, _onThreshold,
+         _offThreshold, (_deviceState == DEVSTATE_FAILED) ? F("OFFLINE") : F(""));
@@ -326 +328,0 @@ protected:
-  
@@ -328 +330 @@ protected:
-private:
+ private:
@@ -348 +350 @@ bool VL53L0X::_addressConfigInProgress = false;
-#endif // IO_VL53L0X_h
+#endif  // IO_VL53L0X_h
diff --git a/IO_duinoNodes.h b/IO_duinoNodes.h
index f9cc0fc..695d6af 100644
--- a/IO_duinoNodes.h
+++ b/IO_duinoNodes.h
@@ -4 +4 @@
- *  
+ *
@@ -21 +21 @@
- #define IO_duinoNodes_h
+#define IO_duinoNodes_h
@@ -26,6 +26,4 @@
-#define DN_PIN_MASK(bit) (0x80>>(bit%8))
-#define DN_GET_BIT(x) (_pinValues[(x)/8] & DN_PIN_MASK((x)) )
-#define DN_SET_BIT(x) _pinValues[(x)/8] |= DN_PIN_MASK((x))
-#define DN_CLR_BIT(x) _pinValues[(x)/8] &= ~DN_PIN_MASK((x))
-
-
+#define DN_PIN_MASK(bit) (0x80 >> (bit % 8))
+#define DN_GET_BIT(x) (_pinValues[(x) / 8] & DN_PIN_MASK((x)))
+#define DN_SET_BIT(x) _pinValues[(x) / 8] |= DN_PIN_MASK((x))
+#define DN_CLR_BIT(x) _pinValues[(x) / 8] &= ~DN_PIN_MASK((x))
@@ -34,13 +32,8 @@ class IO_duinoNodes : public IODevice {
-
-public:
-  IO_duinoNodes(VPIN firstVpin, int nPins, 
-                byte clockPin, byte latchPin, byte dataPin, 
-                const byte* pinmap) :
-    IODevice(firstVpin, nPins) {
- 
-   _latchPin=latchPin;
-    _clockPin=clockPin;
-    _dataPin=dataPin;
-    _pinMap=pinmap;
-    _nShiftBytes=(nPins+7)/8; // rounded up to multiples of 8 bits
-    _pinValues=(byte*) calloc(_nShiftBytes,1);  
+ public:
+  IO_duinoNodes(VPIN firstVpin, int nPins, byte clockPin, byte latchPin, byte dataPin, const byte* pinmap) : IODevice(firstVpin, nPins) {
+    _latchPin = latchPin;
+    _clockPin = clockPin;
+    _dataPin = dataPin;
+    _pinMap = pinmap;
+    _nShiftBytes = (nPins + 7) / 8;  // rounded up to multiples of 8 bits
+    _pinValues = (byte*)calloc(_nShiftBytes, 1);
@@ -48 +41 @@ public:
-    IODevice::addDevice(this);  
+    IODevice::addDevice(this);
@@ -51 +44 @@ public:
-// Called by HAL to start handling this device
+  // Called by HAL to start handling this device
@@ -53,4 +46,4 @@ public:
-     _deviceState = DEVSTATE_NORMAL;
-    pinMode(_latchPin,OUTPUT);
-    pinMode(_clockPin,OUTPUT);
-    pinMode(_dataPin,_pinMap?INPUT_PULLUP:OUTPUT);
+    _deviceState = DEVSTATE_NORMAL;
+    pinMode(_latchPin, OUTPUT);
+    pinMode(_clockPin, OUTPUT);
+    pinMode(_dataPin, _pinMap ? INPUT_PULLUP : OUTPUT);
@@ -58 +51,2 @@ public:
-    if (!_pinMap) _loopOutput();
+    if (!_pinMap)
+      _loopOutput();
@@ -61,5 +55,7 @@ public:
-// loop called by HAL supervisor 
-void _loop(unsigned long currentMicros) override {
-    if (_pinMap) _loopInput(currentMicros);
-    else if (_xmitPending) _loopOutput();
-}
+  // loop called by HAL supervisor
+  void _loop(unsigned long currentMicros) override {
+    if (_pinMap)
+      _loopInput(currentMicros);
+    else if (_xmitPending)
+      _loopOutput();
+  }
@@ -67,10 +63,4 @@ void _loop(unsigned long currentMicros) override {
-void _loopInput(unsigned long currentMicros)  {
-   
-   if (currentMicros-_prevMicros < POLL_MICROS) return; // Nothing to do
-    _prevMicros=currentMicros;
-   
-    //set latch to HIGH to freeze & store parallel data
-   ArduinoPins::fastWriteDigital(_latchPin, HIGH);
-   delayMicroseconds(1);
-   //set latch to LOW to enable the data to be transmitted serially
-   ArduinoPins::fastWriteDigital(_latchPin, LOW);
+  void _loopInput(unsigned long currentMicros) {
+    if (currentMicros - _prevMicros < POLL_MICROS)
+      return;  // Nothing to do
+    _prevMicros = currentMicros;
@@ -78,4 +68,10 @@ void _loopInput(unsigned long currentMicros)  {
-  // stream in the bitmap using mapping order provided at constructor   
-  for (int xmitByte=0;xmitByte<_nShiftBytes; xmitByte++) {
-      byte newByte=0;
-      for (int xmitBit=0;xmitBit<8; xmitBit++) {
+    // set latch to HIGH to freeze & store parallel data
+    ArduinoPins::fastWriteDigital(_latchPin, HIGH);
+    delayMicroseconds(1);
+    // set latch to LOW to enable the data to be transmitted serially
+    ArduinoPins::fastWriteDigital(_latchPin, LOW);
+
+    // stream in the bitmap using mapping order provided at constructor
+    for (int xmitByte = 0; xmitByte < _nShiftBytes; xmitByte++) {
+      byte newByte = 0;
+      for (int xmitBit = 0; xmitBit < 8; xmitBit++) {
@@ -84,6 +80,8 @@ void _loopInput(unsigned long currentMicros)  {
-        bool data = ArduinoPins::fastReadDigital(_dataPin);  
-        byte map=_pinMap[xmitBit];
-        if (data)  newByte |= map;
-            else   newByte &= ~map;
-        ArduinoPins::fastWriteDigital(_clockPin, HIGH); 
-        delayMicroseconds(1);   
+        bool data = ArduinoPins::fastReadDigital(_dataPin);
+        byte map = _pinMap[xmitBit];
+        if (data)
+          newByte |= map;
+        else
+          newByte &= ~map;
+        ArduinoPins::fastWriteDigital(_clockPin, HIGH);
+        delayMicroseconds(1);
@@ -91 +89 @@ void _loopInput(unsigned long currentMicros)  {
-      _pinValues[xmitByte]=newByte;
+      _pinValues[xmitByte] = newByte;
@@ -96 +94 @@ void _loopInput(unsigned long currentMicros)  {
-void _loopOutput()  {
+  void _loopOutput() {
@@ -98 +96 @@ void _loopOutput()  {
-    _xmitPending=false; 
+    _xmitPending = false;
@@ -100,5 +98,5 @@ void _loopOutput()  {
-    for (int xmitBit=_nShiftBytes*8 -1; xmitBit>=0; xmitBit--) {
-        ArduinoPins::fastWriteDigital(_dataPin,DN_GET_BIT(xmitBit));
-        ArduinoPins::fastWriteDigital(_clockPin,HIGH);
-        ArduinoPins::fastWriteDigital(_clockPin,LOW);
-    }  
+    for (int xmitBit = _nShiftBytes * 8 - 1; xmitBit >= 0; xmitBit--) {
+      ArduinoPins::fastWriteDigital(_dataPin, DN_GET_BIT(xmitBit));
+      ArduinoPins::fastWriteDigital(_clockPin, HIGH);
+      ArduinoPins::fastWriteDigital(_clockPin, LOW);
+    }
@@ -109,3 +107,3 @@ void _loopOutput()  {
-    int pin=vpin - _firstVpin;
-    bool b=DN_GET_BIT(pin);
-    return b?1:0;
+    int pin = vpin - _firstVpin;
+    bool b = DN_GET_BIT(pin);
+    return b ? 1 : 0;
@@ -116,6 +114,9 @@ void _loopOutput()  {
-    bool oldval=DN_GET_BIT(pin);
-    bool newval=value!=0;
-    if (newval==oldval) return; // no change  
-    if (newval) DN_SET_BIT(pin);
-           else DN_CLR_BIT(pin);
-    _xmitPending=true;  // shift register will be sent on next _loop()
+    bool oldval = DN_GET_BIT(pin);
+    bool newval = value != 0;
+    if (newval == oldval)
+      return;  // no change
+    if (newval)
+      DN_SET_BIT(pin);
+    else
+      DN_CLR_BIT(pin);
+    _xmitPending = true;  // shift register will be sent on next _loop()
@@ -125,4 +126,2 @@ void _loopOutput()  {
-      DIAG(F("IO_duinoNodes %SPUT Configured on Vpins:%u-%u shift=%d"), 
-      _pinMap?F("IN"):F("OUT"),
-      (int)_firstVpin, 
-      (int)_firstVpin+_nPins-1, _nShiftBytes*8);
+    DIAG(F("IO_duinoNodes %SPUT Configured on Vpins:%u-%u shift=%d"), _pinMap ? F("IN") : F("OUT"), (int)_firstVpin, (int)_firstVpin + _nPins - 1,
+         _nShiftBytes * 8);
@@ -131,5 +130,5 @@ void _loopOutput()  {
-private:
-  static const unsigned long POLL_MICROS=100000; // 10 / S
-  unsigned long _prevMicros; 
-  int  _nShiftBytes=0; 
-  VPIN _latchPin,_clockPin,_dataPin;
+ private:
+  static const unsigned long POLL_MICROS = 100000;  // 10 / S
+  unsigned long _prevMicros;
+  int _nShiftBytes = 0;
+  VPIN _latchPin, _clockPin, _dataPin;
@@ -137,2 +136,2 @@ private:
-  bool _xmitPending; // Only relevant in output mode
-  const byte* _pinMap;  // NULL in output mode 
+  bool _xmitPending;    // Only relevant in output mode
+  const byte* _pinMap;  // NULL in output mode
@@ -141,8 +140,7 @@ private:
-class IO_DNIN8  {
-public:
-  static void create(VPIN firstVpin, int nPins, byte clockPin, byte latchPin, byte dataPin ) 
-  {
-      // input arrives as board pin 0,7,6,5,1,2,3,4 
-      static const byte pinmap[8]={0x80,0x01,0x02,0x04,0x40,0x20,0x10,0x08};
-      if (IODevice::checkNoOverlap(firstVpin,nPins))
-        new IO_duinoNodes( firstVpin,  nPins,  clockPin,  latchPin,   dataPin,pinmap);
+class IO_DNIN8 {
+ public:
+  static void create(VPIN firstVpin, int nPins, byte clockPin, byte latchPin, byte dataPin) {
+    // input arrives as board pin 0,7,6,5,1,2,3,4
+    static const byte pinmap[8] = {0x80, 0x01, 0x02, 0x04, 0x40, 0x20, 0x10, 0x08};
+    if (IODevice::checkNoOverlap(firstVpin, nPins))
+      new IO_duinoNodes(firstVpin, nPins, clockPin, latchPin, dataPin, pinmap);
@@ -150 +147,0 @@ public:
-
@@ -153,8 +150,7 @@ public:
-class IO_DNIN8K  {
-public:
-  static void create(VPIN firstVpin, int nPins, byte clockPin, byte latchPin, byte dataPin ) 
-  {
-      // input arrives as board pin 0, 1, 2, 3, 4, 5, 6, 7
-      static const byte pinmap[8]={0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80}; 
-       if (IODevice::checkNoOverlap(firstVpin,nPins))
-        new IO_duinoNodes( firstVpin,  nPins, clockPin, latchPin, dataPin,pinmap);
+class IO_DNIN8K {
+ public:
+  static void create(VPIN firstVpin, int nPins, byte clockPin, byte latchPin, byte dataPin) {
+    // input arrives as board pin 0, 1, 2, 3, 4, 5, 6, 7
+    static const byte pinmap[8] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};
+    if (IODevice::checkNoOverlap(firstVpin, nPins))
+      new IO_duinoNodes(firstVpin, nPins, clockPin, latchPin, dataPin, pinmap);
@@ -165,5 +161,4 @@ class IO_DNOU8 {
-public:
-  static void create(VPIN firstVpin, int nPins, byte clockPin, byte latchPin, byte dataPin ) 
-  {
-        if (IODevice::checkNoOverlap(firstVpin,nPins))
-         new IO_duinoNodes( firstVpin,  nPins,  clockPin, latchPin,   dataPin,NULL);
+ public:
+  static void create(VPIN firstVpin, int nPins, byte clockPin, byte latchPin, byte dataPin) {
+    if (IODevice::checkNoOverlap(firstVpin, nPins))
+      new IO_duinoNodes(firstVpin, nPins, clockPin, latchPin, dataPin, NULL);
@@ -171 +165,0 @@ public:
-
diff --git a/IO_trainbrains.h b/IO_trainbrains.h
index b762fd1..5860b60 100644
--- a/IO_trainbrains.h
+++ b/IO_trainbrains.h
@@ -4 +4 @@
- *  
+ *
@@ -32,7 +32,2 @@
- 
- enum TrackUnoccupancy
-{
-    TRACK_UNOCCUPANCY_UNKNOWN = 0,
-    TRACK_OCCUPIED = 1,
-    TRACK_UNOCCUPIED = 2
-};
+
+enum TrackUnoccupancy { TRACK_UNOCCUPANCY_UNKNOWN = 0, TRACK_OCCUPIED = 1, TRACK_UNOCCUPIED = 2 };
@@ -41 +36 @@ class Trainbrains02 : public GPIOBase<uint16_t> {
-public:
+ public:
@@ -43 +38,2 @@ public:
-    if (checkNoOverlap(vpin, nPins, i2cAddress)) new Trainbrains02(vpin, nPins, i2cAddress);
+    if (checkNoOverlap(vpin, nPins, i2cAddress))
+      new Trainbrains02(vpin, nPins, i2cAddress);
@@ -46 +42 @@ public:
-private:  
+ private:
@@ -48,16 +44,17 @@ private:
-  Trainbrains02(VPIN vpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin=-1) 
-    : GPIOBase<uint16_t>((FSH *)F("Trainbrains02"), vpin, nPins, i2cAddress, interruptPin) 
-  {
-    requestBlock.setRequestParams(_I2CAddress, inputBuffer, sizeof(inputBuffer),
-      outputBuffer, sizeof(outputBuffer));
-    
-     outputBuffer[0] = (uint8_t)_I2CAddress; // strips away the mux part.
-     outputBuffer[1] =14;
-     outputBuffer[2] =1;
-     outputBuffer[3] =0;  // This is the channel updated at each poling call
-     outputBuffer[4] =0;
-     outputBuffer[5] =0;
-     outputBuffer[6] =0;
-     outputBuffer[7] =0;
-     outputBuffer[8] =0;
-     outputBuffer[9] =0;
+  Trainbrains02(VPIN vpin, uint8_t nPins, I2CAddress i2cAddress, int interruptPin = -1)
+      : GPIOBase<uint16_t>((FSH*)F("Trainbrains02"), vpin, nPins, i2cAddress, interruptPin) {
+    requestBlock.setRequestParams(_I2CAddress, inputBuffer, sizeof(inputBuffer), outputBuffer, sizeof(outputBuffer));
+
+    outputBuffer[0] = (uint8_t)_I2CAddress;  // strips away the mux part.
+    outputBuffer[1] = 14;
+    outputBuffer[2] = 1;
+    outputBuffer[3] = 0;  // This is the channel updated at each poling call
+    outputBuffer[4] = 0;
+    outputBuffer[5] = 0;
+    outputBuffer[6] = 0;
+    outputBuffer[7] = 0;
+    outputBuffer[8] = 0;
+    outputBuffer[9] = 0;
+  }
+
+  void _writeGpioPort() override {
@@ -65,2 +61,0 @@ private:
-  
-  void _writeGpioPort() override {}
@@ -69,2 +64,2 @@ private:
-    // cycle channel on device each time 
-    outputBuffer[3]=channelInProgress+1; // 1-origin 
+    // cycle channel on device each time
+    outputBuffer[3] = channelInProgress + 1;  // 1-origin
@@ -72,2 +67,3 @@ private:
-    if(channelInProgress>=_nPins) channelInProgress=0; 
-    
+    if (channelInProgress >= _nPins)
+      channelInProgress = 0;
+
@@ -75,2 +71 @@ private:
-      _processCompletion(I2CManager.read(_I2CAddress, inputBuffer, sizeof(inputBuffer), 
-                                   outputBuffer, sizeof(outputBuffer)));
+      _processCompletion(I2CManager.read(_I2CAddress, inputBuffer, sizeof(inputBuffer), outputBuffer, sizeof(outputBuffer)));
@@ -79 +74 @@ private:
-      requestBlock.wait(); // Wait for preceding operation to complete
+      requestBlock.wait();  // Wait for preceding operation to complete
@@ -87,3 +82,6 @@ private:
-    if (status != I2C_STATUS_OK) inputBuffer[6]=TRACK_UNOCCUPANCY_UNKNOWN;  
-    if (inputBuffer[6] == TRACK_UNOCCUPIED ) _portInputState |=  0x01 <<channelInProgress;
-    else _portInputState &=  ~(0x01 <<channelInProgress);
+    if (status != I2C_STATUS_OK)
+      inputBuffer[6] = TRACK_UNOCCUPANCY_UNKNOWN;
+    if (inputBuffer[6] == TRACK_UNOCCUPIED)
+      _portInputState |= 0x01 << channelInProgress;
+    else
+      _portInputState &= ~(0x01 << channelInProgress);
@@ -92 +90 @@ private:
-  uint8_t channelInProgress=0; 
+  uint8_t channelInProgress = 0;
@@ -95 +92,0 @@ private:
-  
diff --git a/KeywordHasher.h b/KeywordHasher.h
index 16ff927..0204fec 100644
--- a/KeywordHasher.h
+++ b/KeywordHasher.h
@@ -4 +4 @@
- *  
+ *
@@ -21,2 +21 @@
-
-/* Reader be aware: 
+/* Reader be aware:
@@ -24,4 +23,4 @@
- is hashed to the same value as the DCCEXParser uses to hash incoming 
- keywords. 
- Thus  "MAIN"_hk  generates exactly the same run time vakue 
- as   const int16_t HASH_KEYWORD_MAIN=11339  
+ is hashed to the same value as the DCCEXParser uses to hash incoming
+ keywords.
+ Thus  "MAIN"_hk  generates exactly the same run time vakue
+ as   const int16_t HASH_KEYWORD_MAIN=11339
@@ -33,6 +32,5 @@
-constexpr uint16_t CompiletimeKeywordHasher(const char *  sv, uint16_t running=0) {
-    return (*sv==0) ? running : CompiletimeKeywordHasher(sv+1,
-          (*sv >= '0' && *sv <= '9') 
-            ? (10*running+*sv-'0')  // Numeric hash  
-            : ((running << 5) + running) ^ *sv
-            );  // 
+constexpr uint16_t CompiletimeKeywordHasher(const char* sv, uint16_t running = 0) {
+  return (*sv == 0) ? running
+                    : CompiletimeKeywordHasher(sv + 1,
+                                               (*sv >= '0' && *sv <= '9') ? (10 * running + *sv - '0')          // Numeric hash
+                                                                          : ((running << 5) + running) ^ *sv);  //
@@ -41,3 +39,2 @@ constexpr uint16_t CompiletimeKeywordHasher(const char *  sv, uint16_t running=0
-constexpr int16_t operator""_hk(const char * keyword, size_t len) 
-{
-    return (int16_t) CompiletimeKeywordHasher(keyword,len*0);
+constexpr int16_t operator""_hk(const char* keyword, size_t len) {
+  return (int16_t)CompiletimeKeywordHasher(keyword, len * 0);
@@ -53,4 +50,4 @@ const int16_t HASH_KEYWORD_SPEED128 = 25816;
-static_assert("MAIN"_hk == 11339,"Keyword hasher error");
-static_assert("SLOW"_hk == -17209,"Keyword hasher error");
-static_assert("SPEED28"_hk == -17064,"Keyword hasher error");
-static_assert("SPEED128"_hk == 25816,"Keyword hasher error");
+static_assert("MAIN"_hk == 11339, "Keyword hasher error");
+static_assert("SLOW"_hk == -17209, "Keyword hasher error");
+static_assert("SPEED28"_hk == -17064, "Keyword hasher error");
+static_assert("SPEED128"_hk == 25816, "Keyword hasher error");
@@ -60,19 +57,18 @@ static_assert("SPEED128"_hk == 25816,"Keyword hasher error");
-constexpr uint8_t seg7Digits[]={
-      0b00111111,0b00000110,0b01011011,0b01001111, // 0..3
-      0b01100110,0b01101101,0b01111101,0b00000111, // 4..7
-      0b01111111,0b01101111 // 8..9
-    };
-    
-constexpr uint8_t seg7Letters[]={
-        0b01110111,0b01111100,0b00111001,0b01011110, // ABCD
-        0b01111001,0b01110001,0b00111101,0b01110110, // EFGH 
-        0b00000100,0b00011110,0b01110010,0b00111000,  //IJKL
-        0b01010101,0b01010100,0b01011100,0b01110011, // MNOP
-        0b10111111,0b01010000,0b01101101,0b01111000, // QRST
-        0b00111110,0b00011100,0b01101010,0b01001001,  //UVWX
-        0b01100110,0b01011011  //YZ
-    };
-constexpr uint8_t seg7Space=0b00000000;
-constexpr uint8_t seg7Minus=0b01000000;
-constexpr uint8_t seg7Equals=0b01001000;
-    
+constexpr uint8_t seg7Digits[] = {
+    0b00111111, 0b00000110, 0b01011011, 0b01001111,  // 0..3
+    0b01100110, 0b01101101, 0b01111101, 0b00000111,  // 4..7
+    0b01111111, 0b01101111                           // 8..9
+};
+
+constexpr uint8_t seg7Letters[] = {
+    0b01110111, 0b01111100, 0b00111001, 0b01011110,  // ABCD
+    0b01111001, 0b01110001, 0b00111101, 0b01110110,  // EFGH
+    0b00000100, 0b00011110, 0b01110010, 0b00111000,  // IJKL
+    0b01010101, 0b01010100, 0b01011100, 0b01110011,  // MNOP
+    0b10111111, 0b01010000, 0b01101101, 0b01111000,  // QRST
+    0b00111110, 0b00011100, 0b01101010, 0b01001001,  // UVWX
+    0b01100110, 0b01011011                           // YZ
+};
+constexpr uint8_t seg7Space = 0b00000000;
+constexpr uint8_t seg7Minus = 0b01000000;
+constexpr uint8_t seg7Equals = 0b01001000;
@@ -80,10 +76,10 @@ constexpr uint8_t seg7Equals=0b01001000;
-constexpr uint32_t CompiletimeSeg7(const char *  sv, uint32_t running, size_t rlen) {
-    return (*sv==0 || rlen==0) ? running << (8*rlen) : CompiletimeSeg7(sv+1,
-          (*sv >= '0' && *sv <= '9') ? (running<<8) | seg7Digits[*sv-'0'] : 
-          (*sv >= 'A' && *sv <= 'Z') ? (running<<8) | seg7Letters[*sv-'A'] : 
-          (*sv >= 'a' && *sv <= 'z') ? (running<<8) | seg7Letters[*sv-'a'] : 
-          (*sv == '-') ? (running<<8) | seg7Minus : 
-          (*sv == '=') ? (running<<8) | seg7Equals : 
-                         (running<<8) | seg7Space,
-          rlen-1               
-        );  // 
+constexpr uint32_t CompiletimeSeg7(const char* sv, uint32_t running, size_t rlen) {
+  return (*sv == 0 || rlen == 0) ? running << (8 * rlen)
+                                 : CompiletimeSeg7(sv + 1,
+                                                   (*sv >= '0' && *sv <= '9')   ? (running << 8) | seg7Digits[*sv - '0']
+                                                   : (*sv >= 'A' && *sv <= 'Z') ? (running << 8) | seg7Letters[*sv - 'A']
+                                                   : (*sv >= 'a' && *sv <= 'z') ? (running << 8) | seg7Letters[*sv - 'a']
+                                                   : (*sv == '-')               ? (running << 8) | seg7Minus
+                                                   : (*sv == '=')               ? (running << 8) | seg7Equals
+                                                                                : (running << 8) | seg7Space,
+                                                   rlen - 1);  //
@@ -92,3 +88,2 @@ constexpr uint32_t CompiletimeSeg7(const char *  sv, uint32_t running, size_t rl
-constexpr uint32_t operator""_s7(const char * keyword, size_t len) 
-{
-    return  CompiletimeSeg7(keyword,0*len,4);
+constexpr uint32_t operator""_s7(const char* keyword, size_t len) {
+  return CompiletimeSeg7(keyword, 0 * len, 4);
diff --git a/LCN.cpp b/LCN.cpp
index d1e1228..2078540 100644
--- a/LCN.cpp
+++ b/LCN.cpp
@@ -3,3 +3,3 @@
- *  
- *  This file is part of DCC-EX CommandStation-EX 
- *  
+ *
+ *  This file is part of DCC-EX CommandStation-EX
+ *
@@ -25,3 +25,3 @@
-int  LCN::id = 0;
-Stream * LCN::stream=NULL;
-bool LCN::firstLoop=true;
+int LCN::id = 0;
+Stream* LCN::stream = NULL;
+bool LCN::firstLoop = true;
@@ -29,3 +29,3 @@ bool LCN::firstLoop=true;
-void LCN::init(Stream & lcnstream) {
-  stream=&lcnstream; 
-  DIAG(F("LCN connection setup")); 
+void LCN::init(Stream& lcnstream) {
+  stream = &lcnstream;
+  DIAG(F("LCN connection setup"));
@@ -34 +33,0 @@ void LCN::init(Stream & lcnstream) {
-
@@ -37 +36,2 @@ void LCN::loop() {
-  if (!stream) return;
+  if (!stream)
+    return;
@@ -39 +39 @@ void LCN::loop() {
-    firstLoop=false;
+    firstLoop = false;
@@ -41 +41 @@ void LCN::loop() {
-    return; 
+    return;
@@ -43 +43 @@ void LCN::loop() {
-  
+
@@ -48,5 +48,6 @@ void LCN::loop() {
-    }
-    else if (ch == 't' || ch == 'T') { // Turnout opcodes
-      if (Diag::LCN) DIAG(F("LCN IN %d%c"),id,(char)ch);
-      if (!Turnout::exists(id)) LCNTurnout::create(id);
-      Turnout::setClosedStateOnly(id,ch=='t');
+    } else if (ch == 't' || ch == 'T') {  // Turnout opcodes
+      if (Diag::LCN)
+        DIAG(F("LCN IN %d%c"), id, (char)ch);
+      if (!Turnout::exists(id))
+        LCNTurnout::create(id);
+      Turnout::setClosedStateOnly(id, ch == 't');
@@ -54,4 +55,4 @@ void LCN::loop() {
-    }
-    else if (ch == 'y' || ch == 'Y') { // Turnout opcodes
-      if (Diag::LCN) DIAG(F("LCN IN %d%c"),id,(char)ch);
-      Turnout::setClosed(id,ch=='y');
+    } else if (ch == 'y' || ch == 'Y') {  // Turnout opcodes
+      if (Diag::LCN)
+        DIAG(F("LCN IN %d%c"), id, (char)ch);
+      Turnout::setClosed(id, ch == 'y');
@@ -59,5 +60,6 @@ void LCN::loop() {
-    }
-    else if (ch == 'S' || ch == 's') {
-      if (Diag::LCN) DIAG(F("LCN IN %d%c"),id,(char)ch);
-      Sensor * ss = Sensor::get(id);
-      if (!ss) ss = Sensor::create(id, VPIN_NONE, 0); // impossible pin
+    } else if (ch == 'S' || ch == 's') {
+      if (Diag::LCN)
+        DIAG(F("LCN IN %d%c"), id, (char)ch);
+      Sensor* ss = Sensor::get(id);
+      if (!ss)
+        ss = Sensor::create(id, VPIN_NONE, 0);  // impossible pin
@@ -66,2 +68,2 @@ void LCN::loop() {
-    }
-    else  id = 0; // ignore any other garbage from LCN
+    } else
+      id = 0;  // ignore any other garbage from LCN
@@ -72,4 +74,5 @@ void LCN::send(char opcode, int id, bool state) {
-   if (stream) {
-      StringFormatter::send(stream,F("%c/%d/%d"), opcode, id , state);
-      if (Diag::LCN) DIAG(F("LCN OUT %c/%d/%d"), opcode, id , state);
-   }
+  if (stream) {
+    StringFormatter::send(stream, F("%c/%d/%d"), opcode, id, state);
+    if (Diag::LCN)
+      DIAG(F("LCN OUT %c/%d/%d"), opcode, id, state);
+  }
diff --git a/LCN.h b/LCN.h
index 176d9a2..514680f 100644
--- a/LCN.h
+++ b/LCN.h
@@ -5 +5 @@
- *  
+ *
@@ -26,8 +26,9 @@ class LCN {
-  public: 
-    static void init(Stream & lcnstream);
-    static void loop();
-    static void send(char opcode, int id, bool state);
-  private :
-    static bool firstLoop; 
-    static Stream * stream; 
-    static int id;
+ public:
+  static void init(Stream& lcnstream);
+  static void loop();
+  static void send(char opcode, int id, bool state);
+
+ private:
+  static bool firstLoop;
+  static Stream* stream;
+  static int id;
diff --git a/LiquidCrystal_I2C.cpp b/LiquidCrystal_I2C.cpp
index a517f61..b0d7eee 100644
--- a/LiquidCrystal_I2C.cpp
+++ b/LiquidCrystal_I2C.cpp
@@ -44,2 +44 @@
-LiquidCrystal_I2C::LiquidCrystal_I2C(I2CAddress lcd_Addr, uint8_t lcd_cols,
-                                     uint8_t lcd_rows) {
+LiquidCrystal_I2C::LiquidCrystal_I2C(I2CAddress lcd_Addr, uint8_t lcd_cols, uint8_t lcd_rows) {
@@ -50 +49 @@ LiquidCrystal_I2C::LiquidCrystal_I2C(I2CAddress lcd_Addr, uint8_t lcd_cols,
- }
+}
@@ -53 +51,0 @@ bool LiquidCrystal_I2C::begin() {
-
@@ -55 +53 @@ bool LiquidCrystal_I2C::begin() {
-  I2CManager.setClock(100000L);    // PCF8574 is spec'd to 100kHz.
+  I2CManager.setClock(100000L);  // PCF8574 is spec'd to 100kHz.
@@ -73,2 +71 @@ bool LiquidCrystal_I2C::begin() {
-  expanderWrite(
-      _backlightval);  // reset expander and turn backlight off (Bit 8 =1)
+  expanderWrite(_backlightval);  // reset expander and turn backlight off (Bit 8 =1)
@@ -147 +144 @@ size_t LiquidCrystal_I2C::writeNative(uint8_t value) {
-bool LiquidCrystal_I2C::isBusy() { 
+bool LiquidCrystal_I2C::isBusy() {
@@ -153,2 +150,2 @@ bool LiquidCrystal_I2C::isBusy() {
-inline void LiquidCrystal_I2C::command(uint8_t value) { 
-  send(value, 0); 
+inline void LiquidCrystal_I2C::command(uint8_t value) {
+  send(value, 0);
@@ -166 +163 @@ inline void LiquidCrystal_I2C::command(uint8_t value) {
- *    or continue sending data. The number of data bytes that can be sent 
+ *    or continue sending data. The number of data bytes that can be sent
@@ -169 +166 @@ inline void LiquidCrystal_I2C::command(uint8_t value) {
- * 
+ *
@@ -174 +171 @@ inline void LiquidCrystal_I2C::command(uint8_t value) {
- * 
+ *
@@ -177 +174 @@ inline void LiquidCrystal_I2C::command(uint8_t value) {
- * command is sent in a separate I2C transmission here.  The time taken to end a 
+ * command is sent in a separate I2C transmission here.  The time taken to end a
@@ -181,2 +178,2 @@ inline void LiquidCrystal_I2C::command(uint8_t value) {
- * 
- * Similarly, the Enable must be set/reset for at least 450ns.  This is 
+ *
+ * Similarly, the Enable must be set/reset for at least 450ns.  This is
@@ -190 +187 @@ inline void LiquidCrystal_I2C::command(uint8_t value) {
-//  a single I2C transmission. 
+//  a single I2C transmission.
@@ -198 +195 @@ void LiquidCrystal_I2C::send(uint8_t value, uint8_t mode) {
-  outputBuffer[len++] = highnib|En;
+  outputBuffer[len++] = highnib | En;
@@ -200 +197 @@ void LiquidCrystal_I2C::send(uint8_t value, uint8_t mode) {
-  outputBuffer[len++] = lownib|En;
+  outputBuffer[len++] = lownib | En;
@@ -213 +210 @@ void LiquidCrystal_I2C::write4bits(uint8_t value) {
-  outputBuffer[len++] = _data|En;
+  outputBuffer[len++] = _data | En;
diff --git a/LiquidCrystal_I2C.h b/LiquidCrystal_I2C.h
index 650ad15..77c7c5e 100644
--- a/LiquidCrystal_I2C.h
+++ b/LiquidCrystal_I2C.h
@@ -58 +58 @@
-#define BACKPACK_DATA_BITS 4 // Bits 4-7
+#define BACKPACK_DATA_BITS 4  // Bits 4-7
@@ -61,3 +61,3 @@
-#define En (1 << BACKPACK_En_BIT)  // Enable bit
-#define Rw (1 << BACKPACK_Rw_BIT)  // Read/Write bit
-#define Rs (1 << BACKPACK_Rs_BIT)  // Register select bit
+#define En (1 << BACKPACK_En_BIT)                    // Enable bit
+#define Rw (1 << BACKPACK_Rw_BIT)                    // Read/Write bit
+#define Rs (1 << BACKPACK_Rs_BIT)                    // Register select bit
@@ -66,2 +66,2 @@ class LiquidCrystal_I2C : public DisplayDevice {
-public:
-  LiquidCrystal_I2C(I2CAddress lcd_Addr,uint8_t lcd_cols,uint8_t lcd_rows);
+ public:
+  LiquidCrystal_I2C(I2CAddress lcd_Addr, uint8_t lcd_cols, uint8_t lcd_rows);
@@ -73,2 +73,2 @@ public:
-  bool isBusy() override; 
-  
+  bool isBusy() override;
+
@@ -78,4 +77,0 @@ public:
-  
-  void command(uint8_t);
-  uint16_t getNumCols() { return lcdCols; }
-  uint16_t getNumRows() { return lcdRows; }
@@ -82,0 +79,7 @@ public:
+  void command(uint8_t);
+  uint16_t getNumCols() {
+    return lcdCols;
+  }
+  uint16_t getNumRows() {
+    return lcdRows;
+  }
@@ -84 +87 @@ public:
-private:
+ private:
@@ -88 +91 @@ private:
-  uint8_t lcdCols=0, lcdRows=0;
+  uint8_t lcdCols = 0, lcdRows = 0;
diff --git a/MotorDriver.cpp b/MotorDriver.cpp
index 39ec08d..fc21931 100644
--- a/MotorDriver.cpp
+++ b/MotorDriver.cpp
@@ -10 +10 @@
- *  
+ *
@@ -46,3 +46,3 @@ volatile portreg_t shadowPORTH;
-MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, int16_t brake_pin,
-                         byte current_pin, float sense_factor, unsigned int trip_milliamps, int16_t fault_pin) {
-  const FSH * warnString = F("** WARNING **");
+MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, int16_t brake_pin, byte current_pin, float sense_factor,
+                         unsigned int trip_milliamps, int16_t fault_pin) {
+  const FSH* warnString = F("** WARNING **");
@@ -50 +50 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-  invertPower=power_pin < 0;
+  invertPower = power_pin < 0;
@@ -52,2 +52,2 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-    powerPin = 0-power_pin;
-    IODevice::write(powerPin,HIGH);// set to OUTPUT and off
+    powerPin = 0 - power_pin;
+    IODevice::write(powerPin, HIGH);  // set to OUTPUT and off
@@ -56 +56 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-    IODevice::write(powerPin,LOW);// set to OUTPUT and off
+    IODevice::write(powerPin, LOW);  // set to OUTPUT and off
@@ -58,3 +58,3 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-  
-  signalPin=signal_pin;
-  getFastPin(F("SIG"),signalPin,fastSignalPin);
+
+  signalPin = signal_pin;
+  getFastPin(F("SIG"), signalPin, fastSignalPin);
@@ -65 +65 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-    DIAG(F("Found PORTA pin %d"),signalPin);
+    DIAG(F("Found PORTA pin %d"), signalPin);
@@ -70 +70 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-    DIAG(F("Found PORTB pin %d"),signalPin);
+    DIAG(F("Found PORTB pin %d"), signalPin);
@@ -75 +75 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-    DIAG(F("Found PORTC pin %d"),signalPin);
+    DIAG(F("Found PORTC pin %d"), signalPin);
@@ -80 +80 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-    DIAG(F("Found PORTD pin %d"),signalPin);
+    DIAG(F("Found PORTD pin %d"), signalPin);
@@ -85 +85 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-    DIAG(F("Found PORTE pin %d"),signalPin);
+    DIAG(F("Found PORTE pin %d"), signalPin);
@@ -90 +90 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-    DIAG(F("Found PORTF pin %d"),signalPin);
+    DIAG(F("Found PORTF pin %d"), signalPin);
@@ -95 +95 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-    DIAG(F("Found PORTG pin %d"),signalPin);
+    DIAG(F("Found PORTG pin %d"), signalPin);
@@ -100 +100 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-    DIAG(F("Found PORTH pin %d"),signalPin);
+    DIAG(F("Found PORTH pin %d"), signalPin);
@@ -105,4 +105,4 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-  signalPin2=signal_pin2;
-  if (signalPin2!=UNUSED_PIN) {
-    dualSignal=true;
-    getFastPin(F("SIG2"),signalPin2,fastSignalPin2);
+  signalPin2 = signal_pin2;
+  if (signalPin2 != UNUSED_PIN) {
+    dualSignal = true;
+    getFastPin(F("SIG2"), signalPin2, fastSignalPin2);
@@ -113 +113 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-      DIAG(F("Found PORTA pin %d"),signalPin2);
+      DIAG(F("Found PORTA pin %d"), signalPin2);
@@ -118 +118 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-      DIAG(F("Found PORTB pin %d"),signalPin2);
+      DIAG(F("Found PORTB pin %d"), signalPin2);
@@ -123 +123 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-      DIAG(F("Found PORTC pin %d"),signalPin2);
+      DIAG(F("Found PORTC pin %d"), signalPin2);
@@ -128 +128 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-      DIAG(F("Found PORTD pin %d"),signalPin2);
+      DIAG(F("Found PORTD pin %d"), signalPin2);
@@ -133 +133 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-      DIAG(F("Found PORTE pin %d"),signalPin2);
+      DIAG(F("Found PORTE pin %d"), signalPin2);
@@ -138 +138 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-      DIAG(F("Found PORTF pin %d"),signalPin2);
+      DIAG(F("Found PORTF pin %d"), signalPin2);
@@ -143 +143 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-      DIAG(F("Found PORTG pin %d"),signalPin2);
+      DIAG(F("Found PORTG pin %d"), signalPin2);
@@ -148 +148 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-      DIAG(F("Found PORTH pin %d"),signalPin2);
+      DIAG(F("Found PORTH pin %d"), signalPin2);
@@ -152,5 +152,5 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-  }
-  else dualSignal=false; 
-  
-  if (brake_pin!=UNUSED_PIN){
-    invertBrake=brake_pin < 0;
+  } else
+    dualSignal = false;
+
+  if (brake_pin != UNUSED_PIN) {
+    invertBrake = brake_pin < 0;
@@ -158 +158 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-      brake_pin = 0-brake_pin;
+      brake_pin = 0 - brake_pin;
@@ -161,2 +161,2 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-    brakePin=(byte)brake_pin;
-    getFastPin(F("BRAKE"),brakePin,fastBrakePin);
+    brakePin = (byte)brake_pin;
+    getFastPin(F("BRAKE"), brakePin, fastBrakePin);
@@ -167 +167 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-    brakePin=UNUSED_PIN;
+    brakePin = UNUSED_PIN;
@@ -169,3 +169,3 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-  
-  currentPin=current_pin;
-  if (currentPin!=UNUSED_PIN) {
+
+  currentPin = current_pin;
+  if (currentPin != UNUSED_PIN) {
@@ -173 +173 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-    if (ret < -1010) { // XXX give value a name later
+    if (ret < -1010) {  // XXX give value a name later
@@ -178 +178 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-  senseOffset=0; // value can not be obtained until waveform is activated
+  senseOffset = 0;  // value can not be obtained until waveform is activated
@@ -181 +181 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-    invertFault=fault_pin < 0;
+    invertFault = fault_pin < 0;
@@ -183 +183 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-      fault_pin =  0-fault_pin;
+      fault_pin = 0 - fault_pin;
@@ -186 +186 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-    faultPin=(byte)fault_pin;
+    faultPin = (byte)fault_pin;
@@ -188 +188 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-    getFastPin(F("FAULT"),faultPin, 1 /*input*/, fastFaultPin);
+    getFastPin(F("FAULT"), faultPin, 1 /*input*/, fastFaultPin);
@@ -191 +191 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-      faultPin=UNUSED_PIN;
+    faultPin = UNUSED_PIN;
@@ -195,3 +195,3 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-  // float calculations or libraray code. 
-  senseFactorInternal=sense_factor * senseScale; 
-  tripMilliamps=trip_milliamps;
+  // float calculations or libraray code.
+  senseFactorInternal = sense_factor * senseScale;
+  tripMilliamps = trip_milliamps;
@@ -202 +202 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-  rawCurrentTripValue=mA2raw(tripMilliamps);
+  rawCurrentTripValue = mA2raw(tripMilliamps);
@@ -213 +213 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-    rawCurrentTripValue=ADCee::ADCmax()-senseOffset;
+    rawCurrentTripValue = ADCee::ADCmax() - senseOffset;
@@ -216 +216 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-  if (currentPin==UNUSED_PIN) 
+  if (currentPin == UNUSED_PIN)
@@ -218 +218 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-  else  {
+  else {
@@ -226 +226 @@ MotorDriver::MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, i
-  progTripValue = mA2raw(TRIP_CURRENT_PROG); 
+  progTripValue = mA2raw(TRIP_CURRENT_PROG);
@@ -230 +230 @@ bool MotorDriver::isPWMCapable() {
-    return (!dualSignal) && DCCTimer::isPWMPin(signalPin);
+  return (!dualSignal) && DCCTimer::isPWMPin(signalPin);
@@ -233 +232,0 @@ bool MotorDriver::isPWMCapable() {
-
@@ -235,2 +234,3 @@ void MotorDriver::setPower(POWERMODE mode) {
-  if (powerMode == mode) return;
-  //DIAG(F("Track %c POWERMODE=%d"), trackLetter, (int)mode);
+  if (powerMode == mode)
+    return;
+  // DIAG(F("Track %c POWERMODE=%d"), trackLetter, (int)mode);
@@ -240 +240 @@ void MotorDriver::setPower(POWERMODE mode) {
-  bool on=(mode==POWERMODE::ON || mode ==POWERMODE::ALERT);
+  bool on = (mode == POWERMODE::ON || mode == POWERMODE::ALERT);
@@ -243,3 +243,3 @@ void MotorDriver::setPower(POWERMODE mode) {
-    if (powerMode==POWERMODE::OFF && currentPin!=UNUSED_PIN) {
-        senseOffset = ADCee::read(currentPin);
-        DIAG(F("Track %c sensOffset=%d"),trackLetter,senseOffset);
+    if (powerMode == POWERMODE::OFF && currentPin != UNUSED_PIN) {
+      senseOffset = ADCee::read(currentPin);
+      DIAG(F("Track %c sensOffset=%d"), trackLetter, senseOffset);
@@ -248 +248 @@ void MotorDriver::setPower(POWERMODE mode) {
-    IODevice::write(powerPin,invertPower ? LOW : HIGH);
+    IODevice::write(powerPin, invertPower ? LOW : HIGH);
@@ -250,0 +251,2 @@ void MotorDriver::setPower(POWERMODE mode) {
+  } else {
+    IODevice::write(powerPin, invertPower ? HIGH : LOW);
@@ -252,4 +254 @@ void MotorDriver::setPower(POWERMODE mode) {
-  else {
-      IODevice::write(powerPin,invertPower ? HIGH : LOW);
-  }
-  powerMode=mode; 
+  powerMode = mode;
@@ -267,2 +266,5 @@ void MotorDriver::setBrake(bool on, bool interruptContext) {
-  if (brakePin == UNUSED_PIN) return;
-  if (!interruptContext) {noInterrupts();}
+  if (brakePin == UNUSED_PIN)
+    return;
+  if (!interruptContext) {
+    noInterrupts();
+  }
@@ -273 +275,3 @@ void MotorDriver::setBrake(bool on, bool interruptContext) {
-  if (!interruptContext) {interrupts();}
+  if (!interruptContext) {
+    interrupts();
+  }
@@ -277 +281 @@ bool MotorDriver::canMeasureCurrent() {
-  return currentPin!=UNUSED_PIN;
+  return currentPin != UNUSED_PIN;
@@ -283,2 +287,2 @@ bool MotorDriver::canMeasureCurrent() {
- * 
- * senseOffset handles the case where a shield returns values above or below 
+ *
+ * senseOffset handles the case where a shield returns values above or below
@@ -291 +295,2 @@ int MotorDriver::getCurrentRaw(bool fromISR) {
-  if (currentPin==UNUSED_PIN) return 0; 
+  if (currentPin == UNUSED_PIN)
+    return 0;
@@ -296,2 +301,3 @@ int MotorDriver::getCurrentRaw(bool fromISR) {
-  current = current-senseOffset;     // adjust with offset
-  if (current<0) current=0-current;
+  current = current - senseOffset;  // adjust with offset
+  if (current < 0)
+    current = 0 - current;
@@ -313 +319 @@ int MotorDriver::getCurrentRaw(bool fromISR) {
-#pragma GCC optimize ("-O3")
+#pragma GCC optimize("-O3")
@@ -316 +322 @@ bool MotorDriver::sampleCurrentFromHW() {
-  //if (!bit_is_set(ADCSRA, ADIF))
+  // if (!bit_is_set(ADCSRA, ADIF))
@@ -321 +327 @@ bool MotorDriver::sampleCurrentFromHW() {
-  low = ADCL; //must read low before high
+  low = ADCL;  // must read low before high
@@ -334,2 +340,2 @@ void MotorDriver::startCurrentFromHW() {
-  ADMUX=(1<<REFS0)|((currentPin-A0) & mask); //select AVCC as reference and set MUX
-  bitSet(ADCSRA,ADSC); // start conversion
+  ADMUX = (1 << REFS0) | ((currentPin - A0) & mask);  // select AVCC as reference and set MUX
+  bitSet(ADCSRA, ADSC);                               // start conversion
@@ -338 +344 @@ void MotorDriver::startCurrentFromHW() {
-#endif //ANALOG_READ_INTERRUPT
+#endif  // ANALOG_READ_INTERRUPT
@@ -342,7 +348,2 @@ void MotorDriver::startCurrentFromHW() {
-uint16_t taurustones[28] = { 165, 175, 196, 220,
-			     247, 262, 294, 330,
-			     349, 392, 440, 494,
-			     523, 587, 659, 698,
-			     494, 440, 392, 249,
-			     330, 284, 262, 247,
-			     220, 196, 175, 165 };
+uint16_t taurustones[28] = {165, 175, 196, 220, 247, 262, 294, 330, 349, 392, 440, 494, 523, 587,
+                            659, 698, 494, 440, 392, 249, 330, 284, 262, 247, 220, 196, 175, 165};
@@ -355,2 +356,2 @@ void MotorDriver::setDCSignal(byte speedcode, uint8_t frequency /*default =0*/)
-  byte tSpeed=speedcode & 0x7F; // DCC Speed with 0,1 stop and speed steps 2 to 127
-  byte tDir=speedcode & 0x80;
+  byte tSpeed = speedcode & 0x7F;  // DCC Speed with 0,1 stop and speed steps 2 to 127
+  byte tDir = speedcode & 0x80;
@@ -359,3 +360,6 @@ void MotorDriver::setDCSignal(byte speedcode, uint8_t frequency /*default =0*/)
-  if (tSpeed <= 1) brake = 255;
-  else if (tSpeed >= 127) brake = 0;
-  else  brake = 2 * (128-tSpeed);
+  if (tSpeed <= 1)
+    brake = 255;
+  else if (tSpeed >= 127)
+    brake = 0;
+  else
+    brake = 2 * (128 - tSpeed);
@@ -363 +367 @@ void MotorDriver::setDCSignal(byte speedcode, uint8_t frequency /*default =0*/)
-  { // new block because of variable f
+  {  // new block because of variable f
@@ -369 +373 @@ void MotorDriver::setDCSignal(byte speedcode, uint8_t frequency /*default =0*/)
-	f = taurustones[ (tSpeed-2)/2 ] ;
+        f = taurustones[(tSpeed - 2) / 2];
@@ -373 +377 @@ void MotorDriver::setDCSignal(byte speedcode, uint8_t frequency /*default =0*/)
-    //DIAG(F("Brake pin %d value %d freqency %d"), brakePin, brake, f);
+    // DIAG(F("Brake pin %d value %d freqency %d"), brakePin, brake, f);
@@ -375,4 +379,4 @@ void MotorDriver::setDCSignal(byte speedcode, uint8_t frequency /*default =0*/)
-    DCCTimer::DCCEXanalogWriteFrequency(brakePin, f); // set DC PWM frequency
-#else // all AVR here
-    DCCTimer::DCCEXanalogWriteFrequency(brakePin, frequency); // frequency steps
-    analogWrite(brakePin, invertBrake ? 255-brake : brake);
+    DCCTimer::DCCEXanalogWriteFrequency(brakePin, f);  // set DC PWM frequency
+#else                                                  // all AVR here
+    DCCTimer::DCCEXanalogWriteFrequency(brakePin, frequency);  // frequency steps
+    analogWrite(brakePin, invertBrake ? 255 - brake : brake);
@@ -382 +386 @@ void MotorDriver::setDCSignal(byte speedcode, uint8_t frequency /*default =0*/)
-  //DIAG(F("DCSignal %d"), speedcode);
+  // DIAG(F("DCSignal %d"), speedcode);
@@ -385 +389 @@ void MotorDriver::setDCSignal(byte speedcode, uint8_t frequency /*default =0*/)
-    HAVE_PORTA(shadowPORTA=PORTA);
+    HAVE_PORTA(shadowPORTA = PORTA);
@@ -387 +391 @@ void MotorDriver::setDCSignal(byte speedcode, uint8_t frequency /*default =0*/)
-    HAVE_PORTA(PORTA=shadowPORTA);
+    HAVE_PORTA(PORTA = shadowPORTA);
@@ -391 +395 @@ void MotorDriver::setDCSignal(byte speedcode, uint8_t frequency /*default =0*/)
-    HAVE_PORTB(shadowPORTB=PORTB);
+    HAVE_PORTB(shadowPORTB = PORTB);
@@ -393 +397 @@ void MotorDriver::setDCSignal(byte speedcode, uint8_t frequency /*default =0*/)
-    HAVE_PORTB(PORTB=shadowPORTB);
+    HAVE_PORTB(PORTB = shadowPORTB);
@@ -397 +401 @@ void MotorDriver::setDCSignal(byte speedcode, uint8_t frequency /*default =0*/)
-    HAVE_PORTC(shadowPORTC=PORTC);
+    HAVE_PORTC(shadowPORTC = PORTC);
@@ -399 +403 @@ void MotorDriver::setDCSignal(byte speedcode, uint8_t frequency /*default =0*/)
-    HAVE_PORTC(PORTC=shadowPORTC);
+    HAVE_PORTC(PORTC = shadowPORTC);
@@ -403 +407 @@ void MotorDriver::setDCSignal(byte speedcode, uint8_t frequency /*default =0*/)
-    HAVE_PORTD(shadowPORTD=PORTD);
+    HAVE_PORTD(shadowPORTD = PORTD);
@@ -405 +409 @@ void MotorDriver::setDCSignal(byte speedcode, uint8_t frequency /*default =0*/)
-    HAVE_PORTD(PORTD=shadowPORTD);
+    HAVE_PORTD(PORTD = shadowPORTD);
@@ -409 +413 @@ void MotorDriver::setDCSignal(byte speedcode, uint8_t frequency /*default =0*/)
-    HAVE_PORTE(shadowPORTE=PORTE);
+    HAVE_PORTE(shadowPORTE = PORTE);
@@ -411 +415 @@ void MotorDriver::setDCSignal(byte speedcode, uint8_t frequency /*default =0*/)
-    HAVE_PORTE(PORTE=shadowPORTE);
+    HAVE_PORTE(PORTE = shadowPORTE);
@@ -415 +419 @@ void MotorDriver::setDCSignal(byte speedcode, uint8_t frequency /*default =0*/)
-    HAVE_PORTF(shadowPORTF=PORTF);
+    HAVE_PORTF(shadowPORTF = PORTF);
@@ -417 +421 @@ void MotorDriver::setDCSignal(byte speedcode, uint8_t frequency /*default =0*/)
-    HAVE_PORTF(PORTF=shadowPORTF);
+    HAVE_PORTF(PORTF = shadowPORTF);
@@ -421 +425 @@ void MotorDriver::setDCSignal(byte speedcode, uint8_t frequency /*default =0*/)
-    HAVE_PORTG(shadowPORTG=PORTG);
+    HAVE_PORTG(shadowPORTG = PORTG);
@@ -423 +427 @@ void MotorDriver::setDCSignal(byte speedcode, uint8_t frequency /*default =0*/)
-    HAVE_PORTG(PORTG=shadowPORTG);
+    HAVE_PORTG(PORTG = shadowPORTG);
@@ -427 +431 @@ void MotorDriver::setDCSignal(byte speedcode, uint8_t frequency /*default =0*/)
-    HAVE_PORTH(shadowPORTH=PORTH);
+    HAVE_PORTH(shadowPORTH = PORTH);
@@ -429 +433 @@ void MotorDriver::setDCSignal(byte speedcode, uint8_t frequency /*default =0*/)
-    HAVE_PORTH(PORTH=shadowPORTH);
+    HAVE_PORTH(PORTH = shadowPORTH);
@@ -440 +444 @@ void MotorDriver::throttleInrush(bool on) {
-  if ( !(trackMode & (TRACK_MODE_MAIN | TRACK_MODE_PROG | TRACK_MODE_EXT | TRACK_MODE_BOOST)))
+  if (!(trackMode & (TRACK_MODE_MAIN | TRACK_MODE_PROG | TRACK_MODE_EXT | TRACK_MODE_BOOST)))
@@ -442 +446 @@ void MotorDriver::throttleInrush(bool on) {
-  byte duty = on ? 207 : 0; // duty of 81% at 62500Hz this gives pauses of 3usec
+  byte duty = on ? 207 : 0;  // duty of 81% at 62500Hz this gives pauses of 3usec
@@ -444 +448 @@ void MotorDriver::throttleInrush(bool on) {
-  if(on) {
+  if (on) {
@@ -447,2 +451,2 @@ void MotorDriver::throttleInrush(bool on) {
-    ledcDetachPin(brakePin); // not DCCTimer::DCCEXledcDetachPin() as we have not
-                             // registered the pin in the pin to channel array
+    ledcDetachPin(brakePin);  // not DCCTimer::DCCEXledcDetachPin() as we have not
+                              // registered the pin in the pin to channel array
@@ -451,3 +455,3 @@ void MotorDriver::throttleInrush(bool on) {
-  if(on) {
-    DCCTimer::DCCEXanalogWriteFrequency(brakePin, 7); // 7 means max
-    DCCTimer::DCCEXanalogWrite(brakePin,duty,invertBrake);
+  if (on) {
+    DCCTimer::DCCEXanalogWriteFrequency(brakePin, 7);  // 7 means max
+    DCCTimer::DCCEXanalogWrite(brakePin, duty, invertBrake);
@@ -457 +461 @@ void MotorDriver::throttleInrush(bool on) {
-#else // all AVR here
+#else  // all AVR here
@@ -459,3 +463,3 @@ void MotorDriver::throttleInrush(bool on) {
-    duty = 255-duty;
-  if(on){
-    DCCTimer::DCCEXanalogWriteFrequency(brakePin, 7); // 7 means max
+    duty = 255 - duty;
+  if (on) {
+    DCCTimer::DCCEXanalogWriteFrequency(brakePin, 7);  // 7 means max
@@ -463 +467 @@ void MotorDriver::throttleInrush(bool on) {
-  analogWrite(brakePin,duty);
+  analogWrite(brakePin, duty);
@@ -466,2 +470,2 @@ void MotorDriver::throttleInrush(bool on) {
-unsigned int MotorDriver::raw2mA( int raw) {
-  //DIAG(F("%d = %d * %d / %d"), (int32_t)raw * senseFactorInternal / senseScale, raw, senseFactorInternal, senseScale);
+unsigned int MotorDriver::raw2mA(int raw) {
+  // DIAG(F("%d = %d * %d / %d"), (int32_t)raw * senseFactorInternal / senseScale, raw, senseFactorInternal, senseScale);
@@ -470,2 +474,2 @@ unsigned int MotorDriver::raw2mA( int raw) {
-unsigned int MotorDriver::mA2raw( unsigned int mA) {
-  //DIAG(F("%d = %d * %d / %d"), (int32_t)mA * senseScale / senseFactorInternal, mA, senseScale, senseFactorInternal);
+unsigned int MotorDriver::mA2raw(unsigned int mA) {
+  // DIAG(F("%d = %d * %d / %d"), (int32_t)mA * senseScale / senseFactorInternal, mA, senseScale, senseFactorInternal);
@@ -475,3 +479,3 @@ unsigned int MotorDriver::mA2raw( unsigned int mA) {
-void  MotorDriver::getFastPin(const FSH* type,int pin, bool input, FASTPIN & result) {
-    // DIAG(F("MotorDriver %S Pin=%d,"),type,pin);
-    (void) type; // avoid compiler warning if diag not used above.
+void MotorDriver::getFastPin(const FSH* type, int pin, bool input, FASTPIN& result) {
+  // DIAG(F("MotorDriver %S Pin=%d,"),type,pin);
+  (void)type;  // avoid compiler warning if diag not used above.
@@ -479 +483 @@ void  MotorDriver::getFastPin(const FSH* type,int pin, bool input, FASTPIN & res
-    PortGroup *port = digitalPinToPort(pin);
+  PortGroup* port = digitalPinToPort(pin);
@@ -481 +485 @@ void  MotorDriver::getFastPin(const FSH* type,int pin, bool input, FASTPIN & res
-    GPIO_TypeDef *port = digitalPinToPort(pin);
+  GPIO_TypeDef* port = digitalPinToPort(pin);
@@ -483 +487 @@ void  MotorDriver::getFastPin(const FSH* type,int pin, bool input, FASTPIN & res
-    uint8_t port = digitalPinToPort(pin);
+  uint8_t port = digitalPinToPort(pin);
@@ -485,7 +489,7 @@ void  MotorDriver::getFastPin(const FSH* type,int pin, bool input, FASTPIN & res
-    if (input)
-      result.inout = portInputRegister(port);
-    else
-      result.inout = portOutputRegister(port);
-    result.maskHIGH = digitalPinToBitMask(pin);
-    result.maskLOW = ~result.maskHIGH;
-    // DIAG(F(" port=0x%x, inoutpin=0x%x, isinput=%d, mask=0x%x"),port, result.inout,input,result.maskHIGH);
+  if (input)
+    result.inout = portInputRegister(port);
+  else
+    result.inout = portOutputRegister(port);
+  result.maskHIGH = digitalPinToBitMask(pin);
+  result.maskLOW = ~result.maskHIGH;
+  // DIAG(F(" port=0x%x, inoutpin=0x%x, isinput=%d, mask=0x%x"),port, result.inout,input,result.maskHIGH);
@@ -556 +559,0 @@ void MotorDriver::checkPowerOverload(bool useProgLimit, byte trackno) {
-
@@ -557,0 +561,5 @@ void MotorDriver::checkPowerOverload(bool useProgLimit, byte trackno) {
+    case POWERMODE::OFF: {
+      lastPowerMode = POWERMODE::OFF;
+      power_sample_overload_wait = POWER_SAMPLE_OVERLOAD_WAIT;
+      break;
+    }
@@ -559,18 +567,17 @@ void MotorDriver::checkPowerOverload(bool useProgLimit, byte trackno) {
-  case POWERMODE::OFF: {
-    lastPowerMode = POWERMODE::OFF;
-    power_sample_overload_wait = POWER_SAMPLE_OVERLOAD_WAIT;
-    break;
-  }
-
-  case POWERMODE::ON: {
-    lastPowerMode = POWERMODE::ON;
-    bool cF = checkFault();
-    bool cC = checkCurrent(useProgLimit);
-    if(cF || cC ) {
-      if (cC) {
-	unsigned int mA=raw2mA(lastCurrent);
-	DIAG(F("TRACK %c ALERT %s %dmA"), trackno + 'A',
-	     cF ? "FAULT" : "",
-	     mA);
-      } else {
-	DIAG(F("TRACK %c ALERT FAULT"), trackno + 'A');
+    case POWERMODE::ON: {
+      lastPowerMode = POWERMODE::ON;
+      bool cF = checkFault();
+      bool cC = checkCurrent(useProgLimit);
+      if (cF || cC) {
+        if (cC) {
+          unsigned int mA = raw2mA(lastCurrent);
+          DIAG(F("TRACK %c ALERT %s %dmA"), trackno + 'A', cF ? "FAULT" : "", mA);
+        } else {
+          DIAG(F("TRACK %c ALERT FAULT"), trackno + 'A');
+        }
+        setPower(POWERMODE::ALERT);
+        if ((trackMode & TRACK_MODIFIER_AUTO) && (trackMode & (TRACK_MODE_MAIN | TRACK_MODE_EXT | TRACK_MODE_BOOST))) {
+          DIAG(F("TRACK %c INVERT"), trackno + 'A');
+          invertOutput();
+        }
+        break;
@@ -578,4 +585,3 @@ void MotorDriver::checkPowerOverload(bool useProgLimit, byte trackno) {
-      setPower(POWERMODE::ALERT);
-      if ((trackMode & TRACK_MODIFIER_AUTO) && (trackMode & (TRACK_MODE_MAIN|TRACK_MODE_EXT|TRACK_MODE_BOOST))){
-	DIAG(F("TRACK %c INVERT"), trackno + 'A');
-	invertOutput();
+      // all well
+      if (microsSinceLastPowerChange(POWERMODE::ON) > POWER_SAMPLE_ALL_GOOD) {
+        power_sample_overload_wait = POWER_SAMPLE_OVERLOAD_WAIT;
@@ -585,6 +590,0 @@ void MotorDriver::checkPowerOverload(bool useProgLimit, byte trackno) {
-    // all well
-    if (microsSinceLastPowerChange(POWERMODE::ON) > POWER_SAMPLE_ALL_GOOD) {
-      power_sample_overload_wait = POWER_SAMPLE_OVERLOAD_WAIT;
-    }
-    break;
-  }
@@ -592,18 +592,23 @@ void MotorDriver::checkPowerOverload(bool useProgLimit, byte trackno) {
-  case POWERMODE::ALERT: {
-    // set local flags that handle how much is output to diag (do not output duplicates)
-    bool notFromOverload = (lastPowerMode != POWERMODE::OVERLOAD);
-    bool powerModeChange = (powerMode != lastPowerMode);
-    unsigned long now = micros();
-    if (powerModeChange)
-      lastBadSample = now;
-    lastPowerMode = POWERMODE::ALERT;
-    // check how long we have been in this state
-    unsigned long mslpc = microsSinceLastPowerChange(POWERMODE::ALERT);
-    if(checkFault()) {
-      throttleInrush(true);
-      lastBadSample = now;
-      unsigned long timeout = checkCurrent(useProgLimit) ? POWER_SAMPLE_IGNORE_FAULT_HIGH : POWER_SAMPLE_IGNORE_FAULT_LOW;
-      if ( mslpc < timeout) {
-	if (powerModeChange)
-	  DIAG(F("TRACK %c FAULT PIN (%M ignore)"), trackno + 'A', timeout);
-	break;
+    case POWERMODE::ALERT: {
+      // set local flags that handle how much is output to diag (do not output duplicates)
+      bool notFromOverload = (lastPowerMode != POWERMODE::OVERLOAD);
+      bool powerModeChange = (powerMode != lastPowerMode);
+      unsigned long now = micros();
+      if (powerModeChange)
+        lastBadSample = now;
+      lastPowerMode = POWERMODE::ALERT;
+      // check how long we have been in this state
+      unsigned long mslpc = microsSinceLastPowerChange(POWERMODE::ALERT);
+      if (checkFault()) {
+        throttleInrush(true);
+        lastBadSample = now;
+        unsigned long timeout = checkCurrent(useProgLimit) ? POWER_SAMPLE_IGNORE_FAULT_HIGH : POWER_SAMPLE_IGNORE_FAULT_LOW;
+        if (mslpc < timeout) {
+          if (powerModeChange)
+            DIAG(F("TRACK %c FAULT PIN (%M ignore)"), trackno + 'A', timeout);
+          break;
+        }
+        DIAG(F("TRACK %c FAULT PIN detected after %4M. Pause %4M)"), trackno + 'A', mslpc, power_sample_overload_wait);
+        throttleInrush(false);
+        setPower(POWERMODE::OVERLOAD);
+        break;
@@ -611,13 +616,16 @@ void MotorDriver::checkPowerOverload(bool useProgLimit, byte trackno) {
-      DIAG(F("TRACK %c FAULT PIN detected after %4M. Pause %4M)"), trackno + 'A', mslpc, power_sample_overload_wait);
-      throttleInrush(false);
-      setPower(POWERMODE::OVERLOAD);
-      break;
-    }
-    if (checkCurrent(useProgLimit)) {
-      lastBadSample = now;
-      if (mslpc < POWER_SAMPLE_IGNORE_CURRENT) {
-	if (powerModeChange) {
-	  unsigned int mA=raw2mA(lastCurrent);
-	  DIAG(F("TRACK %c CURRENT (%M ignore) %dmA"), trackno + 'A', POWER_SAMPLE_IGNORE_CURRENT, mA);
-	}
-	break;
+      if (checkCurrent(useProgLimit)) {
+        lastBadSample = now;
+        if (mslpc < POWER_SAMPLE_IGNORE_CURRENT) {
+          if (powerModeChange) {
+            unsigned int mA = raw2mA(lastCurrent);
+            DIAG(F("TRACK %c CURRENT (%M ignore) %dmA"), trackno + 'A', POWER_SAMPLE_IGNORE_CURRENT, mA);
+          }
+          break;
+        }
+        unsigned int mA = raw2mA(lastCurrent);
+        unsigned int maxmA = raw2mA(tripValue);
+        DIAG(F("TRACK %c POWER OVERLOAD %4dmA (max %4dmA) detected after %4M. Pause %4M"), trackno + 'A', mA, maxmA, mslpc,
+             power_sample_overload_wait);
+        throttleInrush(false);
+        setPower(POWERMODE::OVERLOAD);
+        break;
@@ -625,14 +633,13 @@ void MotorDriver::checkPowerOverload(bool useProgLimit, byte trackno) {
-      unsigned int mA=raw2mA(lastCurrent);
-      unsigned int maxmA=raw2mA(tripValue);
-      DIAG(F("TRACK %c POWER OVERLOAD %4dmA (max %4dmA) detected after %4M. Pause %4M"),
-	   trackno + 'A', mA, maxmA, mslpc, power_sample_overload_wait);
-      throttleInrush(false);
-      setPower(POWERMODE::OVERLOAD);
-      break;
-    }
-    // all well
-    unsigned long goodtime = micros() - lastBadSample;
-    if (goodtime > POWER_SAMPLE_ALERT_GOOD) {
-      if (true || notFromOverload) { // we did a RESTORE message XXX
-	unsigned int mA=raw2mA(lastCurrent);
-	DIAG(F("TRACK %c NORMAL (after %M/%M) %dmA"), trackno + 'A', goodtime, mslpc, mA);
+      // all well
+      unsigned long goodtime = micros() - lastBadSample;
+      if (goodtime > POWER_SAMPLE_ALERT_GOOD) {
+        if (true || notFromOverload) {  // we did a RESTORE message XXX
+          unsigned int mA = raw2mA(lastCurrent);
+          DIAG(F("TRACK %c NORMAL (after %M/%M) %dmA"), trackno + 'A', goodtime, mslpc, mA);
+        }
+        throttleInrush(false);
+        setPower(POWERMODE::ON);
+        break;
+      }
+      if (goodtime > POWER_SAMPLE_ALERT_GOOD / 2) {
+        throttleInrush(false);
@@ -640,2 +646,0 @@ void MotorDriver::checkPowerOverload(bool useProgLimit, byte trackno) {
-      throttleInrush(false);
-      setPower(POWERMODE::ON);
@@ -644,5 +648,0 @@ void MotorDriver::checkPowerOverload(bool useProgLimit, byte trackno) {
-    if (goodtime > POWER_SAMPLE_ALERT_GOOD/2) {
-      throttleInrush(false);
-    }
-    break;
-  }
@@ -650,15 +650,17 @@ void MotorDriver::checkPowerOverload(bool useProgLimit, byte trackno) {
-  case POWERMODE::OVERLOAD: {
-    lastPowerMode = POWERMODE::OVERLOAD;
-    unsigned long mslpc = (commonFaultPin ? (micros() - globalOverloadStart) : microsSinceLastPowerChange(POWERMODE::OVERLOAD));
-    if (mslpc > power_sample_overload_wait) {
-      // adjust next wait time
-      power_sample_overload_wait *= 2;
-      if (power_sample_overload_wait > POWER_SAMPLE_RETRY_MAX)
-	      power_sample_overload_wait = POWER_SAMPLE_RETRY_MAX;
-  #ifdef EXRAIL_ACTIVE
-      DIAG(F("Calling EXRAIL"));
-      RMFT2::powerEvent(trackno, true); // Tell EXRAIL we have an overload
-  #endif
-      // power on test
-      DIAG(F("TRACK %c POWER RESTORE (after %4M)"), trackno + 'A', mslpc);
-      setPower(POWERMODE::ALERT);
+    case POWERMODE::OVERLOAD: {
+      lastPowerMode = POWERMODE::OVERLOAD;
+      unsigned long mslpc = (commonFaultPin ? (micros() - globalOverloadStart) : microsSinceLastPowerChange(POWERMODE::OVERLOAD));
+      if (mslpc > power_sample_overload_wait) {
+        // adjust next wait time
+        power_sample_overload_wait *= 2;
+        if (power_sample_overload_wait > POWER_SAMPLE_RETRY_MAX)
+          power_sample_overload_wait = POWER_SAMPLE_RETRY_MAX;
+#ifdef EXRAIL_ACTIVE
+        DIAG(F("Calling EXRAIL"));
+        RMFT2::powerEvent(trackno, true);  // Tell EXRAIL we have an overload
+#endif
+        // power on test
+        DIAG(F("TRACK %c POWER RESTORE (after %4M)"), trackno + 'A', mslpc);
+        setPower(POWERMODE::ALERT);
+      }
+      break;
@@ -666,2 +667,0 @@ void MotorDriver::checkPowerOverload(bool useProgLimit, byte trackno) {
-    break;
-  }
@@ -669,2 +669,2 @@ void MotorDriver::checkPowerOverload(bool useProgLimit, byte trackno) {
-  default:
-    break;
+    default:
+      break;
diff --git a/MotorDriver.h b/MotorDriver.h
index f1d52f7..180a457 100644
--- a/MotorDriver.h
+++ b/MotorDriver.h
@@ -8 +8 @@
- *  
+ *
@@ -36,2 +36,5 @@ enum TRACK_MODE : byte {
-  TRACK_MODE_NONE = 1, TRACK_MODE_MAIN = 2, TRACK_MODE_PROG = 4,
-  TRACK_MODE_DC = 8, TRACK_MODE_EXT = 16,
+  TRACK_MODE_NONE = 1,
+  TRACK_MODE_MAIN = 2,
+  TRACK_MODE_PROG = 4,
+  TRACK_MODE_DC = 8,
+  TRACK_MODE_EXT = 16,
@@ -39 +42,2 @@ enum TRACK_MODE : byte {
-  TRACK_MODIFIER_INV = 64, TRACK_MODIFIER_AUTO = 128,
+  TRACK_MODIFIER_INV = 64,
+  TRACK_MODIFIER_AUTO = 128,
@@ -42,2 +46,2 @@ enum TRACK_MODE : byte {
-  TRACK_MODE_BOOST_INV = TRACK_MODE_BOOST|TRACK_MODIFIER_INV,
-  TRACK_MODE_BOOST_AUTO = TRACK_MODE_BOOST|TRACK_MODIFIER_AUTO,
+  TRACK_MODE_BOOST_INV = TRACK_MODE_BOOST | TRACK_MODIFIER_INV,
+  TRACK_MODE_BOOST_AUTO = TRACK_MODE_BOOST | TRACK_MODIFIER_AUTO,
@@ -50,5 +54,5 @@ enum TRACK_MODE : byte {
-  TRACK_ALL = TRACK_MODE_MAIN|TRACK_MODE_PROG|TRACK_MODE_DC|TRACK_MODE_EXT|TRACK_MODE_BOOST,
-  TRACK_MODE_MAIN_INV  =  TRACK_MODE_MAIN|TRACK_MODIFIER_INV,
-  TRACK_MODE_MAIN_AUTO =  TRACK_MODE_MAIN|TRACK_MODIFIER_AUTO,
-  TRACK_MODE_DC_INV =  TRACK_MODE_DC|TRACK_MODIFIER_INV,
-  TRACK_MODE_DCX = TRACK_MODE_DC_INV // DCX is other name for historical reasons
+  TRACK_ALL = TRACK_MODE_MAIN | TRACK_MODE_PROG | TRACK_MODE_DC | TRACK_MODE_EXT | TRACK_MODE_BOOST,
+  TRACK_MODE_MAIN_INV = TRACK_MODE_MAIN | TRACK_MODIFIER_INV,
+  TRACK_MODE_MAIN_AUTO = TRACK_MODE_MAIN | TRACK_MODIFIER_AUTO,
+  TRACK_MODE_DC_INV = TRACK_MODE_DC | TRACK_MODIFIER_INV,
+  TRACK_MODE_DCX = TRACK_MODE_DC_INV  // DCX is other name for historical reasons
@@ -57,4 +61,4 @@ enum TRACK_MODE : byte {
-#define setHIGH(fastpin)  *fastpin.inout |= fastpin.maskHIGH
-#define setLOW(fastpin)   *fastpin.inout &= fastpin.maskLOW
-#define isHIGH(fastpin)   (*fastpin.inout & fastpin.maskHIGH)
-#define isLOW(fastpin)    (!isHIGH(fastpin))
+#define setHIGH(fastpin) *fastpin.inout |= fastpin.maskHIGH
+#define setLOW(fastpin) *fastpin.inout &= fastpin.maskLOW
+#define isHIGH(fastpin) (*fastpin.inout & fastpin.maskHIGH)
+#define isLOW(fastpin) (!isHIGH(fastpin))
@@ -62 +66 @@ enum TRACK_MODE : byte {
-#define TOKENPASTE(x, y) x ## y
+#define TOKENPASTE(x, y) x##y
@@ -110 +114 @@ enum TRACK_MODE : byte {
-#define HAVE_PORTA(X) byte TOKENPASTE2(Unique_, __LINE__) __attribute__((unused)) =0
+#define HAVE_PORTA(X) byte TOKENPASTE2(Unique_, __LINE__) __attribute__((unused)) = 0
@@ -113 +117 @@ enum TRACK_MODE : byte {
-#define HAVE_PORTB(X) byte TOKENPASTE2(Unique_, __LINE__) __attribute__((unused)) =0
+#define HAVE_PORTB(X) byte TOKENPASTE2(Unique_, __LINE__) __attribute__((unused)) = 0
@@ -116 +120 @@ enum TRACK_MODE : byte {
-#define HAVE_PORTC(X) byte TOKENPASTE2(Unique_, __LINE__) __attribute__((unused)) =0
+#define HAVE_PORTC(X) byte TOKENPASTE2(Unique_, __LINE__) __attribute__((unused)) = 0
@@ -119 +123 @@ enum TRACK_MODE : byte {
-#define HAVE_PORTD(X) byte TOKENPASTE2(Unique_, __LINE__) __attribute__((unused)) =0
+#define HAVE_PORTD(X) byte TOKENPASTE2(Unique_, __LINE__) __attribute__((unused)) = 0
@@ -122 +126 @@ enum TRACK_MODE : byte {
-#define HAVE_PORTE(X) byte TOKENPASTE2(Unique_, __LINE__) __attribute__((unused)) =0
+#define HAVE_PORTE(X) byte TOKENPASTE2(Unique_, __LINE__) __attribute__((unused)) = 0
@@ -125 +129 @@ enum TRACK_MODE : byte {
-#define HAVE_PORTF(X) byte TOKENPASTE2(Unique_, __LINE__) __attribute__((unused)) =0
+#define HAVE_PORTF(X) byte TOKENPASTE2(Unique_, __LINE__) __attribute__((unused)) = 0
@@ -128 +132 @@ enum TRACK_MODE : byte {
-#define HAVE_PORTG(X) byte TOKENPASTE2(Unique_, __LINE__) __attribute__((unused)) =0
+#define HAVE_PORTG(X) byte TOKENPASTE2(Unique_, __LINE__) __attribute__((unused)) = 0
@@ -131 +135 @@ enum TRACK_MODE : byte {
-#define HAVE_PORTH(X) byte TOKENPASTE2(Unique_, __LINE__) __attribute__((unused)) =0
+#define HAVE_PORTH(X) byte TOKENPASTE2(Unique_, __LINE__) __attribute__((unused)) = 0
@@ -136,2 +140,2 @@ enum TRACK_MODE : byte {
-#ifndef UNUSED_PIN     // sync define with the one in MotorDrivers.h
-#define UNUSED_PIN 255 // inside uint8_t
+#ifndef UNUSED_PIN      // sync define with the one in MotorDrivers.h
+#define UNUSED_PIN 255  // inside uint8_t
@@ -142 +146 @@ class pinpair {
-public:
+ public:
@@ -151 +155,2 @@ public:
-#if defined(__IMXRT1062__) || defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32) || defined(ARDUINO_ARCH_SAMD) || defined(ARDUINO_ARCH_STM32)
+#if defined(__IMXRT1062__) || defined(ARDUINO_ARCH_ESP8266) || defined(ARDUINO_ARCH_ESP32) || defined(ARDUINO_ARCH_SAMD) || \
+    defined(ARDUINO_ARCH_STM32)
@@ -158 +163 @@ struct FASTPIN {
-  volatile portreg_t *inout;
+  volatile portreg_t* inout;
@@ -161 +166 @@ struct FASTPIN {
-  volatile portreg_t *shadowinout;
+  volatile portreg_t* shadowinout;
@@ -178,13 +183,14 @@ class MotorDriver {
-  public:
-    
-    MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, int16_t brake_pin, 
-                byte current_pin, float senseFactor, unsigned int tripMilliamps, int16_t fault_pin);
-    void setPower( POWERMODE mode);
-    POWERMODE getPower() { return powerMode;}
-    // as the port registers can be shadowed to get syncronized DCC signals
-    // we need to take care of that and we have to turn off interrupts if
-    // we setSignal() or setBrake() or setPower() during that time as
-    // otherwise the call from interrupt context can undo whatever we do
-    // from outside interrupt
-    void setBrake( bool on, bool interruptContext=false);
-    __attribute__((always_inline)) inline void setSignal( bool high) {
+ public:
+  MotorDriver(int16_t power_pin, byte signal_pin, byte signal_pin2, int16_t brake_pin, byte current_pin, float senseFactor,
+              unsigned int tripMilliamps, int16_t fault_pin);
+  void setPower(POWERMODE mode);
+  POWERMODE getPower() {
+    return powerMode;
+  }
+  // as the port registers can be shadowed to get syncronized DCC signals
+  // we need to take care of that and we have to turn off interrupts if
+  // we setSignal() or setBrake() or setPower() during that time as
+  // otherwise the call from interrupt context can undo whatever we do
+  // from outside interrupt
+  void setBrake(bool on, bool interruptContext = false);
+  __attribute__((always_inline)) inline void setSignal(bool high) {
@@ -192,2 +198,2 @@ class MotorDriver {
-      if (invertPhase)
-	high = !high;
+    if (invertPhase)
+      high = !high;
@@ -195,12 +201,11 @@ class MotorDriver {
-      if (trackPWM) {
-	DCCTimer::setPWM(signalPin,high);
-      }
-      else {
-	if (high) {
-	  setHIGH(fastSignalPin);
-	  if (dualSignal) setLOW(fastSignalPin2);
-	}
-	else {
-	  setLOW(fastSignalPin);
-	  if (dualSignal) setHIGH(fastSignalPin2);
-	}
+    if (trackPWM) {
+      DCCTimer::setPWM(signalPin, high);
+    } else {
+      if (high) {
+        setHIGH(fastSignalPin);
+        if (dualSignal)
+          setLOW(fastSignalPin2);
+      } else {
+        setLOW(fastSignalPin);
+        if (dualSignal)
+          setHIGH(fastSignalPin2);
@@ -208,2 +213,8 @@ class MotorDriver {
-    };
-    inline void enableSignal(bool on) {
+    }
+  };
+  inline void enableSignal(bool on) {
+    if (on)
+      pinMode(signalPin, OUTPUT);
+    else
+      pinMode(signalPin, INPUT);
+    if (signalPin2 != UNUSED_PIN) {
@@ -211 +222 @@ class MotorDriver {
-	pinMode(signalPin, OUTPUT);
+        pinMode(signalPin2, OUTPUT);
@@ -213,13 +224,12 @@ class MotorDriver {
-	pinMode(signalPin, INPUT);
-      if (signalPin2 != UNUSED_PIN) {
-	if (on)
-	  pinMode(signalPin2, OUTPUT);
-	else
-	  pinMode(signalPin2, INPUT);
-      }
-    };
-    inline pinpair getSignalPin() { return pinpair(signalPin,signalPin2); };
-    inline int8_t getBrakePinSigned() { return invertBrake ? -brakePin : brakePin; };
-    void setDCSignal(byte speedByte, uint8_t frequency=0);
-    void throttleInrush(bool on);
-    inline void detachDCSignal() {
+        pinMode(signalPin2, INPUT);
+    }
+  };
+  inline pinpair getSignalPin() {
+    return pinpair(signalPin, signalPin2);
+  };
+  inline int8_t getBrakePinSigned() {
+    return invertBrake ? -brakePin : brakePin;
+  };
+  void setDCSignal(byte speedByte, uint8_t frequency = 0);
+  void throttleInrush(bool on);
+  inline void detachDCSignal() {
@@ -227 +237 @@ class MotorDriver {
-      pinMode(brakePin, OUTPUT);
+    pinMode(brakePin, OUTPUT);
@@ -229 +239 @@ class MotorDriver {
-      DCCTimer::DCCEXledcDetachPin(brakePin);
+    DCCTimer::DCCEXledcDetachPin(brakePin);
@@ -231 +241 @@ class MotorDriver {
-      setDCSignal(128);
+    setDCSignal(128);
@@ -233,5 +243,5 @@ class MotorDriver {
-    };
-    int  getCurrentRaw(bool fromISR=false);
-    unsigned int raw2mA( int raw);
-    unsigned int mA2raw( unsigned int mA);
-    inline bool brakeCanPWM() {
+  };
+  int getCurrentRaw(bool fromISR = false);
+  unsigned int raw2mA(int raw);
+  unsigned int mA2raw(unsigned int mA);
+  inline bool brakeCanPWM() {
@@ -239 +249 @@ class MotorDriver {
-      return (brakePin != UNUSED_PIN); // This was just (true) but we probably do need to check for UNUSED_PIN!
+    return (brakePin != UNUSED_PIN);  // This was just (true) but we probably do need to check for UNUSED_PIN!
@@ -241,2 +251,2 @@ class MotorDriver {
-      // On ARM we can use digitalPinHasPWM
-      return ((brakePin!=UNUSED_PIN) && (digitalPinHasPWM(brakePin)));
+    // On ARM we can use digitalPinHasPWM
+    return ((brakePin != UNUSED_PIN) && (digitalPinHasPWM(brakePin)));
@@ -244 +254 @@ class MotorDriver {
-      return ((brakePin!=UNUSED_PIN) && (digitalPinToTimer(brakePin)));
+    return ((brakePin != UNUSED_PIN) && (digitalPinToTimer(brakePin)));
@@ -246 +256 @@ class MotorDriver {
-      return (brakePin<14 && brakePin >1);
+    return (brakePin < 14 && brakePin > 1);
@@ -248,31 +258,31 @@ class MotorDriver {
-    }
-    inline int getRawCurrentTripValue() {
-	    return rawCurrentTripValue;
-    }
-    bool isPWMCapable();
-    bool canMeasureCurrent();
-    bool trackPWM = false; // this track uses PWM timer to generate the DCC waveform
-    bool commonFaultPin = false; // This is a stupid motor shield which has only a common fault pin for both outputs
-    inline byte setCommonFaultPin() {
-      return commonFaultPin = true;
-    }
-    inline byte getFaultPin() {
-	return faultPin;
-    }
-    inline void makeProgTrack(bool on) {  // let this output know it's a prog track.
-      isProgTrack = on;
-    }
-    void checkPowerOverload(bool useProgLimit, byte trackno);
-    inline void setTrackLetter(char c) {
-      trackLetter = c;
-    };
-    // this returns how much time has passed since the last power change. If it
-    // was really long ago (approx > 52min) advance counter approx 35 min so that
-    // we are at 18 minutes again. Times for 32 bit unsigned long.
-    inline unsigned long microsSinceLastPowerChange(POWERMODE mode) {
-      unsigned long now = micros();
-      unsigned long diff = now - lastPowerChange[(int)mode];
-      if (diff > (1UL << (7 *sizeof(unsigned long)))) // 2^(4*7)us = 268.4 seconds
-        lastPowerChange[(int)mode] = now - 30000000UL;           // 30 seconds ago
-      return diff;
-    };
+  }
+  inline int getRawCurrentTripValue() {
+    return rawCurrentTripValue;
+  }
+  bool isPWMCapable();
+  bool canMeasureCurrent();
+  bool trackPWM = false;        // this track uses PWM timer to generate the DCC waveform
+  bool commonFaultPin = false;  // This is a stupid motor shield which has only a common fault pin for both outputs
+  inline byte setCommonFaultPin() {
+    return commonFaultPin = true;
+  }
+  inline byte getFaultPin() {
+    return faultPin;
+  }
+  inline void makeProgTrack(bool on) {  // let this output know it's a prog track.
+    isProgTrack = on;
+  }
+  void checkPowerOverload(bool useProgLimit, byte trackno);
+  inline void setTrackLetter(char c) {
+    trackLetter = c;
+  };
+  // this returns how much time has passed since the last power change. If it
+  // was really long ago (approx > 52min) advance counter approx 35 min so that
+  // we are at 18 minutes again. Times for 32 bit unsigned long.
+  inline unsigned long microsSinceLastPowerChange(POWERMODE mode) {
+    unsigned long now = micros();
+    unsigned long diff = now - lastPowerChange[(int)mode];
+    if (diff > (1UL << (7 * sizeof(unsigned long))))  // 2^(4*7)us = 268.4 seconds
+      lastPowerChange[(int)mode] = now - 30000000UL;  // 30 seconds ago
+    return diff;
+  };
@@ -280,2 +290,2 @@ class MotorDriver {
-    bool sampleCurrentFromHW();
-    void startCurrentFromHW();
+  bool sampleCurrentFromHW();
+  void startCurrentFromHW();
@@ -287 +297 @@ class MotorDriver {
-  inline void invertOutput() {               // toggles output inversion
+  inline void invertOutput() {  // toggles output inversion
@@ -291 +301 @@ class MotorDriver {
-  inline void invertOutput(bool b) {         // sets output inverted or not
+  inline void invertOutput(bool b) {  // sets output inverted or not
@@ -298,3 +308,3 @@ class MotorDriver {
-    uint32_t *outreg = (uint32_t *)(GPIO_FUNC0_OUT_SEL_CFG_REG + 4*p.pin);
-    if (invertPhase) // set or clear the invert bit in the gpio out register
-      *outreg |=  ((uint32_t)0x1 << GPIO_FUNC0_OUT_INV_SEL_S);
+    uint32_t* outreg = (uint32_t*)(GPIO_FUNC0_OUT_SEL_CFG_REG + 4 * p.pin);
+    if (invertPhase)  // set or clear the invert bit in the gpio out register
+      *outreg |= ((uint32_t)0x1 << GPIO_FUNC0_OUT_INV_SEL_S);
@@ -304,3 +314,3 @@ class MotorDriver {
-      outreg = (uint32_t *)(GPIO_FUNC0_OUT_SEL_CFG_REG + 4*p.invpin);
-      if (invertPhase) // clear or set the invert bit in the gpio out register
-	*outreg &= ~((uint32_t)0x1 << GPIO_FUNC0_OUT_INV_SEL_S);
+      outreg = (uint32_t*)(GPIO_FUNC0_OUT_SEL_CFG_REG + 4 * p.invpin);
+      if (invertPhase)  // clear or set the invert bit in the gpio out register
+        *outreg &= ~((uint32_t)0x1 << GPIO_FUNC0_OUT_INV_SEL_S);
@@ -308 +318 @@ class MotorDriver {
-	*outreg |=  ((uint32_t)0x1 << GPIO_FUNC0_OUT_INV_SEL_S);
+        *outreg |= ((uint32_t)0x1 << GPIO_FUNC0_OUT_INV_SEL_S);
@@ -315,48 +325,49 @@ class MotorDriver {
-  private:
-    char trackLetter = '?';
-    bool isProgTrack = false; // tells us if this is a prog track
-    void  getFastPin(const FSH* type,int pin, bool input, FASTPIN & result);
-    inline void  getFastPin(const FSH* type,int pin, FASTPIN & result) {
-	getFastPin(type, pin, 0, result);
-    };
-    // side effect sets lastCurrent and tripValue
-    inline bool checkCurrent(bool useProgLimit) {
-      tripValue= useProgLimit?progTripValue:getRawCurrentTripValue();
-      lastCurrent = getCurrentRaw();
-      if (lastCurrent < 0)
-	lastCurrent = -lastCurrent;
-      return lastCurrent >= tripValue;
-    };
-    // side effect sets lastCurrent
-    inline bool checkFault() {
-      lastCurrent = getCurrentRaw();
-      return lastCurrent < 0;
-    };
-    VPIN powerPin;
-    byte signalPin, signalPin2, currentPin, faultPin, brakePin;
-    FASTPIN fastSignalPin, fastSignalPin2, fastBrakePin,fastFaultPin;
-    bool dualSignal;       // true to use signalPin2
-    bool invertBrake;       // brake pin passed as negative means pin is inverted
-    bool invertPower;       // power pin passed as negative means pin is inverted
-    bool invertFault;       // fault pin passed as negative means pin is inverted
-    bool invertPhase = 0;   // phase of out pin is inverted
-    // Raw to milliamp conversion factors avoiding float data types.
-    // Milliamps=rawADCreading * sensefactorInternal / senseScale
-    //
-    // senseScale is chosen as 256 to give enough scale for 2 decimal place 
-    // raw->mA conversion with an ultra fast optimised integer multiplication  
-    int senseFactorInternal;  // set to senseFactor * senseScale
-    static const int senseScale=256;
-    int senseOffset;
-    unsigned int tripMilliamps;
-    int rawCurrentTripValue;
-    // current sampling
-    POWERMODE powerMode;
-    POWERMODE lastPowerMode;
-    unsigned long lastPowerChange[4];         // timestamp in microseconds
-    unsigned long lastBadSample;              // timestamp in microseconds
-    // used to sync restore time when common Fault pin detected
-    static unsigned long globalOverloadStart; // timestamp in microseconds
-    int progTripValue;
-    int  lastCurrent; //temp value
-    int  tripValue;   //temp value
+
+ private:
+  char trackLetter = '?';
+  bool isProgTrack = false;  // tells us if this is a prog track
+  void getFastPin(const FSH* type, int pin, bool input, FASTPIN& result);
+  inline void getFastPin(const FSH* type, int pin, FASTPIN& result) {
+    getFastPin(type, pin, 0, result);
+  };
+  // side effect sets lastCurrent and tripValue
+  inline bool checkCurrent(bool useProgLimit) {
+    tripValue = useProgLimit ? progTripValue : getRawCurrentTripValue();
+    lastCurrent = getCurrentRaw();
+    if (lastCurrent < 0)
+      lastCurrent = -lastCurrent;
+    return lastCurrent >= tripValue;
+  };
+  // side effect sets lastCurrent
+  inline bool checkFault() {
+    lastCurrent = getCurrentRaw();
+    return lastCurrent < 0;
+  };
+  VPIN powerPin;
+  byte signalPin, signalPin2, currentPin, faultPin, brakePin;
+  FASTPIN fastSignalPin, fastSignalPin2, fastBrakePin, fastFaultPin;
+  bool dualSignal;       // true to use signalPin2
+  bool invertBrake;      // brake pin passed as negative means pin is inverted
+  bool invertPower;      // power pin passed as negative means pin is inverted
+  bool invertFault;      // fault pin passed as negative means pin is inverted
+  bool invertPhase = 0;  // phase of out pin is inverted
+  // Raw to milliamp conversion factors avoiding float data types.
+  // Milliamps=rawADCreading * sensefactorInternal / senseScale
+  //
+  // senseScale is chosen as 256 to give enough scale for 2 decimal place
+  // raw->mA conversion with an ultra fast optimised integer multiplication
+  int senseFactorInternal;  // set to senseFactor * senseScale
+  static const int senseScale = 256;
+  int senseOffset;
+  unsigned int tripMilliamps;
+  int rawCurrentTripValue;
+  // current sampling
+  POWERMODE powerMode;
+  POWERMODE lastPowerMode;
+  unsigned long lastPowerChange[4];  // timestamp in microseconds
+  unsigned long lastBadSample;       // timestamp in microseconds
+  // used to sync restore time when common Fault pin detected
+  static unsigned long globalOverloadStart;  // timestamp in microseconds
+  int progTripValue;
+  int lastCurrent;  // temp value
+  int tripValue;    // temp value
@@ -364,2 +375,2 @@ class MotorDriver {
-    volatile unsigned long sampleCurrentTimestamp;
-    volatile uint16_t sampleCurrent;
+  volatile unsigned long sampleCurrentTimestamp;
+  volatile uint16_t sampleCurrent;
@@ -367,2 +378,2 @@ class MotorDriver {
-    int maxmA;
-    int tripmA;
+  int maxmA;
+  int tripmA;
@@ -370,22 +381,15 @@ class MotorDriver {
-    // Times for overload management. Unit: microseconds.
-    // Base for wait time until power is turned on again
-    static const unsigned long POWER_SAMPLE_OVERLOAD_WAIT =     40000UL;
-    // Time after we consider all faults old and forgotten
-    static const unsigned long POWER_SAMPLE_ALL_GOOD =        5000000UL;
-    // Time after which we consider a ALERT over 
-    static const unsigned long POWER_SAMPLE_ALERT_GOOD =        20000UL;
-    // How long to ignore fault pin if current is under limit
-    static const unsigned long POWER_SAMPLE_IGNORE_FAULT_LOW = 100000UL;
-    // How long to ignore fault pin if current is higher than limit
-    static const unsigned long POWER_SAMPLE_IGNORE_FAULT_HIGH =  5000UL;
-    // How long to wait between overcurrent and turning off
-    static const unsigned long POWER_SAMPLE_IGNORE_CURRENT  =  100000UL;
-    // Upper limit for retry period
-    static const unsigned long POWER_SAMPLE_RETRY_MAX =      10000000UL;
-    
-    // Trip current for programming track, 250mA. Change only if you really
-    // need to be non-NMRA-compliant because of decoders that are not either.
-    static const int TRIP_CURRENT_PROG=250;
-    unsigned long power_sample_overload_wait = POWER_SAMPLE_OVERLOAD_WAIT;
-    unsigned int power_good_counter = 0;
-    TRACK_MODE trackMode = TRACK_MODE_NONE; // we assume track not assigned at startup
+  // Times for overload management. Unit: microseconds.
+  // Base for wait time until power is turned on again
+  static const unsigned long POWER_SAMPLE_OVERLOAD_WAIT = 40000UL;
+  // Time after we consider all faults old and forgotten
+  static const unsigned long POWER_SAMPLE_ALL_GOOD = 5000000UL;
+  // Time after which we consider a ALERT over
+  static const unsigned long POWER_SAMPLE_ALERT_GOOD = 20000UL;
+  // How long to ignore fault pin if current is under limit
+  static const unsigned long POWER_SAMPLE_IGNORE_FAULT_LOW = 100000UL;
+  // How long to ignore fault pin if current is higher than limit
+  static const unsigned long POWER_SAMPLE_IGNORE_FAULT_HIGH = 5000UL;
+  // How long to wait between overcurrent and turning off
+  static const unsigned long POWER_SAMPLE_IGNORE_CURRENT = 100000UL;
+  // Upper limit for retry period
+  static const unsigned long POWER_SAMPLE_RETRY_MAX = 10000000UL;
@@ -392,0 +397,6 @@ class MotorDriver {
+  // Trip current for programming track, 250mA. Change only if you really
+  // need to be non-NMRA-compliant because of decoders that are not either.
+  static const int TRIP_CURRENT_PROG = 250;
+  unsigned long power_sample_overload_wait = POWER_SAMPLE_OVERLOAD_WAIT;
+  unsigned int power_good_counter = 0;
+  TRACK_MODE trackMode = TRACK_MODE_NONE;  // we assume track not assigned at startup
diff --git a/MotorDrivers.h b/MotorDrivers.h
index defbfd4..25b7f99 100644
--- a/MotorDrivers.h
+++ b/MotorDrivers.h
@@ -38,2 +38,2 @@
-#ifndef UNUSED_PIN     // sync define with the one in MotorDriver.h
-#define UNUSED_PIN 255 // inside uint8_t
+#ifndef UNUSED_PIN      // sync define with the one in MotorDriver.h
+#define UNUSED_PIN 255  // inside uint8_t
@@ -72,3 +72,3 @@
-#define STANDARD_MOTOR_SHIELD F("STANDARD_MOTOR_SHIELD"),                                                 \
-                              new MotorDriver(3, 12, UNUSED_PIN, 9, A0, 0.488, 1500, UNUSED_PIN), \
-                              new MotorDriver(11, 13, UNUSED_PIN, 8, A1, 0.488, 1500, UNUSED_PIN)
+#define STANDARD_MOTOR_SHIELD                                                                     \
+  F("STANDARD_MOTOR_SHIELD"), new MotorDriver(3, 12, UNUSED_PIN, 9, A0, 0.488, 1500, UNUSED_PIN), \
+      new MotorDriver(11, 13, UNUSED_PIN, 8, A1, 0.488, 1500, UNUSED_PIN)
@@ -82,3 +82,2 @@
-#define EX8874_SHIELD F("EX8874"), \
- new MotorDriver( 3, 12, UNUSED_PIN, 9, A0, 1.27, 5000, A4), \
- new MotorDriver( 5, 13, UNUSED_PIN, 6, A1, 1.27, 5000, A5)
+#define EX8874_SHIELD \
+  F("EX8874"), new MotorDriver(3, 12, UNUSED_PIN, 9, A0, 1.27, 5000, A4), new MotorDriver(5, 13, UNUSED_PIN, 6, A1, 1.27, 5000, A5)
@@ -87,3 +86,2 @@
-#define EX8874_SHIELD F("EX8874"), \
- new MotorDriver( 3, 12, UNUSED_PIN, 9, A0, 1.27, 5000, A4), \
- new MotorDriver(11, 13, UNUSED_PIN, 8, A1, 1.27, 5000, A5)
+#define EX8874_SHIELD \
+  F("EX8874"), new MotorDriver(3, 12, UNUSED_PIN, 9, A0, 1.27, 5000, A4), new MotorDriver(11, 13, UNUSED_PIN, 8, A1, 1.27, 5000, A5)
@@ -98,3 +96,3 @@
-#define STANDARD_MOTOR_SHIELD F("STANDARD_MOTOR_SHIELD"), \
- new MotorDriver(25/* 3*/, 19/*12*/, UNUSED_PIN, 13/*9*/, 35/*A2*/, 0.70, 1500, UNUSED_PIN), \
- new MotorDriver(23/*11*/, 18/*13*/, UNUSED_PIN, 12/*8*/, 34/*A3*/, 0.70, 1500, UNUSED_PIN)
+#define STANDARD_MOTOR_SHIELD                                                                                                 \
+  F("STANDARD_MOTOR_SHIELD"), new MotorDriver(25 /* 3*/, 19 /*12*/, UNUSED_PIN, 13 /*9*/, 35 /*A2*/, 0.70, 1500, UNUSED_PIN), \
+      new MotorDriver(23 /*11*/, 18 /*13*/, UNUSED_PIN, 12 /*8*/, 34 /*A3*/, 0.70, 1500, UNUSED_PIN)
@@ -104,3 +102,3 @@
-#define EX8874_SHIELD F("EX8874"),\
- new MotorDriver(25/* 3*/, 19/*12*/, UNUSED_PIN, 13/*9*/, 35/*A2*/, 1.27, 5000, 36 /*A4*/), \
- new MotorDriver(23/*11*/, 18/*13*/, UNUSED_PIN, 12/*8*/, 34/*A3*/, 1.27, 5000, 39 /*A5*/)
+#define EX8874_SHIELD                                                                                         \
+  F("EX8874"), new MotorDriver(25 /* 3*/, 19 /*12*/, UNUSED_PIN, 13 /*9*/, 35 /*A2*/, 1.27, 5000, 36 /*A4*/), \
+      new MotorDriver(23 /*11*/, 18 /*13*/, UNUSED_PIN, 12 /*8*/, 34 /*A3*/, 1.27, 5000, 39 /*A5*/)
@@ -109,3 +107 @@
-#define EXCSB1 F("EXCSB1"),\
- new MotorDriver(25,  0, UNUSED_PIN, -14, 34, 2.23, 5000, 19), \
- new MotorDriver(27, 15, UNUSED_PIN,  -2, 35, 2.23, 5000, 23)
+#define EXCSB1 F("EXCSB1"), new MotorDriver(25, 0, UNUSED_PIN, -14, 34, 2.23, 5000, 19), new MotorDriver(27, 15, UNUSED_PIN, -2, 35, 2.23, 5000, 23)
@@ -114,5 +110,3 @@
-#define EXCSB1_WITH_EX8874 F("EXCSB1_WITH_EX8874"),\
- new MotorDriver(25,  0, UNUSED_PIN, -14, 34, 2.23, 5000, 19), \
- new MotorDriver(27, 15, UNUSED_PIN,  -2, 35, 2.23, 5000, 23), \
- new MotorDriver(26,  5, UNUSED_PIN,  13, 36, 1.52, 5000, 18), \
- new MotorDriver(16,  4, UNUSED_PIN,  12, 39, 1.52, 5000, 17)
+#define EXCSB1_WITH_EX8874                                                                                                                           \
+  F("EXCSB1_WITH_EX8874"), new MotorDriver(25, 0, UNUSED_PIN, -14, 34, 2.23, 5000, 19), new MotorDriver(27, 15, UNUSED_PIN, -2, 35, 2.23, 5000, 23), \
+      new MotorDriver(26, 5, UNUSED_PIN, 13, 36, 1.52, 5000, 18), new MotorDriver(16, 4, UNUSED_PIN, 12, 39, 1.52, 5000, 17)
@@ -122,6 +116,6 @@
-#define STANDARD_MOTOR_SHIELD F("STANDARD_MOTOR_SHIELD"),                                                 \
-                              new MotorDriver(3, 12, UNUSED_PIN, 9, A0, 2.99, 1500, UNUSED_PIN), \
-                              new MotorDriver(11, 13, UNUSED_PIN, 8, A1, 2.99, 1500, UNUSED_PIN)
-#define BRAKE_PWM_SWAPPED_MOTOR_SHIELD F("BPS_MOTOR_SHIELD"),                                       \
-                              new MotorDriver(-9 , 12, UNUSED_PIN, -3, A0, 2.99, 1500, UNUSED_PIN), \
-                              new MotorDriver(-8 , 13, UNUSED_PIN,-11, A1, 2.99, 1500, UNUSED_PIN)
+#define STANDARD_MOTOR_SHIELD                                                                    \
+  F("STANDARD_MOTOR_SHIELD"), new MotorDriver(3, 12, UNUSED_PIN, 9, A0, 2.99, 1500, UNUSED_PIN), \
+      new MotorDriver(11, 13, UNUSED_PIN, 8, A1, 2.99, 1500, UNUSED_PIN)
+#define BRAKE_PWM_SWAPPED_MOTOR_SHIELD                                                        \
+  F("BPS_MOTOR_SHIELD"), new MotorDriver(-9, 12, UNUSED_PIN, -3, A0, 2.99, 1500, UNUSED_PIN), \
+      new MotorDriver(-8, 13, UNUSED_PIN, -11, A1, 2.99, 1500, UNUSED_PIN)
@@ -130,3 +124,2 @@
-#define EX8874_SHIELD F("EX8874"), \
- new MotorDriver( 3, 12, UNUSED_PIN, 9, A0, 5.08, 5000, A4), \
- new MotorDriver(11, 13, UNUSED_PIN, 8, A1, 5.08, 5000, A5)
+#define EX8874_SHIELD \
+  F("EX8874"), new MotorDriver(3, 12, UNUSED_PIN, 9, A0, 5.08, 5000, A4), new MotorDriver(11, 13, UNUSED_PIN, 8, A1, 5.08, 5000, A5)
@@ -137,3 +130,2 @@
-#define POLOLU_MOTOR_SHIELD F("POLOLU_MOTOR_SHIELD"),                                                 \
-                            new MotorDriver( 9, 7, UNUSED_PIN,         -4, A0, 18, 3000, 12), \
-                            new MotorDriver(10, 8, UNUSED_PIN, UNUSED_PIN, A1, 18, 3000, 12)
+#define POLOLU_MOTOR_SHIELD \
+  F("POLOLU_MOTOR_SHIELD"), new MotorDriver(9, 7, UNUSED_PIN, -4, A0, 18, 3000, 12), new MotorDriver(10, 8, UNUSED_PIN, UNUSED_PIN, A1, 18, 3000, 12)
@@ -158,3 +150,2 @@
-#define POLOLU_TB9051FTG F("POLOLU_TB9051FTG"),              \
-   new MotorDriver(2, 7, UNUSED_PIN,  -9, A0, 10, 2500,  6), \
-   new MotorDriver(4, 8, UNUSED_PIN, -10, A1, 10, 2500, 12)
+#define POLOLU_TB9051FTG \
+  F("POLOLU_TB9051FTG"), new MotorDriver(2, 7, UNUSED_PIN, -9, A0, 10, 2500, 6), new MotorDriver(4, 8, UNUSED_PIN, -10, A1, 10, 2500, 12)
@@ -163,3 +154,3 @@
-#define FIREBOX_MK1 F("FIREBOX_MK1"),                                                  \
-                    new MotorDriver(3, 6, 7, UNUSED_PIN, A5, 9.766, 5500, UNUSED_PIN), \
-                    new MotorDriver(4, 8, 9, UNUSED_PIN, A1, 5.00, 1000, UNUSED_PIN)
+#define FIREBOX_MK1                                                                    \
+  F("FIREBOX_MK1"), new MotorDriver(3, 6, 7, UNUSED_PIN, A5, 9.766, 5500, UNUSED_PIN), \
+      new MotorDriver(4, 8, 9, UNUSED_PIN, A1, 5.00, 1000, UNUSED_PIN)
@@ -168,3 +159,2 @@
-#define FIREBOX_MK1S F("FIREBOX_MK1A"),                                            \
-                     new MotorDriver(24, 21, 22, 25, 23, 9.766, 5500, UNUSED_PIN), \
-                     new MotorDriver(30, 27, 28, 31, 29, 5.00, 1000, UNUSED_PIN)
+#define FIREBOX_MK1S \
+  F("FIREBOX_MK1A"), new MotorDriver(24, 21, 22, 25, 23, 9.766, 5500, UNUSED_PIN), new MotorDriver(30, 27, 28, 31, 29, 5.00, 1000, UNUSED_PIN)
@@ -173,3 +163,3 @@
-#define FUNDUMOTO_SHIELD F("FUNDUMOTO_SHIELD"),                                              \
-                         new MotorDriver(10, 12, UNUSED_PIN, UNUSED_PIN, A0, 2.99, 1500, UNUSED_PIN), \
-                         new MotorDriver(11, 13, UNUSED_PIN, UNUSED_PIN, A1, 2.99, 1500, UNUSED_PIN)
+#define FUNDUMOTO_SHIELD                                                                              \
+  F("FUNDUMOTO_SHIELD"), new MotorDriver(10, 12, UNUSED_PIN, UNUSED_PIN, A0, 2.99, 1500, UNUSED_PIN), \
+      new MotorDriver(11, 13, UNUSED_PIN, UNUSED_PIN, A1, 2.99, 1500, UNUSED_PIN)
@@ -178,3 +168,3 @@
-#define IBT_2_WITH_ARDUINO F("IBT_2_WITH_ARDUINO_SHIELD"),                                              \
-                         new MotorDriver(4, 5, 6, UNUSED_PIN, A5, 41.54, 5000, UNUSED_PIN), \
-                         new MotorDriver(11, 13, UNUSED_PIN, UNUSED_PIN, A1, 2.99, 1500, UNUSED_PIN)
+#define IBT_2_WITH_ARDUINO                                                                           \
+  F("IBT_2_WITH_ARDUINO_SHIELD"), new MotorDriver(4, 5, 6, UNUSED_PIN, A5, 41.54, 5000, UNUSED_PIN), \
+      new MotorDriver(11, 13, UNUSED_PIN, UNUSED_PIN, A1, 2.99, 1500, UNUSED_PIN)
@@ -182,3 +172,3 @@
-#define YFROBOT_MOTOR_SHIELD F("YFROBOT_MOTOR_SHIELD"), \
-    new MotorDriver(5, 4, UNUSED_PIN, UNUSED_PIN, A0, 2.99, 1500, UNUSED_PIN), \
-    new MotorDriver(6, 7, UNUSED_PIN, UNUSED_PIN, A1, 2.99, 1500, UNUSED_PIN)
+#define YFROBOT_MOTOR_SHIELD                                                                            \
+  F("YFROBOT_MOTOR_SHIELD"), new MotorDriver(5, 4, UNUSED_PIN, UNUSED_PIN, A0, 2.99, 1500, UNUSED_PIN), \
+      new MotorDriver(6, 7, UNUSED_PIN, UNUSED_PIN, A1, 2.99, 1500, UNUSED_PIN)
@@ -193,3 +183,3 @@
-#define ORION_UNO_INTEGRATED_SHIELD F("ORION_UNO_INTEGRATED_SHIELD"),		      \
-    new MotorDriver(6, 7, UNUSED_PIN, UNUSED_PIN, UNUSED_PIN, 1.0, 1100, UNUSED_PIN), \
-    new MotorDriver(5, 4, UNUSED_PIN, UNUSED_PIN, UNUSED_PIN, 1.0, 1100, UNUSED_PIN)
+#define ORION_UNO_INTEGRATED_SHIELD                                                                                   \
+  F("ORION_UNO_INTEGRATED_SHIELD"), new MotorDriver(6, 7, UNUSED_PIN, UNUSED_PIN, UNUSED_PIN, 1.0, 1100, UNUSED_PIN), \
+      new MotorDriver(5, 4, UNUSED_PIN, UNUSED_PIN, UNUSED_PIN, 1.0, 1100, UNUSED_PIN)
@@ -200,3 +190,3 @@
-#define NANOEVERY_EXAMPLE F("NANOEVERY_EXAMPLE"), \
- new MotorDriver(5,  6, UNUSED_PIN, UNUSED_PIN, A0, 2.99, 1500, UNUSED_PIN),\
- new MotorDriver(9, 10, UNUSED_PIN, UNUSED_PIN, A1, 2.99, 1500, UNUSED_PIN)
+#define NANOEVERY_EXAMPLE                                                                            \
+  F("NANOEVERY_EXAMPLE"), new MotorDriver(5, 6, UNUSED_PIN, UNUSED_PIN, A0, 2.99, 1500, UNUSED_PIN), \
+      new MotorDriver(9, 10, UNUSED_PIN, UNUSED_PIN, A1, 2.99, 1500, UNUSED_PIN)
@@ -225,5 +215,4 @@
-#define STACKED_MOTOR_SHIELD F("STACKED_MOTOR_SHIELD"),\
-  new MotorDriver( 3, 12, UNUSED_PIN, 9, A0, 2.99, 1500, UNUSED_PIN), \
-  new MotorDriver(11, 13, UNUSED_PIN, 8, A1, 2.99, 1500, UNUSED_PIN), \
-  new MotorDriver( 2, 10, UNUSED_PIN, 7, A4, 2.99, 1500, UNUSED_PIN), \
-  new MotorDriver( 5,  4, UNUSED_PIN, 6, A5, 2.99, 1500, UNUSED_PIN)
+#define STACKED_MOTOR_SHIELD                                                                                                                 \
+  F("STACKED_MOTOR_SHIELD"), new MotorDriver(3, 12, UNUSED_PIN, 9, A0, 2.99, 1500, UNUSED_PIN),                                              \
+      new MotorDriver(11, 13, UNUSED_PIN, 8, A1, 2.99, 1500, UNUSED_PIN), new MotorDriver(2, 10, UNUSED_PIN, 7, A4, 2.99, 1500, UNUSED_PIN), \
+      new MotorDriver(5, 4, UNUSED_PIN, 6, A5, 2.99, 1500, UNUSED_PIN)
diff --git a/Outputs.cpp b/Outputs.cpp
index fd459b6..f0a3c96 100644
--- a/Outputs.cpp
+++ b/Outputs.cpp
@@ -7 +7 @@
- *  
+ *
@@ -98,2 +98,2 @@ the state of any outputs being monitored or controlled by a separate interface o
-void Output::printAll(Print *stream){
-  for (Output *tt = Output::firstOutput; tt != NULL; tt = tt->nextOutput)
+void Output::printAll(Print* stream) {
+  for (Output* tt = Output::firstOutput; tt != NULL; tt = tt->nextOutput)
@@ -101 +101 @@ void Output::printAll(Print *stream){
-} // Output::printAll
+}  // Output::printAll
@@ -106,3 +106,3 @@ void Output::printAll(Print *stream){
-void  Output::activate(uint16_t s){
-  s = (s>0);  // Make 0 or 1
-  data.active = s;                     // if s>0, set status to active, else inactive
+void Output::activate(uint16_t s) {
+  s = (s > 0);      // Make 0 or 1
+  data.active = s;  // if s>0, set status to active, else inactive
@@ -110 +110 @@ void  Output::activate(uint16_t s){
-  IODevice::write(data.pin, s ^ data.invert);  
+  IODevice::write(data.pin, s ^ data.invert);
@@ -112,2 +112,2 @@ void  Output::activate(uint16_t s){
-  // Update EEPROM if output has been stored.    
-  if(EEStore::eeStore->data.nOutputs > 0 && num > 0)
+  // Update EEPROM if output has been stored.
+  if (EEStore::eeStore->data.nOutputs > 0 && num > 0)
@@ -122,4 +122,4 @@ void  Output::activate(uint16_t s){
-Output* Output::get(uint16_t n){
-  Output *tt;
-  for(tt=firstOutput;tt!=NULL && tt->data.id!=n;tt=tt->nextOutput);
-  return(tt);
+Output* Output::get(uint16_t n) {
+  Output* tt;
+  for (tt = firstOutput; tt != NULL && tt->data.id != n; tt = tt->nextOutput);
+  return (tt);
@@ -132,2 +132,4 @@ Output* Output::get(uint16_t n){
-bool Output::remove(uint16_t n){
-  Output *tt,*pp=NULL;
+bool Output::remove(uint16_t n) {
+  Output *tt, *pp = NULL;
+
+  for (tt = firstOutput; tt != NULL && tt->data.id != n; pp = tt, tt = tt->nextOutput);
@@ -135 +137,2 @@ bool Output::remove(uint16_t n){
-  for(tt=firstOutput;tt!=NULL && tt->data.id!=n;pp=tt,tt=tt->nextOutput);
+  if (tt == NULL)
+    return false;
@@ -137,4 +140,2 @@ bool Output::remove(uint16_t n){
-  if(tt==NULL) return false;
-  
-  if(tt==firstOutput)
-    firstOutput=tt->nextOutput;
+  if (tt == firstOutput)
+    firstOutput = tt->nextOutput;
@@ -142 +143 @@ bool Output::remove(uint16_t n){
-    pp->nextOutput=tt->nextOutput;
+    pp->nextOutput = tt->nextOutput;
@@ -147 +148 @@ bool Output::remove(uint16_t n){
-  }
+}
@@ -152 +153 @@ bool Output::remove(uint16_t n){
-void Output::load(){
+void Output::load() {
@@ -154 +155 @@ void Output::load(){
-  Output *tt;
+  Output* tt;
@@ -156,2 +157,2 @@ void Output::load(){
-  for(uint16_t i=0;i<EEStore::eeStore->data.nOutputs;i++){
-    EEPROM.get(EEStore::pointer(),data);
+  for (uint16_t i = 0; i < EEStore::eeStore->data.nOutputs; i++) {
+    EEPROM.get(EEStore::pointer(), data);
@@ -159 +160 @@ void Output::load(){
-    tt=create(data.id, data.pin, data.flags);
+    tt = create(data.id, data.pin, data.flags);
@@ -163 +164,2 @@ void Output::load(){
-    if (tt) tt->num=EEStore::pointer() + offsetof(OutputData, oStatus); // Save pointer to flags within EEPROM
+    if (tt)
+      tt->num = EEStore::pointer() + offsetof(OutputData, oStatus);  // Save pointer to flags within EEPROM
@@ -171,2 +173,2 @@ void Output::load(){
-void Output::store(){
-  Output *tt;
+void Output::store() {
+  Output* tt;
@@ -174,2 +176,2 @@ void Output::store(){
-  tt=firstOutput;
-  EEStore::eeStore->data.nOutputs=0;
+  tt = firstOutput;
+  EEStore::eeStore->data.nOutputs = 0;
@@ -177,3 +179,3 @@ void Output::store(){
-  while(tt!=NULL){
-    EEPROM.put(EEStore::pointer(),tt->data);
-    tt->num=EEStore::pointer() + offsetof(OutputData, oStatus); // Save pointer to flags within EEPROM
+  while (tt != NULL) {
+    EEPROM.put(EEStore::pointer(), tt->data);
+    tt->num = EEStore::pointer() + offsetof(OutputData, oStatus);  // Save pointer to flags within EEPROM
@@ -181 +183 @@ void Output::store(){
-    tt=tt->nextOutput;
+    tt = tt->nextOutput;
@@ -184 +185,0 @@ void Output::store(){
-
@@ -193,14 +194,14 @@ void Output::store(){
-Output *Output::create(uint16_t id, VPIN pin, int iFlag, int v){
-  Output *tt;
-
-  if (pin > VPIN_MAX) return NULL;
-  
-  if(firstOutput==NULL){
-    firstOutput=(Output *)calloc(1,sizeof(Output));
-    tt=firstOutput;
-  } else if((tt=get(id))==NULL){
-    tt=firstOutput;
-    while(tt->nextOutput!=NULL)
-      tt=tt->nextOutput;
-    tt->nextOutput=(Output *)calloc(1,sizeof(Output));
-    tt=tt->nextOutput;
+Output* Output::create(uint16_t id, VPIN pin, int iFlag, int v) {
+  Output* tt;
+
+  if (pin > VPIN_MAX)
+    return NULL;
+
+  if (firstOutput == NULL) {
+    firstOutput = (Output*)calloc(1, sizeof(Output));
+    tt = firstOutput;
+  } else if ((tt = get(id)) == NULL) {
+    tt = firstOutput;
+    while (tt->nextOutput != NULL) tt = tt->nextOutput;
+    tt->nextOutput = (Output*)calloc(1, sizeof(Output));
+    tt = tt->nextOutput;
@@ -209,5 +210,6 @@ Output *Output::create(uint16_t id, VPIN pin, int iFlag, int v){
-  if(tt==NULL) return tt;
-  tt->num = 0; // make sure new object doesn't get written to EEPROM until store() command
-  tt->data.id=id;
-  tt->data.pin=pin;
-  tt->data.flags=iFlag;
+  if (tt == NULL)
+    return tt;
+  tt->num = 0;  // make sure new object doesn't get written to EEPROM until store() command
+  tt->data.id = id;
+  tt->data.pin = pin;
+  tt->data.flags = iFlag;
@@ -215 +217 @@ Output *Output::create(uint16_t id, VPIN pin, int iFlag, int v){
-  if(v==1){
+  if (v == 1) {
@@ -217 +219 @@ Output *Output::create(uint16_t id, VPIN pin, int iFlag, int v){
-    if (tt->data.setDefault) 
+    if (tt->data.setDefault)
@@ -224 +226 @@ Output *Output::create(uint16_t id, VPIN pin, int iFlag, int v){
-  return(tt);
+  return (tt);
@@ -229 +231 @@ Output *Output::create(uint16_t id, VPIN pin, int iFlag, int v){
-Output *Output::firstOutput=NULL;
+Output* Output::firstOutput = NULL;
diff --git a/Outputs.h b/Outputs.h
index 556f526..25254ca 100644
--- a/Outputs.h
+++ b/Outputs.h
@@ -6 +6 @@
- *  
+ *
@@ -30 +30 @@ struct OutputData {
-    uint8_t oStatus;      // (Bit 0=Invert, Bit 1=Set state to default, Bit 2=default state, Bit 7=active)
+    uint8_t oStatus;  // (Bit 0=Invert, Bit 1=Set state to default, Bit 2=default state, Bit 7=active)
@@ -32 +32 @@ struct OutputData {
-      unsigned int flags : 7; // Bit 0=Invert, Bit 1=Set state to default, Bit 2=default state
+      unsigned int flags : 7;  // Bit 0=Invert, Bit 1=Set state to default, Bit 2=default state
@@ -39 +39 @@ struct OutputData {
-      unsigned int: 4;
+      unsigned int : 4;
@@ -44 +44 @@ struct OutputData {
-  VPIN pin; 
+  VPIN pin;
@@ -47,3 +47,2 @@ struct OutputData {
-
-class Output{
-public:
+class Output {
+ public:
@@ -58,2 +57,2 @@ public:
-  static Output *create(uint16_t, VPIN, int, int=0);
-  static Output *firstOutput;
+  static Output* create(uint16_t, VPIN, int, int = 0);
+  static Output* firstOutput;
@@ -61,3 +60,4 @@ public:
-  Output *nextOutput;
-  static void printAll(Print *);
-private:
+  Output* nextOutput;
+  static void printAll(Print*);
+
+ private:
@@ -65,3 +65,3 @@ private:
-  
-}; // Output
-  
+
+};  // Output
+
diff --git a/RingStream.cpp b/RingStream.cpp
index 12dbaa1..4f52e78 100644
--- a/RingStream.cpp
+++ b/RingStream.cpp
@@ -4 +4 @@
- *  
+ *
@@ -21 +20,0 @@
-
@@ -23,3 +22,3 @@
-// RingStream is unsuitable for binary data. Should binary data need to be 
-// streamed it will be necessary to implementr an escape strategy to handle the 
-// marker char when embedded in data. 
+// RingStream is unsuitable for binary data. Should binary data need to be
+// streamed it will be necessary to implementr an escape strategy to handle the
+// marker char when embedded in data.
@@ -30,13 +29,12 @@
-const byte FLASH_INSERT_MARKER=0xff;
-
-RingStream::RingStream( const uint16_t len)
-{
-  _len=len;
-  _buffer=new byte[len];
-  _pos_write=0;
-  _pos_read=0;
-  _buffer[0]=0;
-  _overflow=false;
-  _mark=0;
-  _count=0; 
-  _flashInsert=0;
+const byte FLASH_INSERT_MARKER = 0xff;
+
+RingStream::RingStream(const uint16_t len) {
+  _len = len;
+  _buffer = new byte[len];
+  _pos_write = 0;
+  _pos_read = 0;
+  _buffer[0] = 0;
+  _overflow = false;
+  _mark = 0;
+  _count = 0;
+  _flashInsert = 0;
@@ -46 +44,2 @@ size_t RingStream::write(uint8_t b) {
-  if (_overflow) return 0;
+  if (_overflow)
+    return 0;
@@ -49,3 +48,4 @@ size_t RingStream::write(uint8_t b) {
-  if (_pos_write==_len) _pos_write=0;
-  if (_pos_write==_pos_read) {
-    _overflow=true; 
+  if (_pos_write == _len)
+    _pos_write = 0;
+  if (_pos_write == _pos_read) {
+    _overflow = true;
@@ -61,5 +61,5 @@ size_t RingStream::write(uint8_t b) {
-// in order that StringFormatter can recognise a RingStream and call its 
-// printFlash() directly.  
-int RingStream::availableForWrite()  { 
-  return  THIS_IS_A_RINGSTREAM; 
-  }
+// in order that StringFormatter can recognise a RingStream and call its
+// printFlash() directly.
+int RingStream::availableForWrite() {
+  return THIS_IS_A_RINGSTREAM;
+}
@@ -67 +67 @@ int RingStream::availableForWrite()  {
-size_t RingStream::printFlash(const FSH * flashBuffer) {
+size_t RingStream::printFlash(const FSH* flashBuffer) {
@@ -71,28 +71,29 @@ size_t RingStream::printFlash(const FSH * flashBuffer) {
-  // we have adequate ram. 
-  if (sizeof(void*)>2) return print(flashBuffer);
-
-
-// We are about to add a PROGMEM string to the buffer. 
-// To save RAM we can insert a marker and the
-// progmem address into the buffer instead.
-// The buffer reading code must recognise this marker and 
-// silently extract the progmem bytes.
-// In addition, we must make the count correct as if the 
-// string had been embedded so that things like the wifi code
-// can read the expected count before reading the buffer. 
-
-// Establish the actual length of the progmem string.
-char * flash=(char *)flashBuffer;
-int16_t plength=STRLEN_P(flash);
-if (plength==0) return 0; // just ignore empty string
-
-// Retain the buffer count as it will be modified by the marker+address insert
-int prevCount=_count;
-write(FLASH_INSERT_MARKER); // write the marker
-uintptr_t iFlash=reinterpret_cast<uintptr_t>(flash); // expect size match with pointer
-
-// write address bytes LSB first (size depends on CPU) 
-for (byte f=0;f<sizeof(iFlash); f++) {
-    write((byte) (iFlash & 0xFF));
-    iFlash>>=8;
-}
+  // we have adequate ram.
+  if (sizeof(void*) > 2)
+    return print(flashBuffer);
+
+  // We are about to add a PROGMEM string to the buffer.
+  // To save RAM we can insert a marker and the
+  // progmem address into the buffer instead.
+  // The buffer reading code must recognise this marker and
+  // silently extract the progmem bytes.
+  // In addition, we must make the count correct as if the
+  // string had been embedded so that things like the wifi code
+  // can read the expected count before reading the buffer.
+
+  // Establish the actual length of the progmem string.
+  char* flash = (char*)flashBuffer;
+  int16_t plength = STRLEN_P(flash);
+  if (plength == 0)
+    return 0;  // just ignore empty string
+
+  // Retain the buffer count as it will be modified by the marker+address insert
+  int prevCount = _count;
+  write(FLASH_INSERT_MARKER);                             // write the marker
+  uintptr_t iFlash = reinterpret_cast<uintptr_t>(flash);  // expect size match with pointer
+
+  // write address bytes LSB first (size depends on CPU)
+  for (byte f = 0; f < sizeof(iFlash); f++) {
+    write((byte)(iFlash & 0xFF));
+    iFlash >>= 8;
+  }
@@ -100,3 +101,3 @@ for (byte f=0;f<sizeof(iFlash); f++) {
-// correct the buffer count to reflect the flash length, not the marker/addr.
-_count=prevCount+plength;  
-return plength;
+  // correct the buffer count to reflect the flash length, not the marker/addr.
+  _count = prevCount + plength;
+  return plength;
@@ -107,2 +108,2 @@ int RingStream::read() {
-    // we are reading out of a flash string 
-    byte fb=GETFLASH(_flashInsert);
+    // we are reading out of a flash string
+    byte fb = GETFLASH(_flashInsert);
@@ -110 +111,2 @@ int RingStream::read() {
-    if (fb) return fb; // we have a byte from the flash
+    if (fb)
+      return fb;  // we have a byte from the flash
@@ -112 +114 @@ int RingStream::read() {
-    _flashInsert=NULL; 
+    _flashInsert = NULL;
@@ -114,6 +116,8 @@ int RingStream::read() {
-  if ((_pos_read==_pos_write) && !_overflow) return -1;  // empty  
-  byte b=readRawByte();
-  if (b!=FLASH_INSERT_MARKER) return b; 
-  // Detected a flash insert 
-  if (sizeof(void*)>2) {
-    DIAG(F("Detected invalid flash insert marker at pos %d"),_pos_read);
+  if ((_pos_read == _pos_write) && !_overflow)
+    return -1;  // empty
+  byte b = readRawByte();
+  if (b != FLASH_INSERT_MARKER)
+    return b;
+  // Detected a flash insert
+  if (sizeof(void*) > 2) {
+    DIAG(F("Detected invalid flash insert marker at pos %d"), _pos_read);
@@ -122,7 +126,7 @@ int RingStream::read() {
-  // read address bytes LSB first (size depends on CPU) 
-  uintptr_t iFlash=0; 
-  for (byte f=0; f<sizeof(iFlash); f++) {
-    uintptr_t bf=readRawByte();
-    bf&=0x00ff;
-    bf<<= (8*f); // shift byte to correct position in iFlash
-    iFlash |= bf;  
+  // read address bytes LSB first (size depends on CPU)
+  uintptr_t iFlash = 0;
+  for (byte f = 0; f < sizeof(iFlash); f++) {
+    uintptr_t bf = readRawByte();
+    bf &= 0x00ff;
+    bf <<= (8 * f);  // shift byte to correct position in iFlash
+    iFlash |= bf;
@@ -130,2 +134,2 @@ int RingStream::read() {
-  _flashInsert=reinterpret_cast<char * >( iFlash);
-  // and try again... so will read the first byte of the insert. 
+  _flashInsert = reinterpret_cast<char*>(iFlash);
+  // and try again... so will read the first byte of the insert.
@@ -136 +140 @@ byte RingStream::readRawByte() {
-  byte b=_buffer[_pos_read];
+  byte b = _buffer[_pos_read];
@@ -138,2 +142,3 @@ byte RingStream::readRawByte() {
-  if (_pos_read==_len) _pos_read=0;
-  _overflow=false;
+  if (_pos_read == _len)
+    _pos_read = 0;
+  _overflow = false;
@@ -144,2 +149,2 @@ int RingStream::count() {
-  return (readRawByte()<<8) | readRawByte(); 
-  }
+  return (readRawByte() << 8) | readRawByte();
+}
@@ -149,2 +154,4 @@ int RingStream::freeSpace() {
-  if (_pos_read>_pos_write) return _pos_read-_pos_write-3;
-  else return _len - _pos_write + _pos_read-3;  
+  if (_pos_read > _pos_write)
+    return _pos_read - _pos_write - 3;
+  else
+    return _len - _pos_write + _pos_read - 3;
@@ -153 +159,0 @@ int RingStream::freeSpace() {
-
@@ -156,7 +162,7 @@ void RingStream::mark(uint8_t b) {
-    //DIAG(F("RS mark client %d at %d core %d"), b, _pos_write, xPortGetCoreID());
-    _ringClient = b;
-    _mark=_pos_write;
-    write(b); // client id
-    write((uint8_t)0);  // count MSB placemarker
-    write((uint8_t)0);  // count LSB placemarker
-    _count=0;
+  // DIAG(F("RS mark client %d at %d core %d"), b, _pos_write, xPortGetCoreID());
+  _ringClient = b;
+  _mark = _pos_write;
+  write(b);           // client id
+  write((uint8_t)0);  // count MSB placemarker
+  write((uint8_t)0);  // count LSB placemarker
+  _count = 0;
@@ -166 +172 @@ void RingStream::mark(uint8_t b) {
-// to send a callback response to some time later. 
+// to send a callback response to some time later.
@@ -172 +178 @@ void RingStream::info() {
-  DIAG(F("Info len=%d count=%d pr=%d pw=%d m=%d"),_len, _count,_pos_read,_pos_write,_mark);
+  DIAG(F("Info len=%d count=%d pr=%d pw=%d m=%d"), _len, _count, _pos_read, _pos_write, _mark);
@@ -176 +182 @@ bool RingStream::commit() {
-  _flashInsert=NULL; // prepared for first read
+  _flashInsert = NULL;  // prepared for first read
@@ -178,5 +184,5 @@ bool RingStream::commit() {
-        //DIAG(F("RingStream(%d) commit(%d) OVERFLOW"),_len, _count);
-        // just throw it away 
-        _pos_write=_mark;
-        _overflow=false;
-        return false; // commit failed
+    // DIAG(F("RingStream(%d) commit(%d) OVERFLOW"),_len, _count);
+    //  just throw it away
+    _pos_write = _mark;
+    _overflow = false;
+    return false;  // commit failed
@@ -184,6 +190,6 @@ bool RingStream::commit() {
-  if (_count==0) {
-    //DIAG(F("RS commit count=0 rewind back to %d core %d"), _mark, xPortGetCoreID());
-    // ignore empty response
-    _pos_write=_mark;
-    _ringClient = NO_CLIENT;         //XXX make else clause later
-    return true; // true=commit ok
+  if (_count == 0) {
+    // DIAG(F("RS commit count=0 rewind back to %d core %d"), _mark, xPortGetCoreID());
+    //  ignore empty response
+    _pos_write = _mark;
+    _ringClient = NO_CLIENT;  // XXX make else clause later
+    return true;              // true=commit ok
@@ -193,2 +199,3 @@ bool RingStream::commit() {
-  if (_mark==_len) _mark=0;
-  _buffer[_mark]=highByte(_count);
+  if (_mark == _len)
+    _mark = 0;
+  _buffer[_mark] = highByte(_count);
@@ -196,2 +203,3 @@ bool RingStream::commit() {
-  if (_mark==_len) _mark=0;
-  _buffer[_mark]=lowByte(_count);
+  if (_mark == _len)
+    _mark = 0;
+  _buffer[_mark] = lowByte(_count);
@@ -199 +207 @@ bool RingStream::commit() {
-  return true; // commit worked
+  return true;  // commit worked
@@ -202,4 +210,4 @@ void RingStream::flush() {
-  _pos_write=0;
-  _pos_read=0;
-  _buffer[0]=0;
-  _flashInsert=NULL; // prepared for first read
+  _pos_write = 0;
+  _pos_read = 0;
+  _buffer[0] = 0;
+  _flashInsert = NULL;  // prepared for first read
@@ -208 +215,0 @@ void RingStream::flush() {
-  
diff --git a/RingStream.h b/RingStream.h
index b477b77..5b7ba66 100644
--- a/RingStream.h
+++ b/RingStream.h
@@ -6 +6 @@
- *  
+ *
@@ -25 +25 @@
-  
+
@@ -26,0 +27,4 @@ class RingStream : public Print {
+ public:
+  RingStream(const uint16_t len);
+  static const int THIS_IS_A_RINGSTREAM = 777;
+  virtual size_t write(uint8_t b);
@@ -28,4 +32,24 @@ class RingStream : public Print {
-  public:
-    RingStream( const uint16_t len);
-    static const int THIS_IS_A_RINGSTREAM=777;
-    virtual size_t write(uint8_t b);
+  // This availableForWrite function is subverted from its original intention so that a caller
+  // can destinguish between a normal stream and a RingStream.
+  // The Arduino compiler does not support runtime dynamic cast to perform
+  // an instranceOf check.
+  // This is necessary since the Print functions are mostly not virtual so
+  // we cant override the print(__FlashStringHelper *) function.
+  virtual int availableForWrite() override;
+  using Print::write;
+  size_t printFlash(const FSH* flashBuffer);
+  int read();
+  int count();
+  int freeSpace();
+  void mark(uint8_t b);
+  bool commit();
+  uint8_t peekTargetMark();
+  void flush();
+  void info();
+  byte readRawByte();
+  inline int peek() {
+    if ((_pos_read == _pos_write) && !_overflow)
+      return -1;  // empty
+    return _buffer[_pos_read];
+  };
+  static const byte NO_CLIENT = 255;
@@ -33,23 +56,0 @@ class RingStream : public Print {
-    // This availableForWrite function is subverted from its original intention so that a caller 
-    // can destinguish between a normal stream and a RingStream. 
-    // The Arduino compiler does not support runtime dynamic cast to perform
-    // an instranceOf check. 
-    // This is necessary since the Print functions are mostly not virtual so 
-    // we cant override the print(__FlashStringHelper *) function.
-   virtual int availableForWrite() override;
-    using Print::write;
-    size_t printFlash(const FSH * flashBuffer);
-    int read();
-    int count();
-    int freeSpace();
-    void mark(uint8_t b);
-    bool commit();
-    uint8_t peekTargetMark();
-    void flush();
-    void info();
-    byte readRawByte();
-    inline int peek() {
-      if ((_pos_read==_pos_write) && !_overflow) return -1;  // empty
-      return _buffer[_pos_read];
-    };
-    static const byte NO_CLIENT=255;
@@ -57,9 +58,9 @@ class RingStream : public Print {
-   int _len;
-   int _pos_write;
-   int _pos_read;
-   bool _overflow;
-   int _mark;
-   int _count;
-   byte * _buffer;
-   char * _flashInsert;
-   byte _ringClient = NO_CLIENT;
+  int _len;
+  int _pos_write;
+  int _pos_read;
+  bool _overflow;
+  int _mark;
+  int _count;
+  byte* _buffer;
+  char* _flashInsert;
+  byte _ringClient = NO_CLIENT;
diff --git a/SSD1306Ascii.cpp b/SSD1306Ascii.cpp
index ea0c76b..74d7360 100644
--- a/SSD1306Ascii.cpp
+++ b/SSD1306Ascii.cpp
@@ -88,4 +88,2 @@ static const uint8_t SH1106_PUMP_OFF = 0x8A;
-const uint8_t FLASH SSD1306AsciiWire::blankPixels[30] = 
-  {0x40,        // First byte specifies data mode
-  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};  
-
+const uint8_t FLASH SSD1306AsciiWire::blankPixels[30] = {0x40,  // First byte specifies data mode
+                                                         0,    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};
@@ -99 +97 @@ const uint8_t FLASH SSD1306AsciiWire::Adafruit128xXXinit[] = {
-    0x00,                              // Set to command mode
+    0x00,  // Set to command mode
@@ -101,12 +99,21 @@ const uint8_t FLASH SSD1306AsciiWire::Adafruit128xXXinit[] = {
-    SSD1306_SETDISPLAYCLOCKDIV, 0x80,  // the suggested ratio 0x80 
-    SSD1306_SETMULTIPLEX, 0x3F,        // ratio 64 (initially)
-    SSD1306_SETDISPLAYOFFSET, 0x0,     // no offset
-    SSD1306_SETSTARTLINE | 0x0,        // line #0
-    SSD1306_CHARGEPUMP, 0x14,          // internal vcc
-    SSD1306_MEMORYMODE, 0x02,          // page mode
-    SSD1306_SEGREMAP | 0x1,            // column 127 mapped to SEG0
-    SSD1306_COMSCANDEC,                // column scan direction reversed
-    SSD1306_SETCOMPINS, 0X12,          // set COM pins
-    SSD1306_SETCONTRAST, 0x7F,         // contrast level 127
-    SSD1306_SETPRECHARGE, 0xF1,        // pre-charge period (1, 15)
-    SSD1306_SETVCOMDETECT, 0x40,       // vcomh regulator level
+    SSD1306_SETDISPLAYCLOCKDIV,
+    0x80,  // the suggested ratio 0x80
+    SSD1306_SETMULTIPLEX,
+    0x3F,  // ratio 64 (initially)
+    SSD1306_SETDISPLAYOFFSET,
+    0x0,                         // no offset
+    SSD1306_SETSTARTLINE | 0x0,  // line #0
+    SSD1306_CHARGEPUMP,
+    0x14,  // internal vcc
+    SSD1306_MEMORYMODE,
+    0x02,                    // page mode
+    SSD1306_SEGREMAP | 0x1,  // column 127 mapped to SEG0
+    SSD1306_COMSCANDEC,      // column scan direction reversed
+    SSD1306_SETCOMPINS,
+    0X12,  // set COM pins
+    SSD1306_SETCONTRAST,
+    0x7F,  // contrast level 127
+    SSD1306_SETPRECHARGE,
+    0xF1,  // pre-charge period (1, 15)
+    SSD1306_SETVCOMDETECT,
+    0x40,  // vcomh regulator level
@@ -115,2 +122 @@ const uint8_t FLASH SSD1306AsciiWire::Adafruit128xXXinit[] = {
-    SSD1306_DISPLAYON
-};
+    SSD1306_DISPLAYON};
@@ -122,19 +128,25 @@ const uint8_t FLASH SSD1306AsciiWire::Adafruit128xXXinit[] = {
-const uint8_t FLASH SSD1306AsciiWire::SH1106_132x64init[] = {
-  0x00,                                  // Set to command mode
-  SSD1306_DISPLAYOFF,
-  SSD1306_SETDISPLAYCLOCKDIV, 0X80,      // set osc division
-  SSD1306_SETMULTIPLEX, 0x3F,            // ratio 64
-  SSD1306_SETDISPLAYOFFSET, 0X00,        // set display offset
-  SSD1306_SETSTARTPAGE | 0X0,            // set page address
-  SSD1306_SETSTARTLINE | 0x0,            // set start line
-  SH1106_SET_PUMP_MODE, SH1106_PUMP_ON,  // set charge pump enable
-  SSD1306_SEGREMAP | 0X1,                // set segment remap
-  SSD1306_COMSCANDEC,                    // Com scan direction
-  SSD1306_SETCOMPINS, 0X12,              // set COM pins
-  SSD1306_SETCONTRAST, 0x80,             // 128
-  SSD1306_SETPRECHARGE, 0X1F,            // set pre-charge period
-  SSD1306_SETVCOMDETECT,  0x40,          // set vcomh
-  SH1106_SET_PUMP_VOLTAGE | 0X2,         // 8.0 volts
-  SSD1306_NORMALDISPLAY,                 // normal / reverse
-  SSD1306_DISPLAYON
-};
+const uint8_t FLASH SSD1306AsciiWire::SH1106_132x64init[] = {0x00,  // Set to command mode
+                                                             SSD1306_DISPLAYOFF,
+                                                             SSD1306_SETDISPLAYCLOCKDIV,
+                                                             0X80,  // set osc division
+                                                             SSD1306_SETMULTIPLEX,
+                                                             0x3F,  // ratio 64
+                                                             SSD1306_SETDISPLAYOFFSET,
+                                                             0X00,                        // set display offset
+                                                             SSD1306_SETSTARTPAGE | 0X0,  // set page address
+                                                             SSD1306_SETSTARTLINE | 0x0,  // set start line
+                                                             SH1106_SET_PUMP_MODE,
+                                                             SH1106_PUMP_ON,          // set charge pump enable
+                                                             SSD1306_SEGREMAP | 0X1,  // set segment remap
+                                                             SSD1306_COMSCANDEC,      // Com scan direction
+                                                             SSD1306_SETCOMPINS,
+                                                             0X12,  // set COM pins
+                                                             SSD1306_SETCONTRAST,
+                                                             0x80,  // 128
+                                                             SSD1306_SETPRECHARGE,
+                                                             0X1F,  // set pre-charge period
+                                                             SSD1306_SETVCOMDETECT,
+                                                             0x40,                           // set vcomh
+                                                             SH1106_SET_PUMP_VOLTAGE | 0X2,  // 8.0 volts
+                                                             SSD1306_NORMALDISPLAY,          // normal / reverse
+                                                             SSD1306_DISPLAYON};
@@ -145 +157 @@ const uint8_t FLASH SSD1306AsciiWire::SH1106_132x64init[] = {
- 
+
@@ -147,2 +159,2 @@ const uint8_t FLASH SSD1306AsciiWire::SH1106_132x64init[] = {
-SSD1306AsciiWire::SSD1306AsciiWire(int width, int height) 
-  : SSD1306AsciiWire(0, width, height) { }
+SSD1306AsciiWire::SSD1306AsciiWire(int width, int height) : SSD1306AsciiWire(0, width, height) {
+}
@@ -157 +169 @@ SSD1306AsciiWire::SSD1306AsciiWire(I2CAddress address, int width, int height) {
-  m_charsPerRow = (m_displayWidth+fontWidth-1) / fontWidth; // Round up
+  m_charsPerRow = (m_displayWidth + fontWidth - 1) / fontWidth;  // Round up
@@ -180 +192 @@ bool SSD1306AsciiWire::begin() {
-  if (m_displayWidth==132 && m_displayHeight==64) {
+  if (m_displayWidth == 132 && m_displayHeight == 64) {
@@ -184 +196 @@ bool SSD1306AsciiWire::begin() {
-  } else if (m_displayWidth==128 && (m_displayHeight==64 || m_displayHeight==32)) {
+  } else if (m_displayWidth == 128 && (m_displayHeight == 64 || m_displayHeight == 32)) {
@@ -187,4 +199,4 @@ bool SSD1306AsciiWire::begin() {
-    if (m_displayHeight == 32) 
-      I2CManager.write(m_i2cAddr, 5, 0, // Set command mode
-        SSD1306_SETMULTIPLEX, 0x1F,     // ratio 32
-        SSD1306_SETCOMPINS, 0x02);      // sequential COM pins, disable remap
+    if (m_displayHeight == 32)
+      I2CManager.write(m_i2cAddr, 5, 0,             // Set command mode
+                       SSD1306_SETMULTIPLEX, 0x1F,  // ratio 32
+                       SSD1306_SETCOMPINS, 0x02);   // sequential COM pins, disable remap
@@ -203,2 +215,2 @@ void SSD1306AsciiWire::clearNative() {
-  for (uint8_t r = 0; r <= m_displayHeight/8 - 1; r++) {
-    setRowNative(r);   // Position at start of row to be erased
+  for (uint8_t r = 0; r <= m_displayHeight / 8 - 1; r++) {
+    setRowNative(r);  // Position at start of row to be erased
@@ -206,3 +218,4 @@ void SSD1306AsciiWire::clearNative() {
-      uint8_t len = m_displayWidth-c;  // Number of pixel columns remaining
-      if (len > maxBytes) len = maxBytes;
-      I2CManager.write_P(m_i2cAddr, blankPixels, len+1);  // Write command + 'len' blank columns
+      uint8_t len = m_displayWidth - c;  // Number of pixel columns remaining
+      if (len > maxBytes)
+        len = maxBytes;
+      I2CManager.write_P(m_i2cAddr, blankPixels, len + 1);  // Write command + 'len' blank columns
@@ -218 +231 @@ void SSD1306AsciiWire::setRowNative(uint8_t line) {
-  uint8_t row = line*8;
+  uint8_t row = line * 8;
@@ -229 +242 @@ void SSD1306AsciiWire::setRowNative(uint8_t line) {
-    outputBuffer[len++] = SSD1306_SETSTARTPAGE | (m_row/8);
+    outputBuffer[len++] = SSD1306_SETSTARTPAGE | (m_row / 8);
@@ -245 +258 @@ size_t SSD1306AsciiWire::writeNative(uint8_t ch) {
-      ch -= 26; // Allow for missing lowercase letters
+      ch -= 26;  // Allow for missing lowercase letters
@@ -259 +272 @@ size_t SSD1306AsciiWire::writeNative(uint8_t ch) {
-  outputBuffer[0] = 0x40;     // set SSD1306 controller to data mode
+  outputBuffer[0] = 0x40;  // set SSD1306 controller to data mode
@@ -263 +276 @@ size_t SSD1306AsciiWire::writeNative(uint8_t ch) {
-    if (m_col++ < m_displayWidth) 
+    if (m_col++ < m_displayWidth)
@@ -272 +284,0 @@ size_t SSD1306AsciiWire::writeNative(uint8_t ch) {
-
@@ -381,2 +393,2 @@ const uint8_t FLASH SSD1306AsciiWire::System6x8[] = {
-// Extended characters - based on "DOS Western Europe" characters
-//   International characters not yet implemented.
+    // Extended characters - based on "DOS Western Europe" characters
+    //   International characters not yet implemented.
@@ -493 +505 @@ const uint8_t FLASH SSD1306AsciiWire::System6x8[] = {
-    0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00,  // Top left block 
+    0x0f, 0x0f, 0x0f, 0x00, 0x00, 0x00,  // Top left block
@@ -515 +527 @@ const uint8_t FLASH SSD1306AsciiWire::System6x8[] = {
-    0x00, 0x06, 0x09, 0x09, 0x06, 0x00   // degree symbol 0xf8
+    0x00, 0x06, 0x09, 0x09, 0x06, 0x00  // degree symbol 0xf8
diff --git a/SSD1306Ascii.h b/SSD1306Ascii.h
index 57427a1..3b3c427 100644
--- a/SSD1306Ascii.h
+++ b/SSD1306Ascii.h
@@ -33,3 +33 @@
-//#define NOLOWERCASE
-
-
+// #define NOLOWERCASE
@@ -41 +38,0 @@ class SSD1306AsciiWire : public DisplayDevice {
-
@@ -43,2 +40,2 @@ class SSD1306AsciiWire : public DisplayDevice {
-  SSD1306AsciiWire(int width, int height); // Auto-detects I2C address
-  SSD1306AsciiWire(I2CAddress address, int width, int height);  
+  SSD1306AsciiWire(int width, int height);  // Auto-detects I2C address
+  SSD1306AsciiWire(I2CAddress address, int width, int height);
@@ -54 +51 @@ class SSD1306AsciiWire : public DisplayDevice {
-  
+
@@ -58,3 +55,9 @@ class SSD1306AsciiWire : public DisplayDevice {
-  bool isBusy() override { return requestBlock.isBusy(); }
-  uint16_t getNumCols() { return m_charsPerRow; }
-  uint16_t getNumRows() { return m_charsPerColumn; }
+  bool isBusy() override {
+    return requestBlock.isBusy();
+  }
+  uint16_t getNumCols() {
+    return m_charsPerRow;
+  }
+  uint16_t getNumRows() {
+    return m_charsPerColumn;
+  }
@@ -91 +94 @@ class SSD1306AsciiWire : public DisplayDevice {
-  uint8_t outputBuffer[fontWidth+1];
+  uint8_t outputBuffer[fontWidth + 1];
diff --git a/Sensors.cpp b/Sensors.cpp
index efd969d..6a9e035 100644
--- a/Sensors.cpp
+++ b/Sensors.cpp
@@ -6 +6 @@
- *  
+ *
@@ -79 +78,0 @@ decide to ignore the <q ID> return and only react to <Q ID> triggers.
-
@@ -93 +92 @@ decide to ignore the <q ID> return and only react to <Q ID> triggers.
-void Sensor::checkAll(){
+void Sensor::checkAll() {
@@ -103,2 +102,3 @@ void Sensor::checkAll(){
-  if (firstSensor == NULL) return;  // No sensors to be scanned
-  if (readingSensor == NULL) { 
+  if (firstSensor == NULL)
+    return;  // No sensors to be scanned
+  if (readingSensor == NULL) {
@@ -118 +117,0 @@ void Sensor::checkAll(){
-
@@ -132 +131 @@ void Sensor::checkAll(){
-      readingSensor->latchDelay = minReadCount; // Reset counter
+      readingSensor->latchDelay = minReadCount;  // Reset counter
@@ -136 +135 @@ void Sensor::checkAll(){
-    } else { 
+    } else {
@@ -140,2 +139,2 @@ void Sensor::checkAll(){
-      
-      CommandDistributor::broadcastSensor(readingSensor->data.snum,readingSensor->active);
+
+      CommandDistributor::broadcastSensor(readingSensor->data.snum, readingSensor->active);
@@ -153 +152,2 @@ void Sensor::checkAll(){
-    if (sensorCount >= 16) pause = true;
+    if (sensorCount >= 16)
+      pause = true;
@@ -156,2 +156 @@ void Sensor::checkAll(){
-} // Sensor::checkAll
-
+}  // Sensor::checkAll
@@ -161 +160 @@ void Sensor::checkAll(){
-// Updates the inputState field, which is subsequently scanned for changes in the checkAll 
+// Updates the inputState field, which is subsequently scanned for changes in the checkAll
@@ -165 +164 @@ void Sensor::inputChangeCallback(VPIN vpin, int state) {
-  Sensor *tt;
+  Sensor* tt;
@@ -168,2 +167,3 @@ void Sensor::inputChangeCallback(VPIN vpin, int state) {
-  for (tt=firstSensor; tt!=NULL ; tt=tt->nextSensor) {
-    if (tt->data.pin == vpin) break;
+  for (tt = firstSensor; tt != NULL; tt = tt->nextSensor) {
+    if (tt->data.pin == vpin)
+      break;
@@ -171,2 +171,2 @@ void Sensor::inputChangeCallback(VPIN vpin, int state) {
-  if (tt != NULL) { // Sensor found
-    tt->inputState = (state != 0); 
+  if (tt != NULL) {  // Sensor found
+    tt->inputState = (state != 0);
@@ -183,2 +183 @@ void Sensor::inputChangeCallback(VPIN vpin, int state) {
-void Sensor::printAll(Print *stream){
-
+void Sensor::printAll(Print* stream) {
@@ -186 +185 @@ void Sensor::printAll(Print *stream){
-    for(Sensor * tt=firstSensor;tt!=NULL;tt=tt->nextSensor){
+    for (Sensor* tt = firstSensor; tt != NULL; tt = tt->nextSensor) {
@@ -189,2 +188,2 @@ void Sensor::printAll(Print *stream){
-  } // loop over all sensors
-} // Sensor::printAll
+  }  // loop over all sensors
+}  // Sensor::printAll
@@ -195,2 +194,2 @@ void Sensor::printAll(Print *stream){
-Sensor *Sensor::create(int snum, VPIN pin, int pullUp){
-  Sensor *tt;
+Sensor* Sensor::create(int snum, VPIN pin, int pullUp) {
+  Sensor* tt;
@@ -198 +197,2 @@ Sensor *Sensor::create(int snum, VPIN pin, int pullUp){
-  if (pin > VPIN_MAX && pin != VPIN_NONE) return NULL;
+  if (pin > VPIN_MAX && pin != VPIN_NONE)
+    return NULL;
@@ -202,2 +202,3 @@ Sensor *Sensor::create(int snum, VPIN pin, int pullUp){
-  tt = (Sensor *)calloc(1,sizeof(Sensor));
-  if (!tt) return tt;     // memory allocation failure
+  tt = (Sensor*)calloc(1, sizeof(Sensor));
+  if (!tt)
+    return tt;  // memory allocation failure
@@ -205 +206 @@ Sensor *Sensor::create(int snum, VPIN pin, int pullUp){
-  if (pin == VPIN_NONE) 
+  if (pin == VPIN_NONE)
@@ -207,2 +208,2 @@ Sensor *Sensor::create(int snum, VPIN pin, int pullUp){
-  #ifdef USE_NOTIFY
-  else if (IODevice::hasCallback(pin)) 
+#ifdef USE_NOTIFY
+  else if (IODevice::hasCallback(pin))
@@ -210,2 +211,2 @@ Sensor *Sensor::create(int snum, VPIN pin, int pullUp){
-  #endif
-  else 
+#endif
+  else
@@ -225,4 +226,4 @@ Sensor *Sensor::create(int snum, VPIN pin, int pullUp){
-  if (pin != VPIN_NONE) 
-    IODevice::configureInput(pin, pullUp);   
-    // Generally, internal pull-up resistors are not, on their own, sufficient 
-    // for external infrared sensors --- each sensor must have its own 1K external pull-up resistor
+  if (pin != VPIN_NONE)
+    IODevice::configureInput(pin, pullUp);
+  // Generally, internal pull-up resistors are not, on their own, sufficient
+  // for external infrared sensors --- each sensor must have its own 1K external pull-up resistor
@@ -233 +234 @@ Sensor *Sensor::create(int snum, VPIN pin, int pullUp){
-// Creet multiple eponymous sensors based on vpin alone. 
+// Creet multiple eponymous sensors based on vpin alone.
@@ -235,2 +236,2 @@ void Sensor::createMultiple(VPIN firstPin, byte count) {
-  for (byte i=0;i<count;i++) {
-    create(firstPin+i,firstPin+i,1); 
+  for (byte i = 0; i < count; i++) {
+    create(firstPin + i, firstPin + i, 1);
@@ -247 +248 @@ void Sensor::setState(int value) {
-  latchDelay = 0; // Don't wait for anti-jitter logic
+  latchDelay = 0;  // Don't wait for anti-jitter logic
@@ -252,4 +253,4 @@ void Sensor::setState(int value) {
-Sensor* Sensor::get(int n){
-  Sensor *tt;
-  for(tt=firstSensor;tt!=NULL && tt->data.snum!=n;tt=tt->nextSensor);
-  return tt ;
+Sensor* Sensor::get(int n) {
+  Sensor* tt;
+  for (tt = firstSensor; tt != NULL && tt->data.snum != n; tt = tt->nextSensor);
+  return tt;
@@ -259,2 +260,2 @@ Sensor* Sensor::get(int n){
-bool Sensor::remove(int n){
-  Sensor *tt,*pp=NULL;
+bool Sensor::remove(int n) {
+  Sensor *tt, *pp = NULL;
@@ -262 +263 @@ bool Sensor::remove(int n){
-  for(tt=firstSensor;tt!=NULL && tt->data.snum!=n;pp=tt,tt=tt->nextSensor);
+  for (tt = firstSensor; tt != NULL && tt->data.snum != n; pp = tt, tt = tt->nextSensor);
@@ -264 +265,2 @@ bool Sensor::remove(int n){
-  if (tt==NULL)  return false;
+  if (tt == NULL)
+    return false;
@@ -267,4 +269,4 @@ bool Sensor::remove(int n){
-  if(tt==firstSensor) 
-    firstSensor=tt->nextSensor;
-  else 
-    pp->nextSensor=tt->nextSensor;
+  if (tt == firstSensor)
+    firstSensor = tt->nextSensor;
+  else
+    pp->nextSensor = tt->nextSensor;
@@ -272 +274 @@ bool Sensor::remove(int n){
-  if (tt==lastSensor)
+  if (tt == lastSensor)
@@ -274 +276 @@ bool Sensor::remove(int n){
-  if (tt==firstPollSensor)
+  if (tt == firstPollSensor)
@@ -278 +280 @@ bool Sensor::remove(int n){
-  // Check if the sensor being deleted is the next one to be read.  If so, 
+  // Check if the sensor being deleted is the next one to be read.  If so,
@@ -280 +282,2 @@ bool Sensor::remove(int n){
-  if (readingSensor==tt) readingSensor=tt->nextSensor;
+  if (readingSensor == tt)
+    readingSensor = tt->nextSensor;
@@ -289 +292 @@ bool Sensor::remove(int n){
-void Sensor::load(){
+void Sensor::load() {
@@ -291 +294 @@ void Sensor::load(){
-  Sensor *tt;
+  Sensor* tt;
@@ -293,4 +296,4 @@ void Sensor::load(){
-  uint16_t i=EEStore::eeStore->data.nSensors;
-  while(i--){
-    EEPROM.get(EEStore::pointer(),data);
-    tt=create(data.snum, data.pin, data.pullUp);
+  uint16_t i = EEStore::eeStore->data.nSensors;
+  while (i--) {
+    EEPROM.get(EEStore::pointer(), data);
+    tt = create(data.snum, data.pin, data.pullUp);
@@ -303,2 +306,2 @@ void Sensor::load(){
-void Sensor::store(){
-  Sensor *tt;
+void Sensor::store() {
+  Sensor* tt;
@@ -306,2 +309,2 @@ void Sensor::store(){
-  tt=firstSensor;
-  EEStore::eeStore->data.nSensors=0;
+  tt = firstSensor;
+  EEStore::eeStore->data.nSensors = 0;
@@ -309,2 +312,2 @@ void Sensor::store(){
-  while(tt!=NULL){
-    EEPROM.put(EEStore::pointer(),tt->data);
+  while (tt != NULL) {
+    EEPROM.put(EEStore::pointer(), tt->data);
@@ -312 +315 @@ void Sensor::store(){
-    tt=tt->nextSensor;
+    tt = tt->nextSensor;
@@ -319,3 +322,3 @@ void Sensor::store(){
-Sensor *Sensor::firstSensor=NULL;
-Sensor *Sensor::readingSensor=NULL;
-unsigned long Sensor::lastReadCycle=0;
+Sensor* Sensor::firstSensor = NULL;
+Sensor* Sensor::readingSensor = NULL;
+unsigned long Sensor::lastReadCycle = 0;
@@ -324,2 +327,2 @@ unsigned long Sensor::lastReadCycle=0;
-Sensor *Sensor::firstPollSensor = NULL;
-Sensor *Sensor::lastSensor = NULL;
+Sensor* Sensor::firstPollSensor = NULL;
+Sensor* Sensor::lastSensor = NULL;
diff --git a/Sensors.h b/Sensors.h
index f0eded5..33f6268 100644
--- a/Sensors.h
+++ b/Sensors.h
@@ -6 +6 @@
- *  
+ *
@@ -31 +31 @@
-//  having to poll the device driver cyclically for input values, and then scan 
+//  having to poll the device driver cyclically for input values, and then scan
@@ -34,2 +34,2 @@
-//  implementation, the advantages are limited because (a) the Sensor class 
-//  performs debounce checks, and (b) the Sensor class does not have a 
+//  implementation, the advantages are limited because (a) the Sensor class
+//  performs debounce checks, and (b) the Sensor class does not have a
@@ -37,2 +37,2 @@
-//  when a change is detected.  These restrictions mean that the checkAll() 
-//  method still has to iterate through all of the Sensor objects looking 
+//  when a change is detected.  These restrictions mean that the checkAll()
+//  method still has to iterate through all of the Sensor objects looking
@@ -48 +48 @@ struct SensorData {
-class Sensor{
+class Sensor {
@@ -52 +52 @@ class Sensor{
-public:
+ public:
@@ -55,4 +55,4 @@ public:
-    uint8_t active:1;
-    uint8_t inputState:1;
-    uint8_t latchDelay:6;
-  };   // bit 7=active; bit 6=input state; bits 5-0=latchDelay
+    uint8_t active : 1;
+    uint8_t inputState : 1;
+    uint8_t latchDelay : 6;
+  };  // bit 7=active; bit 6=input state; bits 5-0=latchDelay
@@ -60 +60 @@ public:
-  static Sensor *firstSensor;
+  static Sensor* firstSensor;
@@ -62,2 +62,2 @@ public:
-  static Sensor *firstPollSensor;
-  static Sensor *lastSensor;
+  static Sensor* firstPollSensor;
+  static Sensor* lastSensor;
@@ -67 +67 @@ public:
-  static Sensor *readingSensor;
+  static Sensor* readingSensor;
@@ -70,2 +70,2 @@ public:
-  Sensor(); 
-  Sensor *nextSensor;
+  Sensor();
+  Sensor* nextSensor;
@@ -78,4 +78,4 @@ public:
-  static Sensor *create(int id, VPIN vpin, int pullUp);
-  static void createMultiple(VPIN firstPin, byte count=1);
-  static Sensor* get(int id);  
-  static bool remove(int id);  
+  static Sensor* create(int id, VPIN vpin, int pullUp);
+  static void createMultiple(VPIN firstPin, byte count = 1);
+  static Sensor* get(int id);
+  static bool remove(int id);
@@ -83,7 +83,7 @@ public:
-  static void printAll(Print *stream);
-  static unsigned long lastReadCycle; // value of micros at start of last read cycle
-  static const unsigned int cycleInterval = 10000; // min time between consecutive reads of each sensor in microsecs.
-                                                   // should not be less than device scan cycle time.
-  static const unsigned int minReadCount = 1; // number of additional scans before acting on change
-                                        // E.g. 1 means that a change is ignored for one scan and actioned on the next.
-                                        // Max value is 63
+  static void printAll(Print* stream);
+  static unsigned long lastReadCycle;               // value of micros at start of last read cycle
+  static const unsigned int cycleInterval = 10000;  // min time between consecutive reads of each sensor in microsecs.
+                                                    // should not be less than device scan cycle time.
+  static const unsigned int minReadCount = 1;       // number of additional scans before acting on change
+                                                    // E.g. 1 means that a change is ignored for one scan and actioned on the next.
+                                                    // Max value is 63
@@ -96,2 +96,2 @@ public:
-  
-}; // Sensor
+
+};  // Sensor
diff --git a/SerialManager.cpp b/SerialManager.cpp
index aac777e..b93bc6e 100644
--- a/SerialManager.cpp
+++ b/SerialManager.cpp
@@ -1 +1 @@
- /*
+/*
@@ -6 +6 @@
- *  
+ *
@@ -31 +31 @@
-//#include <BleSerial.h>
+// #include <BleSerial.h>
@@ -34 +34 @@
-#endif //ENABLED
+#endif  // ENABLED
@@ -36,3 +36,3 @@ BluetoothSerial SerialBT;
-//BleSerial SerialBT;
-#endif //COMMANDS
-#endif //ESP32
+// BleSerial SerialBT;
+#endif  // COMMANDS
+#endif  // ESP32
@@ -44 +44 @@ static const byte PAYLOAD_STRING = 2;
-SerialManager * SerialManager::first=NULL;
+SerialManager* SerialManager::first = NULL;
@@ -46,7 +46,7 @@ SerialManager * SerialManager::first=NULL;
-SerialManager::SerialManager(Stream * myserial) {
-  serial=myserial;
-  next=first;
-  first=this;
-  bufferLength=0;
-  inCommandPayload=PAYLOAD_FALSE; 
-} 
+SerialManager::SerialManager(Stream* myserial) {
+  serial = myserial;
+  next = first;
+  first = this;
+  bufferLength = 0;
+  inCommandPayload = PAYLOAD_FALSE;
+}
@@ -56 +56 @@ void SerialManager::init() {
-  while (!USB_SERIAL && millis() < 5000); // wait max 5s for Serial to start
+  while (!USB_SERIAL && millis() < 5000);  // wait max 5s for Serial to start
@@ -58 +58 @@ void SerialManager::init() {
-  
+
@@ -77,2 +77,2 @@ void SerialManager::init() {
-  Serial2.begin(115200, SERIAL_8N1, 16, 17); // GPIO 16 RXD2; GPIO 17 TXD2 on ESP32
-#else  // not ESP32
+  Serial2.begin(115200, SERIAL_8N1, 16, 17);  // GPIO 16 RXD2; GPIO 17 TXD2 on ESP32
+#else                                         // not ESP32
@@ -80 +80 @@ void SerialManager::init() {
-#endif // ESP32
+#endif                                        // ESP32
@@ -89 +89 @@ void SerialManager::init() {
-    //SerialBT.setPin("6666"); // choose other pin
+    // SerialBT.setPin("6666"); // choose other pin
@@ -92,2 +92 @@ void SerialManager::init() {
-    snprintf(idstr, 15, "DCCEX-%08X",
-	     __builtin_bswap32((uint32_t)(chipid>>16)));
+    snprintf(idstr, 15, "DCCEX-%08X", __builtin_bswap32((uint32_t)(chipid >> 16)));
@@ -101 +100 @@ void SerialManager::init() {
-  Serial2.begin(9600, SERIAL_8N1, 16, 17); // GPIO 16 RXD2; GPIO 17 TXD2 on ESP32
+  Serial2.begin(9600, SERIAL_8N1, 16, 17);  // GPIO 16 RXD2; GPIO 17 TXD2 on ESP32
@@ -108,2 +107,2 @@ void SerialManager::init() {
-void SerialManager::broadcast(char * stringBuffer) {
-    for (SerialManager * s=first;s;s=s->next) s->broadcast2(stringBuffer);
+void SerialManager::broadcast(char* stringBuffer) {
+  for (SerialManager* s = first; s; s = s->next) s->broadcast2(stringBuffer);
@@ -111,2 +110,2 @@ void SerialManager::broadcast(char * stringBuffer) {
-void SerialManager::broadcast2(char * stringBuffer) {
-    serial->print(stringBuffer);
+void SerialManager::broadcast2(char* stringBuffer) {
+  serial->print(stringBuffer);
@@ -116 +115 @@ void SerialManager::loop() {
-    for (SerialManager * s=first;s;s=s->next) s->loop2();
+  for (SerialManager* s = first; s; s = s->next) s->loop2();
@@ -128,25 +127,25 @@ void SerialManager::loop2() {
-    } else { // if (inCommandPayload)
-      if (bufferLength <  (COMMAND_BUFFER_SIZE-1)) {
-        buffer[bufferLength++] = ch;          // advance bufferLength
-	if (inCommandPayload > PAYLOAD_NORMAL) {
-	  if (inCommandPayload > 32 + 2) {    // String way too long
-	    ch = '>';                         // we end this nonsense
-	    inCommandPayload = PAYLOAD_NORMAL;
-	    DIAG(F("Parse error: Unbalanced string"));
-	    // fall through to ending parsing below
-	  } else if (ch == '"') {               // String end
-	    inCommandPayload = PAYLOAD_NORMAL;
-	    continue; // do not fall through
-	  } else
-	    inCommandPayload++;
-	}
-	if (inCommandPayload == PAYLOAD_NORMAL) {
-	  if (ch == '>') {
-	    buffer[bufferLength] = '\0';               // This \0 is after the '>'
-	    DCCEXParser::parse(serial, buffer, NULL);  // buffer parsed with trailing '>'
-	    inCommandPayload = PAYLOAD_FALSE;
-	    break;
-	  } else if (ch == '"') {
-	    inCommandPayload = PAYLOAD_STRING;
-	  }
-	}
+    } else {  // if (inCommandPayload)
+      if (bufferLength < (COMMAND_BUFFER_SIZE - 1)) {
+        buffer[bufferLength++] = ch;  // advance bufferLength
+        if (inCommandPayload > PAYLOAD_NORMAL) {
+          if (inCommandPayload > 32 + 2) {  // String way too long
+            ch = '>';                       // we end this nonsense
+            inCommandPayload = PAYLOAD_NORMAL;
+            DIAG(F("Parse error: Unbalanced string"));
+            // fall through to ending parsing below
+          } else if (ch == '"') {  // String end
+            inCommandPayload = PAYLOAD_NORMAL;
+            continue;  // do not fall through
+          } else
+            inCommandPayload++;
+        }
+        if (inCommandPayload == PAYLOAD_NORMAL) {
+          if (ch == '>') {
+            buffer[bufferLength] = '\0';               // This \0 is after the '>'
+            DCCEXParser::parse(serial, buffer, NULL);  // buffer parsed with trailing '>'
+            inCommandPayload = PAYLOAD_FALSE;
+            break;
+          } else if (ch == '"') {
+            inCommandPayload = PAYLOAD_STRING;
+          }
+        }
@@ -154,2 +153,2 @@ void SerialManager::loop2() {
-	DIAG(F("Parse error: input buffer overflow"));
-	inCommandPayload = PAYLOAD_FALSE;
+        DIAG(F("Parse error: input buffer overflow"));
+        inCommandPayload = PAYLOAD_FALSE;
diff --git a/SerialManager.h b/SerialManager.h
index 5277e68..537d322 100644
--- a/SerialManager.h
+++ b/SerialManager.h
@@ -1 +1 @@
- /*
+/*
@@ -4 +4 @@
- *  
+ *
@@ -27 +26,0 @@
-
@@ -29 +28 @@
- #define COMMAND_BUFFER_SIZE 100
+#define COMMAND_BUFFER_SIZE 100
@@ -33 +32 @@ class SerialManager {
-public:
+ public:
@@ -36,5 +35,5 @@ public:
-  static void broadcast(char * stringBuffer);
-  
-private:  
-  static SerialManager * first;
-  SerialManager(Stream * myserial);
+  static void broadcast(char* stringBuffer);
+
+ private:
+  static SerialManager* first;
+  SerialManager(Stream* myserial);
@@ -42,3 +41,3 @@ private:
-  void broadcast2(char * stringBuffer);
-  Stream * serial;
-  SerialManager * next;
+  void broadcast2(char* stringBuffer);
+  Stream* serial;
+  SerialManager* next;
@@ -46 +45 @@ private:
-  byte buffer[COMMAND_BUFFER_SIZE]; 
+  byte buffer[COMMAND_BUFFER_SIZE];
diff --git a/StringBuffer.cpp b/StringBuffer.cpp
index 014bf87..87839b5 100644
--- a/StringBuffer.cpp
+++ b/StringBuffer.cpp
@@ -4 +4 @@
- *  
+ *
@@ -25 +25 @@ StringBuffer::StringBuffer() {
-    flush();
+  flush();
@@ -28,2 +28,2 @@ StringBuffer::StringBuffer() {
-char * StringBuffer::getString() { 
-   return _buffer;
+char* StringBuffer::getString() {
+  return _buffer;
@@ -33,2 +33,2 @@ void StringBuffer::flush() {
-    _pos_write=0;
-    _buffer[0]='\0';
+  _pos_write = 0;
+  _buffer[0] = '\0';
@@ -38 +38,2 @@ size_t StringBuffer::write(uint8_t b) {
-  if (_pos_write>=buffer_max) return 0;
+  if (_pos_write >= buffer_max)
+    return 0;
@@ -41 +42 @@ size_t StringBuffer::write(uint8_t b) {
-  _buffer[_pos_write]='\0';
+  _buffer[_pos_write] = '\0';
diff --git a/StringBuffer.h b/StringBuffer.h
index 8bf3458..8398dca 100644
--- a/StringBuffer.h
+++ b/StringBuffer.h
@@ -1 +1 @@
- /*
+/*
@@ -4 +4 @@
- *  
+ *
@@ -26,10 +26,11 @@ class StringBuffer : public Print {
-  public:
-    StringBuffer(); 
-    // Override Print default
-    virtual size_t write(uint8_t b);
-    void flush();
-    char * getString();
-  private:
-    static const int  buffer_max=64; // enough for long text msgs to throttles  
-    int16_t _pos_write;
-    char _buffer[buffer_max+2];
+ public:
+  StringBuffer();
+  // Override Print default
+  virtual size_t write(uint8_t b);
+  void flush();
+  char* getString();
+
+ private:
+  static const int buffer_max = 64;  // enough for long text msgs to throttles
+  int16_t _pos_write;
+  char _buffer[buffer_max + 2];
diff --git a/StringFormatter.cpp b/StringFormatter.cpp
index 192e1cc..6fb5531 100644
--- a/StringFormatter.cpp
+++ b/StringFormatter.cpp
@@ -3 +3 @@
- *  
+ *
@@ -24,6 +24,6 @@
-bool Diag::ACK=false;
-bool Diag::CMD=false;
-bool Diag::WIFI=false;
-bool Diag::WITHROTTLE=false;
-bool Diag::ETHERNET=false;
-bool Diag::LCN=false;
+bool Diag::ACK = false;
+bool Diag::CMD = false;
+bool Diag::WIFI = false;
+bool Diag::WITHROTTLE = false;
+bool Diag::ETHERNET = false;
+bool Diag::LCN = false;
@@ -31,3 +31,2 @@ bool Diag::LCN=false;
- 
-void StringFormatter::diag( const FSH* input...) {
- USB_SERIAL.print(F("<* "));   
+void StringFormatter::diag(const FSH* input...) {
+  USB_SERIAL.print(F("<* "));
@@ -36 +35 @@ void StringFormatter::diag( const FSH* input...) {
-  send2(&USB_SERIAL,input,args);
+  send2(&USB_SERIAL, input, args);
@@ -43 +42 @@ void StringFormatter::lcd(byte row, const FSH* input...) {
-  Print * virtualLCD=CommandDistributor::getVirtualLCDSerial(0,row);
+  Print* virtualLCD = CommandDistributor::getVirtualLCDSerial(0, row);
@@ -45 +44 @@ void StringFormatter::lcd(byte row, const FSH* input...) {
-  Print * virtualLCD=NULL;
+  Print* virtualLCD = NULL;
@@ -49,2 +48,2 @@ void StringFormatter::lcd(byte row, const FSH* input...) {
-  if (virtualLCD!=&USB_SERIAL) {
-    send(&USB_SERIAL,F("<* LCD%d:"),row);
+  if (virtualLCD != &USB_SERIAL) {
+    send(&USB_SERIAL, F("<* LCD%d:"), row);
@@ -52,2 +51,2 @@ void StringFormatter::lcd(byte row, const FSH* input...) {
-    send2(&USB_SERIAL,input,args);
-    send(&USB_SERIAL,F(" *>\n"));
+    send2(&USB_SERIAL, input, args);
+    send(&USB_SERIAL, F(" *>\n"));
@@ -55 +54 @@ void StringFormatter::lcd(byte row, const FSH* input...) {
-  
+
@@ -57 +56 @@ void StringFormatter::lcd(byte row, const FSH* input...) {
-  // send to virtual LCD collector (if any) 
+  // send to virtual LCD collector (if any)
@@ -60 +59 @@ void StringFormatter::lcd(byte row, const FSH* input...) {
-    send2(virtualLCD,input,args);
+    send2(virtualLCD, input, args);
@@ -64 +63 @@ void StringFormatter::lcd(byte row, const FSH* input...) {
-  DisplayInterface::setRow(row);    
+  DisplayInterface::setRow(row);
@@ -66 +65 @@ void StringFormatter::lcd(byte row, const FSH* input...) {
-  send2(DisplayInterface::getDisplayHandler(),input,args);
+  send2(DisplayInterface::getDisplayHandler(), input, args);
@@ -71,2 +70,2 @@ void StringFormatter::lcd2(uint8_t display, byte row, const FSH* input...) {
-  
-   // send to virtual LCD collector (if any) 
+
+  // send to virtual LCD collector (if any)
@@ -74 +73 @@ void StringFormatter::lcd2(uint8_t display, byte row, const FSH* input...) {
-  Print * virtualLCD=CommandDistributor::getVirtualLCDSerial(display,row);
+  Print* virtualLCD = CommandDistributor::getVirtualLCDSerial(display, row);
@@ -77 +76 @@ void StringFormatter::lcd2(uint8_t display, byte row, const FSH* input...) {
-    send2(virtualLCD,input,args);
+    send2(virtualLCD, input, args);
@@ -82 +81 @@ void StringFormatter::lcd2(uint8_t display, byte row, const FSH* input...) {
-  DisplayInterface::setRow(display, row);    
+  DisplayInterface::setRow(display, row);
@@ -84 +83 @@ void StringFormatter::lcd2(uint8_t display, byte row, const FSH* input...) {
-  send2(DisplayInterface::getDisplayHandler(),input,args);
+  send2(DisplayInterface::getDisplayHandler(), input, args);
@@ -87 +86 @@ void StringFormatter::lcd2(uint8_t display, byte row, const FSH* input...) {
-void StringFormatter::send(Print * stream, const FSH* input...) {
+void StringFormatter::send(Print* stream, const FSH* input...) {
@@ -90 +89 @@ void StringFormatter::send(Print * stream, const FSH* input...) {
-  send2(stream,input,args);
+  send2(stream, input, args);
@@ -93 +92 @@ void StringFormatter::send(Print * stream, const FSH* input...) {
-void StringFormatter::send(Print & stream, const FSH* input...) {
+void StringFormatter::send(Print& stream, const FSH* input...) {
@@ -96 +95 @@ void StringFormatter::send(Print & stream, const FSH* input...) {
-  send2(&stream,input,args);
+  send2(&stream, input, args);
@@ -99,2 +98 @@ void StringFormatter::send(Print & stream, const FSH* input...) {
-void StringFormatter::send2(Print * stream,const FSH* format, va_list args) {
-    
+void StringFormatter::send2(Print* stream, const FSH* format, va_list args) {
@@ -103,5 +101,9 @@ void StringFormatter::send2(Print * stream,const FSH* format, va_list args) {
-  char* flash=(char*)format;
-  for(int i=0; ; ++i) {
-    char c=GETFLASH(flash+i);
-    if (c=='\0') break; // to va_end()
-    if(c!='%') { stream->print(c); continue; }
+  char* flash = (char*)format;
+  for (int i = 0;; ++i) {
+    char c = GETFLASH(flash + i);
+    if (c == '\0')
+      break;  // to va_end()
+    if (c != '%') {
+      stream->print(c);
+      continue;
+    }
@@ -109,17 +111,25 @@ void StringFormatter::send2(Print * stream,const FSH* format, va_list args) {
-    bool formatContinues=false;
-    byte formatWidth=0;
-    bool formatLeft=false; 
-  do {
-    
-    formatContinues=false;
-    i++;
-    c=GETFLASH(flash+i);
-    switch(c) {
-      case '%': stream->print('%'); break;
-      case 'c': stream->print((char) va_arg(args, int)); break;
-      case 's': stream->print(va_arg(args, char*)); break;
-      case 'e': printEscapes(stream,va_arg(args, char*)); break;
-      case 'E': printEscapes(stream,(const FSH*)va_arg(args, char*)); break;
-      case 'S':
-      { 
-        const FSH*  flash= (const FSH*)va_arg(args, char*);
+    bool formatContinues = false;
+    byte formatWidth = 0;
+    bool formatLeft = false;
+    do {
+      formatContinues = false;
+      i++;
+      c = GETFLASH(flash + i);
+      switch (c) {
+        case '%':
+          stream->print('%');
+          break;
+        case 'c':
+          stream->print((char)va_arg(args, int));
+          break;
+        case 's':
+          stream->print(va_arg(args, char*));
+          break;
+        case 'e':
+          printEscapes(stream, va_arg(args, char*));
+          break;
+        case 'E':
+          printEscapes(stream, (const FSH*)va_arg(args, char*));
+          break;
+        case 'S': {
+          const FSH* flash = (const FSH*)va_arg(args, char*);
@@ -128,6 +138,6 @@ void StringFormatter::send2(Print * stream,const FSH* format, va_list args) {
-        // RingStream has special logic to handle flash strings
-        // but is not implemented unless wifi or ethernet are enabled.
-        // The define prevents RingStream code being added unnecessariliy.        
-        if (stream->availableForWrite()==RingStream::THIS_IS_A_RINGSTREAM)
-              ((RingStream *)stream)->printFlash(flash);
-              else 
+          // RingStream has special logic to handle flash strings
+          // but is not implemented unless wifi or ethernet are enabled.
+          // The define prevents RingStream code being added unnecessariliy.
+          if (stream->availableForWrite() == RingStream::THIS_IS_A_RINGSTREAM)
+            ((RingStream*)stream)->printFlash(flash);
+          else
@@ -135,29 +145,68 @@ void StringFormatter::send2(Print * stream,const FSH* format, va_list args) {
-        stream->print(flash);
-        break;
-             }
-      case 'P': stream->print((uint32_t)va_arg(args, void*), HEX); break;
-      case 'd': printPadded(stream,va_arg(args, int), formatWidth, formatLeft); break;
-      case 'u': printPadded(stream,va_arg(args, unsigned int), formatWidth, formatLeft); break;
-      case 'l': printPadded(stream,va_arg(args, long), formatWidth, formatLeft); break;
-      case 'L': stream->print(va_arg(args, unsigned long), DEC); break;
-      case 'b': stream->print(va_arg(args, int), BIN); break;
-      case 'o': stream->print(va_arg(args, int), OCT); break;
-      case 'x': stream->print((unsigned int)va_arg(args, unsigned int), HEX); break;
-      case 'X': stream->print((unsigned long)va_arg(args, unsigned long), HEX); break;
-      case 'h': printHex(stream,(unsigned int)va_arg(args, unsigned int)); break;
-      case 'M':
-      { // this prints a unsigned long microseconds time in readable format
-	unsigned long time = va_arg(args, long);
-	if (time >= 2000) {
-	  time = time / 1000;
-	  if (time >= 2000) {
-	    printPadded(stream, time/1000, formatWidth, formatLeft);
-	    stream->print(F("sec"));
-	  } else {
-	    printPadded(stream,time, formatWidth, formatLeft);
-	    stream->print(F("msec"));
-	  }
-	} else {
-	  printPadded(stream,time, formatWidth, formatLeft);
-	  stream->print(F("usec"));
-	}
+            stream->print(flash);
+          break;
+        }
+        case 'P':
+          stream->print((uint32_t)va_arg(args, void*), HEX);
+          break;
+        case 'd':
+          printPadded(stream, va_arg(args, int), formatWidth, formatLeft);
+          break;
+        case 'u':
+          printPadded(stream, va_arg(args, unsigned int), formatWidth, formatLeft);
+          break;
+        case 'l':
+          printPadded(stream, va_arg(args, long), formatWidth, formatLeft);
+          break;
+        case 'L':
+          stream->print(va_arg(args, unsigned long), DEC);
+          break;
+        case 'b':
+          stream->print(va_arg(args, int), BIN);
+          break;
+        case 'o':
+          stream->print(va_arg(args, int), OCT);
+          break;
+        case 'x':
+          stream->print((unsigned int)va_arg(args, unsigned int), HEX);
+          break;
+        case 'X':
+          stream->print((unsigned long)va_arg(args, unsigned long), HEX);
+          break;
+        case 'h':
+          printHex(stream, (unsigned int)va_arg(args, unsigned int));
+          break;
+        case 'M': {  // this prints a unsigned long microseconds time in readable format
+          unsigned long time = va_arg(args, long);
+          if (time >= 2000) {
+            time = time / 1000;
+            if (time >= 2000) {
+              printPadded(stream, time / 1000, formatWidth, formatLeft);
+              stream->print(F("sec"));
+            } else {
+              printPadded(stream, time, formatWidth, formatLeft);
+              stream->print(F("msec"));
+            }
+          } else {
+            printPadded(stream, time, formatWidth, formatLeft);
+            stream->print(F("usec"));
+          }
+        } break;
+        // case 'f': stream->print(va_arg(args, double), 2); break;
+        // format width prefix
+        case '-':
+          formatLeft = true;
+          formatContinues = true;
+          break;
+        case '0':
+        case '1':
+        case '2':
+        case '3':
+        case '4':
+        case '5':
+        case '6':
+        case '7':
+        case '8':
+        case '9':
+          formatWidth = formatWidth * 10 + (c - '0');
+          formatContinues = true;
+          break;
@@ -165,22 +214 @@ void StringFormatter::send2(Print * stream,const FSH* format, va_list args) {
-      break;
-      //case 'f': stream->print(va_arg(args, double), 2); break;
-      //format width prefix
-      case '-': 
-            formatLeft=true;
-            formatContinues=true;
-            break; 
-      case '0': 
-      case '1': 
-      case '2': 
-      case '3': 
-      case '4': 
-      case '5': 
-      case '6': 
-      case '7': 
-      case '8': 
-      case '9': 
-            formatWidth=formatWidth * 10 + (c-'0');
-            formatContinues=true;
-            break;
-    }
-  } while(formatContinues);
+    } while (formatContinues);
@@ -191,7 +219,9 @@ void StringFormatter::send2(Print * stream,const FSH* format, va_list args) {
-void StringFormatter::printEscapes(Print * stream,char * input) {
- if (!stream) return;
- for(int i=0; ; ++i) {
-  char c=input[i];
-  printEscape(stream,c);
-  if (c=='\0') return;
- }
+void StringFormatter::printEscapes(Print* stream, char* input) {
+  if (!stream)
+    return;
+  for (int i = 0;; ++i) {
+    char c = input[i];
+    printEscape(stream, c);
+    if (c == '\0')
+      return;
+  }
@@ -200,9 +230,10 @@ void StringFormatter::printEscapes(Print * stream,char * input) {
-void StringFormatter::printEscapes(Print * stream, const FSH * input) {
- 
- if (!stream) return;
- char* flash=(char*)input;
- for(int i=0; ; ++i) {
-  char c=GETFLASH(flash+i);
-  printEscape(stream,c);
-  if (c=='\0') return;
- }
+void StringFormatter::printEscapes(Print* stream, const FSH* input) {
+  if (!stream)
+    return;
+  char* flash = (char*)input;
+  for (int i = 0;; ++i) {
+    char c = GETFLASH(flash + i);
+    printEscape(stream, c);
+    if (c == '\0')
+      return;
+  }
@@ -211,2 +242,2 @@ void StringFormatter::printEscapes(Print * stream, const FSH * input) {
-void StringFormatter::printEscape( char c) {
-  printEscape(&USB_SERIAL,c);
+void StringFormatter::printEscape(char c) {
+  printEscape(&USB_SERIAL, c);
@@ -215,9 +246,21 @@ void StringFormatter::printEscape( char c) {
-void StringFormatter::printEscape(Print * stream, char c) {
-  if (!stream) return;
-  switch(c) {
-     case '\n': stream->print(F("\\n")); break; 
-     case '\r': stream->print(F("\\r")); break; 
-     case '\0': stream->print(F("\\0")); return; 
-     case '\t': stream->print(F("\\t")); break;
-     case '\\': stream->print(F("\\\\")); break;
-     default: stream->write(c);
+void StringFormatter::printEscape(Print* stream, char c) {
+  if (!stream)
+    return;
+  switch (c) {
+    case '\n':
+      stream->print(F("\\n"));
+      break;
+    case '\r':
+      stream->print(F("\\r"));
+      break;
+    case '\0':
+      stream->print(F("\\0"));
+      return;
+    case '\t':
+      stream->print(F("\\t"));
+      break;
+    case '\\':
+      stream->print(F("\\\\"));
+      break;
+    default:
+      stream->write(c);
@@ -225 +268 @@ void StringFormatter::printEscape(Print * stream, char c) {
- }
+}
@@ -227 +269,0 @@ void StringFormatter::printEscape(Print * stream, char c) {
- 
@@ -229 +271 @@ void StringFormatter::printPadded(Print* stream, long value, byte width, bool fo
-  if (width==0) {
+  if (width == 0) {
@@ -233,14 +275,6 @@ void StringFormatter::printPadded(Print* stream, long value, byte width, bool fo
-  
-    int digits=(value <= 0)? 1: 0;  // zero and negative need extra digot
-    long v=value;
-    while (v) {
-        v /= 10;
-        digits++;
-    }
-    
-    if (formatLeft) stream->print(value, DEC);
-    while(digits<width) {
-      stream->print(' ');
-      digits++;
-    }
-    if (!formatLeft) stream->print(value, DEC);    
+
+  int digits = (value <= 0) ? 1 : 0;  // zero and negative need extra digot
+  long v = value;
+  while (v) {
+    v /= 10;
+    digits++;
@@ -248,0 +283,10 @@ void StringFormatter::printPadded(Print* stream, long value, byte width, bool fo
+  if (formatLeft)
+    stream->print(value, DEC);
+  while (digits < width) {
+    stream->print(' ');
+    digits++;
+  }
+  if (!formatLeft)
+    stream->print(value, DEC);
+}
+
@@ -250,9 +294,9 @@ void StringFormatter::printPadded(Print* stream, long value, byte width, bool fo
-const char FLASH hexchars[]="0123456789ABCDEF";
-void StringFormatter::printHex(Print * stream,uint16_t value) {
-    char result[5];
-    for (int i=3;i>=0;i--) {
-      result[i]=GETFLASH(hexchars+(value & 0x0F));
-      value>>=4;
-    }
-    result[4]='\0';
-     stream->print(result);
+const char FLASH hexchars[] = "0123456789ABCDEF";
+void StringFormatter::printHex(Print* stream, uint16_t value) {
+  char result[5];
+  for (int i = 3; i >= 0; i--) {
+    result[i] = GETFLASH(hexchars + (value & 0x0F));
+    value >>= 4;
+  }
+  result[4] = '\0';
+  stream->print(result);
diff --git a/StringFormatter.h b/StringFormatter.h
index 25d15e2..15a0826 100644
--- a/StringFormatter.h
+++ b/StringFormatter.h
@@ -3 +3 @@
- *  
+ *
@@ -26 +26 @@ class Diag {
-  public:
+ public:
@@ -33 +32,0 @@ class Diag {
-  
@@ -36,9 +35,8 @@ class Diag {
-class StringFormatter
-{
-  public:
-    static void send(Print * serial, const FSH* input...);
-    static void send(Print & serial, const FSH* input...);
-    
-    static void printEscapes(Print * serial,char * input);
-    static void printEscapes(Print * serial,const FSH* input);
-    static void printEscape(Print * serial, char c);
+class StringFormatter {
+ public:
+  static void send(Print* serial, const FSH* input...);
+  static void send(Print& serial, const FSH* input...);
+
+  static void printEscapes(Print* serial, char* input);
+  static void printEscapes(Print* serial, const FSH* input);
+  static void printEscape(Print* serial, char c);
@@ -46,7 +44,7 @@ class StringFormatter
-    // DIAG support
-    static void diag( const FSH* input...);
-    static void lcd(byte row, const FSH* input...);
-    static void lcd2(uint8_t display, byte row, const FSH* input...);
-    static void printEscapes(char * input);
-    static void printEscape( char c);
-    static void printHex(Print * stream,uint16_t value);
+  // DIAG support
+  static void diag(const FSH* input...);
+  static void lcd(byte row, const FSH* input...);
+  static void lcd2(uint8_t display, byte row, const FSH* input...);
+  static void printEscapes(char* input);
+  static void printEscape(char c);
+  static void printHex(Print* stream, uint16_t value);
@@ -54,3 +52,3 @@ class StringFormatter
-    private: 
-    static void send2(Print * serial, const FSH* input,va_list args);
-    static void printPadded(Print* stream, long value, byte width, bool formatLeft);
+ private:
+  static void send2(Print* serial, const FSH* input, va_list args);
+  static void printPadded(Print* stream, long value, byte width, bool formatLeft);
diff --git a/TemplateForEnums.h b/TemplateForEnums.h
index 459568d..de07327 100644
--- a/TemplateForEnums.h
+++ b/TemplateForEnums.h
@@ -3 +3 @@
- *  
+ *
@@ -21,4 +21,16 @@
-template<class T> inline T operator~ (T a) { return (T)~(int)a; }
-template<class T> inline T operator| (T a, T b) { return (T)((int)a | (int)b); }
-template<class T> inline T operator& (T a, T b) { return (T)((int)a & (int)b); }
-template<class T> inline T operator^ (T a, T b) { return (T)((int)a ^ (int)b); }
+template <class T>
+inline T operator~(T a) {
+  return (T) ~(int)a;
+}
+template <class T>
+inline T operator|(T a, T b) {
+  return (T)((int)a | (int)b);
+}
+template <class T>
+inline T operator&(T a, T b) {
+  return (T)((int)a & (int)b);
+}
+template <class T>
+inline T operator^(T a, T b) {
+  return (T)((int)a ^ (int)b);
+}
@@ -26 +37,0 @@ template<class T> inline T operator^ (T a, T b) { return (T)((int)a ^ (int)b); }
-
diff --git a/TrackManager.cpp b/TrackManager.cpp
index c54dc31..aa3260a 100644
--- a/TrackManager.cpp
+++ b/TrackManager.cpp
@@ -8 +8 @@
- *  
+ *
@@ -36,14 +36,14 @@
-#define FOR_EACH_TRACK(t) for (byte t=0;t<=lastTrack;t++)
-    
-#define APPLY_BY_MODE(findmode,function) \
-        FOR_EACH_TRACK(t) \
-	    if (track[t]->getMode() & findmode)	\
-                track[t]->function;
-
-MotorDriver * TrackManager::track[MAX_TRACKS] = { NULL };
-int16_t TrackManager::trackDCAddr[MAX_TRACKS] = { 0 };
-
-int8_t TrackManager::lastTrack=-1;
-bool TrackManager::progTrackSyncMain=false; 
-bool TrackManager::progTrackBoosted=false; 
-int16_t TrackManager::joinRelay=UNUSED_PIN;
+#define FOR_EACH_TRACK(t) for (byte t = 0; t <= lastTrack; t++)
+
+#define APPLY_BY_MODE(findmode, function) \
+  FOR_EACH_TRACK(t)                       \
+  if (track[t]->getMode() & findmode)     \
+    track[t]->function;
+
+MotorDriver* TrackManager::track[MAX_TRACKS] = {NULL};
+int16_t TrackManager::trackDCAddr[MAX_TRACKS] = {0};
+
+int8_t TrackManager::lastTrack = -1;
+bool TrackManager::progTrackSyncMain = false;
+bool TrackManager::progTrackBoosted = false;
+int16_t TrackManager::joinRelay = UNUSED_PIN;
@@ -51 +51 @@ int16_t TrackManager::joinRelay=UNUSED_PIN;
-byte TrackManager::tempProgTrack=MAX_TRACKS+1; // MAX_TRACKS+1 is the unused flag
+byte TrackManager::tempProgTrack = MAX_TRACKS + 1;  // MAX_TRACKS+1 is the unused flag
@@ -64,2 +64,2 @@ void TrackManager::sampleCurrent() {
-    if (! track[tr]->sampleCurrentFromHW()) {
-      return; // no result, continue to wait
+    if (!track[tr]->sampleCurrentFromHW()) {
+      return;  // no result, continue to wait
@@ -71 +71,2 @@ void TrackManager::sampleCurrent() {
-    if (tr > lastTrack) tr = 0;
+    if (tr > lastTrack)
+      tr = 0;
@@ -73,5 +74,5 @@ void TrackManager::sampleCurrent() {
-      return; // We could continue but for prog track we
-              // rather do it in next interrupt beacuse
-              // that gives us well defined sampling point.
-              // For other tracks we care less unless we
-              // have only few (max 2) tracks.
+      return;  // We could continue but for prog track we
+               // rather do it in next interrupt beacuse
+               // that gives us well defined sampling point.
+               // For other tracks we care less unless we
+               // have only few (max 2) tracks.
@@ -83,5 +84,5 @@ void TrackManager::sampleCurrent() {
-      if (track[tr]->getMode() & ( TRACK_MODE_MAIN|TRACK_MODE_PROG|TRACK_MODE_DC|TRACK_MODE_BOOST|TRACK_MODE_EXT )) {
-	track[tr]->startCurrentFromHW();
-	// for scope debug track[1]->setBrake(1);
-	waiting = true;
-	break;
+      if (track[tr]->getMode() & (TRACK_MODE_MAIN | TRACK_MODE_PROG | TRACK_MODE_DC | TRACK_MODE_BOOST | TRACK_MODE_EXT)) {
+        track[tr]->startCurrentFromHW();
+        // for scope debug track[1]->setBrake(1);
+        waiting = true;
+        break;
@@ -90,3 +91,4 @@ void TrackManager::sampleCurrent() {
-      if (tr > lastTrack) tr = 0;
-      if (tr == trAtStart) // we are through and nothing found to do
-	return;
+      if (tr > lastTrack)
+        tr = 0;
+      if (tr == trAtStart)  // we are through and nothing found to do
+        return;
@@ -98,17 +100,15 @@ void TrackManager::sampleCurrent() {
-// The setup call is done this way so that the tracks can be in a list 
-// from the config... the tracks default to NULL in the declaration                 
-void TrackManager::Setup(const FSH * shieldname,
-        MotorDriver * track0, MotorDriver * track1, MotorDriver * track2,
-        MotorDriver * track3, MotorDriver * track4,  MotorDriver * track5,
-        MotorDriver * track6, MotorDriver * track7 ) {       
-    addTrack(0,track0);
-    addTrack(1,track1);
-    addTrack(2,track2);
-    addTrack(3,track3);
-    addTrack(4,track4);
-    addTrack(5,track5);
-    addTrack(6,track6);
-    addTrack(7,track7);
-    
-    // Default the first 2 tracks (which may be null) and perform HA waveform check.
-    setTrackMode(0,TRACK_MODE_MAIN);
+// The setup call is done this way so that the tracks can be in a list
+// from the config... the tracks default to NULL in the declaration
+void TrackManager::Setup(const FSH* shieldname, MotorDriver* track0, MotorDriver* track1, MotorDriver* track2, MotorDriver* track3,
+                         MotorDriver* track4, MotorDriver* track5, MotorDriver* track6, MotorDriver* track7) {
+  addTrack(0, track0);
+  addTrack(1, track1);
+  addTrack(2, track2);
+  addTrack(3, track3);
+  addTrack(4, track4);
+  addTrack(5, track5);
+  addTrack(6, track6);
+  addTrack(7, track7);
+
+  // Default the first 2 tracks (which may be null) and perform HA waveform check.
+  setTrackMode(0, TRACK_MODE_MAIN);
@@ -116 +116 @@ void TrackManager::Setup(const FSH * shieldname,
-    setTrackMode(1,TRACK_MODE_PROG);
+  setTrackMode(1, TRACK_MODE_PROG);
@@ -118 +118 @@ void TrackManager::Setup(const FSH * shieldname,
-    setTrackMode(1,TRACK_MODE_MAIN);
+  setTrackMode(1, TRACK_MODE_MAIN);
@@ -120 +120 @@ void TrackManager::Setup(const FSH * shieldname,
-  
+
@@ -123,6 +123,5 @@ void TrackManager::Setup(const FSH * shieldname,
-    for (byte s=t+1;s<=lastTrack;s++) {
-      if (track[t]->getFaultPin() != UNUSED_PIN &&
-	  track[t]->getFaultPin() == track[s]->getFaultPin()) {
-	track[t]->setCommonFaultPin();
-	track[s]->setCommonFaultPin();
-	DIAG(F("Common Fault pin tracks %c and %c"), t+'A', s+'A');
+    for (byte s = t + 1; s <= lastTrack; s++) {
+      if (track[t]->getFaultPin() != UNUSED_PIN && track[t]->getFaultPin() == track[s]->getFaultPin()) {
+        track[t]->setCommonFaultPin();
+        track[s]->setCommonFaultPin();
+        DIAG(F("Common Fault pin tracks %c and %c"), t + 'A', s + 'A');
@@ -136,7 +135,7 @@ void TrackManager::addTrack(byte t, MotorDriver* driver) {
-     track[t]=driver;
-     if (driver) {
-         track[t]->setPower(POWERMODE::OFF);
-         track[t]->setMode(TRACK_MODE_NONE);
-	 track[t]->setTrackLetter('A'+t);
-         lastTrack=t;
-     } 
+  track[t] = driver;
+  if (driver) {
+    track[t]->setPower(POWERMODE::OFF);
+    track[t]->setMode(TRACK_MODE_NONE);
+    track[t]->setTrackLetter('A' + t);
+    lastTrack = t;
+  }
@@ -147,18 +146,18 @@ void TrackManager::addTrack(byte t, MotorDriver* driver) {
-void TrackManager::setDCCSignal( bool on) {
-  HAVE_PORTA(shadowPORTA=PORTA);
-  HAVE_PORTB(shadowPORTB=PORTB);
-  HAVE_PORTC(shadowPORTC=PORTC);
-  HAVE_PORTD(shadowPORTD=PORTD);
-  HAVE_PORTE(shadowPORTE=PORTE);
-  HAVE_PORTF(shadowPORTF=PORTF);
-  HAVE_PORTG(shadowPORTG=PORTG);
-  HAVE_PORTH(shadowPORTH=PORTH);
-  APPLY_BY_MODE(TRACK_MODE_MAIN,setSignal(on));
-  HAVE_PORTA(PORTA=shadowPORTA);
-  HAVE_PORTB(PORTB=shadowPORTB);
-  HAVE_PORTC(PORTC=shadowPORTC);
-  HAVE_PORTD(PORTD=shadowPORTD);
-  HAVE_PORTE(PORTE=shadowPORTE);
-  HAVE_PORTF(PORTF=shadowPORTF);
-  HAVE_PORTG(PORTG=shadowPORTG);
-  HAVE_PORTH(PORTH=shadowPORTH);
+void TrackManager::setDCCSignal(bool on) {
+  HAVE_PORTA(shadowPORTA = PORTA);
+  HAVE_PORTB(shadowPORTB = PORTB);
+  HAVE_PORTC(shadowPORTC = PORTC);
+  HAVE_PORTD(shadowPORTD = PORTD);
+  HAVE_PORTE(shadowPORTE = PORTE);
+  HAVE_PORTF(shadowPORTF = PORTF);
+  HAVE_PORTG(shadowPORTG = PORTG);
+  HAVE_PORTH(shadowPORTH = PORTH);
+  APPLY_BY_MODE(TRACK_MODE_MAIN, setSignal(on));
+  HAVE_PORTA(PORTA = shadowPORTA);
+  HAVE_PORTB(PORTB = shadowPORTB);
+  HAVE_PORTC(PORTC = shadowPORTC);
+  HAVE_PORTD(PORTD = shadowPORTD);
+  HAVE_PORTE(PORTE = shadowPORTE);
+  HAVE_PORTF(PORTF = shadowPORTF);
+  HAVE_PORTG(PORTG = shadowPORTG);
+  HAVE_PORTH(PORTH = shadowPORTH);
@@ -169,18 +168,18 @@ void TrackManager::setDCCSignal( bool on) {
-void TrackManager::setPROGSignal( bool on) {
-  HAVE_PORTA(shadowPORTA=PORTA);
-  HAVE_PORTB(shadowPORTB=PORTB);
-  HAVE_PORTC(shadowPORTC=PORTC);
-  HAVE_PORTD(shadowPORTD=PORTD);
-  HAVE_PORTE(shadowPORTE=PORTE);
-  HAVE_PORTF(shadowPORTF=PORTF);
-  HAVE_PORTG(shadowPORTG=PORTG);
-  HAVE_PORTH(shadowPORTH=PORTH);
-  APPLY_BY_MODE(TRACK_MODE_PROG,setSignal(on));
-  HAVE_PORTA(PORTA=shadowPORTA);
-  HAVE_PORTB(PORTB=shadowPORTB);
-  HAVE_PORTC(PORTC=shadowPORTC);
-  HAVE_PORTD(PORTD=shadowPORTD);
-  HAVE_PORTE(PORTE=shadowPORTE);
-  HAVE_PORTF(PORTF=shadowPORTF);
-  HAVE_PORTG(PORTG=shadowPORTG);
-  HAVE_PORTH(PORTH=shadowPORTH);
+void TrackManager::setPROGSignal(bool on) {
+  HAVE_PORTA(shadowPORTA = PORTA);
+  HAVE_PORTB(shadowPORTB = PORTB);
+  HAVE_PORTC(shadowPORTC = PORTC);
+  HAVE_PORTD(shadowPORTD = PORTD);
+  HAVE_PORTE(shadowPORTE = PORTE);
+  HAVE_PORTF(shadowPORTF = PORTF);
+  HAVE_PORTG(shadowPORTG = PORTG);
+  HAVE_PORTH(shadowPORTH = PORTH);
+  APPLY_BY_MODE(TRACK_MODE_PROG, setSignal(on));
+  HAVE_PORTA(PORTA = shadowPORTA);
+  HAVE_PORTB(PORTB = shadowPORTB);
+  HAVE_PORTC(PORTC = shadowPORTC);
+  HAVE_PORTD(PORTD = shadowPORTD);
+  HAVE_PORTE(PORTE = shadowPORTE);
+  HAVE_PORTF(PORTF = shadowPORTF);
+  HAVE_PORTG(PORTG = shadowPORTG);
+  HAVE_PORTH(PORTH = shadowPORTH);
@@ -194 +193,2 @@ void TrackManager::setDCSignal(int16_t cab, byte speedbyte) {
-    if (trackDCAddr[t]!=cab && cab != 0) continue;
+    if (trackDCAddr[t] != cab && cab != 0)
+      continue;
@@ -198 +198 @@ void TrackManager::setDCSignal(int16_t cab, byte speedbyte) {
-}    
+}
@@ -201 +201,2 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
-    if (trackToSet>lastTrack || track[trackToSet]==NULL) return false;
+  if (trackToSet > lastTrack || track[trackToSet] == NULL)
+    return false;
@@ -203,2 +204,2 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
-    // Remember track mode we came from for later
-    TRACK_MODE oldmode = track[trackToSet]->getMode();
+  // Remember track mode we came from for later
+  TRACK_MODE oldmode = track[trackToSet]->getMode();
@@ -206,3 +207,3 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
-    //DIAG(F("Track=%c Mode=%d"),trackToSet+'A', mode);
-    // DC tracks require a motorDriver that can set brake!
-    if (mode & TRACK_MODE_DC) {
+  // DIAG(F("Track=%c Mode=%d"),trackToSet+'A', mode);
+  //  DC tracks require a motorDriver that can set brake!
+  if (mode & TRACK_MODE_DC) {
@@ -210,2 +211,2 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
-      DIAG(F("Uno has no PWM timers available for DC"));
-      return false;
+    DIAG(F("Uno has no PWM timers available for DC"));
+    return false;
@@ -213,4 +214,3 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
-      if (!track[trackToSet]->brakeCanPWM()) {
-	DIAG(F("Brake pin can't PWM: No DC"));
-	return false;
-      }
+    if (!track[trackToSet]->brakeCanPWM()) {
+      DIAG(F("Brake pin can't PWM: No DC"));
+      return false;
@@ -217,0 +218 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
+  }
@@ -220,4 +221,14 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
-    // remove pin from MUX matrix and turn it off
-    pinpair p = track[trackToSet]->getSignalPin();
-    //DIAG(F("Track=%c remove  pin %d"),trackToSet+'A', p.pin);
-    gpio_reset_pin((gpio_num_t)p.pin);
+  // remove pin from MUX matrix and turn it off
+  pinpair p = track[trackToSet]->getSignalPin();
+  // DIAG(F("Track=%c remove  pin %d"),trackToSet+'A', p.pin);
+  gpio_reset_pin((gpio_num_t)p.pin);
+  if (p.invpin != UNUSED_PIN) {
+    // DIAG(F("Track=%c remove ^pin %d"),trackToSet+'A', p.invpin);
+    gpio_reset_pin((gpio_num_t)p.invpin);
+  }
+#ifdef BOOSTER_INPUT
+  if (mode & TRACK_MODE_BOOST) {
+    // DIAG(F("Track=%c mode boost pin %d"),trackToSet+'A', p.pin);
+    pinMode(BOOSTER_INPUT, INPUT);
+    gpio_matrix_in(BOOSTER_INPUT, SIG_IN_FUNC228_IDX, false);  // pads 224 to 228 available as loopback
+    gpio_matrix_out(p.pin, SIG_IN_FUNC228_IDX, false, false);
@@ -225,2 +236 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
-      //DIAG(F("Track=%c remove ^pin %d"),trackToSet+'A', p.invpin);
-      gpio_reset_pin((gpio_num_t)p.invpin);
+      gpio_matrix_out(p.invpin, SIG_IN_FUNC228_IDX, true /*inverted*/, false);
@@ -228,10 +238 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
-#ifdef BOOSTER_INPUT
-    if (mode & TRACK_MODE_BOOST) {
-      //DIAG(F("Track=%c mode boost pin %d"),trackToSet+'A', p.pin);
-      pinMode(BOOSTER_INPUT, INPUT);
-      gpio_matrix_in(BOOSTER_INPUT, SIG_IN_FUNC228_IDX, false); //pads 224 to 228 available as loopback
-      gpio_matrix_out(p.pin, SIG_IN_FUNC228_IDX, false, false);
-      if (p.invpin != UNUSED_PIN) {
-	gpio_matrix_out(p.invpin, SIG_IN_FUNC228_IDX, true /*inverted*/, false);
-      }
-    } else // elseif clause continues
+  } else  // elseif clause continues
@@ -239,6 +240,6 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
-    if (mode & (TRACK_MODE_MAIN | TRACK_MODE_PROG | TRACK_MODE_DC)) {
-      // gpio_reset_pin may reset to input
-      pinMode(p.pin, OUTPUT);
-      if (p.invpin != UNUSED_PIN)
-	pinMode(p.invpin, OUTPUT);
-    }
+      if (mode & (TRACK_MODE_MAIN | TRACK_MODE_PROG | TRACK_MODE_DC)) {
+    // gpio_reset_pin may reset to input
+    pinMode(p.pin, OUTPUT);
+    if (p.invpin != UNUSED_PIN)
+      pinMode(p.invpin, OUTPUT);
+  }
@@ -248,12 +249,8 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
-    if (mode & TRACK_MODE_PROG) {
-      // only allow 1 track to be prog
-      FOR_EACH_TRACK(t)
-	if ( (track[t]->getMode() & TRACK_MODE_PROG) && t != trackToSet) {
-	  track[t]->setPower(POWERMODE::OFF);
-	  track[t]->setMode(TRACK_MODE_NONE);
-	  track[t]->makeProgTrack(false);     // revoke prog track special handling
-	  streamTrackState(NULL,t);
-	}
-      track[trackToSet]->makeProgTrack(true); // set for prog track special handling
-    } else {
-      track[trackToSet]->makeProgTrack(false); // only the prog track knows it's type
+  if (mode & TRACK_MODE_PROG) {
+    // only allow 1 track to be prog
+    FOR_EACH_TRACK(t)
+    if ((track[t]->getMode() & TRACK_MODE_PROG) && t != trackToSet) {
+      track[t]->setPower(POWERMODE::OFF);
+      track[t]->setMode(TRACK_MODE_NONE);
+      track[t]->makeProgTrack(false);  // revoke prog track special handling
+      streamTrackState(NULL, t);
@@ -260,0 +258,4 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
+    track[trackToSet]->makeProgTrack(true);  // set for prog track special handling
+  } else {
+    track[trackToSet]->makeProgTrack(false);  // only the prog track knows it's type
+  }
@@ -263,13 +264,13 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
-    // When a track is switched, we must clear any side effects of its previous 
-    // state, otherwise trains run away or just dont move.
-
-    // This can be done BEFORE the PWM-Timer evaluation (methinks)
-    if (mode & TRACK_MODE_DC) {
-      if (trackDCAddr[trackToSet] != dcAddr) {
-	// new or changed DC Addr, run the new setup
-	if (trackDCAddr[trackToSet] != 0) {
-	  // if we change dcAddr and not only
-	  // change from another mode,
-	  // first detach old DC signal
-	  track[trackToSet]->detachDCSignal();
-	}
+  // When a track is switched, we must clear any side effects of its previous
+  // state, otherwise trains run away or just dont move.
+
+  // This can be done BEFORE the PWM-Timer evaluation (methinks)
+  if (mode & TRACK_MODE_DC) {
+    if (trackDCAddr[trackToSet] != dcAddr) {
+      // new or changed DC Addr, run the new setup
+      if (trackDCAddr[trackToSet] != 0) {
+        // if we change dcAddr and not only
+        // change from another mode,
+        // first detach old DC signal
+        track[trackToSet]->detachDCSignal();
+      }
@@ -277,16 +278,13 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
-	int trackfound = -1;
-	FOR_EACH_TRACK(t) {
-	  //DIAG(F("Checking track %c mode %x dcAddr %d"), 'A'+t, track[t]->getMode(), trackDCAddr[t]);
-	  if (t != trackToSet                          // not our track
-	      && (track[t]->getMode() & TRACK_MODE_DC) // right mode
-	      && trackDCAddr[t] == dcAddr) {           // right addr
-	    //DIAG(F("Found track %c"), 'A'+t);
-	    trackfound = t;
-	    break;
-	  }
-	}
-	if (trackfound > -1) {
-	  DCCTimer::DCCEXanalogCopyChannel(track[trackfound]->getBrakePinSigned(),
-					   track[trackToSet]->getBrakePinSigned());
-	}
-#endif
+      int trackfound = -1;
+      FOR_EACH_TRACK(t) {
+        // DIAG(F("Checking track %c mode %x dcAddr %d"), 'A'+t, track[t]->getMode(), trackDCAddr[t]);
+        if (t != trackToSet                           // not our track
+            && (track[t]->getMode() & TRACK_MODE_DC)  // right mode
+            && trackDCAddr[t] == dcAddr) {            // right addr
+          // DIAG(F("Found track %c"), 'A'+t);
+          trackfound = t;
+          break;
+        }
+      }
+      if (trackfound > -1) {
+        DCCTimer::DCCEXanalogCopyChannel(track[trackfound]->getBrakePinSigned(), track[trackToSet]->getBrakePinSigned());
@@ -294,7 +292 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
-      // set future DC Addr;
-      trackDCAddr[trackToSet]=dcAddr;
-    } else {
-      // DCC tracks need to have set the PWM to zero or they will not work.
-      track[trackToSet]->detachDCSignal();
-      track[trackToSet]->setBrake(false);
-      trackDCAddr[trackToSet]=0; // clear that an addr is set for DC as this is not a DC track
+#endif
@@ -302 +294,9 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
-    track[trackToSet]->setMode(mode);
+    // set future DC Addr;
+    trackDCAddr[trackToSet] = dcAddr;
+  } else {
+    // DCC tracks need to have set the PWM to zero or they will not work.
+    track[trackToSet]->detachDCSignal();
+    track[trackToSet]->setBrake(false);
+    trackDCAddr[trackToSet] = 0;  // clear that an addr is set for DC as this is not a DC track
+  }
+  track[trackToSet]->setMode(mode);
@@ -304,8 +304,8 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
-    // BOOST:
-    //  Leave it as is
-    // otherwise:
-    //  EXT is a special case where the signal pin is
-    //  turned off. So unless that is set, the signal
-    //  pin should be turned on
-    if (!(mode & TRACK_MODE_BOOST))
-      track[trackToSet]->enableSignal(!(mode & TRACK_MODE_EXT));
+  // BOOST:
+  //  Leave it as is
+  // otherwise:
+  //  EXT is a special case where the signal pin is
+  //  turned off. So unless that is set, the signal
+  //  pin should be turned on
+  if (!(mode & TRACK_MODE_BOOST))
+    track[trackToSet]->enableSignal(!(mode & TRACK_MODE_EXT));
@@ -314,19 +314,14 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
-    // re-evaluate HighAccuracy mode
-    // We can only do this is all main and prog tracks agree
-    bool canDo=true;
-    FOR_EACH_TRACK(t) {
-      // DC tracks must not have the DCC PWM switched on
-      // so we globally turn it off if one of the PWM
-      // capable tracks is now DC or DCX.
-      if (track[t]->getMode() & TRACK_MODE_DC) {
-	if (track[t]->isPWMCapable()) {
-	  canDo=false;    // this track is capable but can not run PWM
-	  break;          // in this mode, so abort and prevent globally below
-	} else {
-	  track[t]->trackPWM=false; // this track sure can not run with PWM
-	  //DIAG(F("Track %c trackPWM 0 (not capable)"), t+'A');
-	}
-      } else if (track[t]->getMode() & (TRACK_MODE_MAIN |TRACK_MODE_PROG)) {
-	track[t]->trackPWM = track[t]->isPWMCapable(); // trackPWM is still a guess here
-	//DIAG(F("Track %c trackPWM %d"), t+'A', track[t]->trackPWM);
-	canDo &= track[t]->trackPWM;
+  // re-evaluate HighAccuracy mode
+  // We can only do this is all main and prog tracks agree
+  bool canDo = true;
+  FOR_EACH_TRACK(t) {
+    // DC tracks must not have the DCC PWM switched on
+    // so we globally turn it off if one of the PWM
+    // capable tracks is now DC or DCX.
+    if (track[t]->getMode() & TRACK_MODE_DC) {
+      if (track[t]->isPWMCapable()) {
+        canDo = false;  // this track is capable but can not run PWM
+        break;          // in this mode, so abort and prevent globally below
+      } else {
+        track[t]->trackPWM = false;  // this track sure can not run with PWM
+        // DIAG(F("Track %c trackPWM 0 (not capable)"), t+'A');
@@ -333,0 +329,4 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
+    } else if (track[t]->getMode() & (TRACK_MODE_MAIN | TRACK_MODE_PROG)) {
+      track[t]->trackPWM = track[t]->isPWMCapable();  // trackPWM is still a guess here
+      // DIAG(F("Track %c trackPWM %d"), t+'A', track[t]->trackPWM);
+      canDo &= track[t]->trackPWM;
@@ -335,8 +334,7 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
-    if (!canDo) {
-      // if we discover that HA mode was globally impossible
-      // we must adjust the trackPWM capabilities
-      FOR_EACH_TRACK(t) {
-	track[t]->trackPWM=false;
-	//DIAG(F("Track %c trackPWM 0 (global override)"), t+'A');
-      }
-      DCCTimer::clearPWM(); // has to be AFTER trackPWM changes because if trackPWM==true this is undone for  that track
+  }
+  if (!canDo) {
+    // if we discover that HA mode was globally impossible
+    // we must adjust the trackPWM capabilities
+    FOR_EACH_TRACK(t) {
+      track[t]->trackPWM = false;
+      // DIAG(F("Track %c trackPWM 0 (global override)"), t+'A');
@@ -343,0 +342,2 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
+    DCCTimer::clearPWM();  // has to be AFTER trackPWM changes because if trackPWM==true this is undone for  that track
+  }
@@ -345,4 +345,4 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
-    // For ESP32 we just reinitialize the DCC Waveform
-    DCCWaveform::begin();
-    // setMode() again AFTER Waveform::begin() of ESP32 fixes INVERTED signal
-    track[trackToSet]->setMode(mode);
+  // For ESP32 we just reinitialize the DCC Waveform
+  DCCWaveform::begin();
+  // setMode() again AFTER Waveform::begin() of ESP32 fixes INVERTED signal
+  track[trackToSet]->setMode(mode);
@@ -351,7 +351,7 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
-    // This block must be AFTER the PWM-Timer modifications
-    if (mode & TRACK_MODE_DC) {
-        // DC tracks need to be given speed of the throttle for that cab address
-        // otherwise will not match other tracks on same cab.
-        // This also needs to allow for inverted DCX
-        applyDCSpeed(trackToSet);
-    }
+  // This block must be AFTER the PWM-Timer modifications
+  if (mode & TRACK_MODE_DC) {
+    // DC tracks need to be given speed of the throttle for that cab address
+    // otherwise will not match other tracks on same cab.
+    // This also needs to allow for inverted DCX
+    applyDCSpeed(trackToSet);
+  }
@@ -361,8 +361,9 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
-    if (tempProgTrack == trackToSet && oldmode & TRACK_MODE_MAIN && !(mode & TRACK_MODE_PROG)) {
-      // If we just take away the prog track, the join should not
-      // be active either. So do in effect an unjoin
-      //DIAG(F("Unsync"));
-      tempProgTrack = MAX_TRACKS+1;
-      progTrackSyncMain=false;
-      if (joinRelay!=UNUSED_PIN) digitalWrite(joinRelay,LOW);
-    }
+  if (tempProgTrack == trackToSet && oldmode & TRACK_MODE_MAIN && !(mode & TRACK_MODE_PROG)) {
+    // If we just take away the prog track, the join should not
+    // be active either. So do in effect an unjoin
+    // DIAG(F("Unsync"));
+    tempProgTrack = MAX_TRACKS + 1;
+    progTrackSyncMain = false;
+    if (joinRelay != UNUSED_PIN)
+      digitalWrite(joinRelay, LOW);
+  }
@@ -371,4 +372,4 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
-    // Turn off power if we changed the mode of this track
-    if (mode != oldmode) {
-      track[trackToSet]->setPower(POWERMODE::OFF);
-    }
+  // Turn off power if we changed the mode of this track
+  if (mode != oldmode) {
+    track[trackToSet]->setPower(POWERMODE::OFF);
+  }
@@ -376,3 +377,3 @@ bool TrackManager::setTrackMode(byte trackToSet, TRACK_MODE mode, int16_t dcAddr
-    streamTrackState(NULL,trackToSet);
-    //DIAG(F("TrackMode=%d"),mode);
-    return true; 
+  streamTrackState(NULL, trackToSet);
+  // DIAG(F("TrackMode=%d"),mode);
+  return true;
@@ -382,2 +383 @@ void TrackManager::applyDCSpeed(byte t) {
-  track[t]->setDCSignal(DCC::getThrottleSpeedByte(trackDCAddr[t]),
-			DCC::getThrottleFrequency(trackDCAddr[t]));
+  track[t]->setDCSignal(DCC::getThrottleSpeedByte(trackDCAddr[t]), DCC::getThrottleFrequency(trackDCAddr[t]));
@@ -386,22 +386,19 @@ void TrackManager::applyDCSpeed(byte t) {
-bool TrackManager::parseEqualSign(Print *stream, int16_t params, int16_t p[])
-{
-    
-    if (params==0) { // <=>  List track assignments
-        FOR_EACH_TRACK(t)
-             streamTrackState(stream,t);
-        return true;
-        
-    }
-    
-    p[0]-="A"_hk;  // convert A... to 0.... 
-
-    if (params>1 && (p[0]<0 || p[0]>=MAX_TRACKS)) 
-        return false;
-    
-    if (params==2  && p[1]=="MAIN"_hk)                     // <= id MAIN>
-        return setTrackMode(p[0],TRACK_MODE_MAIN);
-    if (params==2  && p[1]=="MAIN_INV"_hk)                 // <= id MAIN_INV>
-        return setTrackMode(p[0],TRACK_MODE_MAIN_INV);
-    if (params==2  && p[1]=="MAIN_AUTO"_hk)                // <= id MAIN_AUTO>
-        return setTrackMode(p[0],TRACK_MODE_MAIN_AUTO);
-    
+bool TrackManager::parseEqualSign(Print* stream, int16_t params, int16_t p[]) {
+  if (params == 0) {  // <=>  List track assignments
+    FOR_EACH_TRACK(t)
+    streamTrackState(stream, t);
+    return true;
+  }
+
+  p[0] -= "A"_hk;  // convert A... to 0....
+
+  if (params > 1 && (p[0] < 0 || p[0] >= MAX_TRACKS))
+    return false;
+
+  if (params == 2 && p[1] == "MAIN"_hk)  // <= id MAIN>
+    return setTrackMode(p[0], TRACK_MODE_MAIN);
+  if (params == 2 && p[1] == "MAIN_INV"_hk)  // <= id MAIN_INV>
+    return setTrackMode(p[0], TRACK_MODE_MAIN_INV);
+  if (params == 2 && p[1] == "MAIN_AUTO"_hk)  // <= id MAIN_AUTO>
+    return setTrackMode(p[0], TRACK_MODE_MAIN_AUTO);
+
@@ -409,2 +406,2 @@ bool TrackManager::parseEqualSign(Print *stream, int16_t params, int16_t p[])
-    if (params==2  && p[1]=="PROG"_hk)                     // <= id PROG>
-        return setTrackMode(p[0],TRACK_MODE_PROG);
+  if (params == 2 && p[1] == "PROG"_hk)  // <= id PROG>
+    return setTrackMode(p[0], TRACK_MODE_PROG);
@@ -412,3 +408,0 @@ bool TrackManager::parseEqualSign(Print *stream, int16_t params, int16_t p[])
-    
-    if (params==2  && (p[1]=="OFF"_hk || p[1]=="NONE"_hk)) // <= id OFF> <= id NONE>
-        return setTrackMode(p[0],TRACK_MODE_NONE);
@@ -416,2 +410,5 @@ bool TrackManager::parseEqualSign(Print *stream, int16_t params, int16_t p[])
-    if (params==2  && p[1]=="EXT"_hk) // <= id EXT>
-        return setTrackMode(p[0],TRACK_MODE_EXT);
+  if (params == 2 && (p[1] == "OFF"_hk || p[1] == "NONE"_hk))  // <= id OFF> <= id NONE>
+    return setTrackMode(p[0], TRACK_MODE_NONE);
+
+  if (params == 2 && p[1] == "EXT"_hk)  // <= id EXT>
+    return setTrackMode(p[0], TRACK_MODE_EXT);
@@ -419,9 +416,9 @@ bool TrackManager::parseEqualSign(Print *stream, int16_t params, int16_t p[])
-    if (TRACK_MODE_BOOST != 0 &&        // compile time optimization
-	params==2  && p[1]=="BOOST"_hk)                    // <= id BOOST>
-        return setTrackMode(p[0],TRACK_MODE_BOOST);
-    if (TRACK_MODE_BOOST_INV != 0 &&        // compile time optimization
-	params==2  && p[1]=="BOOST_INV"_hk)                // <= id BOOST_INV>
-        return setTrackMode(p[0],TRACK_MODE_BOOST_INV);
-    if (TRACK_MODE_BOOST_AUTO != 0 &&        // compile time optimization
-	params==2  && p[1]=="BOOST_AUTO"_hk)               // <= id BOOST_AUTO>
-        return setTrackMode(p[0],TRACK_MODE_BOOST_AUTO);
+  if (TRACK_MODE_BOOST != 0 &&            // compile time optimization
+      params == 2 && p[1] == "BOOST"_hk)  // <= id BOOST>
+    return setTrackMode(p[0], TRACK_MODE_BOOST);
+  if (TRACK_MODE_BOOST_INV != 0 &&            // compile time optimization
+      params == 2 && p[1] == "BOOST_INV"_hk)  // <= id BOOST_INV>
+    return setTrackMode(p[0], TRACK_MODE_BOOST_INV);
+  if (TRACK_MODE_BOOST_AUTO != 0 &&            // compile time optimization
+      params == 2 && p[1] == "BOOST_AUTO"_hk)  // <= id BOOST_AUTO>
+    return setTrackMode(p[0], TRACK_MODE_BOOST_AUTO);
@@ -429,2 +426,2 @@ bool TrackManager::parseEqualSign(Print *stream, int16_t params, int16_t p[])
-    if (params==2  && p[1]=="AUTO"_hk)                     // <= id AUTO>
-      return setTrackMode(p[0], track[p[0]]->getMode() | TRACK_MODIFIER_AUTO);
+  if (params == 2 && p[1] == "AUTO"_hk)  // <= id AUTO>
+    return setTrackMode(p[0], track[p[0]]->getMode() | TRACK_MODIFIER_AUTO);
@@ -432,2 +429,2 @@ bool TrackManager::parseEqualSign(Print *stream, int16_t params, int16_t p[])
-    if (params==2  && p[1]=="INV"_hk)                      // <= id INV>
-      return setTrackMode(p[0], track[p[0]]->getMode() | TRACK_MODIFIER_INV);
+  if (params == 2 && p[1] == "INV"_hk)  // <= id INV>
+    return setTrackMode(p[0], track[p[0]]->getMode() | TRACK_MODIFIER_INV);
@@ -435,6 +432,2 @@ bool TrackManager::parseEqualSign(Print *stream, int16_t params, int16_t p[])
-    if (params==3  && p[1]=="DC"_hk && p[2]>0)             // <= id DC cab>
-        return setTrackMode(p[0],TRACK_MODE_DC,p[2]);
-    
-    if (params==3  && (p[1]=="DC_INV"_hk ||                // <= id DC_INV cab>
-		       p[1]=="DCX"_hk) && p[2]>0)          // <= id DCX cab>
-        return setTrackMode(p[0],TRACK_MODE_DC_INV,p[2]);
+  if (params == 3 && p[1] == "DC"_hk && p[2] > 0)  // <= id DC cab>
+    return setTrackMode(p[0], TRACK_MODE_DC, p[2]);
@@ -442 +435,7 @@ bool TrackManager::parseEqualSign(Print *stream, int16_t params, int16_t p[])
-    return false;
+  if (params == 3 &&
+      (p[1] == "DC_INV"_hk ||  // <= id DC_INV cab>
+       p[1] == "DCX"_hk) &&
+      p[2] > 0)  // <= id DCX cab>
+    return setTrackMode(p[0], TRACK_MODE_DC_INV, p[2]);
+
+  return false;
@@ -446,2 +445,2 @@ const FSH* TrackManager::getModeName(TRACK_MODE tm) {
-  const FSH *modename=F("---");
-  
+  const FSH* modename = F("---");
+
@@ -449,2 +448,2 @@ const FSH* TrackManager::getModeName(TRACK_MODE tm) {
-    if(tm & TRACK_MODIFIER_AUTO)
-      modename=F("MAIN A");
+    if (tm & TRACK_MODIFIER_AUTO)
+      modename = F("MAIN A");
@@ -452 +451 @@ const FSH* TrackManager::getModeName(TRACK_MODE tm) {
-      modename=F("MAIN I>\n");
+      modename = F("MAIN I>\n");
@@ -454 +453 @@ const FSH* TrackManager::getModeName(TRACK_MODE tm) {
-      modename=F("MAIN");
+      modename = F("MAIN");
@@ -458 +457 @@ const FSH* TrackManager::getModeName(TRACK_MODE tm) {
-    modename=F("PROG");
+    modename = F("PROG");
@@ -461,6 +460,6 @@ const FSH* TrackManager::getModeName(TRACK_MODE tm) {
-    modename=F("NONE");
-  else if(tm & TRACK_MODE_EXT)
-    modename=F("EXT");
-  else if(tm & TRACK_MODE_BOOST) {
-        if(tm & TRACK_MODIFIER_AUTO)
-      modename=F("BOOST A");
+    modename = F("NONE");
+  else if (tm & TRACK_MODE_EXT)
+    modename = F("EXT");
+  else if (tm & TRACK_MODE_BOOST) {
+    if (tm & TRACK_MODIFIER_AUTO)
+      modename = F("BOOST A");
@@ -468 +467 @@ const FSH* TrackManager::getModeName(TRACK_MODE tm) {
-      modename=F("BOOST I");
+      modename = F("BOOST I");
@@ -470,3 +469,2 @@ const FSH* TrackManager::getModeName(TRACK_MODE tm) {
-      modename=F("BOOST");
-  }
-  else if (tm & TRACK_MODE_DC) {
+      modename = F("BOOST");
+  } else if (tm & TRACK_MODE_DC) {
@@ -474 +472 @@ const FSH* TrackManager::getModeName(TRACK_MODE tm) {
-      modename=F("DCX");
+      modename = F("DCX");
@@ -476 +474 @@ const FSH* TrackManager::getModeName(TRACK_MODE tm) {
-      modename=F("DC");
+      modename = F("DC");
@@ -483,3 +481,4 @@ void TrackManager::streamTrackState(Print* stream, byte t) {
-  const FSH *format;
-  
-  if (track[t]==NULL) return;
+  const FSH* format;
+
+  if (track[t] == NULL)
+    return;
@@ -488 +487 @@ void TrackManager::streamTrackState(Print* stream, byte t) {
-    format=F("<= %c %S %d>\n");
+    format = F("<= %c %S %d>\n");
@@ -490 +489 @@ void TrackManager::streamTrackState(Print* stream, byte t) {
-    format=F("<= %c %S>\n");
+    format = F("<= %c %S>\n");
@@ -492 +491 @@ void TrackManager::streamTrackState(Print* stream, byte t) {
-  const FSH *modename=getModeName(tm);
+  const FSH* modename = getModeName(tm);
@@ -494 +493 @@ void TrackManager::streamTrackState(Print* stream, byte t) {
-    StringFormatter::send(stream,format,'A'+t, modename, trackDCAddr[t]);
+    StringFormatter::send(stream, format, 'A' + t, modename, trackDCAddr[t]);
@@ -496 +495 @@ void TrackManager::streamTrackState(Print* stream, byte t) {
-    CommandDistributor::broadcastTrackState(format,'A'+t, modename, trackDCAddr[t]);
+    CommandDistributor::broadcastTrackState(format, 'A' + t, modename, trackDCAddr[t]);
@@ -499 +497,0 @@ void TrackManager::streamTrackState(Print* stream, byte t) {
-  
@@ -502 +500 @@ void TrackManager::streamTrackState(Print* stream, byte t) {
-byte TrackManager::nextCycleTrack=MAX_TRACKS;
+byte TrackManager::nextCycleTrack = MAX_TRACKS;
@@ -505 +503 @@ void TrackManager::loop() {
-    DCCWaveform::loop();
+  DCCWaveform::loop();
@@ -507 +505 @@ void TrackManager::loop() {
-    DCCACK::loop();
+  DCCACK::loop();
@@ -509,7 +507,9 @@ void TrackManager::loop() {
-    bool dontLimitProg=DCCACK::isActive() || progTrackSyncMain || progTrackBoosted;
-    nextCycleTrack++;
-    if (nextCycleTrack>lastTrack) nextCycleTrack=0;
-    if (track[nextCycleTrack]==NULL) return;
-    MotorDriver * motorDriver=track[nextCycleTrack];
-    bool useProgLimit=dontLimitProg ? false : (bool)(track[nextCycleTrack]->getMode() & TRACK_MODE_PROG);
-    motorDriver->checkPowerOverload(useProgLimit, nextCycleTrack);   
+  bool dontLimitProg = DCCACK::isActive() || progTrackSyncMain || progTrackBoosted;
+  nextCycleTrack++;
+  if (nextCycleTrack > lastTrack)
+    nextCycleTrack = 0;
+  if (track[nextCycleTrack] == NULL)
+    return;
+  MotorDriver* motorDriver = track[nextCycleTrack];
+  bool useProgLimit = dontLimitProg ? false : (bool)(track[nextCycleTrack]->getMode() & TRACK_MODE_PROG);
+  motorDriver->checkPowerOverload(useProgLimit, nextCycleTrack);
@@ -518,5 +518,6 @@ void TrackManager::loop() {
-MotorDriver * TrackManager::getProgDriver() {
-    FOR_EACH_TRACK(t)
-      if (track[t]->getMode() & TRACK_MODE_PROG) return track[t];
-    return NULL;
-} 
+MotorDriver* TrackManager::getProgDriver() {
+  FOR_EACH_TRACK(t)
+  if (track[t]->getMode() & TRACK_MODE_PROG)
+    return track[t];
+  return NULL;
+}
@@ -525,2 +526,2 @@ MotorDriver * TrackManager::getProgDriver() {
-std::vector<MotorDriver *>TrackManager::getMainDrivers() {
-  std::vector<MotorDriver *>  v;
+std::vector<MotorDriver*> TrackManager::getMainDrivers() {
+  std::vector<MotorDriver*> v;
@@ -528 +529,2 @@ std::vector<MotorDriver *>TrackManager::getMainDrivers() {
-    if (track[t]->getMode() & TRACK_MODE_MAIN) v.push_back(track[t]);
+  if (track[t]->getMode() & TRACK_MODE_MAIN)
+    v.push_back(track[t]);
@@ -535 +537 @@ void TrackManager::setTrackPower(TRACK_MODE trackmodeToMatch, POWERMODE powermod
-  bool didChange=false;
+  bool didChange = false;
@@ -537 +539 @@ void TrackManager::setTrackPower(TRACK_MODE trackmodeToMatch, POWERMODE powermod
-    MotorDriver *driver=track[t];
+    MotorDriver* driver = track[t];
@@ -541 +543 @@ void TrackManager::setTrackPower(TRACK_MODE trackmodeToMatch, POWERMODE powermod
-	didChange=true;
+        didChange = true;
@@ -543,9 +545,9 @@ void TrackManager::setTrackPower(TRACK_MODE trackmodeToMatch, POWERMODE powermod
-	if (trackmodeOfTrack & TRACK_MODE_DC) {
-	  driver->setBrake(true);   // DC starts with brake on
-	  applyDCSpeed(t);          // speed match DCC throttles
-	} else {
-	  // toggle brake before turning power on - resets overcurrent error
-	  // on the Pololu board if brake is wired to ^D2.
-	  driver->setBrake(true);
-	  driver->setBrake(false); // DCC runs with brake off
-	}
+        if (trackmodeOfTrack & TRACK_MODE_DC) {
+          driver->setBrake(true);  // DC starts with brake on
+          applyDCSpeed(t);         // speed match DCC throttles
+        } else {
+          // toggle brake before turning power on - resets overcurrent error
+          // on the Pololu board if brake is wired to ^D2.
+          driver->setBrake(true);
+          driver->setBrake(false);  // DCC runs with brake off
+        }
@@ -562,3 +564,3 @@ void TrackManager::setTrackPower(POWERMODE powermode, byte t) {
-  MotorDriver *driver=track[t];
-  if (driver == NULL) { // track is not defined at all
-    DIAG(F("Error: Track %c does not exist"), t+'A');
+  MotorDriver* driver = track[t];
+  if (driver == NULL) {  // track is not defined at all
+    DIAG(F("Error: Track %c does not exist"), t + 'A');
@@ -570,3 +572,3 @@ void TrackManager::setTrackPower(POWERMODE powermode, byte t) {
-    driver->setBrake(true);     // Track is unused. Brake is good to have.
-    powermode = POWERMODE::OFF; // Track is unused. Force it to OFF
-  } else if (trackmode & TRACK_MODE_DC) { // includes inverted DC (called DCX)
+    driver->setBrake(true);                // Track is unused. Brake is good to have.
+    powermode = POWERMODE::OFF;            // Track is unused. Force it to OFF
+  } else if (trackmode & TRACK_MODE_DC) {  // includes inverted DC (called DCX)
@@ -574,2 +576,2 @@ void TrackManager::setTrackPower(POWERMODE powermode, byte t) {
-      driver->setBrake(true);   // DC starts with brake on
-      applyDCSpeed(t);          // speed match DCC throttles
+      driver->setBrake(true);  // DC starts with brake on
+      applyDCSpeed(t);         // speed match DCC throttles
@@ -582 +584 @@ void TrackManager::setTrackPower(POWERMODE powermode, byte t) {
-      driver->setBrake(false); // DCC runs with brake off
+      driver->setBrake(false);  // DCC runs with brake off
@@ -593,2 +595,2 @@ POWERMODE TrackManager::getProgPower() {
-    if (track[t]->getMode() & TRACK_MODE_PROG)
-      return track[t]->getPower(); // optimize: there is max one prog track
+  if (track[t]->getMode() & TRACK_MODE_PROG)
+    return track[t]->getPower();  // optimize: there is max one prog track
@@ -605 +607 @@ POWERMODE TrackManager::getMainPower() {
-	return POWERMODE::OFF; // done and out
+        return POWERMODE::OFF;  // done and out
@@ -607 +609 @@ POWERMODE TrackManager::getMainPower() {
-	result = POWERMODE::ON;
+        result = POWERMODE::ON;
@@ -629,3 +631,3 @@ void TrackManager::reportObsoleteCurrent(Print* stream) {
-  int maxCurrent=track[0]->raw2mA(track[0]->getRawCurrentTripValue());
-  StringFormatter::send(stream, F("<c CurrentMAIN %d C Milli 0 %d 1 %d>\n"), 
-            track[0]->raw2mA(track[0]->getCurrentRaw(false)), maxCurrent, maxCurrent);
+  int maxCurrent = track[0]->raw2mA(track[0]->getRawCurrentTripValue());
+  StringFormatter::send(stream, F("<c CurrentMAIN %d C Milli 0 %d 1 %d>\n"), track[0]->raw2mA(track[0]->getCurrentRaw(false)), maxCurrent,
+                        maxCurrent);
@@ -638,7 +640,5 @@ void TrackManager::reportCurrent(Print* stream) {
-    StringFormatter::send(stream,F("<jI"));
-    FOR_EACH_TRACK(t) {
-         StringFormatter::send(stream, F(" %d"),
-         (track[t]->getPower()==POWERMODE::OVERLOAD) ? -1 :
-            track[t]->raw2mA(track[t]->getCurrentRaw(false)));
-         }
-    StringFormatter::send(stream,F(">\n"));    
+  StringFormatter::send(stream, F("<jI"));
+  FOR_EACH_TRACK(t) {
+    StringFormatter::send(stream, F(" %d"), (track[t]->getPower() == POWERMODE::OVERLOAD) ? -1 : track[t]->raw2mA(track[t]->getCurrentRaw(false)));
+  }
+  StringFormatter::send(stream, F(">\n"));
@@ -648,6 +648,5 @@ void TrackManager::reportGauges(Print* stream) {
-    StringFormatter::send(stream,F("<jG"));
-    FOR_EACH_TRACK(t) {
-         StringFormatter::send(stream, F(" %d"),
-            track[t]->raw2mA(track[t]->getRawCurrentTripValue()));
-         }
-    StringFormatter::send(stream,F(">\n"));    
+  StringFormatter::send(stream, F("<jG"));
+  FOR_EACH_TRACK(t) {
+    StringFormatter::send(stream, F(" %d"), track[t]->raw2mA(track[t]->getRawCurrentTripValue()));
+  }
+  StringFormatter::send(stream, F(">\n"));
@@ -657,4 +656,4 @@ void TrackManager::setJoinRelayPin(byte joinRelayPin) {
-  joinRelay=joinRelayPin;
-  if (joinRelay!=UNUSED_PIN) {
-    pinMode(joinRelay,OUTPUT);
-    digitalWrite(joinRelay,LOW);  // LOW is relay disengaged
+  joinRelay = joinRelayPin;
+  if (joinRelay != UNUSED_PIN) {
+    pinMode(joinRelay, OUTPUT);
+    digitalWrite(joinRelay, LOW);  // LOW is relay disengaged
@@ -666 +665 @@ void TrackManager::setJoin(bool joined) {
-  if (joined) {                                          // if we go into joined mode (PROG acts as MAIN)
+  if (joined) {  // if we go into joined mode (PROG acts as MAIN)
@@ -668,6 +667,6 @@ void TrackManager::setJoin(bool joined) {
-      if (track[t]->getMode() & TRACK_MODE_PROG) {       // find PROG track
-	tempProgTrack = t;                               // remember PROG track
-	setTrackMode(t, TRACK_MODE_MAIN);
-	// setPower() of the track called after
-	// seperately after setJoin() instead
-	break;                                           // there is only one prog track, done
+      if (track[t]->getMode() & TRACK_MODE_PROG) {  // find PROG track
+        tempProgTrack = t;                          // remember PROG track
+        setTrackMode(t, TRACK_MODE_MAIN);
+        // setPower() of the track called after
+        // seperately after setJoin() instead
+        break;  // there is only one prog track, done
@@ -677 +676 @@ void TrackManager::setJoin(bool joined) {
-    if (tempProgTrack != MAX_TRACKS+1) {
+    if (tempProgTrack != MAX_TRACKS + 1) {
@@ -680,4 +679,4 @@ void TrackManager::setJoin(bool joined) {
-      POWERMODE tPTmode = track[tempProgTrack]->getPower(); // get current power status of this track
-      setTrackMode(tempProgTrack, TRACK_MODE_PROG);         // set track mode back to prog
-      track[tempProgTrack]->setPower(tPTmode);              // set power status as it was before
-      tempProgTrack = MAX_TRACKS+1;
+      POWERMODE tPTmode = track[tempProgTrack]->getPower();  // get current power status of this track
+      setTrackMode(tempProgTrack, TRACK_MODE_PROG);          // set track mode back to prog
+      track[tempProgTrack]->setPower(tPTmode);               // set power status as it was before
+      tempProgTrack = MAX_TRACKS + 1;
@@ -687,2 +686,3 @@ void TrackManager::setJoin(bool joined) {
-  progTrackSyncMain=joined;
-  if (joinRelay!=UNUSED_PIN) digitalWrite(joinRelay,joined?HIGH:LOW);
+  progTrackSyncMain = joined;
+  if (joinRelay != UNUSED_PIN)
+    digitalWrite(joinRelay, joined ? HIGH : LOW);
@@ -692,4 +692,4 @@ bool TrackManager::isPowerOn(byte t) {
-      if (track[t]->getPower()!=POWERMODE::ON) 
-	        return false;
-    return true;   
-  }
+  if (track[t]->getPower() != POWERMODE::ON)
+    return false;
+  return true;
+}
@@ -698,3 +698,3 @@ bool TrackManager::isProg(byte t) {
-    if (track[t]->getMode() & TRACK_MODE_PROG)
-        return true;
-    return false;
+  if (track[t]->getMode() & TRACK_MODE_PROG)
+    return true;
+  return false;
@@ -704 +704 @@ TRACK_MODE TrackManager::getMode(byte t) {
-    return (track[t]->getMode());
+  return (track[t]->getMode());
@@ -708 +708 @@ int16_t TrackManager::returnDCAddr(byte t) {
-    return (trackDCAddr[t]);
+  return (trackDCAddr[t]);
diff --git a/TrackManager.h b/TrackManager.h
index 7dce0ee..afa9bf2 100644
--- a/TrackManager.h
+++ b/TrackManager.h
@@ -5 +5 @@
- * 
+ *
@@ -7 +7 @@
- *  
+ *
@@ -33,8 +33,8 @@
-const byte TRACK_NUMBER_0=0, TRACK_NUMBER_A=0;    
-const byte TRACK_NUMBER_1=1, TRACK_NUMBER_B=1;    
-const byte TRACK_NUMBER_2=2, TRACK_NUMBER_C=2;    
-const byte TRACK_NUMBER_3=3, TRACK_NUMBER_D=3;    
-const byte TRACK_NUMBER_4=4, TRACK_NUMBER_E=4;    
-const byte TRACK_NUMBER_5=5, TRACK_NUMBER_F=5;    
-const byte TRACK_NUMBER_6=6, TRACK_NUMBER_G=6;    
-const byte TRACK_NUMBER_7=7, TRACK_NUMBER_H=7;    
+const byte TRACK_NUMBER_0 = 0, TRACK_NUMBER_A = 0;
+const byte TRACK_NUMBER_1 = 1, TRACK_NUMBER_B = 1;
+const byte TRACK_NUMBER_2 = 2, TRACK_NUMBER_C = 2;
+const byte TRACK_NUMBER_3 = 3, TRACK_NUMBER_D = 3;
+const byte TRACK_NUMBER_4 = 4, TRACK_NUMBER_E = 4;
+const byte TRACK_NUMBER_5 = 5, TRACK_NUMBER_F = 5;
+const byte TRACK_NUMBER_6 = 6, TRACK_NUMBER_G = 6;
+const byte TRACK_NUMBER_7 = 7, TRACK_NUMBER_H = 7;
@@ -43,2 +43,2 @@ const byte TRACK_NUMBER_7=7, TRACK_NUMBER_H=7;
-const byte TRACK_POWER_0=0, TRACK_POWER_OFF=0;    
-const byte TRACK_POWER_1=1, TRACK_POWER_ON=1;   
+const byte TRACK_POWER_0 = 0, TRACK_POWER_OFF = 0;
+const byte TRACK_POWER_1 = 1, TRACK_POWER_ON = 1;
@@ -47,16 +47,9 @@ class TrackManager {
-  public:
-    static void Setup(const FSH * shieldName,
-                 MotorDriver * track0=NULL,
-                 MotorDriver * track1=NULL,
-                 MotorDriver * track2=NULL,
-                 MotorDriver * track3=NULL,
-                 MotorDriver * track4=NULL,
-                 MotorDriver * track5=NULL,
-                 MotorDriver * track6=NULL,
-                 MotorDriver * track7=NULL
-                 );
-    
-    static void setDCCSignal( bool on);
-    static void setPROGSignal( bool on);
-    static void setDCSignal(int16_t cab, byte speedbyte);
-    static MotorDriver * getProgDriver();
+ public:
+  static void Setup(const FSH* shieldName, MotorDriver* track0 = NULL, MotorDriver* track1 = NULL, MotorDriver* track2 = NULL,
+                    MotorDriver* track3 = NULL, MotorDriver* track4 = NULL, MotorDriver* track5 = NULL, MotorDriver* track6 = NULL,
+                    MotorDriver* track7 = NULL);
+
+  static void setDCCSignal(bool on);
+  static void setPROGSignal(bool on);
+  static void setDCSignal(int16_t cab, byte speedbyte);
+  static MotorDriver* getProgDriver();
@@ -64 +57 @@ class TrackManager {
-    static std::vector<MotorDriver *>getMainDrivers();
+  static std::vector<MotorDriver*> getMainDrivers();
@@ -66,6 +58,0 @@ class TrackManager {
-  
-    static void setPower(POWERMODE mode) {setMainPower(mode); setProgPower(mode);}
-    static void setTrackPower(POWERMODE mode, byte t);
-    static void setTrackPower(TRACK_MODE trackmode, POWERMODE powermode);
-    static void setMainPower(POWERMODE mode) {setTrackPower(TRACK_MODE_MAIN, mode);}
-    static void setProgPower(POWERMODE mode) {setTrackPower(TRACK_MODE_PROG, mode);}
@@ -73,24 +60,43 @@ class TrackManager {
-    static const int16_t MAX_TRACKS=8;
-    static bool setTrackMode(byte track, TRACK_MODE mode, int16_t DCaddr=0);
-    static bool parseEqualSign(Print * stream,  int16_t params, int16_t p[]);
-    static void loop();
-    static POWERMODE getMainPower();
-    static POWERMODE getProgPower();
-    static inline POWERMODE getPower(byte t) { return track[t]->getPower(); }
-    static bool getPower(byte t, char s[]);
-    static void setJoin(bool join);
-    static bool isJoined() { return progTrackSyncMain;}
-    static inline bool isActive (byte tr) {
-      if (tr > lastTrack) return false;
-      return track[tr]->getMode() & (TRACK_MODE_MAIN|TRACK_MODE_PROG|TRACK_MODE_DC|TRACK_MODE_BOOST|TRACK_MODE_EXT);}
-    static void setJoinRelayPin(byte joinRelayPin);
-    static void sampleCurrent();
-    static void reportGauges(Print* stream);
-    static void reportCurrent(Print* stream);
-    static void reportObsoleteCurrent(Print* stream); 
-    static void streamTrackState(Print* stream, byte t);
-    static bool isPowerOn(byte t);
-    static bool isProg(byte t);
-    static TRACK_MODE getMode(byte t);
-    static int16_t returnDCAddr(byte t);
-    static const FSH* getModeName(TRACK_MODE Mode);
+  static void setPower(POWERMODE mode) {
+    setMainPower(mode);
+    setProgPower(mode);
+  }
+  static void setTrackPower(POWERMODE mode, byte t);
+  static void setTrackPower(TRACK_MODE trackmode, POWERMODE powermode);
+  static void setMainPower(POWERMODE mode) {
+    setTrackPower(TRACK_MODE_MAIN, mode);
+  }
+  static void setProgPower(POWERMODE mode) {
+    setTrackPower(TRACK_MODE_PROG, mode);
+  }
+
+  static const int16_t MAX_TRACKS = 8;
+  static bool setTrackMode(byte track, TRACK_MODE mode, int16_t DCaddr = 0);
+  static bool parseEqualSign(Print* stream, int16_t params, int16_t p[]);
+  static void loop();
+  static POWERMODE getMainPower();
+  static POWERMODE getProgPower();
+  static inline POWERMODE getPower(byte t) {
+    return track[t]->getPower();
+  }
+  static bool getPower(byte t, char s[]);
+  static void setJoin(bool join);
+  static bool isJoined() {
+    return progTrackSyncMain;
+  }
+  static inline bool isActive(byte tr) {
+    if (tr > lastTrack)
+      return false;
+    return track[tr]->getMode() & (TRACK_MODE_MAIN | TRACK_MODE_PROG | TRACK_MODE_DC | TRACK_MODE_BOOST | TRACK_MODE_EXT);
+  }
+  static void setJoinRelayPin(byte joinRelayPin);
+  static void sampleCurrent();
+  static void reportGauges(Print* stream);
+  static void reportCurrent(Print* stream);
+  static void reportObsoleteCurrent(Print* stream);
+  static void streamTrackState(Print* stream, byte t);
+  static bool isPowerOn(byte t);
+  static bool isProg(byte t);
+  static TRACK_MODE getMode(byte t);
+  static int16_t returnDCAddr(byte t);
+  static const FSH* getModeName(TRACK_MODE Mode);
@@ -98,3 +104,3 @@ class TrackManager {
-    static int16_t joinRelay;
-    static bool progTrackSyncMain;  // true when prog track is a siding switched to main
-    static bool progTrackBoosted;   // true when prog track is not current limited
+  static int16_t joinRelay;
+  static bool progTrackSyncMain;  // true when prog track is a siding switched to main
+  static bool progTrackBoosted;   // true when prog track is not current limited
@@ -103 +109 @@ class TrackManager {
-  public:
+ public:
@@ -105 +111 @@ class TrackManager {
-  private:
+ private:
@@ -107 +113 @@ class TrackManager {
-    static MotorDriver* track[MAX_TRACKS];
+  static MotorDriver* track[MAX_TRACKS];
@@ -109,5 +115,5 @@ class TrackManager {
-  private:
-    static void addTrack(byte t, MotorDriver* driver);
-    static int8_t lastTrack;
-    static byte nextCycleTrack;
-    static void applyDCSpeed(byte t);
+ private:
+  static void addTrack(byte t, MotorDriver* driver);
+  static int8_t lastTrack;
+  static byte nextCycleTrack;
+  static void applyDCSpeed(byte t);
@@ -115 +121 @@ class TrackManager {
-    static int16_t trackDCAddr[MAX_TRACKS];  // dc address if TRACK_MODE_DC
+  static int16_t trackDCAddr[MAX_TRACKS];  // dc address if TRACK_MODE_DC
@@ -117 +123 @@ class TrackManager {
-    static byte tempProgTrack; // holds the prog track number during join
+  static byte tempProgTrack;  // holds the prog track number during join
@@ -119 +125 @@ class TrackManager {
-    };
+};
diff --git a/Turnouts.cpp b/Turnouts.cpp
index dfe9615..60a218a 100644
--- a/Turnouts.cpp
+++ b/Turnouts.cpp
@@ -9 +9 @@
- *  
+ *
@@ -26 +25,0 @@
-
@@ -41,21 +40,10 @@
-  /* 
-   * Protected static data
-   */ 
-
-  /* static */ Turnout *Turnout::_firstTurnout = 0;
-
-  /* 
-   * Public static data
-   */
-  /* static */ int Turnout::turnoutlistHash = 0;
- 
-  /*
-   * Protected static functions
-   */
-
-  /* static */ Turnout *Turnout::get(uint16_t id) {
-    // Find turnout object from list.
-    for (Turnout *tt = _firstTurnout; tt != NULL; tt = tt->_nextTurnout)
-      if (tt->_turnoutData.id == id) return tt;
-    return NULL;
-  }
+/*
+ * Protected static data
+ */
+
+/* static */ Turnout* Turnout::_firstTurnout = 0;
+
+/*
+ * Public static data
+ */
+/* static */ int Turnout::turnoutlistHash = 0;
@@ -63,10 +51,20 @@
-  // Add new turnout to end of chain
-  /* static */ void Turnout::add(Turnout *tt) {
-    if (!_firstTurnout) 
-      _firstTurnout = tt;
-    else {
-      // Find last object on chain
-      Turnout *ptr = _firstTurnout;
-      for ( ; ptr->_nextTurnout!=0; ptr=ptr->_nextTurnout) {}
-      // Line new object to last object.
-      ptr->_nextTurnout = tt;
+/*
+ * Protected static functions
+ */
+
+/* static */ Turnout* Turnout::get(uint16_t id) {
+  // Find turnout object from list.
+  for (Turnout* tt = _firstTurnout; tt != NULL; tt = tt->_nextTurnout)
+    if (tt->_turnoutData.id == id)
+      return tt;
+  return NULL;
+}
+
+// Add new turnout to end of chain
+/* static */ void Turnout::add(Turnout* tt) {
+  if (!_firstTurnout)
+    _firstTurnout = tt;
+  else {
+    // Find last object on chain
+    Turnout* ptr = _firstTurnout;
+    for (; ptr->_nextTurnout != 0; ptr = ptr->_nextTurnout) {
@@ -74 +72,2 @@
-    turnoutlistHash++;
+    // Line new object to last object.
+    ptr->_nextTurnout = tt;
@@ -76,32 +75,8 @@
-  
-  
-
-  // Remove nominated turnout from turnout linked list and delete the object.
-  /* static */ bool Turnout::remove(uint16_t id) {
-    Turnout *tt,*pp=NULL;
-
-    for(tt=_firstTurnout; tt!=NULL && tt->_turnoutData.id!=id; pp=tt, tt=tt->_nextTurnout) {}
-    if (tt == NULL) return false;
-    
-    if (tt == _firstTurnout)
-      _firstTurnout = tt->_nextTurnout;
-    else
-      pp->_nextTurnout = tt->_nextTurnout;
-
-    delete (ServoTurnout *)tt;
-
-    turnoutlistHash++;
-    return true; 
-  } 
-
-
-  /*
-   * Public static functions
-   */
-
-  /* static */ bool Turnout::isClosed(uint16_t id) {
-    Turnout *tt = get(id);
-    if (tt) 
-      return tt->isClosed();
-    else
-      return false;
+  turnoutlistHash++;
+}
+
+// Remove nominated turnout from turnout linked list and delete the object.
+/* static */ bool Turnout::remove(uint16_t id) {
+  Turnout *tt, *pp = NULL;
+
+  for (tt = _firstTurnout; tt != NULL && tt->_turnoutData.id != id; pp = tt, tt = tt->_nextTurnout) {
@@ -108,0 +84,2 @@
+  if (tt == NULL)
+    return false;
@@ -110,10 +87,34 @@
-  /* static */ bool Turnout::setClosedStateOnly(uint16_t id, bool closeFlag) {
-    Turnout *tt = get(id);
-    if (!tt) return false;
-    // I know it says setClosedStateOnly, but we need to tell others
-    // that the state has changed too. But we only broadcast if there
-    // really has been a change.
-    if (tt->_turnoutData.closed != closeFlag) {
-      tt->_turnoutData.closed = closeFlag;
-      CommandDistributor::broadcastTurnout(id, closeFlag);
-    }
+  if (tt == _firstTurnout)
+    _firstTurnout = tt->_nextTurnout;
+  else
+    pp->_nextTurnout = tt->_nextTurnout;
+
+  delete (ServoTurnout*)tt;
+
+  turnoutlistHash++;
+  return true;
+}
+
+/*
+ * Public static functions
+ */
+
+/* static */ bool Turnout::isClosed(uint16_t id) {
+  Turnout* tt = get(id);
+  if (tt)
+    return tt->isClosed();
+  else
+    return false;
+}
+
+/* static */ bool Turnout::setClosedStateOnly(uint16_t id, bool closeFlag) {
+  Turnout* tt = get(id);
+  if (!tt)
+    return false;
+  // I know it says setClosedStateOnly, but we need to tell others
+  // that the state has changed too. But we only broadcast if there
+  // really has been a change.
+  if (tt->_turnoutData.closed != closeFlag) {
+    tt->_turnoutData.closed = closeFlag;
+    CommandDistributor::broadcastTurnout(id, closeFlag);
+  }
@@ -121 +122 @@
-    RMFT2::turnoutEvent(id, closeFlag);
+  RMFT2::turnoutEvent(id, closeFlag);
@@ -123,8 +124,8 @@
-    return true;
-  }
-
-  // Static setClosed function is invoked from close(), throw() etc. to perform the 
-  //  common parts of the turnout operation.  Code which is specific to a turnout
-  //  type should be placed in the virtual function setClosedInternal(bool) which is
-  //  called from here.
-  /* static */ bool Turnout::setClosed(uint16_t id, bool closeFlag) { 
+  return true;
+}
+
+// Static setClosed function is invoked from close(), throw() etc. to perform the
+//  common parts of the turnout operation.  Code which is specific to a turnout
+//  type should be placed in the virtual function setClosedInternal(bool) which is
+//  called from here.
+/* static */ bool Turnout::setClosed(uint16_t id, bool closeFlag) {
@@ -132 +133 @@
-    DIAG(F("Turnout(%d,%c)"), id, closeFlag ? 'c':'t');
+  DIAG(F("Turnout(%d,%c)"), id, closeFlag ? 'c' : 't');
@@ -134,3 +135,4 @@
-    Turnout *tt = Turnout::get(id);
-    if (!tt) return false;
-    bool ok = tt->setClosedInternal(closeFlag);
+  Turnout* tt = Turnout::get(id);
+  if (!tt)
+    return false;
+  bool ok = tt->setClosedInternal(closeFlag);
@@ -138,2 +140,2 @@
-    if (ok) {
-      tt->setClosedStateOnly(id, closeFlag);
+  if (ok) {
+    tt->setClosedStateOnly(id, closeFlag);
@@ -141,4 +143,4 @@
-      // Write byte containing new closed/thrown state to EEPROM if required.  Note that eepromAddress
-      // is always zero for LCN turnouts.
-      if (EEStore::eeStore->data.nTurnouts > 0 && tt->_eepromAddress > 0) 
-        EEPROM.put(tt->_eepromAddress, tt->_turnoutData.flags);
+    // Write byte containing new closed/thrown state to EEPROM if required.  Note that eepromAddress
+    // is always zero for LCN turnouts.
+    if (EEStore::eeStore->data.nTurnouts > 0 && tt->_eepromAddress > 0)
+      EEPROM.put(tt->_eepromAddress, tt->_turnoutData.flags);
@@ -146,2 +147,0 @@
-    }
-    return ok;
@@ -148,0 +149,2 @@
+  return ok;
+}
@@ -151,5 +153,4 @@
-  // Load all turnout objects
-  /* static */ void Turnout::load() {
-    for (uint16_t i=0; i<EEStore::eeStore->data.nTurnouts; i++) {
-      Turnout::loadTurnout();
-    }
+// Load all turnout objects
+/* static */ void Turnout::load() {
+  for (uint16_t i = 0; i < EEStore::eeStore->data.nTurnouts; i++) {
+    Turnout::loadTurnout();
@@ -157,8 +158,41 @@
-
-  // Save all turnout objects
-  /* static */ void Turnout::store() {
-    EEStore::eeStore->data.nTurnouts=0;
-    for (Turnout *tt = _firstTurnout; tt != 0; tt = tt->_nextTurnout) {
-      tt->save();
-      EEStore::eeStore->data.nTurnouts++;
-    }
+}
+
+// Save all turnout objects
+/* static */ void Turnout::store() {
+  EEStore::eeStore->data.nTurnouts = 0;
+  for (Turnout* tt = _firstTurnout; tt != 0; tt = tt->_nextTurnout) {
+    tt->save();
+    EEStore::eeStore->data.nTurnouts++;
+  }
+}
+
+// Load one turnout from EEPROM
+/* static */ Turnout* Turnout::loadTurnout() {
+  Turnout* tt = 0;
+  // Read turnout type from EEPROM
+  struct TurnoutData turnoutData;
+  int eepromAddress = EEStore::pointer() + offsetof(struct TurnoutData, flags);  // Address of byte containing the closed flag.
+  EEPROM.get(EEStore::pointer(), turnoutData);
+  EEStore::advance(sizeof(turnoutData));
+
+  switch (turnoutData.turnoutType) {
+    case TURNOUT_SERVO:
+      // Servo turnout
+      tt = ServoTurnout::load(&turnoutData);
+      break;
+    case TURNOUT_DCC:
+      // DCC Accessory turnout
+      tt = DCCTurnout::load(&turnoutData);
+      break;
+    case TURNOUT_VPIN:
+      // VPIN turnout
+      tt = VpinTurnout::load(&turnoutData);
+      break;
+    default:
+      // If we find anything else, then we don't know what it is or how long it is,
+      // so we can't go any further through the EEPROM!
+      return NULL;
+  }
+  if (tt) {
+    // Save EEPROM address in object.  Note that LCN turnouts always have eepromAddress of zero.
+    tt->_eepromAddress = eepromAddress + offsetof(struct TurnoutData, flags);
@@ -166,32 +199,0 @@
-
-  // Load one turnout from EEPROM
-  /* static */ Turnout *Turnout::loadTurnout () {
-    Turnout *tt = 0;
-    // Read turnout type from EEPROM
-    struct TurnoutData turnoutData;
-    int eepromAddress = EEStore::pointer() + offsetof(struct TurnoutData, flags); // Address of byte containing the closed flag.
-    EEPROM.get(EEStore::pointer(), turnoutData);
-    EEStore::advance(sizeof(turnoutData));
-
-    switch (turnoutData.turnoutType) {
-      case TURNOUT_SERVO:
-        // Servo turnout
-        tt = ServoTurnout::load(&turnoutData);
-        break;
-      case TURNOUT_DCC:
-        // DCC Accessory turnout
-        tt = DCCTurnout::load(&turnoutData);
-        break;
-      case TURNOUT_VPIN:
-        // VPIN turnout
-        tt = VpinTurnout::load(&turnoutData);
-        break;
-      default:
-        // If we find anything else, then we don't know what it is or how long it is, 
-        // so we can't go any further through the EEPROM!
-        return NULL;
-    }
-    if (tt) {
-      // Save EEPROM address in object.  Note that LCN turnouts always have eepromAddress of zero.
-      tt->_eepromAddress = eepromAddress + offsetof(struct TurnoutData, flags);
-    }
@@ -200 +202 @@
-    printAll(&USB_SERIAL);
+  printAll(&USB_SERIAL);
@@ -202,2 +204,2 @@
-    return tt;
-  }
+  return tt;
+}
@@ -208 +210 @@
- * 
+ *
@@ -211,12 +213,11 @@
-  // Private Constructor
-  ServoTurnout::ServoTurnout(uint16_t id, VPIN vpin, uint16_t thrownPosition, uint16_t closedPosition, uint8_t profile, bool closed) :
-    Turnout(id, TURNOUT_SERVO, closed) 
-  {
-    _servoTurnoutData.vpin = vpin;
-    _servoTurnoutData.thrownPosition = thrownPosition; 
-    _servoTurnoutData.closedPosition = closedPosition;
-    _servoTurnoutData.profile = profile;
-  }
-
-  // Create function
-  /* static */ Turnout *ServoTurnout::create(uint16_t id, VPIN vpin, uint16_t thrownPosition, uint16_t closedPosition, uint8_t profile, bool closed) {
+// Private Constructor
+ServoTurnout::ServoTurnout(uint16_t id, VPIN vpin, uint16_t thrownPosition, uint16_t closedPosition, uint8_t profile, bool closed)
+    : Turnout(id, TURNOUT_SERVO, closed) {
+  _servoTurnoutData.vpin = vpin;
+  _servoTurnoutData.thrownPosition = thrownPosition;
+  _servoTurnoutData.closedPosition = closedPosition;
+  _servoTurnoutData.profile = profile;
+}
+
+// Create function
+/* static */ Turnout* ServoTurnout::create(uint16_t id, VPIN vpin, uint16_t thrownPosition, uint16_t closedPosition, uint8_t profile, bool closed) {
@@ -224,26 +225,25 @@
-    Turnout *tt = get(id);
-    if (tt) { 
-      // Object already exists, check if it is usable
-      if (tt->isType(TURNOUT_SERVO)) {
-        // Yes, so set parameters
-        ServoTurnout *st = (ServoTurnout *)tt;
-        st->_servoTurnoutData.vpin = vpin;
-        st->_servoTurnoutData.thrownPosition = thrownPosition;
-        st->_servoTurnoutData.closedPosition = closedPosition;
-        st->_servoTurnoutData.profile = profile;
-        // Don't touch the _closed parameter, retain the original value.
-
-        // We don't really need to do the following, since a call to IODevice::_writeAnalogue 
-        //  will provide all the data that is required!  However, if someone has configured 
-        //  a Turnout, we should ensure that the SET() RESET() and other commands that use write() 
-        //  behave consistently with the turnout commands.
-        IODevice::configureServo(vpin, thrownPosition, closedPosition, profile, 0, closed);
-
-        // Set position directly to specified position - we don't know where it is moving from.
-        IODevice::writeAnalogue(vpin, closed ? closedPosition : thrownPosition, PCA9685::Instant);
-
-        return tt;
-      } else {
-        // Incompatible object, delete and recreate
-        remove(id);
-      }
+  Turnout* tt = get(id);
+  if (tt) {
+    // Object already exists, check if it is usable
+    if (tt->isType(TURNOUT_SERVO)) {
+      // Yes, so set parameters
+      ServoTurnout* st = (ServoTurnout*)tt;
+      st->_servoTurnoutData.vpin = vpin;
+      st->_servoTurnoutData.thrownPosition = thrownPosition;
+      st->_servoTurnoutData.closedPosition = closedPosition;
+      st->_servoTurnoutData.profile = profile;
+      // Don't touch the _closed parameter, retain the original value.
+
+      // We don't really need to do the following, since a call to IODevice::_writeAnalogue
+      //  will provide all the data that is required!  However, if someone has configured
+      //  a Turnout, we should ensure that the SET() RESET() and other commands that use write()
+      //  behave consistently with the turnout commands.
+      IODevice::configureServo(vpin, thrownPosition, closedPosition, profile, 0, closed);
+
+      // Set position directly to specified position - we don't know where it is moving from.
+      IODevice::writeAnalogue(vpin, closed ? closedPosition : thrownPosition, PCA9685::Instant);
+
+      return tt;
+    } else {
+      // Incompatible object, delete and recreate
+      remove(id);
@@ -251,4 +251,5 @@
-    tt = (Turnout *)new ServoTurnout(id, vpin, thrownPosition, closedPosition, profile, closed);
-    DIAG(F("Turnout 0x%x size %d size %d"), tt, sizeof(Turnout),sizeof(struct TurnoutData));
-    IODevice::writeAnalogue(vpin, closed ? closedPosition : thrownPosition, PCA9685::Instant);
-    return tt;
+  }
+  tt = (Turnout*)new ServoTurnout(id, vpin, thrownPosition, closedPosition, profile, closed);
+  DIAG(F("Turnout 0x%x size %d size %d"), tt, sizeof(Turnout), sizeof(struct TurnoutData));
+  IODevice::writeAnalogue(vpin, closed ? closedPosition : thrownPosition, PCA9685::Instant);
+  return tt;
@@ -256,3 +257,7 @@
-    (void)id; (void)vpin; (void)thrownPosition; (void)closedPosition;
-    (void)profile; (void)closed;          // avoid compiler warnings.
-    return NULL;
+  (void)id;
+  (void)vpin;
+  (void)thrownPosition;
+  (void)closedPosition;
+  (void)profile;
+  (void)closed;  // avoid compiler warnings.
+  return NULL;
@@ -260 +265 @@
-  }
+}
@@ -262,2 +267,2 @@
-  // Load a Servo turnout definition from EEPROM.  The common Turnout data has already been read at this point.
-  Turnout *ServoTurnout::load(struct TurnoutData *turnoutData) {
+// Load a Servo turnout definition from EEPROM.  The common Turnout data has already been read at this point.
+Turnout* ServoTurnout::load(struct TurnoutData* turnoutData) {
@@ -265,9 +270,9 @@
-    ServoTurnoutData servoTurnoutData;
-    // Read class-specific data from EEPROM
-    EEPROM.get(EEStore::pointer(), servoTurnoutData);
-    EEStore::advance(sizeof(servoTurnoutData));
-    
-    // Create new object
-    Turnout *tt = ServoTurnout::create(turnoutData->id, servoTurnoutData.vpin, servoTurnoutData.thrownPosition,
-      servoTurnoutData.closedPosition, servoTurnoutData.profile, turnoutData->closed);
-    return tt;
+  ServoTurnoutData servoTurnoutData;
+  // Read class-specific data from EEPROM
+  EEPROM.get(EEStore::pointer(), servoTurnoutData);
+  EEStore::advance(sizeof(servoTurnoutData));
+
+  // Create new object
+  Turnout* tt = ServoTurnout::create(turnoutData->id, servoTurnoutData.vpin, servoTurnoutData.thrownPosition, servoTurnoutData.closedPosition,
+                                     servoTurnoutData.profile, turnoutData->closed);
+  return tt;
@@ -275,2 +280,2 @@
-    (void)turnoutData;
-    return NULL;
+  (void)turnoutData;
+  return NULL;
@@ -278 +283 @@
-  }
+}
@@ -280,6 +285,5 @@
-  // For DCC++ classic compatibility, state reported to JMRI is 1 for thrown and 0 for closed
-  void ServoTurnout::print(Print *stream) {
-    StringFormatter::send(stream, F("<H %d SERVO %d %d %d %d %d>\n"), _turnoutData.id, _servoTurnoutData.vpin, 
-      _servoTurnoutData.thrownPosition, _servoTurnoutData.closedPosition, _servoTurnoutData.profile, 
-      !_turnoutData.closed);
-  }
+// For DCC++ classic compatibility, state reported to JMRI is 1 for thrown and 0 for closed
+void ServoTurnout::print(Print* stream) {
+  StringFormatter::send(stream, F("<H %d SERVO %d %d %d %d %d>\n"), _turnoutData.id, _servoTurnoutData.vpin, _servoTurnoutData.thrownPosition,
+                        _servoTurnoutData.closedPosition, _servoTurnoutData.profile, !_turnoutData.closed);
+}
@@ -287,2 +291,2 @@
-  // ServoTurnout-specific code for throwing or closing a servo turnout.
-  bool ServoTurnout::setClosedInternal(bool close) {
+// ServoTurnout-specific code for throwing or closing a servo turnout.
+bool ServoTurnout::setClosedInternal(bool close) {
@@ -290,2 +294,2 @@
-    IODevice::writeAnalogue(_servoTurnoutData.vpin, 
-      close ? _servoTurnoutData.closedPosition : _servoTurnoutData.thrownPosition, _servoTurnoutData.profile);
+  IODevice::writeAnalogue(_servoTurnoutData.vpin, close ? _servoTurnoutData.closedPosition : _servoTurnoutData.thrownPosition,
+                          _servoTurnoutData.profile);
@@ -293 +297 @@
-    (void)close;  // avoid compiler warnings
+  (void)close;  // avoid compiler warnings
@@ -295,2 +299,2 @@
-    return true;
-  }
+  return true;
+}
@@ -298 +302 @@
-  void ServoTurnout::save() {
+void ServoTurnout::save() {
@@ -300,7 +304,7 @@
-    // Write turnout definition and current position to EEPROM
-    // First write common servo data, then
-    // write the servo-specific data
-    EEPROM.put(EEStore::pointer(), _turnoutData);
-    EEStore::advance(sizeof(_turnoutData));
-    EEPROM.put(EEStore::pointer(), _servoTurnoutData);
-    EEStore::advance(sizeof(_servoTurnoutData));
+  // Write turnout definition and current position to EEPROM
+  // First write common servo data, then
+  // write the servo-specific data
+  EEPROM.put(EEStore::pointer(), _turnoutData);
+  EEStore::advance(sizeof(_turnoutData));
+  EEPROM.put(EEStore::pointer(), _servoTurnoutData);
+  EEStore::advance(sizeof(_servoTurnoutData));
@@ -308 +312 @@
-  }
+}
@@ -312 +316 @@
- * 
+ *
@@ -315,32 +319,29 @@
-  // DCCTurnoutData contains data specific to this subclass that is 
-  // written to EEPROM when the turnout is saved.
-  struct DCCTurnoutData {
-    // DCC address (Address in bits 15-2, subaddress in bits 1-0
-    uint16_t address; // CS currently supports linear address 1-2048
-      // That's DCC accessory address 1-512 and subaddress 0-3.
-  } _dccTurnoutData; // 2 bytes
-
-  // Constructor
-  DCCTurnout::DCCTurnout(uint16_t id, uint16_t address, uint8_t subAdd) :
-    Turnout(id, TURNOUT_DCC, false)
-  {
-    _dccTurnoutData.address = address;
-    _dccTurnoutData.subAddress = subAdd;
-  }
-
-  // Create function
-  /* static */ Turnout *DCCTurnout::create(uint16_t id, uint16_t add, uint8_t subAdd) {
-    Turnout *tt = get(id);
-    if (tt) { 
-      // Object already exists, check if it is usable
-      if (tt->isType(TURNOUT_DCC)) {
-        // Yes, so set parameters<T>
-        DCCTurnout *dt = (DCCTurnout *)tt;
-        dt->_dccTurnoutData.address = add;
-        dt->_dccTurnoutData.subAddress = subAdd;
-        // Don't touch the _closed parameter, retain the original value.
-        return tt;
-      } else {
-        // Incompatible object, delete and recreate
-        remove(id);
-      }
+// DCCTurnoutData contains data specific to this subclass that is
+// written to EEPROM when the turnout is saved.
+struct DCCTurnoutData {
+  // DCC address (Address in bits 15-2, subaddress in bits 1-0
+  uint16_t address;  // CS currently supports linear address 1-2048
+                     // That's DCC accessory address 1-512 and subaddress 0-3.
+} _dccTurnoutData;   // 2 bytes
+
+// Constructor
+DCCTurnout::DCCTurnout(uint16_t id, uint16_t address, uint8_t subAdd) : Turnout(id, TURNOUT_DCC, false) {
+  _dccTurnoutData.address = address;
+  _dccTurnoutData.subAddress = subAdd;
+}
+
+// Create function
+/* static */ Turnout* DCCTurnout::create(uint16_t id, uint16_t add, uint8_t subAdd) {
+  Turnout* tt = get(id);
+  if (tt) {
+    // Object already exists, check if it is usable
+    if (tt->isType(TURNOUT_DCC)) {
+      // Yes, so set parameters<T>
+      DCCTurnout* dt = (DCCTurnout*)tt;
+      dt->_dccTurnoutData.address = add;
+      dt->_dccTurnoutData.subAddress = subAdd;
+      // Don't touch the _closed parameter, retain the original value.
+      return tt;
+    } else {
+      // Incompatible object, delete and recreate
+      remove(id);
@@ -348,2 +348,0 @@
-    tt = (Turnout *)new DCCTurnout(id, add, subAdd);
-    return tt;
@@ -350,0 +350,3 @@
+  tt = (Turnout*)new DCCTurnout(id, add, subAdd);
+  return tt;
+}
@@ -352,2 +354,2 @@
-  // Load a DCC turnout definition from EEPROM.  The common Turnout data has already been read at this point.
-  /* static */ Turnout *DCCTurnout::load(struct TurnoutData *turnoutData) {
+// Load a DCC turnout definition from EEPROM.  The common Turnout data has already been read at this point.
+/* static */ Turnout* DCCTurnout::load(struct TurnoutData* turnoutData) {
@@ -355,14 +357,4 @@
-    DCCTurnoutData dccTurnoutData;
-    // Read class-specific data from EEPROM
-    EEPROM.get(EEStore::pointer(), dccTurnoutData);
-    EEStore::advance(sizeof(dccTurnoutData));
-    
-    // Create new object
-    DCCTurnout *tt = new DCCTurnout(turnoutData->id, dccTurnoutData.address, dccTurnoutData.subAddress);
-
-    return tt;
-#else
-    (void)turnoutData;
-    return NULL;
-#endif
-  }
+  DCCTurnoutData dccTurnoutData;
+  // Read class-specific data from EEPROM
+  EEPROM.get(EEStore::pointer(), dccTurnoutData);
+  EEStore::advance(sizeof(dccTurnoutData));
@@ -370,7 +362,2 @@
-  void DCCTurnout::print(Print *stream) {
-    StringFormatter::send(stream, F("<H %d DCC %d %d %d>\n"), _turnoutData.id, 
-      _dccTurnoutData.address, _dccTurnoutData.subAddress, !_turnoutData.closed); 
-    // Also report using classic DCC++ syntax for DCC accessory turnouts, since JMRI expects this.
-    StringFormatter::send(stream, F("<H %d %d %d %d>\n"), _turnoutData.id, 
-      _dccTurnoutData.address, _dccTurnoutData.subAddress, !_turnoutData.closed); 
-  }
+  // Create new object
+  DCCTurnout* tt = new DCCTurnout(turnoutData->id, dccTurnoutData.address, dccTurnoutData.subAddress);
@@ -378,4 +365,18 @@
-  bool DCCTurnout::setClosedInternal(bool close) {
-    // DCC++ Classic behaviour is that Throw writes a 1 in the packet,
-    // and Close writes a 0.  
-    // RCN-213 specifies that Throw is 0 and Close is 1.
+  return tt;
+#else
+  (void)turnoutData;
+  return NULL;
+#endif
+}
+
+void DCCTurnout::print(Print* stream) {
+  StringFormatter::send(stream, F("<H %d DCC %d %d %d>\n"), _turnoutData.id, _dccTurnoutData.address, _dccTurnoutData.subAddress,
+                        !_turnoutData.closed);
+  // Also report using classic DCC++ syntax for DCC accessory turnouts, since JMRI expects this.
+  StringFormatter::send(stream, F("<H %d %d %d %d>\n"), _turnoutData.id, _dccTurnoutData.address, _dccTurnoutData.subAddress, !_turnoutData.closed);
+}
+
+bool DCCTurnout::setClosedInternal(bool close) {
+  // DCC++ Classic behaviour is that Throw writes a 1 in the packet,
+  // and Close writes a 0.
+  // RCN-213 specifies that Throw is 0 and Close is 1.
@@ -383 +384 @@
-    close = !close;
+  close = !close;
@@ -385,3 +386,3 @@
-    DCC::setAccessory(_dccTurnoutData.address, _dccTurnoutData.subAddress, close);
-    return true;
-  }
+  DCC::setAccessory(_dccTurnoutData.address, _dccTurnoutData.subAddress, close);
+  return true;
+}
@@ -389 +390 @@
-  void DCCTurnout::save() {
+void DCCTurnout::save() {
@@ -391,7 +392,7 @@
-    // Write turnout definition and current position to EEPROM
-    // First write common servo data, then
-    // write the servo-specific data
-    EEPROM.put(EEStore::pointer(), _turnoutData);
-    EEStore::advance(sizeof(_turnoutData));
-    EEPROM.put(EEStore::pointer(), _dccTurnoutData);
-    EEStore::advance(sizeof(_dccTurnoutData));
+  // Write turnout definition and current position to EEPROM
+  // First write common servo data, then
+  // write the servo-specific data
+  EEPROM.put(EEStore::pointer(), _turnoutData);
+  EEStore::advance(sizeof(_turnoutData));
+  EEPROM.put(EEStore::pointer(), _dccTurnoutData);
+  EEStore::advance(sizeof(_dccTurnoutData));
@@ -399,3 +400 @@
-  }
-
-
+}
@@ -405 +404 @@
- * 
+ *
@@ -408,22 +407,19 @@
-  // Constructor
-  VpinTurnout::VpinTurnout(uint16_t id, VPIN vpin, bool closed) :
-    Turnout(id, TURNOUT_VPIN, closed)
-  {
-    _vpinTurnoutData.vpin = vpin;
-  }
-
-  // Create function
-  /* static */ Turnout *VpinTurnout::create(uint16_t id, VPIN vpin, bool closed) {
-    Turnout *tt = get(id);
-    if (tt) { 
-      // Object already exists, check if it is usable
-      if (tt->isType(TURNOUT_VPIN)) {
-        // Yes, so set parameters
-        VpinTurnout *vt = (VpinTurnout *)tt;
-        vt->_vpinTurnoutData.vpin = vpin;
-        // Don't touch the _closed parameter, retain the original value.
-        return tt;
-      } else {
-        // Incompatible object, delete and recreate
-        remove(id);
-      }
+// Constructor
+VpinTurnout::VpinTurnout(uint16_t id, VPIN vpin, bool closed) : Turnout(id, TURNOUT_VPIN, closed) {
+  _vpinTurnoutData.vpin = vpin;
+}
+
+// Create function
+/* static */ Turnout* VpinTurnout::create(uint16_t id, VPIN vpin, bool closed) {
+  Turnout* tt = get(id);
+  if (tt) {
+    // Object already exists, check if it is usable
+    if (tt->isType(TURNOUT_VPIN)) {
+      // Yes, so set parameters
+      VpinTurnout* vt = (VpinTurnout*)tt;
+      vt->_vpinTurnoutData.vpin = vpin;
+      // Don't touch the _closed parameter, retain the original value.
+      return tt;
+    } else {
+      // Incompatible object, delete and recreate
+      remove(id);
@@ -431,2 +426,0 @@
-    tt = (Turnout *)new VpinTurnout(id, vpin, closed);
-    return tt;
@@ -433,0 +428,3 @@
+  tt = (Turnout*)new VpinTurnout(id, vpin, closed);
+  return tt;
+}
@@ -435,2 +432,2 @@
-  // Load a VPIN turnout definition from EEPROM.  The common Turnout data has already been read at this point.
-  /* static */ Turnout *VpinTurnout::load(struct TurnoutData *turnoutData) {
+// Load a VPIN turnout definition from EEPROM.  The common Turnout data has already been read at this point.
+/* static */ Turnout* VpinTurnout::load(struct TurnoutData* turnoutData) {
@@ -438,9 +435,9 @@
-    VpinTurnoutData vpinTurnoutData;
-    // Read class-specific data from EEPROM
-    EEPROM.get(EEStore::pointer(), vpinTurnoutData);
-    EEStore::advance(sizeof(vpinTurnoutData));
-    
-    // Create new object
-    VpinTurnout *tt = new VpinTurnout(turnoutData->id, vpinTurnoutData.vpin, turnoutData->closed);
-
-    return tt;
+  VpinTurnoutData vpinTurnoutData;
+  // Read class-specific data from EEPROM
+  EEPROM.get(EEStore::pointer(), vpinTurnoutData);
+  EEStore::advance(sizeof(vpinTurnoutData));
+
+  // Create new object
+  VpinTurnout* tt = new VpinTurnout(turnoutData->id, vpinTurnoutData.vpin, turnoutData->closed);
+
+  return tt;
@@ -448,2 +445,2 @@
-    (void)turnoutData;
-    return NULL;
+  (void)turnoutData;
+  return NULL;
@@ -451 +448 @@
-  }
+}
@@ -453,5 +450,4 @@
-  // Report 1 for thrown, 0 for closed.
-  void VpinTurnout::print(Print *stream) {
-    StringFormatter::send(stream, F("<H %d VPIN %d %d>\n"), _turnoutData.id, _vpinTurnoutData.vpin, 
-      !_turnoutData.closed); 
-  }
+// Report 1 for thrown, 0 for closed.
+void VpinTurnout::print(Print* stream) {
+  StringFormatter::send(stream, F("<H %d VPIN %d %d>\n"), _turnoutData.id, _vpinTurnoutData.vpin, !_turnoutData.closed);
+}
@@ -459,4 +455,4 @@
-  bool VpinTurnout::setClosedInternal(bool close) {
-    IODevice::write(_vpinTurnoutData.vpin, close);
-    return true;
-  }
+bool VpinTurnout::setClosedInternal(bool close) {
+  IODevice::write(_vpinTurnoutData.vpin, close);
+  return true;
+}
@@ -464 +460 @@
-  void VpinTurnout::save() {
+void VpinTurnout::save() {
@@ -466,7 +462,7 @@
-    // Write turnout definition and current position to EEPROM
-    // First write common servo data, then
-    // write the servo-specific data
-    EEPROM.put(EEStore::pointer(), _turnoutData);
-    EEStore::advance(sizeof(_turnoutData));
-    EEPROM.put(EEStore::pointer(), _vpinTurnoutData);
-    EEStore::advance(sizeof(_vpinTurnoutData));
+  // Write turnout definition and current position to EEPROM
+  // First write common servo data, then
+  // write the servo-specific data
+  EEPROM.put(EEStore::pointer(), _turnoutData);
+  EEStore::advance(sizeof(_turnoutData));
+  EEPROM.put(EEStore::pointer(), _vpinTurnoutData);
+  EEStore::advance(sizeof(_vpinTurnoutData));
@@ -474,2 +470 @@
-  }
-
+}
@@ -479 +474 @@
- * 
+ *
@@ -482,21 +477,19 @@
-  // LCNTurnout has no specific data, and in any case is not written to EEPROM!
-  // struct LCNTurnoutData {
-  // } _lcnTurnoutData; // 0 bytes
-
-  // Constructor
-  LCNTurnout::LCNTurnout(uint16_t id, bool closed) :
-    Turnout(id, TURNOUT_LCN, closed)
-  { }
-
-  // Create function
-  /* static */ Turnout *LCNTurnout::create(uint16_t id, bool closed) {
-    Turnout *tt = get(id);
-    if (tt) { 
-      // Object already exists, check if it is usable
-      if (tt->isType(TURNOUT_LCN)) {
-        // Yes, so return this object
-        return tt;
-      } else {
-        // Incompatible object, delete and recreate
-        remove(id);
-      }
+// LCNTurnout has no specific data, and in any case is not written to EEPROM!
+// struct LCNTurnoutData {
+// } _lcnTurnoutData; // 0 bytes
+
+// Constructor
+LCNTurnout::LCNTurnout(uint16_t id, bool closed) : Turnout(id, TURNOUT_LCN, closed) {
+}
+
+// Create function
+/* static */ Turnout* LCNTurnout::create(uint16_t id, bool closed) {
+  Turnout* tt = get(id);
+  if (tt) {
+    // Object already exists, check if it is usable
+    if (tt->isType(TURNOUT_LCN)) {
+      // Yes, so return this object
+      return tt;
+    } else {
+      // Incompatible object, delete and recreate
+      remove(id);
@@ -504,22 +496,0 @@
-    tt = (Turnout *)new LCNTurnout(id, closed);
-    return tt;
-  }
-
-  bool LCNTurnout::setClosedInternal(bool close) {
-    // Assume that the LCN command still uses 1 for throw and 0 for close...
-    LCN::send('T', _turnoutData.id, !close);
-    // The _turnoutData.closed flag should be updated by a message from the LCN master.
-    // but in this implementation it is updated in setClosedStateOnly() instead.
-    // If the LCN master updates this, setClosedStateOnly() and all setClosedInternal()
-    // have to be updated accordingly so that the closed flag is only set once.
-    return true;
-  }
-
-  // LCN turnouts not saved to EEPROM.
-  //void save() override {  }
-  //static Turnout *load(struct TurnoutData *turnoutData) {
-
-  // Report 1 for thrown, 0 for closed.
-  void LCNTurnout::print(Print *stream) {
-    StringFormatter::send(stream, F("<H %d LCN %d>\n"), _turnoutData.id, 
-    !_turnoutData.closed); 
@@ -526,0 +498,22 @@
+  tt = (Turnout*)new LCNTurnout(id, closed);
+  return tt;
+}
+
+bool LCNTurnout::setClosedInternal(bool close) {
+  // Assume that the LCN command still uses 1 for throw and 0 for close...
+  LCN::send('T', _turnoutData.id, !close);
+  // The _turnoutData.closed flag should be updated by a message from the LCN master.
+  // but in this implementation it is updated in setClosedStateOnly() instead.
+  // If the LCN master updates this, setClosedStateOnly() and all setClosedInternal()
+  // have to be updated accordingly so that the closed flag is only set once.
+  return true;
+}
+
+// LCN turnouts not saved to EEPROM.
+// void save() override {  }
+// static Turnout *load(struct TurnoutData *turnoutData) {
+
+// Report 1 for thrown, 0 for closed.
+void LCNTurnout::print(Print* stream) {
+  StringFormatter::send(stream, F("<H %d LCN %d>\n"), _turnoutData.id, !_turnoutData.closed);
+}
diff --git a/Turnouts.h b/Turnouts.h
index 82baf0a..98c7788 100644
--- a/Turnouts.h
+++ b/Turnouts.h
@@ -9 +9 @@
- *  
+ *
@@ -29 +29 @@
-//#define EESTOREDEBUG 
+// #define EESTOREDEBUG
@@ -44 +44 @@ enum {
- * 
+ *
@@ -48,2 +48,2 @@ class Turnout {
-protected:
-  /* 
+ protected:
+  /*
@@ -53 +53 @@ protected:
-  // The TurnoutData struct contains data common to all turnout types, that 
+  // The TurnoutData struct contains data common to all turnout types, that
@@ -74 +74 @@ protected:
-  // Set to zero if the object has not been saved in EEPROM, e.g. for newly created Turnouts, and 
+  // Set to zero if the object has not been saved in EEPROM, e.g. for newly created Turnouts, and
@@ -80 +80 @@ protected:
-  Turnout *_nextTurnout = 0;
+  Turnout* _nextTurnout = 0;
@@ -89 +89 @@ protected:
-    _turnoutData.hidden=false;
+    _turnoutData.hidden = false;
@@ -93 +93 @@ protected:
-  /* 
+  /*
@@ -95 +95 @@ protected:
-   */ 
+   */
@@ -97 +97 @@ protected:
-  static Turnout *_firstTurnout;
+  static Turnout* _firstTurnout;
@@ -100 +100 @@ protected:
-  /* 
+  /*
@@ -105,2 +105,3 @@ protected:
-  virtual void save() {}
-  
+  virtual void save() {
+  }
+
@@ -110,0 +112 @@ protected:
+  static void add(Turnout* tt);
@@ -112,5 +114,3 @@ protected:
-  static void add(Turnout *tt);
-  
-public:
-  static Turnout *get(uint16_t id);
-  /* 
+ public:
+  static Turnout* get(uint16_t id);
+  /*
@@ -121 +121 @@ public:
-  
+
@@ -125,9 +125,23 @@ public:
-  inline bool isClosed() { return _turnoutData.closed; };
-  inline bool isThrown() { return !_turnoutData.closed; }
-  inline bool isHidden() { return _turnoutData.hidden; }
-  inline void setHidden(bool h) { _turnoutData.hidden=h; }
-  inline bool isType(uint8_t type) { return _turnoutData.turnoutType == type; }
-  inline uint16_t getId() { return _turnoutData.id; }
-  inline Turnout *next() { return _nextTurnout; }
-  void printState(Print *stream);
-  /* 
+  inline bool isClosed() {
+    return _turnoutData.closed;
+  };
+  inline bool isThrown() {
+    return !_turnoutData.closed;
+  }
+  inline bool isHidden() {
+    return _turnoutData.hidden;
+  }
+  inline void setHidden(bool h) {
+    _turnoutData.hidden = h;
+  }
+  inline bool isType(uint8_t type) {
+    return _turnoutData.turnoutType == type;
+  }
+  inline uint16_t getId() {
+    return _turnoutData.id;
+  }
+  inline Turnout* next() {
+    return _nextTurnout;
+  }
+  void printState(Print* stream);
+  /*
@@ -136 +150 @@ public:
-  virtual void print(Print *stream) {
+  virtual void print(Print* stream) {
@@ -139 +153,2 @@ public:
-  virtual ~Turnout() {}   // Destructor
+  virtual ~Turnout() {
+  }  // Destructor
@@ -144 +159,3 @@ public:
-  inline static bool exists(uint16_t id) { return get(id) != 0; }
+  inline static bool exists(uint16_t id) {
+    return get(id) != 0;
+  }
@@ -166 +183,3 @@ public:
-  inline static Turnout *first() { return _firstTurnout; }
+  inline static Turnout* first() {
+    return _firstTurnout;
+  }
@@ -172 +191 @@ public:
-  static Turnout *loadTurnout();
+  static Turnout* loadTurnout();
@@ -176,3 +195,3 @@ public:
-  static bool printAll(Print *stream) {
-    bool gotOne=false;
-    for (Turnout *tt = _firstTurnout; tt != 0; tt = tt->_nextTurnout)
+  static bool printAll(Print* stream) {
+    bool gotOne = false;
+    for (Turnout* tt = _firstTurnout; tt != 0; tt = tt->_nextTurnout)
@@ -180,2 +199,2 @@ public:
-	gotOne=true;
-	StringFormatter::send(stream, F("<H %d %d>\n"),tt->getId(), tt->isThrown());
+        gotOne = true;
+        StringFormatter::send(stream, F("<H %d %d>\n"), tt->getId(), tt->isThrown());
@@ -185,2 +203,0 @@ public:
-
-
@@ -189 +205,0 @@ public:
-
@@ -192 +208 @@ public:
- * 
+ *
@@ -195,2 +211,2 @@ class ServoTurnout : public Turnout {
-private:
-  // ServoTurnoutData contains data specific to this subclass that is 
+ private:
+  // ServoTurnoutData contains data specific to this subclass that is
@@ -203 +219 @@ private:
-  } _servoTurnoutData; // 6 bytes
+  } _servoTurnoutData;  // 6 bytes
@@ -208 +224 @@ private:
-public:
+ public:
@@ -210 +226 @@ public:
-  static Turnout *create(uint16_t id, VPIN vpin, uint16_t thrownPosition, uint16_t closedPosition, uint8_t profile, bool closed=true);
+  static Turnout* create(uint16_t id, VPIN vpin, uint16_t thrownPosition, uint16_t closedPosition, uint8_t profile, bool closed = true);
@@ -213,2 +229,2 @@ public:
-  static Turnout *load(struct TurnoutData *turnoutData);
-  void print(Print *stream) override;
+  static Turnout* load(struct TurnoutData* turnoutData);
+  void print(Print* stream) override;
@@ -216 +232 @@ public:
-protected:
+ protected:
@@ -220 +235,0 @@ protected:
-
@@ -225 +240 @@ protected:
- * 
+ *
@@ -228,2 +243,2 @@ class DCCTurnout : public Turnout {
-private:
-  // DCCTurnoutData contains data specific to this subclass that is 
+ private:
+  // DCCTurnoutData contains data specific to this subclass that is
@@ -237 +252 @@ private:
-  } _dccTurnoutData; // 2 bytes
+  } _dccTurnoutData;  // 2 bytes
@@ -242 +257 @@ private:
-public:
+ public:
@@ -244 +259 @@ public:
-  static Turnout *create(uint16_t id, uint16_t add, uint8_t subAdd);
+  static Turnout* create(uint16_t id, uint16_t add, uint8_t subAdd);
@@ -246,2 +261,2 @@ public:
-  static Turnout *load(struct TurnoutData *turnoutData);
-  void print(Print *stream) override;
+  static Turnout* load(struct TurnoutData* turnoutData);
+  void print(Print* stream) override;
@@ -249 +264 @@ public:
-protected:
+ protected:
@@ -252 +266,0 @@ protected:
-
@@ -255 +268,0 @@ protected:
-
@@ -258 +271 @@ protected:
- * 
+ *
@@ -261,2 +274,2 @@ class VpinTurnout : public Turnout {
-private:
-  // VpinTurnoutData contains data specific to this subclass that is 
+ private:
+  // VpinTurnoutData contains data specific to this subclass that is
@@ -266 +279 @@ private:
-  } _vpinTurnoutData; // 2 bytes
+  } _vpinTurnoutData;  // 2 bytes
@@ -269 +282 @@ private:
- VpinTurnout(uint16_t id, VPIN vpin, bool closed);
+  VpinTurnout(uint16_t id, VPIN vpin, bool closed);
@@ -271 +284 @@ private:
-public:
+ public:
@@ -273 +286 @@ public:
-  static Turnout *create(uint16_t id, VPIN vpin, bool closed=true);
+  static Turnout* create(uint16_t id, VPIN vpin, bool closed = true);
@@ -276,2 +289,2 @@ public:
-  static Turnout *load(struct TurnoutData *turnoutData);
-  void print(Print *stream) override;
+  static Turnout* load(struct TurnoutData* turnoutData);
+  void print(Print* stream) override;
@@ -279 +292 @@ public:
-protected:
+ protected:
@@ -282 +294,0 @@ protected:
-
@@ -285 +296,0 @@ protected:
-
@@ -288 +299 @@ protected:
- * 
+ *
@@ -291 +302 @@ class LCNTurnout : public Turnout {
-private:
+ private:
@@ -296 +307 @@ private:
-  // Constructor 
+  // Constructor
@@ -299 +310 @@ private:
-public:
+ public:
@@ -301,2 +312 @@ public:
-  static Turnout *create(uint16_t id, bool closed=true);
-
+  static Turnout* create(uint16_t id, bool closed = true);
@@ -307,4 +317,2 @@ public:
-  //void save() override {  }
-  //static Turnout *load(struct TurnoutData *turnoutData) {
-
-  void print(Print *stream) override;
+  // void save() override {  }
+  // static Turnout *load(struct TurnoutData *turnoutData) {
@@ -311,0 +320 @@ public:
+  void print(Print* stream) override;
diff --git a/Turntables.cpp b/Turntables.cpp
index f75005c..e5c3f66 100644
--- a/Turntables.cpp
+++ b/Turntables.cpp
@@ -4 +4 @@
- *  
+ *
@@ -35,2 +35 @@
-Turntable *Turntable::_firstTurntable = 0;
-
+Turntable* Turntable::_firstTurntable = 0;
@@ -43 +41,0 @@ int Turntable::turntablelistHash = 0;
-
@@ -49 +47 @@ int Turntable::turntablelistHash = 0;
-void Turntable::add(Turntable *tto) {
+void Turntable::add(Turntable* tto) {
@@ -53,2 +51,3 @@ void Turntable::add(Turntable *tto) {
-    Turntable *ptr = _firstTurntable;
-    for ( ; ptr->_nextTurntable!=0; ptr=ptr->_nextTurntable) {}
+    Turntable* ptr = _firstTurntable;
+    for (; ptr->_nextTurntable != 0; ptr = ptr->_nextTurntable) {
+    }
@@ -90 +89 @@ uint16_t Turntable::getPositionAngle(uint8_t position) {
-uint8_t Turntable::getPositionCount()  {
+uint8_t Turntable::getPositionCount() {
@@ -104,3 +103,4 @@ uint8_t Turntable::getPositionCount()  {
-Turntable *Turntable::get(uint16_t id) {
-  for (Turntable *tto = _firstTurntable; tto != nullptr; tto = tto->_nextTurntable)
-    if (tto->_turntableData.id == id) return tto;
+Turntable* Turntable::get(uint16_t id) {
+  for (Turntable* tto = _firstTurntable; tto != nullptr; tto = tto->_nextTurntable)
+    if (tto->_turntableData.id == id)
+      return tto;
@@ -111,2 +111,2 @@ Turntable *Turntable::get(uint16_t id) {
-Turntable *Turntable::getByVpin(VPIN vpin) {
-  for (Turntable *tto = _firstTurntable; tto != nullptr; tto = tto->_nextTurntable) {
+Turntable* Turntable::getByVpin(VPIN vpin) {
+  for (Turntable* tto = _firstTurntable; tto != nullptr; tto = tto->_nextTurntable) {
@@ -114 +114 @@ Turntable *Turntable::getByVpin(VPIN vpin) {
-      EXTTTurntable *exttTto = static_cast<EXTTTurntable*>(tto);
+      EXTTTurntable* exttTto = static_cast<EXTTTurntable*>(tto);
@@ -125,2 +125,3 @@ uint8_t Turntable::getPosition(uint16_t id) {
-  Turntable *tto = get(id);
-  if (!tto) return false;
+  Turntable* tto = get(id);
+  if (!tto)
+    return false;
@@ -132,2 +133,3 @@ bool Turntable::ttMoving(uint16_t id) {
-  Turntable *tto = get(id);
-  if (!tto) return false;
+  Turntable* tto = get(id);
+  if (!tto)
+    return false;
@@ -142,3 +144,5 @@ bool Turntable::setPosition(uint16_t id, uint8_t position, uint8_t activity) {
-  Turntable *tto = Turntable::get(id);
-  if (!tto) return false;
-  if (tto->isMoving()) return false;
+  Turntable* tto = Turntable::get(id);
+  if (!tto)
+    return false;
+  if (tto->isMoving())
+    return false;
@@ -155 +159,2 @@ bool Turntable::setPosition(uint16_t id, uint8_t position, uint8_t activity) {
-    if (position != tto->_previousPosition) rotated = true;
+    if (position != tto->_previousPosition)
+      rotated = true;
@@ -164 +169 @@ bool Turntable::setPosition(uint16_t id, uint8_t position, uint8_t activity) {
- * 
+ *
@@ -167,3 +172 @@ bool Turntable::setPosition(uint16_t id, uint8_t position, uint8_t activity) {
-EXTTTurntable::EXTTTurntable(uint16_t id, VPIN vpin) :
-  Turntable(id, TURNTABLE_EXTT)
-{
+EXTTTurntable::EXTTTurntable(uint16_t id, VPIN vpin) : Turntable(id, TURNTABLE_EXTT) {
@@ -176 +179 @@ using DevState = IODevice::DeviceStateEnum;
-  Turntable *EXTTTurntable::create(uint16_t id, VPIN vpin) {
+Turntable* EXTTTurntable::create(uint16_t id, VPIN vpin) {
@@ -178,7 +181,6 @@ using DevState = IODevice::DeviceStateEnum;
-    Turntable *tto = get(id);
-    if (tto) {
-      if (tto->isType(TURNTABLE_EXTT)) {
-        EXTTTurntable *extt = (EXTTTurntable *)tto;
-        extt->_exttTurntableData.vpin = vpin;
-        return tto;
-      }
+  Turntable* tto = get(id);
+  if (tto) {
+    if (tto->isType(TURNTABLE_EXTT)) {
+      EXTTTurntable* extt = (EXTTTurntable*)tto;
+      extt->_exttTurntableData.vpin = vpin;
+      return tto;
@@ -186,6 +188,10 @@ using DevState = IODevice::DeviceStateEnum;
-    if (!IODevice::exists(vpin)) return nullptr;
-    if (IODevice::getStatus(vpin) == DevState::DEVSTATE_FAILED) return nullptr;
-    if (Turntable::getByVpin(vpin)) return nullptr;
-    tto = (Turntable *)new EXTTTurntable(id, vpin);
-    DIAG(F("Turntable 0x%x size %d size %d"), tto, sizeof(Turntable), sizeof(struct TurntableData));
-    return tto;
+  }
+  if (!IODevice::exists(vpin))
+    return nullptr;
+  if (IODevice::getStatus(vpin) == DevState::DEVSTATE_FAILED)
+    return nullptr;
+  if (Turntable::getByVpin(vpin))
+    return nullptr;
+  tto = (Turntable*)new EXTTTurntable(id, vpin);
+  DIAG(F("Turntable 0x%x size %d size %d"), tto, sizeof(Turntable), sizeof(struct TurntableData));
+  return tto;
@@ -197 +203 @@ using DevState = IODevice::DeviceStateEnum;
-  }
+}
@@ -199,3 +205,3 @@ using DevState = IODevice::DeviceStateEnum;
-  void EXTTTurntable::print(Print *stream) {
-    StringFormatter::send(stream, F("<i %d EXTURNTABLE %d>\n"), _turntableData.id, _exttTurntableData.vpin);
-  }
+void EXTTTurntable::print(Print* stream) {
+  StringFormatter::send(stream, F("<i %d EXTURNTABLE %d>\n"), _turntableData.id, _exttTurntableData.vpin);
+}
@@ -203,2 +209,2 @@ using DevState = IODevice::DeviceStateEnum;
-  // EX-Turntable specific code for moving to the specified position
-  bool EXTTTurntable::setPositionInternal(uint8_t position, uint8_t activity) {
+// EX-Turntable specific code for moving to the specified position
+bool EXTTTurntable::setPositionInternal(uint8_t position, uint8_t activity) {
@@ -206,12 +212,14 @@ using DevState = IODevice::DeviceStateEnum;
-    int16_t value;
-    if (position == 0) {
-      value = 0;  // Position 0 is just to send activities
-    } else {
-      if (activity > 1) return false; // If sending a position update, only phase changes valid (0|1)
-      value = getPositionValue(position); // Get position value from position list
-    }
-    if (position > 0 && !value) return false; // Return false if it's not a valid position
-    // Set position via device driver
-    _previousPosition = _turntableData.position;
-    _turntableData.position = position;
-    EXTurntable::writeAnalogue(_exttTurntableData.vpin, value, activity);
+  int16_t value;
+  if (position == 0) {
+    value = 0;  // Position 0 is just to send activities
+  } else {
+    if (activity > 1)
+      return false;                      // If sending a position update, only phase changes valid (0|1)
+    value = getPositionValue(position);  // Get position value from position list
+  }
+  if (position > 0 && !value)
+    return false;  // Return false if it's not a valid position
+  // Set position via device driver
+  _previousPosition = _turntableData.position;
+  _turntableData.position = position;
+  EXTurntable::writeAnalogue(_exttTurntableData.vpin, value, activity);
@@ -219 +227 @@ using DevState = IODevice::DeviceStateEnum;
-    (void)position;
+  (void)position;
@@ -221,2 +229,2 @@ using DevState = IODevice::DeviceStateEnum;
-    return true;
-  }
+  return true;
+}
@@ -226 +234 @@ using DevState = IODevice::DeviceStateEnum;
- * 
+ *
@@ -229 +237,2 @@ using DevState = IODevice::DeviceStateEnum;
-DCCTurntable::DCCTurntable(uint16_t id) : Turntable(id, TURNTABLE_DCC) {}
+DCCTurntable::DCCTurntable(uint16_t id) : Turntable(id, TURNTABLE_DCC) {
+}
@@ -232 +241 @@ DCCTurntable::DCCTurntable(uint16_t id) : Turntable(id, TURNTABLE_DCC) {}
-  Turntable *DCCTurntable::create(uint16_t id) {
+Turntable* DCCTurntable::create(uint16_t id) {
@@ -234,6 +243,6 @@ DCCTurntable::DCCTurntable(uint16_t id) : Turntable(id, TURNTABLE_DCC) {}
-    Turntable *tto = get(id);
-    if (!tto) {
-      tto = (Turntable *)new DCCTurntable(id);
-      DIAG(F("Turntable 0x%x size %d size %d"), tto, sizeof(Turntable), sizeof(struct TurntableData));
-    }
-    return tto;
+  Turntable* tto = get(id);
+  if (!tto) {
+    tto = (Turntable*)new DCCTurntable(id);
+    DIAG(F("Turntable 0x%x size %d size %d"), tto, sizeof(Turntable), sizeof(struct TurntableData));
+  }
+  return tto;
@@ -244 +253 @@ DCCTurntable::DCCTurntable(uint16_t id) : Turntable(id, TURNTABLE_DCC) {}
-  }
+}
@@ -246,3 +255,3 @@ DCCTurntable::DCCTurntable(uint16_t id) : Turntable(id, TURNTABLE_DCC) {}
-  void DCCTurntable::print(Print *stream) {
-    StringFormatter::send(stream, F("<i %d DCCTURNTABLE>\n"), _turntableData.id);
-  }
+void DCCTurntable::print(Print* stream) {
+  StringFormatter::send(stream, F("<i %d DCCTURNTABLE>\n"), _turntableData.id);
+}
@@ -252 +261 @@ bool DCCTurntable::setPositionInternal(uint8_t position, uint8_t activity) {
-  (void) activity;
+  (void)activity;
@@ -255 +264,2 @@ bool DCCTurntable::setPositionInternal(uint8_t position, uint8_t activity) {
-  if (position == 0 || !value) return false; // Return false if it's not a valid position
+  if (position == 0 || !value)
+    return false;  // Return false if it's not a valid position
@@ -257,3 +267,3 @@ bool DCCTurntable::setPositionInternal(uint8_t position, uint8_t activity) {
-  int16_t addr=value>>3;
-  int16_t subaddr=(value>>1) & 0x03;
-  bool active=value & 0x01;
+  int16_t addr = value >> 3;
+  int16_t subaddr = (value >> 1) & 0x03;
+  bool active = value & 0x01;
diff --git a/Turntables.h b/Turntables.h
index aa089ef..140a734 100644
--- a/Turntables.h
+++ b/Turntables.h
@@ -4 +4 @@
- *  
+ *
@@ -41 +41 @@ enum {
- * 
+ *
@@ -48,2 +48,3 @@ struct TurntablePosition {
-  
-  TurntablePosition(uint8_t idx, uint16_t value, uint16_t angle) : index(idx), data(value), angle(angle), next(nullptr) {}
+
+  TurntablePosition(uint8_t idx, uint16_t value, uint16_t angle) : index(idx), data(value), angle(angle), next(nullptr) {
+  }
@@ -53,2 +54,3 @@ class TurntablePositionList {
-public:
-  TurntablePositionList() : head(nullptr) {}
+ public:
+  TurntablePositionList() : head(nullptr) {
+  }
@@ -58 +60 @@ public:
-    if(!head) {
+    if (!head) {
@@ -70 +72 @@ public:
-private:
+ private:
@@ -72 +73,0 @@ private:
-
@@ -75 +75,0 @@ private:
-
@@ -78 +78 @@ private:
- * 
+ *
@@ -82 +82 @@ class Turntable {
-protected:
+ protected:
@@ -93 +93 @@ protected:
-        uint8_t position : 6;       // Allows up to 63 positions including 0/home
+        uint8_t position : 6;  // Allows up to 63 positions including 0/home
@@ -101 +101 @@ protected:
-  Turntable *_nextTurntable = 0;
+  Turntable* _nextTurntable = 0;
@@ -105 +105 @@ protected:
-  
+
@@ -126 +126 @@ protected:
-  static Turntable *_firstTurntable;
+  static Turntable* _firstTurntable;
@@ -137 +137 @@ protected:
-  static void add(Turntable *tto);
+  static void add(Turntable* tto);
@@ -139,3 +139,3 @@ protected:
-public:
-  static Turntable *get(uint16_t id);
-  static Turntable *getByVpin(VPIN vpin);
+ public:
+  static Turntable* get(uint16_t id);
+  static Turntable* getByVpin(VPIN vpin);
@@ -151,8 +151,22 @@ public:
-  inline uint8_t getPosition() { return _turntableData.position; }
-  inline bool isHidden() { return _turntableData.hidden; }
-  inline void setHidden(bool h) {_turntableData.hidden=h; }
-  inline bool isType(uint8_t type) { return _turntableData.turntableType == type; }
-  inline bool isEXTT() const { return _turntableData.turntableType == TURNTABLE_EXTT; }
-  inline uint16_t getId() { return _turntableData.id; }
-  inline Turntable *next() { return _nextTurntable; }
-  void printState(Print *stream);
+  inline uint8_t getPosition() {
+    return _turntableData.position;
+  }
+  inline bool isHidden() {
+    return _turntableData.hidden;
+  }
+  inline void setHidden(bool h) {
+    _turntableData.hidden = h;
+  }
+  inline bool isType(uint8_t type) {
+    return _turntableData.turntableType == type;
+  }
+  inline bool isEXTT() const {
+    return _turntableData.turntableType == TURNTABLE_EXTT;
+  }
+  inline uint16_t getId() {
+    return _turntableData.id;
+  }
+  inline Turntable* next() {
+    return _nextTurntable;
+  }
+  void printState(Print* stream);
@@ -163,2 +177,6 @@ public:
-  bool isMoving() { return _isMoving; }
-  void setMoving(bool moving) { _isMoving=moving; }
+  bool isMoving() {
+    return _isMoving;
+  }
+  void setMoving(bool moving) {
+    _isMoving = moving;
+  }
@@ -169,2 +187,2 @@ public:
-  virtual void print(Print *stream) {
-    (void)stream; // suppress compiler warnings
+  virtual void print(Print* stream) {
+    (void)stream;  // suppress compiler warnings
@@ -172,2 +190,2 @@ public:
-  virtual ~Turntable() {} // Destructor
-  
+  virtual ~Turntable() {
+  }  // Destructor
@@ -178,2 +196,4 @@ public:
-  inline static bool exists(uint16_t id) { return get(id) != 0; }
-  static bool setPosition(uint16_t id, uint8_t position, uint8_t activity=0);
+  inline static bool exists(uint16_t id) {
+    return get(id) != 0;
+  }
+  static bool setPosition(uint16_t id, uint8_t position, uint8_t activity = 0);
@@ -182,2 +202,4 @@ public:
-  inline static Turntable *first() { return _firstTurntable; }
-  static bool printAll(Print *stream) {
+  inline static Turntable* first() {
+    return _firstTurntable;
+  }
+  static bool printAll(Print* stream) {
@@ -185 +207 @@ public:
-    for (Turntable *tto = _firstTurntable; tto != 0; tto = tto->_nextTurntable)
+    for (Turntable* tto = _firstTurntable; tto != 0; tto = tto->_nextTurntable)
@@ -192 +213,0 @@ public:
-
@@ -197 +218 @@ public:
- * 
+ *
@@ -200 +221 @@ class EXTTTurntable : public Turntable {
-private:
+ private:
@@ -209 +230 @@ private:
-public:
+ public:
@@ -211,3 +232,5 @@ public:
-  static Turntable *create(uint16_t id, VPIN vpin);
-  void print(Print *stream) override;
-  VPIN getVpin() const { return _exttTurntableData.vpin; }
+  static Turntable* create(uint16_t id, VPIN vpin);
+  void print(Print* stream) override;
+  VPIN getVpin() const {
+    return _exttTurntableData.vpin;
+  }
@@ -215 +238 @@ public:
-protected:
+ protected:
@@ -218 +240,0 @@ protected:
-
@@ -223 +245 @@ protected:
- * 
+ *
@@ -226 +248 @@ class DCCTurntable : public Turntable {
-private:
+ private:
@@ -230 +252 @@ private:
-public:
+ public:
@@ -232,2 +254,2 @@ public:
-  static Turntable *create(uint16_t id);
-  void print(Print *stream) override;
+  static Turntable* create(uint16_t id);
+  void print(Print* stream) override;
@@ -235 +257 @@ public:
-protected:
+ protected:
@@ -237,2 +259 @@ protected:
-  bool setPositionInternal(uint8_t position, uint8_t activity=0) override;
-
+  bool setPositionInternal(uint8_t position, uint8_t activity = 0) override;
diff --git a/WiThrottle.cpp b/WiThrottle.cpp
index aaa60de..0843317 100644
--- a/WiThrottle.cpp
+++ b/WiThrottle.cpp
@@ -8 +8 @@
- *  
+ *
@@ -31,2 +31,2 @@
- * 
- * 
+ *
+ *
@@ -38,4 +38,4 @@
- *  Broadcasting to other WiThrottles when things change.  
- *    -  Bear in mind that changes may have taken place due to  
- *      other WiThrottles, OR JMRI commands received OR TPL automation. 
- *    - I suggest that at the end of parse(), then anything that has changed and is of interest could  
+ *  Broadcasting to other WiThrottles when things change.
+ *    -  Bear in mind that changes may have taken place due to
+ *      other WiThrottles, OR JMRI commands received OR TPL automation.
+ *    - I suggest that at the end of parse(), then anything that has changed and is of interest could
@@ -43,3 +43,3 @@
- *       
- *  WiThrottle.h sets the max locos per client at 10, this is ok to increase but requires just an extra 3 bytes per loco per client.      
-*/
+ *
+ *  WiThrottle.h sets the max locos per client at 10, this is ok to increase but requires just an extra 3 bytes per loco per client.
+ */
@@ -61,2 +61,3 @@
-#define LOOPLOCOS(THROTTLECHAR, CAB)  for (int loco=0;loco<MAX_MY_LOCO;loco++) \
-      if ((myLocos[loco].throttle==THROTTLECHAR || '*'==THROTTLECHAR) && (CAB<0 || myLocos[loco].cab==CAB))
+#define LOOPLOCOS(THROTTLECHAR, CAB)             \
+  for (int loco = 0; loco < MAX_MY_LOCO; loco++) \
+    if ((myLocos[loco].throttle == THROTTLECHAR || '*' == THROTTLECHAR) && (CAB < 0 || myLocos[loco].cab == CAB))
@@ -64 +65 @@
-WiThrottle * WiThrottle::firstThrottle=NULL;
+WiThrottle* WiThrottle::firstThrottle = NULL;
@@ -66,4 +67,5 @@ WiThrottle * WiThrottle::firstThrottle=NULL;
-WiThrottle* WiThrottle::getThrottle( int wifiClient) {
-  for (WiThrottle* wt=firstThrottle; wt!=NULL ; wt=wt->nextThrottle)  
-     if (wt->clientid==wifiClient) return wt; 
-  return new WiThrottle( wifiClient);
+WiThrottle* WiThrottle::getThrottle(int wifiClient) {
+  for (WiThrottle* wt = firstThrottle; wt != NULL; wt = wt->nextThrottle)
+    if (wt->clientid == wifiClient)
+      return wt;
+  return new WiThrottle(wifiClient);
@@ -72,4 +74,4 @@ WiThrottle* WiThrottle::getThrottle( int wifiClient) {
-void WiThrottle::forget( byte clientId) {
-  for (WiThrottle* wt=firstThrottle; wt!=NULL ; wt=wt->nextThrottle)  
-     if (wt->clientid==clientId) {
-      DIAG(F("Withrottle client %d dropped"),clientId);
+void WiThrottle::forget(byte clientId) {
+  for (WiThrottle* wt = firstThrottle; wt != NULL; wt = wt->nextThrottle)
+    if (wt->clientid == clientId) {
+      DIAG(F("Withrottle client %d dropped"), clientId);
@@ -77,2 +79,2 @@ void WiThrottle::forget( byte clientId) {
-      break; 
-     }
+      break;
+    }
@@ -82,2 +84,3 @@ bool WiThrottle::isThrottleInUse(int cab) {
-  for (WiThrottle* wt=firstThrottle; wt!=NULL ; wt=wt->nextThrottle)  
-     if (wt->areYouUsingThrottle(cab)) return true;
+  for (WiThrottle* wt = firstThrottle; wt != NULL; wt = wt->nextThrottle)
+    if (wt->areYouUsingThrottle(cab))
+      return true;
@@ -88,2 +91,2 @@ bool WiThrottle::areYouUsingThrottle(int cab) {
-  LOOPLOCOS('*', cab) { // see if I have this cab in use
-      return true;
+  LOOPLOCOS('*', cab) {  // see if I have this cab in use
+    return true;
@@ -93,10 +96,11 @@ bool WiThrottle::areYouUsingThrottle(int cab) {
- // One instance of WiThrottle per connected client, so we know what the locos are 
- 
-WiThrottle::WiThrottle( int wificlientid) {
-   if (Diag::WITHROTTLE) DIAG(F("%l Creating new WiThrottle for client %d"),millis(),wificlientid); 
-   nextThrottle=firstThrottle;
-   firstThrottle= this;
-   clientid=wificlientid;
-   heartBeatEnable=false; // until client turns it on
-   mostRecentCab=0;                
-   for (int loco=0;loco<MAX_MY_LOCO; loco++) myLocos[loco].throttle='\0';
+// One instance of WiThrottle per connected client, so we know what the locos are
+
+WiThrottle::WiThrottle(int wificlientid) {
+  if (Diag::WITHROTTLE)
+    DIAG(F("%l Creating new WiThrottle for client %d"), millis(), wificlientid);
+  nextThrottle = firstThrottle;
+  firstThrottle = this;
+  clientid = wificlientid;
+  heartBeatEnable = false;  // until client turns it on
+  mostRecentCab = 0;
+  for (int loco = 0; loco < MAX_MY_LOCO; loco++) myLocos[loco].throttle = '\0';
@@ -106,3 +110,4 @@ WiThrottle::~WiThrottle() {
-  if (Diag::WITHROTTLE) DIAG(F("Deleting WiThrottle client %d"),this->clientid);
-  if (firstThrottle== this) {
-    firstThrottle=this->nextThrottle;
+  if (Diag::WITHROTTLE)
+    DIAG(F("Deleting WiThrottle client %d"), this->clientid);
+  if (firstThrottle == this) {
+    firstThrottle = this->nextThrottle;
@@ -111,5 +116,5 @@ WiThrottle::~WiThrottle() {
-  for (WiThrottle* wt=firstThrottle; wt!=NULL ; wt=wt->nextThrottle) {
-    if (wt->nextThrottle==this) {
-      wt->nextThrottle=this->nextThrottle;
-      return;  
-     }
+  for (WiThrottle* wt = firstThrottle; wt != NULL; wt = wt->nextThrottle) {
+    if (wt->nextThrottle == this) {
+      wt->nextThrottle = this->nextThrottle;
+      return;
+    }
@@ -119,16 +124,6 @@ WiThrottle::~WiThrottle() {
-void WiThrottle::parse(RingStream * stream, byte * cmdx) {
-  
-  byte * cmd=cmdx;
-  
-  heartBeat=millis();
-  if (Diag::WITHROTTLE) DIAG(F("%l WiThrottle(%d)<-[%e]"),millis(),clientid,cmd);
-  
-  // On first few commands, send turnout, roster and routes 
-  if (introSent) {  
-    if (!turnoutsSent) sendTurnouts(stream);
-    else if(!rosterSent) sendRoster(stream);
-    else if (!routesSent) sendRoutes(stream);
-    else if (!heartrateSent) {
-         heartrateSent=true;
-        // allow heartbeat to slow down once all metadata sent     
-        StringFormatter::send(stream,F("*%d\nHMConnected\n"),HEARTBEAT_SECONDS);
+void WiThrottle::parse(RingStream* stream, byte* cmdx) {
+  byte* cmd = cmdx;
+
+  heartBeat = millis();
+  if (Diag::WITHROTTLE)
+    DIAG(F("%l WiThrottle(%d)<-[%e]"), millis(), clientid, cmd);
@@ -135,0 +131,12 @@ void WiThrottle::parse(RingStream * stream, byte * cmdx) {
+  // On first few commands, send turnout, roster and routes
+  if (introSent) {
+    if (!turnoutsSent)
+      sendTurnouts(stream);
+    else if (!rosterSent)
+      sendRoster(stream);
+    else if (!routesSent)
+      sendRoutes(stream);
+    else if (!heartrateSent) {
+      heartrateSent = true;
+      // allow heartbeat to slow down once all metadata sent
+      StringFormatter::send(stream, F("*%d\nHMConnected\n"), HEARTBEAT_SECONDS);
@@ -138 +145 @@ void WiThrottle::parse(RingStream * stream, byte * cmdx) {
-  
+
@@ -141,11 +148,13 @@ void WiThrottle::parse(RingStream * stream, byte * cmdx) {
-    case '*':  // heartbeat control
-      if (cmd[1]=='+') heartBeatEnable=true;
-      else if (cmd[1]=='-') heartBeatEnable=false;
-      break;
-    case 'P':  
-      if (cmd[1]=='P' && cmd[2]=='A' )  {  //PPA power mode 
-	TrackManager::setMainPower(cmd[3]=='1'?POWERMODE::ON:POWERMODE::OFF);
-/* TODO 
-	if (MotorDriver::commonFaultPin) // commonFaultPin prevents individual track handling
-	  DCCWaveform::progTrack.setPowerMode(cmd[3]=='1'?POWERMODE::ON:POWERMODE::OFF);
-*/
+      case '*':  // heartbeat control
+        if (cmd[1] == '+')
+          heartBeatEnable = true;
+        else if (cmd[1] == '-')
+          heartBeatEnable = false;
+        break;
+      case 'P':
+        if (cmd[1] == 'P' && cmd[2] == 'A') {  // PPA power mode
+          TrackManager::setMainPower(cmd[3] == '1' ? POWERMODE::ON : POWERMODE::OFF);
+          /* TODO
+            if (MotorDriver::commonFaultPin) // commonFaultPin prevents individual track handling
+              DCCWaveform::progTrack.setPowerMode(cmd[3]=='1'?POWERMODE::ON:POWERMODE::OFF);
+          */
@@ -153 +162 @@ void WiThrottle::parse(RingStream * stream, byte * cmdx) {
-      }
+        }
@@ -155,55 +164,56 @@ void WiThrottle::parse(RingStream * stream, byte * cmdx) {
-      else if (cmd[1]=='R' && cmd[2]=='A' && cmd[3]=='2' ) { // Route activate
-	// exrail routes are RA2Rn , Animations are RA2An 
-	int route=getInt(cmd+5);
-	uint16_t cab=cmd[4]=='A' ? mostRecentCab : 0; 
-	RMFT2::createNewTask(route, cab);
-      }
-#endif    
-      else if (cmd[1]=='T' && cmd[2]=='A') { // PTA accessory toggle 
-	int id=getInt(cmd+4); 
-	if (!Turnout::exists(id)) {
-	  // If turnout does not exist, create it
-	  int addr = ((id - 1) / 4) + 1;
-	  int subaddr = (id - 1) % 4;
-	  DCCTurnout::create(id,addr,subaddr);
-	  StringFormatter::send(stream, F("HmTurnout %d created\n"),id);
-	}
-	switch (cmd[3]) {
-	  // T and C according to RCN-213 where 0 is Stop, Red, Thrown, Diverging.
-	case 'T': 
-	  Turnout::setClosed(id,false);
-	  break;
-	case 'C': 
-	  Turnout::setClosed(id,true);
-	  break;
-	case '2': 
-	  Turnout::setClosed(id,!Turnout::isClosed(id));
-	  break;
-	default :
-	  Turnout::setClosed(id,true);
-	  break;
-	}
-	StringFormatter::send(stream, F("PTA%c%d\n"),Turnout::isClosed(id)?'2':'4',id );
-      }
-      break;
-    case 'N':  // Heartbeat (2), only send if connection completed by 'HU' message
-      sendIntro(stream);
-      StringFormatter::send(stream, F("*%d\n"), heartrateSent ? HEARTBEAT_SECONDS : HEARTBEAT_PRELOAD); // return timeout value
-      break;
-    case 'M': // multithrottle
-      multithrottle(stream, cmd); 
-      break;
-    case 'H': // send initial connection info after receiving "HU" message
-      if (cmd[1] == 'U') {    
-	sendIntro(stream);
-      }
-      break;           
-    case 'Q': // 
-      LOOPLOCOS('*', -1) { // tell client to drop any locos still assigned to this WiThrottle
-	if (myLocos[loco].throttle!='\0') {
-	  StringFormatter::send(stream, F("M%c-%c%d<;>\n"), myLocos[loco].throttle, LorS(myLocos[loco].cab), myLocos[loco].cab);
-	}
-      }
-      if (Diag::WITHROTTLE) DIAG(F("WiThrottle(%d) Quit"),clientid);
-      delete this; 
-      break;           
+        else if (cmd[1] == 'R' && cmd[2] == 'A' && cmd[3] == '2') {  // Route activate
+          // exrail routes are RA2Rn , Animations are RA2An
+          int route = getInt(cmd + 5);
+          uint16_t cab = cmd[4] == 'A' ? mostRecentCab : 0;
+          RMFT2::createNewTask(route, cab);
+        }
+#endif
+        else if (cmd[1] == 'T' && cmd[2] == 'A') {  // PTA accessory toggle
+          int id = getInt(cmd + 4);
+          if (!Turnout::exists(id)) {
+            // If turnout does not exist, create it
+            int addr = ((id - 1) / 4) + 1;
+            int subaddr = (id - 1) % 4;
+            DCCTurnout::create(id, addr, subaddr);
+            StringFormatter::send(stream, F("HmTurnout %d created\n"), id);
+          }
+          switch (cmd[3]) {
+              // T and C according to RCN-213 where 0 is Stop, Red, Thrown, Diverging.
+            case 'T':
+              Turnout::setClosed(id, false);
+              break;
+            case 'C':
+              Turnout::setClosed(id, true);
+              break;
+            case '2':
+              Turnout::setClosed(id, !Turnout::isClosed(id));
+              break;
+            default:
+              Turnout::setClosed(id, true);
+              break;
+          }
+          StringFormatter::send(stream, F("PTA%c%d\n"), Turnout::isClosed(id) ? '2' : '4', id);
+        }
+        break;
+      case 'N':  // Heartbeat (2), only send if connection completed by 'HU' message
+        sendIntro(stream);
+        StringFormatter::send(stream, F("*%d\n"), heartrateSent ? HEARTBEAT_SECONDS : HEARTBEAT_PRELOAD);  // return timeout value
+        break;
+      case 'M':  // multithrottle
+        multithrottle(stream, cmd);
+        break;
+      case 'H':  // send initial connection info after receiving "HU" message
+        if (cmd[1] == 'U') {
+          sendIntro(stream);
+        }
+        break;
+      case 'Q':               //
+        LOOPLOCOS('*', -1) {  // tell client to drop any locos still assigned to this WiThrottle
+          if (myLocos[loco].throttle != '\0') {
+            StringFormatter::send(stream, F("M%c-%c%d<;>\n"), myLocos[loco].throttle, LorS(myLocos[loco].cab), myLocos[loco].cab);
+          }
+        }
+        if (Diag::WITHROTTLE)
+          DIAG(F("WiThrottle(%d) Quit"), clientid);
+        delete this;
+        break;
@@ -212,3 +222,4 @@ void WiThrottle::parse(RingStream * stream, byte * cmdx) {
-    while(*cmd !='\0' && *cmd != '\r' && *cmd !='\n') cmd++;
-    if (*cmd!='\0') cmd++; // skip \r or \n  
-  }           
+    while (*cmd != '\0' && *cmd != '\r' && *cmd != '\n') cmd++;
+    if (*cmd != '\0')
+      cmd++;  // skip \r or \n
+  }
@@ -217,6 +228,7 @@ void WiThrottle::parse(RingStream * stream, byte * cmdx) {
-int WiThrottle::getInt(byte * cmd) {
-  int i=0;
-  bool negate=cmd[0]=='-';
-  if (negate) cmd++;
-  while (cmd[0]>='0' && cmd[0]<='9') {
-    i=i*10 + (cmd[0]-'0');
+int WiThrottle::getInt(byte* cmd) {
+  int i = 0;
+  bool negate = cmd[0] == '-';
+  if (negate)
+    cmd++;
+  while (cmd[0] >= '0' && cmd[0] <= '9') {
+    i = i * 10 + (cmd[0] - '0');
@@ -225,2 +237,3 @@ int WiThrottle::getInt(byte * cmd) {
-  if (negate) i=0-i;
-  return i ;    
+  if (negate)
+    i = 0 - i;
+  return i;
@@ -229,4 +242,6 @@ int WiThrottle::getInt(byte * cmd) {
-int WiThrottle::getLocoId(byte * cmd) {
-    if (cmd[0]=='*') return -1;  // match all locos 
-    if (cmd[0]!='L' && cmd[0]!='S') return 0; // should not match any locos
-    return getInt(cmd+1); 
+int WiThrottle::getLocoId(byte* cmd) {
+  if (cmd[0] == '*')
+    return -1;  // match all locos
+  if (cmd[0] != 'L' && cmd[0] != 'S')
+    return 0;  // should not match any locos
+  return getInt(cmd + 1);
@@ -235,3 +250,3 @@ int WiThrottle::getLocoId(byte * cmd) {
-void WiThrottle::multithrottle(RingStream * stream, byte * cmd){ 
-  char throttleChar=cmd[1];
-  int locoid=getLocoId(cmd+3); // -1 for *
+void WiThrottle::multithrottle(RingStream* stream, byte* cmd) {
+  char throttleChar = cmd[1];
+  int locoid = getLocoId(cmd + 3);  // -1 for *
@@ -242,41 +257,18 @@ void WiThrottle::multithrottle(RingStream * stream, byte * cmd){
-  byte * aval=cmd;
-  while(*aval !=';' && *aval !='\0') aval++;
-  if (*aval) aval+=2;  // skip ;>
-  
-  //       DIAG(F("Multithrottle aval=%c cab=%d"), aval[0],locoid);    
-  switch(cmd[2]) {
-  case '+':  // add loco request
-    if (cmd[3]=='*') { 
-      // M+* means get loco from prog track, then join tracks ready to drive away
-      // Stash the things the callback will need later
-      stashStream= stream;
-      stashClient=stream->peekTargetMark();
-      stashThrottleChar=throttleChar;
-      stashInstance=this;
-      // ask DCC to call us back when the loco id has been read
-      DCC::getLocoId(getLocoCallback); // will remove any previous join                    
-      return; // return nothing in stream as response is sent later in the callback 
-    }
-    //return error if address zero requested
-    if (locoid==0) { 
-      StringFormatter::send(stream, F("HMAddress '0' not supported!\n"), cmd[3] ,locoid);                    
-      return;
-    }
-    //return error if L or S from request doesn't match DCC++ assumptions
-    if (cmd[3] != LorS(locoid)) { 
-      StringFormatter::send(stream, F("HMLength '%c' not valid for %d!\n"), cmd[3] ,locoid);                    
-      return;
-    }
-    //use first empty "slot" on this client's list, will be added to DCC registration list
-    for (int loco=0;loco<MAX_MY_LOCO;loco++) {
-      if (myLocos[loco].throttle=='\0') {
-	      myLocos[loco].throttle=throttleChar;
-	      myLocos[loco].cab=locoid; 
-	      myLocos[loco].functionMap=DCC::getFunctionMap(locoid); 
-	      myLocos[loco].broadcastPending=true; // means speed/dir will be sent later
-	      mostRecentCab=locoid;
-	      StringFormatter::send(stream, F("M%c+%c%d<;>\n"), throttleChar, cmd[3] ,locoid); //tell client to add loco
-	      sendFunctions(stream,loco);
-	      //speed and direction will be published at next broadcast cycle
-	      StringFormatter::send(stream, F("M%cA%c%d<;>s1\n"), throttleChar, cmd[3], locoid); //default speed step 128
-	      return;
+  byte* aval = cmd;
+  while (*aval != ';' && *aval != '\0') aval++;
+  if (*aval)
+    aval += 2;  // skip ;>
+
+  //       DIAG(F("Multithrottle aval=%c cab=%d"), aval[0],locoid);
+  switch (cmd[2]) {
+    case '+':  // add loco request
+      if (cmd[3] == '*') {
+        // M+* means get loco from prog track, then join tracks ready to drive away
+        // Stash the things the callback will need later
+        stashStream = stream;
+        stashClient = stream->peekTargetMark();
+        stashThrottleChar = throttleChar;
+        stashInstance = this;
+        // ask DCC to call us back when the loco id has been read
+        DCC::getLocoId(getLocoCallback);  // will remove any previous join
+        return;                           // return nothing in stream as response is sent later in the callback
@@ -284,12 +276,36 @@ void WiThrottle::multithrottle(RingStream * stream, byte * cmd){
-    }
-    StringFormatter::send(stream, F("HMMax locos (%d) exceeded, %d not added!\n"), MAX_MY_LOCO ,locoid);                    
-    break;
-  case '-': // remove loco(s) from this client (leave in DCC registration)
-    LOOPLOCOS(throttleChar, locoid) {
-      myLocos[loco].throttle='\0';
-      StringFormatter::send(stream, F("M%c-%c%d<;>\n"), throttleChar, LorS(myLocos[loco].cab), myLocos[loco].cab);
-    }
-    
-    break;
-  case 'A':
-    locoAction(stream,aval, throttleChar, locoid);
+      // return error if address zero requested
+      if (locoid == 0) {
+        StringFormatter::send(stream, F("HMAddress '0' not supported!\n"), cmd[3], locoid);
+        return;
+      }
+      // return error if L or S from request doesn't match DCC++ assumptions
+      if (cmd[3] != LorS(locoid)) {
+        StringFormatter::send(stream, F("HMLength '%c' not valid for %d!\n"), cmd[3], locoid);
+        return;
+      }
+      // use first empty "slot" on this client's list, will be added to DCC registration list
+      for (int loco = 0; loco < MAX_MY_LOCO; loco++) {
+        if (myLocos[loco].throttle == '\0') {
+          myLocos[loco].throttle = throttleChar;
+          myLocos[loco].cab = locoid;
+          myLocos[loco].functionMap = DCC::getFunctionMap(locoid);
+          myLocos[loco].broadcastPending = true;  // means speed/dir will be sent later
+          mostRecentCab = locoid;
+          StringFormatter::send(stream, F("M%c+%c%d<;>\n"), throttleChar, cmd[3], locoid);  // tell client to add loco
+          sendFunctions(stream, loco);
+          // speed and direction will be published at next broadcast cycle
+          StringFormatter::send(stream, F("M%cA%c%d<;>s1\n"), throttleChar, cmd[3], locoid);  // default speed step 128
+          return;
+        }
+      }
+      StringFormatter::send(stream, F("HMMax locos (%d) exceeded, %d not added!\n"), MAX_MY_LOCO, locoid);
+      break;
+    case '-':  // remove loco(s) from this client (leave in DCC registration)
+      LOOPLOCOS(throttleChar, locoid) {
+        myLocos[loco].throttle = '\0';
+        StringFormatter::send(stream, F("M%c-%c%d<;>\n"), throttleChar, LorS(myLocos[loco].cab), myLocos[loco].cab);
+      }
+
+      break;
+    case 'A':
+      locoAction(stream, aval, throttleChar, locoid);
@@ -299,2 +315,2 @@ void WiThrottle::multithrottle(RingStream * stream, byte * cmd){
-void WiThrottle::locoAction(RingStream * stream, byte* aval, char throttleChar, int cab){
-  // Note cab=-1 for all cabs in the consist called throttleChar.  
+void WiThrottle::locoAction(RingStream* stream, byte* aval, char throttleChar, int cab) {
+  // Note cab=-1 for all cabs in the consist called throttleChar.
@@ -302 +318 @@ void WiThrottle::locoAction(RingStream * stream, byte* aval, char throttleChar,
-  (void) stream;
+  (void)stream;
@@ -304,3 +320,3 @@ void WiThrottle::locoAction(RingStream * stream, byte* aval, char throttleChar,
-  case 'V':  // Vspeed
-    { 
-      int witSpeed=getInt(aval+1);
+    case 'V':  // Vspeed
+    {
+      int witSpeed = getInt(aval + 1);
@@ -308,3 +324,3 @@ void WiThrottle::locoAction(RingStream * stream, byte* aval, char throttleChar,
-	mostRecentCab=myLocos[loco].cab;
-	DCC::setThrottle(myLocos[loco].cab, WiTToDCCSpeed(witSpeed), DCC::getThrottleDirection(myLocos[loco].cab));
-	// SetThrottle will cause speed change broadcast
+        mostRecentCab = myLocos[loco].cab;
+        DCC::setThrottle(myLocos[loco].cab, WiTToDCCSpeed(witSpeed), DCC::getThrottleDirection(myLocos[loco].cab));
+        // SetThrottle will cause speed change broadcast
@@ -312,6 +328,5 @@ void WiThrottle::locoAction(RingStream * stream, byte* aval, char throttleChar,
-    } 
-    break;
-  case 'F': // Function key pressed/released
-    {  
-      bool pressed=aval[1]=='1';
-      int fKey = getInt(aval+2);
+    } break;
+    case 'F':  // Function key pressed/released
+    {
+      bool pressed = aval[1] == '1';
+      int fKey = getInt(aval + 2);
@@ -319,3 +334,5 @@ void WiThrottle::locoAction(RingStream * stream, byte* aval, char throttleChar,
-	bool unsetOnRelease = myLocos[loco].functionToggles & (1L<<fKey);
-	if (unsetOnRelease) DCC::setFn(myLocos[loco].cab,fKey, pressed);
-	else if (pressed)  DCC::changeFn(myLocos[loco].cab, fKey);
+        bool unsetOnRelease = myLocos[loco].functionToggles & (1L << fKey);
+        if (unsetOnRelease)
+          DCC::setFn(myLocos[loco].cab, fKey, pressed);
+        else if (pressed)
+          DCC::changeFn(myLocos[loco].cab, fKey);
@@ -323 +340 @@ void WiThrottle::locoAction(RingStream * stream, byte* aval, char throttleChar,
-      break;  
+      break;
@@ -325 +342 @@ void WiThrottle::locoAction(RingStream * stream, byte* aval, char throttleChar,
-  case 'f': // Function key set, force function variant
+    case 'f':  // Function key set, force function variant
@@ -327,2 +344,2 @@ void WiThrottle::locoAction(RingStream * stream, byte* aval, char throttleChar,
-      bool pressed=aval[1]=='1';
-      int fKey = getInt(aval+2);
+      bool pressed = aval[1] == '1';
+      int fKey = getInt(aval + 2);
@@ -330 +347 @@ void WiThrottle::locoAction(RingStream * stream, byte* aval, char throttleChar,
-	DCC::setFn(myLocos[loco].cab,fKey, pressed);
+        DCC::setFn(myLocos[loco].cab, fKey, pressed);
@@ -334,4 +351,14 @@ void WiThrottle::locoAction(RingStream * stream, byte* aval, char throttleChar,
-  case 'q':
-    if (aval[1]=='V' || aval[1]=='R' ) {   //qV or qR
-      // just flag the loco for broadcast and it will happen.
-      bool foundone = false;
+    case 'q':
+      if (aval[1] == 'V' || aval[1] == 'R') {  // qV or qR
+        // just flag the loco for broadcast and it will happen.
+        bool foundone = false;
+        LOOPLOCOS(throttleChar, cab) {
+          foundone = true;
+          myLocos[loco].broadcastPending = true;
+        }
+        if (!foundone)
+          StringFormatter::send(stream, F("HMCS loco list empty\n"));
+      }
+      break;
+    case 'R': {
+      bool forward = aval[1] != '0';
@@ -339,2 +366,6 @@ void WiThrottle::locoAction(RingStream * stream, byte* aval, char throttleChar,
-	foundone = true;
-	myLocos[loco].broadcastPending=true;
+        mostRecentCab = myLocos[loco].cab;
+        int8_t speed = DCC::getThrottleSpeed(myLocos[loco].cab);
+        if (speed < 0)  // can not find any speed for this cab
+          speed = 0;
+        DCC::setThrottle(myLocos[loco].cab, speed, forward);
+        // setThrottle will cause a broadcast so notification will be sent
@@ -342,7 +373,3 @@ void WiThrottle::locoAction(RingStream * stream, byte* aval, char throttleChar,
-      if (!foundone)
-	StringFormatter::send(stream,F("HMCS loco list empty\n"));
-    }     
-    break;    
-  case 'R':
-    { 
-      bool forward=aval[1]!='0';
+    } break;
+    case 'X':
+      // Emergency Stop  (speed code 1)
@@ -350,6 +377,2 @@ void WiThrottle::locoAction(RingStream * stream, byte* aval, char throttleChar,
-	mostRecentCab=myLocos[loco].cab;
-	int8_t speed = DCC::getThrottleSpeed(myLocos[loco].cab);
-	if (speed < 0) //can not find any speed for this cab
-	  speed = 0;
-	DCC::setThrottle(myLocos[loco].cab, speed, forward);
-	// setThrottle will cause a broadcast so notification will be sent
+        DCC::setThrottle(myLocos[loco].cab, 1, DCC::getThrottleDirection(myLocos[loco].cab));
+        // setThrottle will cause a broadcast so notification will be sent
@@ -357,18 +380,10 @@ void WiThrottle::locoAction(RingStream * stream, byte* aval, char throttleChar,
-    }        
-    break;      
-  case 'X':
-    //Emergency Stop  (speed code 1)
-    LOOPLOCOS(throttleChar, cab) {
-      DCC::setThrottle(myLocos[loco].cab, 1, DCC::getThrottleDirection(myLocos[loco].cab));
-      // setThrottle will cause a broadcast so notification will be sent
-    }
-    break;
-  case 'I': // Idle, set speed to 0
-  case 'Q': // Quit, set speed to 0
-    LOOPLOCOS(throttleChar, cab) {
-      mostRecentCab=myLocos[loco].cab;
-      DCC::setThrottle(myLocos[loco].cab, 0, DCC::getThrottleDirection(myLocos[loco].cab));
-      // setThrottle will cause a broadcast so notification will be sent
-    }
-    break;
-  }               
+      break;
+    case 'I':  // Idle, set speed to 0
+    case 'Q':  // Quit, set speed to 0
+      LOOPLOCOS(throttleChar, cab) {
+        mostRecentCab = myLocos[loco].cab;
+        DCC::setThrottle(myLocos[loco].cab, 0, DCC::getThrottleDirection(myLocos[loco].cab));
+        // setThrottle will cause a broadcast so notification will be sent
+      }
+      break;
+  }
@@ -379,3 +394,5 @@ int WiThrottle::DCCToWiTSpeed(int DCCSpeed) {
-  if (DCCSpeed == 0) return 0; //stop is stop
-  if (DCCSpeed == 1) return -1; //eStop value
-  return DCCSpeed - 1; //offset others by 1
+  if (DCCSpeed == 0)
+    return 0;  // stop is stop
+  if (DCCSpeed == 1)
+    return -1;          // eStop value
+  return DCCSpeed - 1;  // offset others by 1
@@ -386,3 +403,5 @@ int WiThrottle::WiTToDCCSpeed(int WiTSpeed) {
-  if (WiTSpeed == 0) return 0;  //stop is stop
-  if (WiTSpeed == -1) return 1; //eStop value
-  return WiTSpeed + 1; //offset others by 1
+  if (WiTSpeed == 0)
+    return 0;  // stop is stop
+  if (WiTSpeed == -1)
+    return 1;           // eStop value
+  return WiTSpeed + 1;  // offset others by 1
@@ -391 +410 @@ int WiThrottle::WiTToDCCSpeed(int WiTSpeed) {
-void WiThrottle::loop(RingStream * stream) {
+void WiThrottle::loop(RingStream* stream) {
@@ -393,2 +412 @@ void WiThrottle::loop(RingStream * stream) {
-  for (WiThrottle* wt=firstThrottle; wt!=NULL ; wt=wt->nextThrottle) 
-    wt->checkHeartbeat(stream);
+  for (WiThrottle* wt = firstThrottle; wt != NULL; wt = wt->nextThrottle) wt->checkHeartbeat(stream);
@@ -397 +415 @@ void WiThrottle::loop(RingStream * stream) {
-void WiThrottle::checkHeartbeat(RingStream * stream) {
+void WiThrottle::checkHeartbeat(RingStream* stream) {
@@ -399,7 +417,9 @@ void WiThrottle::checkHeartbeat(RingStream * stream) {
-  if(heartBeatEnable && (millis()-heartBeat > ESTOP_SECONDS*1000)) {
-    if (Diag::WITHROTTLE)  DIAG(F("%l WiThrottle(%d) eStop(%ds) timeout, drop connection"), millis(), clientid, ESTOP_SECONDS);
-    LOOPLOCOS('*', -1) { 
-      if (myLocos[loco].throttle!='\0') {
-        if (Diag::WITHROTTLE) DIAG(F("%l  eStopping cab %d"),millis(),myLocos[loco].cab);
-        DCC::setThrottle(myLocos[loco].cab, 1, DCC::getThrottleDirection(myLocos[loco].cab)); // speed 1 is eStop
-	heartBeat=millis(); // We have just stopped everyting, we don't need to do that again at next loop.
+  if (heartBeatEnable && (millis() - heartBeat > ESTOP_SECONDS * 1000)) {
+    if (Diag::WITHROTTLE)
+      DIAG(F("%l WiThrottle(%d) eStop(%ds) timeout, drop connection"), millis(), clientid, ESTOP_SECONDS);
+    LOOPLOCOS('*', -1) {
+      if (myLocos[loco].throttle != '\0') {
+        if (Diag::WITHROTTLE)
+          DIAG(F("%l  eStopping cab %d"), millis(), myLocos[loco].cab);
+        DCC::setThrottle(myLocos[loco].cab, 1, DCC::getThrottleDirection(myLocos[loco].cab));  // speed 1 is eStop
+        heartBeat = millis();  // We have just stopped everyting, we don't need to do that again at next loop.
@@ -408 +428 @@ void WiThrottle::checkHeartbeat(RingStream * stream) {
-    // if it does come back, the throttle should re-acquire 
+    // if it does come back, the throttle should re-acquire
@@ -412,6 +432,6 @@ void WiThrottle::checkHeartbeat(RingStream * stream) {
-   
-   // send any outstanding speed/direction/function changes for this clients locos
-   // Changes may have been caused by this client, or another non-Withrottle or Exrail
-  bool streamHasBeenMarked=false; 
-  LOOPLOCOS('*', -1) { 
-    if (myLocos[loco].throttle!='\0' && myLocos[loco].broadcastPending) {
+
+  // send any outstanding speed/direction/function changes for this clients locos
+  // Changes may have been caused by this client, or another non-Withrottle or Exrail
+  bool streamHasBeenMarked = false;
+  LOOPLOCOS('*', -1) {
+    if (myLocos[loco].throttle != '\0' && myLocos[loco].broadcastPending) {
@@ -419,2 +439,2 @@ void WiThrottle::checkHeartbeat(RingStream * stream) {
-	stream->mark(clientid);
-	streamHasBeenMarked=true;
+        stream->mark(clientid);
+        streamHasBeenMarked = true;
@@ -422,14 +442,12 @@ void WiThrottle::checkHeartbeat(RingStream * stream) {
-      myLocos[loco].broadcastPending=false;
-      int cab=myLocos[loco].cab;
-      char lors=LorS(cab);
-      char throttle=myLocos[loco].throttle;
-      StringFormatter::send(stream,F("M%cA%c%d<;>V%d\n"),
-			    throttle, lors , cab, DCCToWiTSpeed(DCC::getThrottleSpeed(cab)));
-      StringFormatter::send(stream,F("M%cA%c%d<;>R%d\n"), 
-			    throttle, lors , cab, DCC::getThrottleDirection(cab));
-      
-      // compare the DCC functionmap with the local copy and send changes  
-      uint32_t dccFunctionMap=DCC::getFunctionMap(cab);
-      uint32_t myFunctionMap=myLocos[loco].functionMap;
-      myLocos[loco].functionMap=dccFunctionMap;
-      
+      myLocos[loco].broadcastPending = false;
+      int cab = myLocos[loco].cab;
+      char lors = LorS(cab);
+      char throttle = myLocos[loco].throttle;
+      StringFormatter::send(stream, F("M%cA%c%d<;>V%d\n"), throttle, lors, cab, DCCToWiTSpeed(DCC::getThrottleSpeed(cab)));
+      StringFormatter::send(stream, F("M%cA%c%d<;>R%d\n"), throttle, lors, cab, DCC::getThrottleDirection(cab));
+
+      // compare the DCC functionmap with the local copy and send changes
+      uint32_t dccFunctionMap = DCC::getFunctionMap(cab);
+      uint32_t myFunctionMap = myLocos[loco].functionMap;
+      myLocos[loco].functionMap = dccFunctionMap;
+
@@ -438,10 +456,8 @@ void WiThrottle::checkHeartbeat(RingStream * stream) {
-      for (byte fn=0;dccFunctionMap!=myFunctionMap;fn++) {
-	if ((dccFunctionMap&1) != (myFunctionMap&1)) {
-	  StringFormatter::send(stream,F("M%cA%c%d<;>F%c%d\n"),
-				throttle, lors , cab, (dccFunctionMap&1)?'1':'0',fn);
-	} 
-	// shift just checked bit off end of both maps
-	dccFunctionMap>>=1;
-	myFunctionMap>>=1;
-      } 
-    }
+      for (byte fn = 0; dccFunctionMap != myFunctionMap; fn++) {
+        if ((dccFunctionMap & 1) != (myFunctionMap & 1)) {
+          StringFormatter::send(stream, F("M%cA%c%d<;>F%c%d\n"), throttle, lors, cab, (dccFunctionMap & 1) ? '1' : '0', fn);
+        }
+        // shift just checked bit off end of both maps
+        dccFunctionMap >>= 1;
+        myFunctionMap >>= 1;
+      }
@@ -449 +465,3 @@ void WiThrottle::checkHeartbeat(RingStream * stream) {
-  if (streamHasBeenMarked)   stream->commit();     
+  }
+  if (streamHasBeenMarked)
+    stream->commit();
@@ -453,2 +471 @@ void WiThrottle::markForBroadcast(int cab) {
-  for (WiThrottle* wt=firstThrottle; wt!=NULL ; wt=wt->nextThrottle) 
-      wt->markForBroadcast2(cab);
+  for (WiThrottle* wt = firstThrottle; wt != NULL; wt = wt->nextThrottle) wt->markForBroadcast2(cab);
@@ -457,2 +474,2 @@ void WiThrottle::markForBroadcast2(int cab) {
-  LOOPLOCOS('*', cab) { 
-    myLocos[loco].broadcastPending=true;
+  LOOPLOCOS('*', cab) {
+    myLocos[loco].broadcastPending = true;
@@ -462 +478,0 @@ void WiThrottle::markForBroadcast2(int cab) {
-
@@ -464 +480 @@ char WiThrottle::LorS(int cab) {
-  return (cab<=HIGHEST_SHORT_ADDR)?'S':'L';
+  return (cab <= HIGHEST_SHORT_ADDR) ? 'S' : 'L';
@@ -469,4 +485,4 @@ char WiThrottle::LorS(int cab) {
-RingStream * WiThrottle::stashStream;
-WiThrottle * WiThrottle::stashInstance;
-byte         WiThrottle::stashClient;
-char         WiThrottle::stashThrottleChar;
+RingStream* WiThrottle::stashStream;
+WiThrottle* WiThrottle::stashInstance;
+byte WiThrottle::stashClient;
+char WiThrottle::stashThrottleChar;
@@ -475 +491 @@ void WiThrottle::getLocoCallback(int16_t locoid) {
-  //DIAG(F("LocoCallback mark client %d"), stashClient);
+  // DIAG(F("LocoCallback mark client %d"), stashClient);
@@ -477,5 +493,5 @@ void WiThrottle::getLocoCallback(int16_t locoid) {
-  
-  if (locoid<=0) {
-    StringFormatter::send(stashStream,F("HMNo loco found on prog track\n"));
-    //DIAG(F("LocoCallback commit (noloco)"));
-    stashStream->commit();                  // done here, commit and return
+
+  if (locoid <= 0) {
+    StringFormatter::send(stashStream, F("HMNo loco found on prog track\n"));
+    // DIAG(F("LocoCallback commit (noloco)"));
+    stashStream->commit();  // done here, commit and return
@@ -487,6 +503,6 @@ void WiThrottle::getLocoCallback(int16_t locoid) {
-  if (locoid & LONG_ADDR_MARKER) {          // maker bit indicates long addr
-    locoid = locoid ^ LONG_ADDR_MARKER;     // remove marker bit to get real long addr
-    if (locoid <= HIGHEST_SHORT_ADDR ) {    // out of range for long addr
-      StringFormatter::send(stashStream,F("HMLong addr %d <= %d unsupported\n"), locoid, HIGHEST_SHORT_ADDR);
-      //DIAG(F("LocoCallback commit (error)"));
-      stashStream->commit();                // done here, commit and return
+  if (locoid & LONG_ADDR_MARKER) {       // maker bit indicates long addr
+    locoid = locoid ^ LONG_ADDR_MARKER;  // remove marker bit to get real long addr
+    if (locoid <= HIGHEST_SHORT_ADDR) {  // out of range for long addr
+      StringFormatter::send(stashStream, F("HMLong addr %d <= %d unsupported\n"), locoid, HIGHEST_SHORT_ADDR);
+      // DIAG(F("LocoCallback commit (error)"));
+      stashStream->commit();  // done here, commit and return
@@ -499,5 +515,5 @@ void WiThrottle::getLocoCallback(int16_t locoid) {
-  
-  char addcmd[20]={'M',stashThrottleChar,'+', addrchar};
-  itoa(locoid,addcmd+4,10);
-  stashInstance->multithrottle(stashStream, (byte *)addcmd);
-  TrackManager::setJoin(true);          // <1 JOIN> so we can drive loco away
+
+  char addcmd[20] = {'M', stashThrottleChar, '+', addrchar};
+  itoa(locoid, addcmd + 4, 10);
+  stashInstance->multithrottle(stashStream, (byte*)addcmd);
+  TrackManager::setJoin(true);  // <1 JOIN> so we can drive loco away
@@ -511 +527 @@ void WiThrottle::sendIntro(Print* stream) {
-  if (introSent) // sendIntro only once
+  if (introSent)  // sendIntro only once
@@ -513,5 +529,5 @@ void WiThrottle::sendIntro(Print* stream) {
-  introSent=true; 
-  StringFormatter::send(stream,F("VN2.0\nHTDCC-EX\nRL0\n"));
-  StringFormatter::send(stream,F("HtDCC-EX v%S, %S, %S, %S\n"), F(VERSION), F(ARDUINO_TYPE), DCC::getMotorShieldName(), F(GITHUB_SHA));
-  StringFormatter::send(stream,F("PTT]\\[Turnouts}|{Turnout]\\[THROW}|{2]\\[CLOSE}|{4\n"));
-  StringFormatter::send(stream,F("PPA%x\n"),TrackManager::getMainPower()==POWERMODE::ON);
+  introSent = true;
+  StringFormatter::send(stream, F("VN2.0\nHTDCC-EX\nRL0\n"));
+  StringFormatter::send(stream, F("HtDCC-EX v%S, %S, %S, %S\n"), F(VERSION), F(ARDUINO_TYPE), DCC::getMotorShieldName(), F(GITHUB_SHA));
+  StringFormatter::send(stream, F("PTT]\\[Turnouts}|{Turnout]\\[THROW}|{2]\\[CLOSE}|{4\n"));
+  StringFormatter::send(stream, F("PPA%x\n"), TrackManager::getMainPower() == POWERMODE::ON);
@@ -519 +535 @@ void WiThrottle::sendIntro(Print* stream) {
-  StringFormatter::send(stream,F("*%d\nHMConnecting..\n"), HEARTBEAT_PRELOAD);
+  StringFormatter::send(stream, F("*%d\nHMConnecting..\n"), HEARTBEAT_PRELOAD);
@@ -523,16 +539,17 @@ void WiThrottle::sendTurnouts(Print* stream) {
-     turnoutsSent=true;
-      StringFormatter::send(stream,F("PTL"));
-      for(Turnout *tt=Turnout::first();tt!=NULL;tt=tt->next()){
-          if (tt->isHidden()) continue;
-          int id=tt->getId();
-          const FSH * tdesc=NULL;
-          #ifdef EXRAIL_ACTIVE
-          tdesc=RMFT2::getTurnoutDescription(id);
-          #endif
-          char tchar=Turnout::isClosed(id)?'2':'4';
-          if (tdesc==NULL) // turnout with no description
-              StringFormatter::send(stream,F("]\\[%d}|{T%d}|{T%c"), id,id,tchar);
-	        else 
-              StringFormatter::send(stream,F("]\\[%d}|{%S}|{%c"), id,tdesc,tchar);
-      }
-      StringFormatter::send(stream,F("\n"));
+  turnoutsSent = true;
+  StringFormatter::send(stream, F("PTL"));
+  for (Turnout* tt = Turnout::first(); tt != NULL; tt = tt->next()) {
+    if (tt->isHidden())
+      continue;
+    int id = tt->getId();
+    const FSH* tdesc = NULL;
+#ifdef EXRAIL_ACTIVE
+    tdesc = RMFT2::getTurnoutDescription(id);
+#endif
+    char tchar = Turnout::isClosed(id) ? '2' : '4';
+    if (tdesc == NULL)  // turnout with no description
+      StringFormatter::send(stream, F("]\\[%d}|{T%d}|{T%c"), id, id, tchar);
+    else
+      StringFormatter::send(stream, F("]\\[%d}|{%S}|{%c"), id, tdesc, tchar);
+  }
+  StringFormatter::send(stream, F("\n"));
@@ -541 +558 @@ void WiThrottle::sendRoster(Print* stream) {
-  rosterSent=true;
+  rosterSent = true;
@@ -543,8 +560,7 @@ void WiThrottle::sendRoster(Print* stream) {
-  StringFormatter::send(stream,F("RL%d"), RMFT2::rosterNameCount);
-  for (int16_t r=0;;r++) {
-      int16_t cabid=GETHIGHFLASHW(RMFT2::rosterIdList,r*2);
-      if (cabid == INT16_MAX)
-	break;
-      if (cabid > 0)
-	StringFormatter::send(stream,F("]\\[%S}|{%d}|{%c"),
-			      RMFT2::getRosterName(cabid),cabid,cabid<128?'S':'L');
+  StringFormatter::send(stream, F("RL%d"), RMFT2::rosterNameCount);
+  for (int16_t r = 0;; r++) {
+    int16_t cabid = GETHIGHFLASHW(RMFT2::rosterIdList, r * 2);
+    if (cabid == INT16_MAX)
+      break;
+    if (cabid > 0)
+      StringFormatter::send(stream, F("]\\[%S}|{%d}|{%c"), RMFT2::getRosterName(cabid), cabid, cabid < 128 ? 'S' : 'L');
@@ -552 +568 @@ void WiThrottle::sendRoster(Print* stream) {
-  StringFormatter::send(stream,F("\n"));       
+  StringFormatter::send(stream, F("\n"));
@@ -554 +570 @@ void WiThrottle::sendRoster(Print* stream) {
-   (void)stream; // remove warning
+  (void)stream;  // remove warning
@@ -558 +574 @@ void WiThrottle::sendRoutes(Print* stream) {
-  routesSent=true; 
+  routesSent = true;
@@ -560,16 +576,18 @@ void WiThrottle::sendRoutes(Print* stream) {
-   StringFormatter::send(stream,F("PRT]\\[Routes}|{Route]\\[Set}|{2]\\[Handoff}|{4\nPRL"));
-    // first pass automations
-    for (int ix=0;;ix+=2) {
-        int16_t id =GETHIGHFLASHW(RMFT2::automationIdList,ix);
-        if (id==INT16_MAX) break;
-        const FSH * desc=RMFT2::getRouteDescription(id);
-        StringFormatter::send(stream,F("]\\[A%d}|{%S}|{4"),id,desc);
-    }
-    // second pass routes.
-    for (int ix=0;;ix+=2) {
-        int16_t id=GETHIGHFLASHW(RMFT2::routeIdList,ix);
-        if (id==INT16_MAX) break;
-        const FSH * desc=RMFT2::getRouteDescription(id);
-        StringFormatter::send(stream,F("]\\[R%d}|{%S}|{2"),id,desc);
-    }
-   StringFormatter::send(stream,F("\n"));
+  StringFormatter::send(stream, F("PRT]\\[Routes}|{Route]\\[Set}|{2]\\[Handoff}|{4\nPRL"));
+  // first pass automations
+  for (int ix = 0;; ix += 2) {
+    int16_t id = GETHIGHFLASHW(RMFT2::automationIdList, ix);
+    if (id == INT16_MAX)
+      break;
+    const FSH* desc = RMFT2::getRouteDescription(id);
+    StringFormatter::send(stream, F("]\\[A%d}|{%S}|{4"), id, desc);
+  }
+  // second pass routes.
+  for (int ix = 0;; ix += 2) {
+    int16_t id = GETHIGHFLASHW(RMFT2::routeIdList, ix);
+    if (id == INT16_MAX)
+      break;
+    const FSH* desc = RMFT2::getRouteDescription(id);
+    StringFormatter::send(stream, F("]\\[R%d}|{%S}|{2"), id, desc);
+  }
+  StringFormatter::send(stream, F("\n"));
@@ -577 +595 @@ void WiThrottle::sendRoutes(Print* stream) {
-   (void)stream; // remove warning
+  (void)stream;  // remove warning
@@ -582,4 +600,4 @@ void WiThrottle::sendFunctions(Print* stream, byte loco) {
-  int16_t locoid=myLocos[loco].cab;
-  int fkeys=32; // upper limit (send functions 0 to 31)
-	myLocos[loco].functionToggles=1<<2; // F2 (HORN)  is a non-toggle
-        
+  int16_t locoid = myLocos[loco].cab;
+  int fkeys = 32;                          // upper limit (send functions 0 to 31)
+  myLocos[loco].functionToggles = 1 << 2;  // F2 (HORN)  is a non-toggle
+
@@ -587,43 +605,39 @@ void WiThrottle::sendFunctions(Print* stream, byte loco) {
-	const FSH * functionNames= RMFT2::getRosterFunctions(locoid);
-	if (functionNames == NULL) {
-	  // no roster entry for locoid, try to find default entry
-	  functionNames= RMFT2::getRosterFunctions(0);
-	}
-	if (functionNames == NULL) {
-	  // no default roster entry either, use non-exrail presets as above 
-	}
-	else if (GETFLASH(functionNames)=='\0') {
-	  // "" = Roster but no functions given
-	  fkeys=0;
-	}  
-	else {
-	  // we have function names... 
-	  // scan names list emitting names, counting functions and 
-	  // flagging non-toggling things like horn.
-	  myLocos[loco].functionToggles =0;
-	  StringFormatter::send(stream, F("M%cL%c%d<;>]\\["), myLocos[loco].throttle,LorS(locoid),locoid);   
-	  fkeys=0;
-	  bool firstchar=true;
-	  for (int fx=0;;fx++) {
-	    char c=GETFLASH((char *)functionNames+fx);
-	    if (c=='\0') {
-	      fkeys++;
-	      break;
-	    }
-	    if (c=='/') {
-	      fkeys++;
-	      StringFormatter::send(stream,F("]\\["));
-	      firstchar=true;
-	    }
-	    else if (firstchar && c=='*') {
-	      myLocos[loco].functionToggles |= 1UL<<fkeys;
-	      firstchar=false;
-	    } 
-	    else {
-	      firstchar=false;
-	      stream->write(c);
-	    }
-	  }
-	  StringFormatter::send(stream,F("\n"));
-	}
-        
+  const FSH* functionNames = RMFT2::getRosterFunctions(locoid);
+  if (functionNames == NULL) {
+    // no roster entry for locoid, try to find default entry
+    functionNames = RMFT2::getRosterFunctions(0);
+  }
+  if (functionNames == NULL) {
+    // no default roster entry either, use non-exrail presets as above
+  } else if (GETFLASH(functionNames) == '\0') {
+    // "" = Roster but no functions given
+    fkeys = 0;
+  } else {
+    // we have function names...
+    // scan names list emitting names, counting functions and
+    // flagging non-toggling things like horn.
+    myLocos[loco].functionToggles = 0;
+    StringFormatter::send(stream, F("M%cL%c%d<;>]\\["), myLocos[loco].throttle, LorS(locoid), locoid);
+    fkeys = 0;
+    bool firstchar = true;
+    for (int fx = 0;; fx++) {
+      char c = GETFLASH((char*)functionNames + fx);
+      if (c == '\0') {
+        fkeys++;
+        break;
+      }
+      if (c == '/') {
+        fkeys++;
+        StringFormatter::send(stream, F("]\\["));
+        firstchar = true;
+      } else if (firstchar && c == '*') {
+        myLocos[loco].functionToggles |= 1UL << fkeys;
+        firstchar = false;
+      } else {
+        firstchar = false;
+        stream->write(c);
+      }
+    }
+    StringFormatter::send(stream, F("\n"));
+  }
+
@@ -631,5 +645,6 @@ void WiThrottle::sendFunctions(Print* stream, byte loco) {
-	
-	for(int fKey=0; fKey<fkeys; fKey++) { 
-      int8_t fstate=DCC::getFn(locoid,fKey);
-      if (fstate>=0) StringFormatter::send(stream,F("M%cA%c%d<;>F%d%d\n"),myLocos[loco].throttle,LorS(locoid),locoid,fstate,fKey);                     
-	}
+
+  for (int fKey = 0; fKey < fkeys; fKey++) {
+    int8_t fstate = DCC::getFn(locoid, fKey);
+    if (fstate >= 0)
+      StringFormatter::send(stream, F("M%cA%c%d<;>F%d%d\n"), myLocos[loco].throttle, LorS(locoid), locoid, fstate, fKey);
+  }
diff --git a/WiThrottle.h b/WiThrottle.h
index 6756943..277b8d9 100644
--- a/WiThrottle.h
+++ b/WiThrottle.h
@@ -5 +5 @@
- *  
+ *
@@ -27,5 +27,5 @@ struct MYLOCO {
-    char throttle; //indicates which throttle letter on client, often '0','1' or '2'
-    int cab; //address of this loco
-    bool broadcastPending;
-    uint32_t functionMap;
-    uint32_t functionToggles;
+  char throttle;  // indicates which throttle letter on client, often '0','1' or '2'
+  int cab;        // address of this loco
+  bool broadcastPending;
+  uint32_t functionMap;
+  uint32_t functionToggles;
@@ -35,7 +35,11 @@ class WiThrottle {
-  public:  
-    static void loop(RingStream * stream);
-    void parse(RingStream * stream, byte * cmd);
-    static WiThrottle* getThrottle( int wifiClient); 
-    static void markForBroadcast(int cab);
-    static void forget(byte clientId);
-    static void findUniqThrottle(int id, char *u);
+ public:
+  static void loop(RingStream* stream);
+  void parse(RingStream* stream, byte* cmd);
+  static WiThrottle* getThrottle(int wifiClient);
+  static void markForBroadcast(int cab);
+  static void forget(byte clientId);
+  static void findUniqThrottle(int id, char* u);
+
+ private:
+  WiThrottle(int wifiClientId);
+  ~WiThrottle();
@@ -43,29 +47,14 @@ class WiThrottle {
-  private: 
-    WiThrottle( int wifiClientId);
-    ~WiThrottle();
-   
-      static const int MAX_MY_LOCO=10;      // maximum number of locos assigned to a single client
-      static const int HEARTBEAT_SECONDS=10; // heartbeat at 10 secs to provide messaging transport
-      static const int HEARTBEAT_PRELOAD=2; // request fast callback when connecting multiple messages
-      static const int ESTOP_SECONDS=20;     // eStop if no incoming messages for more than 8secs
-      static WiThrottle* firstThrottle;
-      static int getInt(byte * cmd);
-      static int getLocoId(byte * cmd);
-      static char LorS(int cab); 
-      static bool isThrottleInUse(int cab);
-      static void setSendTurnoutList();
-      bool areYouUsingThrottle(int cab);
-      WiThrottle* nextThrottle;
-      int clientid;
-      char uniq[17] = "";
-       
-      MYLOCO myLocos[MAX_MY_LOCO];   
-      bool heartBeatEnable;
-      unsigned long heartBeat;
-      bool introSent=false; 
-      bool turnoutsSent=false; 
-      bool rosterSent=false; 
-      bool routesSent=false; 
-      bool heartrateSent=false;
-      uint16_t mostRecentCab;
-      bool lastPowerState;  // last power state sent to this client
+  static const int MAX_MY_LOCO = 10;        // maximum number of locos assigned to a single client
+  static const int HEARTBEAT_SECONDS = 10;  // heartbeat at 10 secs to provide messaging transport
+  static const int HEARTBEAT_PRELOAD = 2;   // request fast callback when connecting multiple messages
+  static const int ESTOP_SECONDS = 20;      // eStop if no incoming messages for more than 8secs
+  static WiThrottle* firstThrottle;
+  static int getInt(byte* cmd);
+  static int getLocoId(byte* cmd);
+  static char LorS(int cab);
+  static bool isThrottleInUse(int cab);
+  static void setSendTurnoutList();
+  bool areYouUsingThrottle(int cab);
+  WiThrottle* nextThrottle;
+  int clientid;
+  char uniq[17] = "";
@@ -73,18 +62,10 @@ class WiThrottle {
-      int DCCToWiTSpeed(int DCCSpeed);
-      int WiTToDCCSpeed(int WiTSpeed);
-      void multithrottle(RingStream * stream, byte * cmd);
-      void locoAction(RingStream * stream, byte* aval, char throttleChar, int cab);
-      void accessory(RingStream *, byte* cmd);
-      void checkHeartbeat(RingStream * stream); 
-      void markForBroadcast2(int cab);
-      void sendIntro(Print * stream);
-      void sendTurnouts(Print * stream);
-      void sendRoster(Print * stream);
-      void sendRoutes(Print * stream);
-      void sendFunctions(Print* stream, byte loco);
-       // callback stuff to support prog track acquire
-       static RingStream * stashStream;
-       static WiThrottle * stashInstance;
-       static byte         stashClient;
-       static char         stashThrottleChar;
-       static void         getLocoCallback(int16_t locoid);
+  MYLOCO myLocos[MAX_MY_LOCO];
+  bool heartBeatEnable;
+  unsigned long heartBeat;
+  bool introSent = false;
+  bool turnoutsSent = false;
+  bool rosterSent = false;
+  bool routesSent = false;
+  bool heartrateSent = false;
+  uint16_t mostRecentCab;
+  bool lastPowerState;  // last power state sent to this client
@@ -91,0 +73,18 @@ class WiThrottle {
+  int DCCToWiTSpeed(int DCCSpeed);
+  int WiTToDCCSpeed(int WiTSpeed);
+  void multithrottle(RingStream* stream, byte* cmd);
+  void locoAction(RingStream* stream, byte* aval, char throttleChar, int cab);
+  void accessory(RingStream*, byte* cmd);
+  void checkHeartbeat(RingStream* stream);
+  void markForBroadcast2(int cab);
+  void sendIntro(Print* stream);
+  void sendTurnouts(Print* stream);
+  void sendRoster(Print* stream);
+  void sendRoutes(Print* stream);
+  void sendFunctions(Print* stream, byte loco);
+  // callback stuff to support prog track acquire
+  static RingStream* stashStream;
+  static WiThrottle* stashInstance;
+  static byte stashClient;
+  static char stashThrottleChar;
+  static void getLocoCallback(int16_t locoid);
diff --git a/WifiESP32.cpp b/WifiESP32.cpp
index 227484c..4aecb69 100644
--- a/WifiESP32.cpp
+++ b/WifiESP32.cpp
@@ -40 +40 @@
-void feedTheDog0(){
+void feedTheDog0() {
@@ -42,3 +42,3 @@ void feedTheDog0(){
-  TIMERG0.wdt_wprotect=TIMG_WDT_WKEY_VALUE; // write enable
-  TIMERG0.wdt_feed=1;                       // feed dog
-  TIMERG0.wdt_wprotect=0;                   // write protect
+  TIMERG0.wdt_wprotect = TIMG_WDT_WKEY_VALUE;  // write enable
+  TIMERG0.wdt_feed = 1;                        // feed dog
+  TIMERG0.wdt_wprotect = 0;                    // write protect
@@ -46,3 +46,3 @@ void feedTheDog0(){
-  //TIMERG1.wdt_wprotect=TIMG_WDT_WKEY_VALUE; // write enable
-  //TIMERG1.wdt_feed=1;                       // feed dog
-  //TIMERG1.wdt_wprotect=0;                   // write protect
+  // TIMERG1.wdt_wprotect=TIMG_WDT_WKEY_VALUE; // write enable
+  // TIMERG1.wdt_feed=1;                       // feed dog
+  // TIMERG1.wdt_wprotect=0;                   // write protect
@@ -74 +74 @@ class NetworkClient {
-public:
+ public:
@@ -82 +82 @@ public:
-    if(!wifi.connected()) {
+    if (!wifi.connected()) {
@@ -94 +94 @@ public:
-	DIAG(F("WARNING: Duplicate"));
+        DIAG(F("WARNING: Duplicate"));
@@ -96 +96 @@ public:
-	DIAG(F("Returning"));
+        DIAG(F("Returning"));
@@ -108 +108,2 @@ public:
-private:
+
+ private:
@@ -113,2 +114,2 @@ private:
-static std::vector<NetworkClient> clients; // a list to hold all clients
-static RingStream *outboundRing = new RingStream(10240);
+static std::vector<NetworkClient> clients;  // a list to hold all clients
+static RingStream* outboundRing = new RingStream(10240);
@@ -118 +119 @@ bool WifiESP::wifiUp = false;
-WiFiServer *WifiESP::server = NULL;
+WiFiServer* WifiESP::server = NULL;
@@ -121,2 +122,2 @@ WiFiServer *WifiESP::server = NULL;
-void wifiLoop(void *){
-  for(;;){
+void wifiLoop(void*) {
+  for (;;) {
@@ -136 +137 @@ void WifiESP::teardown() {
-  DCC::setThrottle(0,1,1); // this broadcasts speed 1(estop) and sets all reminders to speed 1.
+  DCC::setThrottle(0, 1, 1);  // this broadcasts speed 1(estop) and sets all reminders to speed 1.
@@ -158,6 +159 @@ void WifiESP::teardown() {
-bool WifiESP::setup(const char *SSid,
-                    const char *password,
-                    const char *hostname,
-                    int port,
-                    const byte channel,
-                    const bool forceAP) {
+bool WifiESP::setup(const char* SSid, const char* password, const char* hostname, int port, const byte channel, const bool forceAP) {
@@ -166 +162 @@ bool WifiESP::setup(const char *SSid,
-//  bool wifiUp = false;
+  //  bool wifiUp = false;
@@ -171,3 +167,3 @@ bool WifiESP::setup(const char *SSid,
-  //#ifdef SERIAL_BT_COMMANDS
-  //return false;
-  //#endif
+  // #ifdef SERIAL_BT_COMMANDS
+  // return false;
+  // #endif
@@ -193 +189 @@ bool WifiESP::setup(const char *SSid,
-  const char *yourNetwork = "Your network ";
+  const char* yourNetwork = "Your network ";
@@ -200 +196 @@ bool WifiESP::setup(const char *SSid,
-    WiFi.setHostname(hostname); // Strangely does not work unless we do it HERE!
+    WiFi.setHostname(hostname);  // Strangely does not work unless we do it HERE!
@@ -202,2 +198,2 @@ bool WifiESP::setup(const char *SSid,
-    WiFi.setScanMethod(WIFI_ALL_CHANNEL_SCAN); // Scan all channels so we find strongest
-                                               // (default in Wifi library is first match)
+    WiFi.setScanMethod(WIFI_ALL_CHANNEL_SCAN);  // Scan all channels so we find strongest
+                                                // (default in Wifi library is first match)
@@ -222 +218 @@ bool WifiESP::setup(const char *SSid,
-      DIAG(F("Could not connect to Wifi SSID %s"),SSid);
+      DIAG(F("Could not connect to Wifi SSID %s"), SSid);
@@ -226 +222 @@ bool WifiESP::setup(const char *SSid,
-      tries=40;
+      tries = 40;
@@ -228,3 +224,3 @@ bool WifiESP::setup(const char *SSid,
-	Serial.print('.');
-	tries--;
-	delay(500);
+        Serial.print('.');
+        tries--;
+        delay(500);
@@ -233,2 +229,2 @@ bool WifiESP::setup(const char *SSid,
-	DIAG(F("Wifi STA IP 2nd try %s"),WiFi.localIP().toString().c_str());
-	wifiUp = true;
+        DIAG(F("Wifi STA IP 2nd try %s"), WiFi.localIP().toString().c_str());
+        wifiUp = true;
@@ -236,2 +232,2 @@ bool WifiESP::setup(const char *SSid,
-	DIAG(F("Wifi STA mode FAIL. Will revert to AP mode"));
-	haveSSID=false;
+        DIAG(F("Wifi STA mode FAIL. Will revert to AP mode"));
+        haveSSID = false;
@@ -244 +240 @@ bool WifiESP::setup(const char *SSid,
-    String strPass( (forceAP && havePassword) ? password : "PASS_");
+    String strPass((forceAP && havePassword) ? password : "PASS_");
@@ -247,3 +243,3 @@ bool WifiESP::setup(const char *SSid,
-      strMac.remove(0,9);
-      strMac.replace(":","");
-      strMac.replace(":","");
+      strMac.remove(0, 9);
+      strMac.replace(":", "");
+      strMac.replace(":", "");
@@ -262,3 +258 @@ bool WifiESP::setup(const char *SSid,
-    if (WiFi.softAP(strSSID.c_str(),
-		    havePassword ? password : strPass.c_str(),
-		    channel, false, 8)) {
+    if (WiFi.softAP(strSSID.c_str(), havePassword ? password : strPass.c_str(), channel, false, 8)) {
@@ -269 +263 @@ bool WifiESP::setup(const char *SSid,
-	LCD(6, F("PASS: %s"),strPass.c_str());
+        LCD(6, F("PASS: %s"), strPass.c_str());
@@ -271 +265 @@ bool WifiESP::setup(const char *SSid,
-      LCD(7, F("IP: %s"),WiFi.softAPIP().toString().c_str());
+      LCD(7, F("IP: %s"), WiFi.softAPIP().toString().c_str());
@@ -275 +269 @@ bool WifiESP::setup(const char *SSid,
-      DIAG(F("Could not set up AP with Wifi SSID %s"),strSSID.c_str());
+      DIAG(F("Could not set up AP with Wifi SSID %s"), strSSID.c_str());
@@ -279 +272,0 @@ bool WifiESP::setup(const char *SSid,
-
@@ -286 +279 @@ bool WifiESP::setup(const char *SSid,
-  else{
+  else {
@@ -292 +284,0 @@ bool WifiESP::setup(const char *SSid,
-
@@ -294 +286 @@ bool WifiESP::setup(const char *SSid,
-  if(!MDNS.begin(hostname)) {
+  if (!MDNS.begin(hostname)) {
@@ -297 +289 @@ bool WifiESP::setup(const char *SSid,
-  if(!MDNS.addService("withrottle", "tcp", port)) {
+  if (!MDNS.addService("withrottle", "tcp", port)) {
@@ -301 +293 @@ bool WifiESP::setup(const char *SSid,
-  server = new WiFiServer(port); // start listening on tcp port
+  server = new WiFiServer(port);  // start listening on tcp port
@@ -306,9 +298,8 @@ bool WifiESP::setup(const char *SSid,
-  //start loop task
-  if (pdPASS != xTaskCreatePinnedToCore(
-	wifiLoop, /* Task function. */
-	"wifiLoop",/* name of task.  */
-	10000,     /* Stack size of task */
-	NULL,      /* parameter of the task */
-	1,         /* priority of the task */
-	NULL,      /* Task handle to keep track of created task */
-	0)) {      /* pin task to core 0 */
+  // start loop task
+  if (pdPASS != xTaskCreatePinnedToCore(wifiLoop,   /* Task function. */
+                                        "wifiLoop", /* name of task.  */
+                                        10000,      /* Stack size of task */
+                                        NULL,       /* parameter of the task */
+                                        1,          /* priority of the task */
+                                        NULL,       /* Task handle to keep track of created task */
+                                        0)) {       /* pin task to core 0 */
@@ -321 +312 @@ bool WifiESP::setup(const char *SSid,
-  DIAG(F("Server starting (core 0) port %d"),port);
+  DIAG(F("Server starting (core 0) port %d"), port);
@@ -323 +314 @@ bool WifiESP::setup(const char *SSid,
-  DIAG(F("Server will be started on port %d"),port);
+  DIAG(F("Server will be started on port %d"), port);
@@ -328,9 +319,2 @@ bool WifiESP::setup(const char *SSid,
-const char *wlerror[] = {
-			 "WL_IDLE_STATUS",
-			 "WL_NO_SSID_AVAIL",
-			 "WL_SCAN_COMPLETED",
-			 "WL_CONNECTED",
-			 "WL_CONNECT_FAILED",
-			 "WL_CONNECTION_LOST",
-			 "WL_DISCONNECTED"
-};
+const char* wlerror[] = {"WL_IDLE_STATUS",    "WL_NO_SSID_AVAIL",   "WL_SCAN_COMPLETED", "WL_CONNECTED",
+                         "WL_CONNECT_FAILED", "WL_CONNECTION_LOST", "WL_DISCONNECTED"};
@@ -339 +323 @@ void WifiESP::loop() {
-  int clientId; //tmp loop var
+  int clientId;  // tmp loop var
@@ -347,11 +331,11 @@ void WifiESP::loop() {
-	for (clientId=0; clientId<clients.size(); clientId++){
-	  if (clients[clientId].recycle(client)) {
-	    DIAG(F("Recycle client %d %s:%d"), clientId, client.remoteIP().toString().c_str(),client.remotePort());
-	    break;
-	  }
-	}
-	if (clientId>=clients.size()) {
-	  NetworkClient nc(client);
-	  clients.push_back(nc);
-	  DIAG(F("New client %d, %s:%d"), clientId, client.remoteIP().toString().c_str(),client.remotePort());
-	}
+        for (clientId = 0; clientId < clients.size(); clientId++) {
+          if (clients[clientId].recycle(client)) {
+            DIAG(F("Recycle client %d %s:%d"), clientId, client.remoteIP().toString().c_str(), client.remotePort());
+            break;
+          }
+        }
+        if (clientId >= clients.size()) {
+          NetworkClient nc(client);
+          clients.push_back(nc);
+          DIAG(F("New client %d, %s:%d"), clientId, client.remoteIP().toString().c_str(), client.remotePort());
+        }
@@ -362,12 +346,12 @@ void WifiESP::loop() {
-    for (clientId=0; clientId<clients.size(); clientId++){
-      if(clients[clientId].active(clientId)) {
-	int len;
-	if ((len = clients[clientId].wifi.available()) > 0) {
-	  // read data from client
-	  byte cmd[len+1];
-	  for(int i=0; i<len; i++) {
-	    cmd[i]=clients[clientId].wifi.read();
-	  }
-	  cmd[len]=0;
-	  CommandDistributor::parse(clientId,cmd,outboundRing);
-	}
+    for (clientId = 0; clientId < clients.size(); clientId++) {
+      if (clients[clientId].active(clientId)) {
+        int len;
+        if ((len = clients[clientId].wifi.available()) > 0) {
+          // read data from client
+          byte cmd[len + 1];
+          for (int i = 0; i < len; i++) {
+            cmd[i] = clients[clientId].wifi.read();
+          }
+          cmd[len] = 0;
+          CommandDistributor::parse(clientId, cmd, outboundRing);
+        }
@@ -375 +359 @@ void WifiESP::loop() {
-    } // all clients
+    }  // all clients
@@ -380 +364 @@ void WifiESP::loop() {
-    clientId=outboundRing->read();
+    clientId = outboundRing->read();
@@ -387 +371 @@ void WifiESP::loop() {
-      int count=outboundRing->count();
+      int count = outboundRing->count();
@@ -389,19 +373,19 @@ void WifiESP::loop() {
-	char buffer[count+1]; // one extra for '\0'
-	for(int i=0;i<count;i++) {
-	  int c = outboundRing->read();
-	  if (c >= 0) // Panic check, should never be false
-	    buffer[i] = (char)c;
-	  else {
-	    DIAG(F("Ringread fail at %d"),i);
-	    break;
-	  }
-	}
-	// buffer filled, end with '\0' so we can use it as C string
-	buffer[count]='\0';
-	if((unsigned int)clientId <= clients.size() && clients[clientId].active(clientId)) {
-	  if (Diag::CMD || Diag::WITHROTTLE)
-	    DIAG(F("SEND %d:%s"), clientId, buffer);
-	  clients[clientId].wifi.write(buffer,count);
-	} else {
-	  DIAG(F("Unsent(%d): %s"), clientId, buffer);
-	}
+        char buffer[count + 1];  // one extra for '\0'
+        for (int i = 0; i < count; i++) {
+          int c = outboundRing->read();
+          if (c >= 0)  // Panic check, should never be false
+            buffer[i] = (char)c;
+          else {
+            DIAG(F("Ringread fail at %d"), i);
+            break;
+          }
+        }
+        // buffer filled, end with '\0' so we can use it as C string
+        buffer[count] = '\0';
+        if ((unsigned int)clientId <= clients.size() && clients[clientId].active(clientId)) {
+          if (Diag::CMD || Diag::WITHROTTLE)
+            DIAG(F("SEND %d:%s"), clientId, buffer);
+          clients[clientId].wifi.write(buffer, count);
+        } else {
+          DIAG(F("Unsent(%d): %s"), clientId, buffer);
+        }
@@ -410 +394 @@ void WifiESP::loop() {
-  } else if (!APmode) { // in STA mode but not connected any more
+  } else if (!APmode) {  // in STA mode but not connected any more
@@ -416 +400 @@ void WifiESP::loop() {
-      uint8_t tries=40;
+      uint8_t tries = 40;
@@ -418,3 +402,3 @@ void WifiESP::loop() {
-	Serial.print('.');
-	tries--;
-	delay(500);
+        Serial.print('.');
+        tries--;
+        delay(500);
@@ -424 +408 @@ void WifiESP::loop() {
-      //DIAG(F("Running BT"));
+      // DIAG(F("Running BT"));
@@ -439 +423 @@ void WifiESP::loop() {
-#endif //ESP32
+#endif  // ESP32
diff --git a/WifiESP32.h b/WifiESP32.h
index 58cceca..f8ff380 100644
--- a/WifiESP32.h
+++ b/WifiESP32.h
@@ -28,10 +28,3 @@
-class WifiESP
-{
-
-public:
-  static bool setup(const char *wifiESSID,
-		    const char *wifiPassword,
-		    const char *hostname,
-		    const int port,
-		    const byte channel,
-			const bool forceAP);
+class WifiESP {
+ public:
+  static bool setup(const char* wifiESSID, const char* wifiPassword, const char* hostname, const int port, const byte channel, const bool forceAP);
@@ -39 +32,2 @@ public:
-private:
+
+ private:
@@ -42 +36 @@ private:
-  static WiFiServer *server;
+  static WiFiServer* server;
@@ -44,2 +38,2 @@ private:
-#endif //WifiESP8266_h
-#endif //ESP8266
+#endif  // WifiESP8266_h
+#endif  // ESP8266
diff --git a/WifiInboundHandler.cpp b/WifiInboundHandler.cpp
index b570527..14bdc81 100644
--- a/WifiInboundHandler.cpp
+++ b/WifiInboundHandler.cpp
@@ -7 +7 @@
- *  
+ *
@@ -30 +30 @@
-WifiInboundHandler * WifiInboundHandler::singleton;
+WifiInboundHandler* WifiInboundHandler::singleton;
@@ -32,2 +32,2 @@ WifiInboundHandler * WifiInboundHandler::singleton;
-void WifiInboundHandler::setup(Stream * ESStream) {
-  singleton=new WifiInboundHandler(ESStream);
+void WifiInboundHandler::setup(Stream* ESStream) {
+  singleton = new WifiInboundHandler(ESStream);
@@ -40,9 +40,7 @@ void WifiInboundHandler::loop() {
-
-WifiInboundHandler::WifiInboundHandler(Stream * ESStream) {
-  wifiStream=ESStream;
-  clientPendingCIPSEND=-1;
-  inboundRing=new RingStream(INBOUND_RING);
-  outboundRing=new RingStream(OUTBOUND_RING);
-  pendingCipsend=false;
-} 
-
+WifiInboundHandler::WifiInboundHandler(Stream* ESStream) {
+  wifiStream = ESStream;
+  clientPendingCIPSEND = -1;
+  inboundRing = new RingStream(INBOUND_RING);
+  outboundRing = new RingStream(OUTBOUND_RING);
+  pendingCipsend = false;
+}
@@ -52 +50 @@ WifiInboundHandler::WifiInboundHandler(Stream * ESStream) {
-// Other input returns  
+// Other input returns
@@ -54,41 +52,41 @@ void WifiInboundHandler::loop1() {
-   // First handle all inbound traffic events because they will block the sending 
-   if (loop2()!=INBOUND_IDLE) return;
-
-   WiThrottle::loop(outboundRing);
-   
-    // if nothing is already CIPSEND pending, we can CIPSEND one reply
-    if (clientPendingCIPSEND<0) {
-       clientPendingCIPSEND=outboundRing->read();
-       if (clientPendingCIPSEND>=0) {
-         currentReplySize=outboundRing->count();
-         pendingCipsend=true;
-       }
-     }
-    
-
-    if (pendingCipsend && millis()-lastCIPSEND > CIPSENDgap) {
-         if (Diag::WIFI) DIAG( F("WiFi: [[CIPSEND=%d,%d]]"), clientPendingCIPSEND, currentReplySize);
-         StringFormatter::send(wifiStream, F("AT+CIPSEND=%d,%d\r\n"),  clientPendingCIPSEND, currentReplySize);
-         pendingCipsend=false;
-         return;
-      }
-    
-    
-    // if something waiting to execute, we can call it 
-      int clientId=inboundRing->read();
-      if (clientId>=0) {
-         int count=inboundRing->count();
-         if (Diag::WIFI) DIAG(F("Wifi EXEC: %d %d:"),clientId,count); 
-         byte cmd[count+1];
-         for (int i=0;i<count;i++) cmd[i]=inboundRing->read();   
-         cmd[count]=0;
-         if (Diag::WIFI) DIAG(F("%e"),cmd); 
-         
-         CommandDistributor::parse(clientId,cmd,outboundRing);
-         return;
-      }
-   }
-
-
-
-// This is a Finite State Automation (FSA) handling the inbound bytes from an ES AT command processor    
+  // First handle all inbound traffic events because they will block the sending
+  if (loop2() != INBOUND_IDLE)
+    return;
+
+  WiThrottle::loop(outboundRing);
+
+  // if nothing is already CIPSEND pending, we can CIPSEND one reply
+  if (clientPendingCIPSEND < 0) {
+    clientPendingCIPSEND = outboundRing->read();
+    if (clientPendingCIPSEND >= 0) {
+      currentReplySize = outboundRing->count();
+      pendingCipsend = true;
+    }
+  }
+
+  if (pendingCipsend && millis() - lastCIPSEND > CIPSENDgap) {
+    if (Diag::WIFI)
+      DIAG(F("WiFi: [[CIPSEND=%d,%d]]"), clientPendingCIPSEND, currentReplySize);
+    StringFormatter::send(wifiStream, F("AT+CIPSEND=%d,%d\r\n"), clientPendingCIPSEND, currentReplySize);
+    pendingCipsend = false;
+    return;
+  }
+
+  // if something waiting to execute, we can call it
+  int clientId = inboundRing->read();
+  if (clientId >= 0) {
+    int count = inboundRing->count();
+    if (Diag::WIFI)
+      DIAG(F("Wifi EXEC: %d %d:"), clientId, count);
+    byte cmd[count + 1];
+    for (int i = 0; i < count; i++) cmd[i] = inboundRing->read();
+    cmd[count] = 0;
+    if (Diag::WIFI)
+      DIAG(F("%e"), cmd);
+
+    CommandDistributor::parse(clientId, cmd, outboundRing);
+    return;
+  }
+}
+
+// This is a Finite State Automation (FSA) handling the inbound bytes from an ES AT command processor
@@ -103 +101 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-      StringFormatter::printEscape(ch); // DIAG in disguise
+      StringFormatter::printEscape(ch);  // DIAG in disguise
@@ -107,2 +105,2 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-      case ANYTHING:  // looking for +IPD, > , busy ,  n,CONNECTED, n,CLOSED, ERROR, SEND OK 
-        
+      case ANYTHING:  // looking for +IPD, > , busy ,  n,CONNECTED, n,CLOSED, ERROR, SEND OK
+
@@ -111 +109 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-          break; 
+          break;
@@ -113,12 +111,14 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-        
-        if (ch=='>') { 
-           if (Diag::WIFI) DIAG(F("[XMIT %d]"),currentReplySize); 
-           for (int i=0;i<currentReplySize;i++) {
-             int cout=outboundRing->read();
-             wifiStream->write(cout);
-             if (Diag::WIFI) StringFormatter::printEscape(cout); // DIAG in disguise
-           }
-           clientPendingCIPSEND=-1;
-           pendingCipsend=false;
-           loopState=SKIPTOEND;
-           break;
+
+        if (ch == '>') {
+          if (Diag::WIFI)
+            DIAG(F("[XMIT %d]"), currentReplySize);
+          for (int i = 0; i < currentReplySize; i++) {
+            int cout = outboundRing->read();
+            wifiStream->write(cout);
+            if (Diag::WIFI)
+              StringFormatter::printEscape(cout);  // DIAG in disguise
+          }
+          clientPendingCIPSEND = -1;
+          pendingCipsend = false;
+          loopState = SKIPTOEND;
+          break;
@@ -126,3 +126,3 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-        
-        if (ch=='R') { // Received ... bytes 
-          loopState=SKIPTOEND;
+
+        if (ch == 'R') {  // Received ... bytes
+          loopState = SKIPTOEND;
@@ -131,4 +131,4 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-       
-        if (ch=='S') { // SEND OK probably 
-          loopState=SKIPTOEND;
-          lastCIPSEND=0; // no need to wait next time 
+
+        if (ch == 'S') {  // SEND OK probably
+          loopState = SKIPTOEND;
+          lastCIPSEND = 0;  // no need to wait next time
@@ -137,6 +137,7 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-        
-        if (ch=='b') {   // This is a busy indicator... probabaly must restart a CIPSEND  
-           pendingCipsend=(clientPendingCIPSEND>=0);
-           if (pendingCipsend) lastCIPSEND=millis(); // forces a gap to next CIPSEND
-           loopState=SKIPTOEND; 
-           break; 
+
+        if (ch == 'b') {  // This is a busy indicator... probabaly must restart a CIPSEND
+          pendingCipsend = (clientPendingCIPSEND >= 0);
+          if (pendingCipsend)
+            lastCIPSEND = millis();  // forces a gap to next CIPSEND
+          loopState = SKIPTOEND;
+          break;
@@ -144,5 +145,5 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-        
-        if (ch>='0' && ch<='9') { 
-              runningClientId=ch-'0';
-              loopState=GOT_CLIENT_ID;
-              break;
+
+        if (ch >= '0' && ch <= '9') {
+          runningClientId = ch - '0';
+          loopState = GOT_CLIENT_ID;
+          break;
@@ -151,2 +152,2 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-        if (ch=='E' || ch=='l') { // ERROR or "link is not valid"
-          if (clientPendingCIPSEND>=0) {
+        if (ch == 'E' || ch == 'l') {  // ERROR or "link is not valid"
+          if (clientPendingCIPSEND >= 0) {
@@ -154 +155 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-            purgeCurrentCIPSEND(); 
+            purgeCurrentCIPSEND();
@@ -156,2 +157,2 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-          loopState=SKIPTOEND; 
-          break; 
+          loopState = SKIPTOEND;
+          break;
@@ -159 +160 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-        
+
@@ -161 +162 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-        
+
@@ -165 +166 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-        
+
@@ -169 +170 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-        
+
@@ -171 +172 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-        loopState = (ch == 'D') ?  IPD3 : SKIPTOEND;
+        loopState = (ch == 'D') ? IPD3 : SKIPTOEND;
@@ -173 +174 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-        
+
@@ -177 +178 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-        
+
@@ -179,5 +180,5 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-        if (ch >= '0' || ch <='9'){
-           runningClientId=ch-'0';
-           loopState=IPD5;
-        }
-        else loopState=SKIPTOEND;
+        if (ch >= '0' || ch <= '9') {
+          runningClientId = ch - '0';
+          loopState = IPD5;
+        } else
+          loopState = SKIPTOEND;
@@ -185 +186 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-        
+
@@ -188 +189 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-        dataLength=0;  // ready to start collecting the length
+        dataLength = 0;  // ready to start collecting the length
@@ -190,2 +191,2 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-        
-      case IPD6_LENGTH: // reading for length
+
+      case IPD6_LENGTH:  // reading for length
@@ -193,2 +194,2 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-          if (dataLength==0) {
-            loopState=ANYTHING;
+          if (dataLength == 0) {
+            loopState = ANYTHING;
@@ -197,5 +198,7 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-          if (Diag::WIFI) DIAG(F("Wifi inbound data(%d:%d):"),runningClientId,dataLength); 
-          if (inboundRing->freeSpace()<=(dataLength+1)) {
-            // This input would overflow the inbound ring, ignore it  
-            loopState=IPD_IGNORE_DATA;
-            if (Diag::WIFI) DIAG(F("Wifi OVERFLOW IGNORING:"));    
+          if (Diag::WIFI)
+            DIAG(F("Wifi inbound data(%d:%d):"), runningClientId, dataLength);
+          if (inboundRing->freeSpace() <= (dataLength + 1)) {
+            // This input would overflow the inbound ring, ignore it
+            loopState = IPD_IGNORE_DATA;
+            if (Diag::WIFI)
+              DIAG(F("Wifi OVERFLOW IGNORING:"));
@@ -205,2 +208,2 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-          loopState=IPD_DATA;
-          break; 
+          loopState = IPD_DATA;
+          break;
@@ -210,3 +213,3 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-        
-      case IPD_DATA: // reading data
-        inboundRing->write(ch);    
+
+      case IPD_DATA:  // reading data
+        inboundRing->write(ch);
@@ -215 +218 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-          inboundRing->commit();    
+          inboundRing->commit();
@@ -220 +223 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-      case IPD_IGNORE_DATA: // ignoring data that would not fit in inbound ring
+      case IPD_IGNORE_DATA:  // ignoring data that would not fit in inbound ring
@@ -222 +225,2 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-        if (dataLength == 0) loopState = ANYTHING;
+        if (dataLength == 0)
+          loopState = ANYTHING;
@@ -226 +230 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-        loopState=(ch==',') ? GOT_CLIENT_ID2: SKIPTOEND;
+        loopState = (ch == ',') ? GOT_CLIENT_ID2 : SKIPTOEND;
@@ -228,6 +232,8 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-        
-      case GOT_CLIENT_ID2:  // got "x,"  
-        if (ch=='C') {
-         // got "x C" before CLOSE or CONNECTED, or CONNECT FAILED
-         if (runningClientId==clientPendingCIPSEND) purgeCurrentCIPSEND();
-         else CommandDistributor::forget(runningClientId);
+
+      case GOT_CLIENT_ID2:  // got "x,"
+        if (ch == 'C') {
+          // got "x C" before CLOSE or CONNECTED, or CONNECT FAILED
+          if (runningClientId == clientPendingCIPSEND)
+            purgeCurrentCIPSEND();
+          else
+            CommandDistributor::forget(runningClientId);
@@ -235 +241 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-        loopState=SKIPTOEND;   
+        loopState = SKIPTOEND;
@@ -237,3 +243,4 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-         
-      case SKIPTOEND: // skipping for /n
-        if (ch=='\n') loopState=ANYTHING;
+
+      case SKIPTOEND:  // skipping for /n
+        if (ch == '\n')
+          loopState = ANYTHING;
@@ -242,2 +249,2 @@ WifiInboundHandler::INBOUND_STATE WifiInboundHandler::loop2() {
-  } // available
-  return (loopState==ANYTHING) ? INBOUND_IDLE: INBOUND_BUSY;
+  }  // available
+  return (loopState == ANYTHING) ? INBOUND_IDLE : INBOUND_BUSY;
@@ -247,6 +254,6 @@ void WifiInboundHandler::purgeCurrentCIPSEND() {
-         // A CIPSEND was sent but errored... or the client closed just toss it away
-         CommandDistributor::forget(clientPendingCIPSEND); 
-         DIAG(F("Wifi: DROPPING CIPSEND=%d,%d"),clientPendingCIPSEND,currentReplySize);
-         for (int i=0;i<currentReplySize;i++) outboundRing->read();
-         pendingCipsend=false;  
-         clientPendingCIPSEND=-1;
+  // A CIPSEND was sent but errored... or the client closed just toss it away
+  CommandDistributor::forget(clientPendingCIPSEND);
+  DIAG(F("Wifi: DROPPING CIPSEND=%d,%d"), clientPendingCIPSEND, currentReplySize);
+  for (int i = 0; i < currentReplySize; i++) outboundRing->read();
+  pendingCipsend = false;
+  clientPendingCIPSEND = -1;
diff --git a/WifiInboundHandler.h b/WifiInboundHandler.h
index 08f6789..ae5bcbd 100644
--- a/WifiInboundHandler.h
+++ b/WifiInboundHandler.h
@@ -30,5 +30,3 @@ class WifiInboundHandler {
- public:  
-   static void setup(Stream * ESStream);
-   static void loop();
-   
-   private:
+ public:
+  static void setup(Stream* ESStream);
+  static void loop();
@@ -36,7 +34,2 @@ class WifiInboundHandler {
-   static WifiInboundHandler * singleton;
-  
-   
-   enum INBOUND_STATE : byte {
-        INBOUND_BUSY,     // keep calling in loop() 
-        INBOUND_IDLE     // Nothing happening, outbound may xcall CIPSEND
-   };      
+ private:
+  static WifiInboundHandler* singleton;
@@ -44,14 +37,8 @@ class WifiInboundHandler {
-        enum LOOP_STATE : byte {
-          ANYTHING,    // ready for +IPD, n CLOSED, n CONNECTED, busy etc...
-          SKIPTOEND,   // skip to newline
-          
-          // +IPD,client,length:data
-          IPD,         // got +
-          IPD1,        // got +I
-          IPD2,        // got +IP
-          IPD3,        // got +IPD
-          IPD4_CLIENT,  // got +IPD,  reading cient id
-          IPD5,        // got +IPD,c 
-          IPD6_LENGTH, // got +IPD,c, reading length 
-          IPD_DATA,    // got +IPD,c,ll,: collecting data
-          IPD_IGNORE_DATA, // got +IPD,c,ll,: ignoring the data that won't fit inblound Ring
+  enum INBOUND_STATE : byte {
+    INBOUND_BUSY,  // keep calling in loop()
+    INBOUND_IDLE   // Nothing happening, outbound may xcall CIPSEND
+  };
+
+  enum LOOP_STATE : byte {
+    ANYTHING,   // ready for +IPD, n CLOSED, n CONNECTED, busy etc...
+    SKIPTOEND,  // skip to newline
@@ -59,2 +46,13 @@ class WifiInboundHandler {
-          GOT_CLIENT_ID,  // clientid prefix to CONNECTED / CLOSED
-          GOT_CLIENT_ID2  // clientid prefix to CONNECTED / CLOSED
+    // +IPD,client,length:data
+    IPD,              // got +
+    IPD1,             // got +I
+    IPD2,             // got +IP
+    IPD3,             // got +IPD
+    IPD4_CLIENT,      // got +IPD,  reading cient id
+    IPD5,             // got +IPD,c
+    IPD6_LENGTH,      // got +IPD,c, reading length
+    IPD_DATA,         // got +IPD,c,ll,: collecting data
+    IPD_IGNORE_DATA,  // got +IPD,c,ll,: ignoring the data that won't fit inblound Ring
+
+    GOT_CLIENT_ID,  // clientid prefix to CONNECTED / CLOSED
+    GOT_CLIENT_ID2  // clientid prefix to CONNECTED / CLOSED
@@ -63,19 +61,18 @@ class WifiInboundHandler {
-  
-   WifiInboundHandler(Stream * ESStream);
-   void loop1();
-   INBOUND_STATE loop2();
-   void purgeCurrentCIPSEND();
-   Stream * wifiStream;
-   
-   static const int INBOUND_RING = 512;
-   static const int OUTBOUND_RING = sizeof(void*)==2?2048:8192;
- 
-   static const int CIPSENDgap=100; // millis() between retries of cipsend. 
- 
-   RingStream * inboundRing;
-   RingStream * outboundRing;
-     
-  LOOP_STATE loopState=ANYTHING;
-  int runningClientId;   // latest client inbound processing data or CLOSE
-  int dataLength; // dataLength of +IPD
-  int clientPendingCIPSEND=-1;
+  WifiInboundHandler(Stream* ESStream);
+  void loop1();
+  INBOUND_STATE loop2();
+  void purgeCurrentCIPSEND();
+  Stream* wifiStream;
+
+  static const int INBOUND_RING = 512;
+  static const int OUTBOUND_RING = sizeof(void*) == 2 ? 2048 : 8192;
+
+  static const int CIPSENDgap = 100;  // millis() between retries of cipsend.
+
+  RingStream* inboundRing;
+  RingStream* outboundRing;
+
+  LOOP_STATE loopState = ANYTHING;
+  int runningClientId;  // latest client inbound processing data or CLOSE
+  int dataLength;       // dataLength of +IPD
+  int clientPendingCIPSEND = -1;
@@ -84,2 +81 @@ class WifiInboundHandler {
-  uint32_t lastCIPSEND=0; // millis() of previous cipsend
-  
+  uint32_t lastCIPSEND = 0;  // millis() of previous cipsend
diff --git a/WifiInterface.cpp b/WifiInterface.cpp
index 6b6ec4a..cb64fe5 100644
--- a/WifiInterface.cpp
+++ b/WifiInterface.cpp
@@ -25,3 +25,3 @@
-// This code is NOT compiled on a unoWifiRev2 processor which uses a different architecture 
-#include "WifiInterface.h"        /* config.h included there */
-//#include <avr/pgmspace.h>
+// This code is NOT compiled on a unoWifiRev2 processor which uses a different architecture
+#include "WifiInterface.h" /* config.h included there */
+// #include <avr/pgmspace.h>
@@ -33,3 +32,0 @@
-
-
-
@@ -38 +35 @@ bool WifiInterface::connected = false;
-Stream * WifiInterface::wifiStream;
+Stream* WifiInterface::wifiStream;
@@ -43 +40 @@ Stream * WifiInterface::wifiStream;
-// or ot will cause issues with the following commands. 
+// or ot will cause issues with the following commands.
@@ -54 +51 @@ Stream * WifiInterface::wifiStream;
- 
+
@@ -72,3 +69,2 @@ Stream * WifiInterface::wifiStream;
-#elif defined(ARDUINO_NUCLEO_F413ZH) || defined(ARDUINO_NUCLEO_F429ZI) \
-    || defined(ARDUINO_NUCLEO_F446ZE) || defined(ARDUINO_NUCLEO_F412ZG) \
-    || defined(ARDUINO_NUCLEO_F439ZI) || defined(ARDUINO_NUCLEO_F4X9ZI)
+#elif defined(ARDUINO_NUCLEO_F413ZH) || defined(ARDUINO_NUCLEO_F429ZI) || defined(ARDUINO_NUCLEO_F446ZE) || defined(ARDUINO_NUCLEO_F412ZG) || \
+    defined(ARDUINO_NUCLEO_F439ZI) || defined(ARDUINO_NUCLEO_F4X9ZI)
@@ -88,8 +84,2 @@ Stream * WifiInterface::wifiStream;
-bool WifiInterface::setup(long serial_link_speed, 
-                          const FSH *wifiESSID,
-                          const FSH *wifiPassword,
-                          const FSH *hostname,
-                          const int port,
-                          const byte channel,
-                          const bool forceAP) {
-
+bool WifiInterface::setup(long serial_link_speed, const FSH* wifiESSID, const FSH* wifiPassword, const FSH* hostname, const int port,
+                          const byte channel, const bool forceAP) {
@@ -99,9 +89,9 @@ bool WifiInterface::setup(long serial_link_speed,
-  // no warning about unused parameters. 
-  (void) serial_link_speed;
-  (void) wifiESSID;
-  (void) wifiPassword;
-  (void) hostname;
-  (void) port;
-  (void) channel;
-  (void) forceAP;
-#endif  
+  // no warning about unused parameters.
+  (void)serial_link_speed;
+  (void)wifiESSID;
+  (void)wifiPassword;
+  (void)hostname;
+  (void)port;
+  (void)channel;
+  (void)forceAP;
+#endif
@@ -119,2 +109 @@ bool WifiInterface::setup(long serial_link_speed,
-  if (wifiUp == WIFI_NOAT)
-  {
+  if (wifiUp == WIFI_NOAT) {
@@ -130,2 +119 @@ bool WifiInterface::setup(long serial_link_speed,
-  if (wifiUp == WIFI_NOAT)
-  {
+  if (wifiUp == WIFI_NOAT) {
@@ -137,2 +125,2 @@ bool WifiInterface::setup(long serial_link_speed,
-  if (wifiUp == WIFI_NOAT) // here and still not AT commands found
-      return false;
+  if (wifiUp == WIFI_NOAT)  // here and still not AT commands found
+    return false;
@@ -141 +129 @@ bool WifiInterface::setup(long serial_link_speed,
-  // CAUTION... ONLY CALL THIS ONCE 
+  // CAUTION... ONLY CALL THIS ONCE
@@ -144 +132 @@ bool WifiInterface::setup(long serial_link_speed,
-      connected = true;
+    connected = true;
@@ -146,2 +134,2 @@ bool WifiInterface::setup(long serial_link_speed,
-      connected = false;
-  return connected; 
+    connected = false;
+  return connected;
@@ -150,2 +138,2 @@ bool WifiInterface::setup(long serial_link_speed,
-wifiSerialState WifiInterface::setup(Stream & setupStream,  const FSH* SSid, const FSH* password,
-				     const FSH* hostname,  int port, byte channel, bool forceAP) {
+wifiSerialState WifiInterface::setup(Stream& setupStream, const FSH* SSid, const FSH* password, const FSH* hostname, int port, byte channel,
+                                     bool forceAP) {
@@ -160 +148 @@ wifiSerialState WifiInterface::setup(Stream & setupStream,  const FSH* SSid, con
-  wifiState = setup2( SSid, password, hostname,  port, channel, forceAP);
+  wifiState = setup2(SSid, password, hostname, port, channel, forceAP);
@@ -166 +154 @@ wifiSerialState WifiInterface::setup(Stream & setupStream,  const FSH* SSid, con
- 
+
@@ -168 +156 @@ wifiSerialState WifiInterface::setup(Stream & setupStream,  const FSH* SSid, con
-    StringFormatter::send(wifiStream, F("ATE0\r\n")); // turn off the echo 
+    StringFormatter::send(wifiStream, F("ATE0\r\n"));  // turn off the echo
@@ -173 +161 @@ wifiSerialState WifiInterface::setup(Stream & setupStream,  const FSH* SSid, con
-    LCD(4,F("WiFi DISCON."));
+    LCD(4, F("WiFi DISCON."));
@@ -183,2 +171 @@ wifiSerialState WifiInterface::setup(Stream & setupStream,  const FSH* SSid, con
-wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-				      const FSH* hostname, int port, byte channel, bool forceAP) {
+wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password, const FSH* hostname, int port, byte channel, bool forceAP) {
@@ -188,3 +175,3 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-  char macAddress[17];  //  mac address extraction   
- 
-  // First check... Restarting the Arduino does not restart the ES. 
+  char macAddress[17];  //  mac address extraction
+
+  // First check... Restarting the Arduino does not restart the ES.
@@ -193 +180 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-  if (checkForOK(200,F("+IPD"), true)) {
+  if (checkForOK(200, F("+IPD"), true)) {
@@ -195 +182 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-    return WIFI_CONNECTED; 
+    return WIFI_CONNECTED;
@@ -198,3 +185,3 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-  StringFormatter::send(wifiStream, F("AT\r\n"));   // Is something here that understands AT?
-  if(!checkForOK(200, true))
-    return WIFI_NOAT;                               // No AT compatible WiFi module here
+  StringFormatter::send(wifiStream, F("AT\r\n"));  // Is something here that understands AT?
+  if (!checkForOK(200, true))
+    return WIFI_NOAT;  // No AT compatible WiFi module here
@@ -202,2 +189,2 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-  StringFormatter::send(wifiStream, F("ATE1\r\n")); // Turn on the echo, se we can see what's happening
-  checkForOK(2000, true);                // Makes this visible on the console
+  StringFormatter::send(wifiStream, F("ATE1\r\n"));  // Turn on the echo, se we can see what's happening
+  checkForOK(2000, true);                            // Makes this visible on the console
@@ -206 +193 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-  StringFormatter::send(wifiStream, F("AT+GMR\r\n")); 
+  StringFormatter::send(wifiStream, F("AT+GMR\r\n"));
@@ -209,3 +196,3 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-    for (int i=0; i<11;i++) {
-      while(!wifiStream->available());
-      version[i]=wifiStream->read();
+    for (int i = 0; i < 11; i++) {
+      while (!wifiStream->available());
+      version[i] = wifiStream->read();
@@ -214,4 +201,3 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-    if ((version[0] == '0') ||
-	(version[0] == '2' && version[2] == '0') ||
-	(version[0] == '2' && version[2] == '2' && version[4] == '0' && version[6] == '0'
-	 && version[7] == '-' && version[8] == 'd' && version[9] == 'e' && version[10] == 'v')) {
+    if ((version[0] == '0') || (version[0] == '2' && version[2] == '0') ||
+        (version[0] == '2' && version[2] == '2' && version[4] == '0' && version[6] == '0' && version[7] == '-' && version[8] == 'd' &&
+         version[9] == 'e' && version[10] == 'v')) {
@@ -231,2 +217,2 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-      oldCmd=true;
-      while (wifiStream->available()) StringFormatter::printEscape( wifiStream->read()); /// THIS IS A DIAG IN DISGUISE
+    oldCmd = true;
+    while (wifiStream->available()) StringFormatter::printEscape(wifiStream->read());  /// THIS IS A DIAG IN DISGUISE
@@ -235,2 +221,2 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-  StringFormatter::send(wifiStream, F("AT+CWMODE%s=1\r\n"), oldCmd ? "" : "_CUR"); // configure as "station" = WiFi client
-  checkForOK(1000, true);                       // Not always OK, sometimes "no change"
+  StringFormatter::send(wifiStream, F("AT+CWMODE%s=1\r\n"), oldCmd ? "" : "_CUR");  // configure as "station" = WiFi client
+  checkForOK(1000, true);                                                           // Not always OK, sometimes "no change"
@@ -238 +224 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-  const char *yourNetwork = "Your network ";
+  const char* yourNetwork = "Your network ";
@@ -249,3 +235,3 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-      if (checkForOK(5000, F("+CIFSR:STAIP"), true,false))
-	  if (!checkForOK(1000, F("0.0.0.0"), true,false))
-	      ipOK = true;
+      if (checkForOK(5000, F("+CIFSR:STAIP"), true, false))
+        if (!checkForOK(1000, F("0.0.0.0"), true, false))
+          ipOK = true;
@@ -254,6 +240,6 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-      // SSID was configured, so we assume station (client) mode.
-      if (oldCmd) {
-	      // AT command early version supports CWJAP/CWSAP
-	      StringFormatter::send(wifiStream, F("AT+CWJAP=\"%S\",\"%S\"\r\n"), SSid, password);
-	      ipOK = checkForOK(WIFI_CONNECT_TIMEOUT, true);
-      } else {
+    // SSID was configured, so we assume station (client) mode.
+    if (oldCmd) {
+      // AT command early version supports CWJAP/CWSAP
+      StringFormatter::send(wifiStream, F("AT+CWJAP=\"%S\",\"%S\"\r\n"), SSid, password);
+      ipOK = checkForOK(WIFI_CONNECT_TIMEOUT, true);
+    } else {
@@ -261,6 +247,2 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-        StringFormatter::send(wifiStream, F("AT+CWHOSTNAME=\"%S\"\r\n"), hostname); // Set Host name for Wifi Client
-      	checkForOK(2000, true); // dont care if not supported
-      
-        StringFormatter::send(wifiStream, F("AT+CWJAP_CUR=\"%S\",\"%S\"\r\n"), SSid, password);
-        ipOK = checkForOK(WIFI_CONNECT_TIMEOUT, true);
-      }
+      StringFormatter::send(wifiStream, F("AT+CWHOSTNAME=\"%S\"\r\n"), hostname);  // Set Host name for Wifi Client
+      checkForOK(2000, true);                                                      // dont care if not supported
@@ -268,9 +250,13 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-      if (ipOK) {
-	      // But we really only have the ESSID and password correct
-        // Let's check for IP (via DHCP)
-        ipOK = false;
-        StringFormatter::send(wifiStream, F("AT+CIFSR\r\n"));
-        if (checkForOK(5000, F("+CIFSR:STAIP"), true,false))
-        if (!checkForOK(1000, F("0.0.0.0"), true,false))
-        ipOK = true;
-      }
+      StringFormatter::send(wifiStream, F("AT+CWJAP_CUR=\"%S\",\"%S\"\r\n"), SSid, password);
+      ipOK = checkForOK(WIFI_CONNECT_TIMEOUT, true);
+    }
+
+    if (ipOK) {
+      // But we really only have the ESSID and password correct
+      // Let's check for IP (via DHCP)
+      ipOK = false;
+      StringFormatter::send(wifiStream, F("AT+CIFSR\r\n"));
+      if (checkForOK(5000, F("+CIFSR:STAIP"), true, false))
+        if (!checkForOK(1000, F("0.0.0.0"), true, false))
+          ipOK = true;
+    }
@@ -282,2 +268,2 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-  //    StringFormatter::send(wifiStream, F("AT+RST\r\n"));
-  //    checkForOK(1000, true); // Not always OK, sometimes "no change"
+    //    StringFormatter::send(wifiStream, F("AT+RST\r\n"));
+    //    checkForOK(1000, true); // Not always OK, sometimes "no change"
@@ -285 +271 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-    int i=0;
+    int i = 0;
@@ -288,3 +274,3 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-      // last way out to get any Wifi connectivity. 
-      StringFormatter::send(wifiStream, F("AT+CWMODE%s=2\r\n"), oldCmd ? "" : "_CUR"); 
-    } while (!checkForOK(1000+i*500, true) && i++<10);
+      // last way out to get any Wifi connectivity.
+      StringFormatter::send(wifiStream, F("AT+CWMODE%s=2\r\n"), oldCmd ? "" : "_CUR");
+    } while (!checkForOK(1000 + i * 500, true) && i++ < 10);
@@ -292 +278 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-    while (wifiStream->available()) StringFormatter::printEscape( wifiStream->read()); /// THIS IS A DIAG IN DISGUISE
+    while (wifiStream->available()) StringFormatter::printEscape(wifiStream->read());  /// THIS IS A DIAG IN DISGUISE
@@ -295 +281 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-    StringFormatter::send(wifiStream, F("AT+CIFSR\r\n")); // not TOMATO
+    StringFormatter::send(wifiStream, F("AT+CIFSR\r\n"));  // not TOMATO
@@ -297 +283 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-    if (checkForOK(5000, F("+CIFSR:APMAC,\""), true,false)) {
+    if (checkForOK(5000, F("+CIFSR:APMAC,\""), true, false)) {
@@ -299,4 +285,4 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-      for (int i=0; i<17;i++) {
-        while(!wifiStream->available());
-	macAddress[i]=wifiStream->read();
-	StringFormatter::printEscape(macAddress[i]);
+      for (int i = 0; i < 17; i++) {
+        while (!wifiStream->available());
+        macAddress[i] = wifiStream->read();
+        StringFormatter::printEscape(macAddress[i]);
@@ -305 +291 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-	memset(macAddress,'f',sizeof(macAddress));
+      memset(macAddress, 'f', sizeof(macAddress));
@@ -307 +293 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-    char macTail[]={macAddress[9],macAddress[10],macAddress[12],macAddress[13],macAddress[15],macAddress[16],'\0'};
+    char macTail[] = {macAddress[9], macAddress[10], macAddress[12], macAddress[13], macAddress[15], macAddress[16], '\0'};
@@ -310,2 +296,2 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-  
-    i=0;
+
+    i = 0;
@@ -315,3 +301,2 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-    // unconfigured
-          StringFormatter::send(wifiStream, F("AT+CWSAP%s=\"DCCEX_%s\",\"PASS_%s\",%d,4\r\n"),
-                                            oldCmd ? "" : "_CUR", macTail, macTail, channel);
+          // unconfigured
+          StringFormatter::send(wifiStream, F("AT+CWSAP%s=\"DCCEX_%s\",\"PASS_%s\",%d,4\r\n"), oldCmd ? "" : "_CUR", macTail, macTail, channel);
@@ -320,2 +305 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-          StringFormatter::send(wifiStream, F("AT+CWSAP%s=\"DCCEX_%s\",\"%S\",%d,4\r\n"), oldCmd ? "" : "_CUR",
-                                          macTail, password, channel);
+          StringFormatter::send(wifiStream, F("AT+CWSAP%s=\"DCCEX_%s\",\"%S\",%d,4\r\n"), oldCmd ? "" : "_CUR", macTail, password, channel);
@@ -324,2 +308 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-        StringFormatter::send(wifiStream, F("AT+CWSAP%s=\"%S\",\"%S\",%d,4\r\n"),
-                                        oldCmd ? "" : "_CUR", SSid, password, channel);
+        StringFormatter::send(wifiStream, F("AT+CWSAP%s=\"%S\",\"%S\",%d,4\r\n"), oldCmd ? "" : "_CUR", SSid, password, channel);
@@ -327 +310 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-    } while (!checkForOK(WIFI_CONNECT_TIMEOUT, true) && i++<2); // do twice if necessary but ignore failure as AP mode may still be ok
+    } while (!checkForOK(WIFI_CONNECT_TIMEOUT, true) && i++ < 2);  // do twice if necessary but ignore failure as AP mode may still be ok
@@ -329 +312 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-	DIAG(F("Warning: Setting AP SSID and password failed"));       // but issue warning
+      DIAG(F("Warning: Setting AP SSID and password failed"));  // but issue warning
@@ -332 +315 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-      StringFormatter::send(wifiStream, F("AT+CIPRECVMODE=0\r\n"), port); // make sure transfer mode is correct
+      StringFormatter::send(wifiStream, F("AT+CIPRECVMODE=0\r\n"), port);  // make sure transfer mode is correct
@@ -336 +319 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-#endif //DONT_TOUCH_WIFI_CONF
+#endif  // DONT_TOUCH_WIFI_CONF
@@ -338,2 +321,2 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-  StringFormatter::send(wifiStream, F("AT+CIPSERVER=0\r\n")); // turn off tcp server (to clean connections before CIPMUX=1)
-  checkForOK(1000, true); // ignore result in case it already was off
+  StringFormatter::send(wifiStream, F("AT+CIPSERVER=0\r\n"));  // turn off tcp server (to clean connections before CIPMUX=1)
+  checkForOK(1000, true);                                      // ignore result in case it already was off
@@ -341,2 +324,3 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-  StringFormatter::send(wifiStream, F("AT+CIPMUX=1\r\n")); // configure for multiple connections
-  if (!checkForOK(1000, true)) return WIFI_DISCONNECTED;
+  StringFormatter::send(wifiStream, F("AT+CIPMUX=1\r\n"));  // configure for multiple connections
+  if (!checkForOK(1000, true))
+    return WIFI_DISCONNECTED;
@@ -344,4 +328,3 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-  if(!oldCmd) {                                                                    // no idea to test this on old firmware
-    StringFormatter::send(wifiStream, F("AT+MDNS=1,\"%S\",\"withrottle\",%d\r\n"),
-			  hostname, port);                                         // mDNS responder
-    checkForOK(1000, true);                                                        // dont care if not supported
+  if (!oldCmd) {                                                                                     // no idea to test this on old firmware
+    StringFormatter::send(wifiStream, F("AT+MDNS=1,\"%S\",\"withrottle\",%d\r\n"), hostname, port);  // mDNS responder
+    checkForOK(1000, true);                                                                          // dont care if not supported
@@ -350,5 +333,7 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-  StringFormatter::send(wifiStream, F("AT+CIPSERVER=1,%d\r\n"), port); // turn on server on port
-  if (!checkForOK(1000, true)) return WIFI_DISCONNECTED;
- 
-  StringFormatter::send(wifiStream, F("AT+CIFSR\r\n")); // Display  ip addresses to the DIAG 
-  if (!checkForOK(1000, F("IP,\"") , true, false)) return WIFI_DISCONNECTED;
+  StringFormatter::send(wifiStream, F("AT+CIPSERVER=1,%d\r\n"), port);  // turn on server on port
+  if (!checkForOK(1000, true))
+    return WIFI_DISCONNECTED;
+
+  StringFormatter::send(wifiStream, F("AT+CIFSR\r\n"));  // Display  ip addresses to the DIAG
+  if (!checkForOK(1000, F("IP,\""), true, false))
+    return WIFI_DISCONNECTED;
@@ -357,6 +342,6 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-    const byte MAX_IP_LENGTH=15;
-    char ipString[MAX_IP_LENGTH+1];
-    ipString[MAX_IP_LENGTH]='\0'; // protection against missing " character on end. 
-    for(byte ipLen=0;ipLen<MAX_IP_LENGTH;ipLen++) {
-      while(!wifiStream->available());
-      int ipChar=wifiStream->read();
+    const byte MAX_IP_LENGTH = 15;
+    char ipString[MAX_IP_LENGTH + 1];
+    ipString[MAX_IP_LENGTH] = '\0';  // protection against missing " character on end.
+    for (byte ipLen = 0; ipLen < MAX_IP_LENGTH; ipLen++) {
+      while (!wifiStream->available());
+      int ipChar = wifiStream->read();
@@ -364,2 +349,2 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-      if (ipChar=='"') {
-        ipString[ipLen]='\0';
+      if (ipChar == '"') {
+        ipString[ipLen] = '\0';
@@ -368 +353 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-      ipString[ipLen]=ipChar;
+      ipString[ipLen] = ipChar;
@@ -370 +355 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-    LCD(4,F("%s"),ipString);  // There is not enough room on some LCDs to put a title to this      
+    LCD(4, F("%s"), ipString);  // There is not enough room on some LCDs to put a title to this
@@ -372,4 +357,5 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-  // suck up anything after the IP. 
-  if (!checkForOK(1000, true, false)) return WIFI_DISCONNECTED;
-  LCD(5,F("PORT=%d"),port);
-   
+  // suck up anything after the IP.
+  if (!checkForOK(1000, true, false))
+    return WIFI_DISCONNECTED;
+  LCD(5, F("PORT=%d"), port);
+
@@ -382 +367,0 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
-
@@ -393,2 +378 @@ wifiSerialState WifiInterface::setup2(const FSH* SSid, const FSH* password,
- 
-void WifiInterface::ATCommand(HardwareSerial * stream,const byte * command) {
+void WifiInterface::ATCommand(HardwareSerial* stream, const byte* command) {
@@ -396 +380 @@ void WifiInterface::ATCommand(HardwareSerial * stream,const byte * command) {
-  if (*command=='\0') { // User gave <+> command  
+  if (*command == '\0') {  // User gave <+> command
@@ -398,3 +382,3 @@ void WifiInterface::ATCommand(HardwareSerial * stream,const byte * command) {
-    while(stream->available()) stream->read(); // Drain serial input first 
-    bool startOfLine=true;
-    while(true) {
+    while (stream->available()) stream->read();  // Drain serial input first
+    bool startOfLine = true;
+    while (true) {
@@ -403 +387 @@ void WifiInterface::ATCommand(HardwareSerial * stream,const byte * command) {
-        int cx=stream->read();
+        int cx = stream->read();
@@ -405,4 +389,7 @@ void WifiInterface::ATCommand(HardwareSerial * stream,const byte * command) {
-        if (cx=='\n' || cx=='\r') startOfLine=true; 
-        else if (startOfLine && cx=='!')  break;
-        else startOfLine=false; 
-        wifiStream->write(cx);  
+        if (cx == '\n' || cx == '\r')
+          startOfLine = true;
+        else if (startOfLine && cx == '!')
+          break;
+        else
+          startOfLine = false;
+        wifiStream->write(cx);
@@ -412 +399 @@ void WifiInterface::ATCommand(HardwareSerial * stream,const byte * command) {
-    return; 
+    return;
@@ -414,2 +401,2 @@ void WifiInterface::ATCommand(HardwareSerial * stream,const byte * command) {
-  
-  if (*command=='X') {
+
+  if (*command == 'X') {
@@ -418,4 +405,3 @@ void WifiInterface::ATCommand(HardwareSerial * stream,const byte * command) {
-  }
-  else {
-    StringFormatter::  send(wifiStream, F("AT+%s\r\n"), command);
-    checkForOK(10000,  true);
+  } else {
+    StringFormatter::send(wifiStream, F("AT+%s\r\n"), command);
+    checkForOK(10000, true);
@@ -425,4 +411,2 @@ void WifiInterface::ATCommand(HardwareSerial * stream,const byte * command) {
-
-
-bool WifiInterface::checkForOK( const unsigned int timeout,  bool echo, bool escapeEcho) {
-  return checkForOK(timeout,F("\r\nOK\r\n"),echo,escapeEcho);
+bool WifiInterface::checkForOK(const unsigned int timeout, bool echo, bool escapeEcho) {
+  return checkForOK(timeout, F("\r\nOK\r\n"), echo, escapeEcho);
@@ -431,3 +415,3 @@ bool WifiInterface::checkForOK( const unsigned int timeout,  bool echo, bool esc
-bool WifiInterface::checkForOK( const unsigned int timeout, const FSH * waitfor, bool echo, bool escapeEcho) {
-  unsigned long  startTime = millis();
-  char *locator = (char *)waitfor;
+bool WifiInterface::checkForOK(const unsigned int timeout, const FSH* waitfor, bool echo, bool escapeEcho) {
+  unsigned long startTime = millis();
+  char* locator = (char*)waitfor;
@@ -435 +419 @@ bool WifiInterface::checkForOK( const unsigned int timeout, const FSH * waitfor,
-  while ( millis() - startTime < timeout) {
+  while (millis() - startTime < timeout) {
@@ -440,2 +424,4 @@ bool WifiInterface::checkForOK( const unsigned int timeout, const FSH * waitfor,
-        if (escapeEcho) StringFormatter::printEscape( ch); /// THIS IS A DIAG IN DISGUISE
-        else USB_SERIAL.print(ch);
+        if (escapeEcho)
+          StringFormatter::printEscape(ch);  /// THIS IS A DIAG IN DISGUISE
+        else
+          USB_SERIAL.print(ch);
@@ -443 +429,2 @@ bool WifiInterface::checkForOK( const unsigned int timeout, const FSH * waitfor,
-      if (ch != GETFLASH(locator)) locator = (char *)waitfor;
+      if (ch != GETFLASH(locator))
+        locator = (char*)waitfor;
@@ -457 +443,0 @@ bool WifiInterface::checkForOK( const unsigned int timeout, const FSH * waitfor,
-
@@ -460 +446 @@ void WifiInterface::loop() {
-    WifiInboundHandler::loop(); 
+    WifiInboundHandler::loop();
diff --git a/WifiInterface.h b/WifiInterface.h
index 652156d..39ee340 100644
--- a/WifiInterface.h
+++ b/WifiInterface.h
@@ -27 +27 @@
-//#include <avr/pgmspace.h>
+// #include <avr/pgmspace.h>
@@ -31,11 +31,4 @@ enum wifiSerialState { WIFI_NOAT, WIFI_DISCONNECTED, WIFI_CONNECTED };
-class WifiInterface
-{
-
-public:
-  static bool setup(long serial_link_speed, 
-                          const FSH *wifiESSID,
-                          const FSH *wifiPassword,
-                          const FSH *hostname,
-                          const int port,
-                          const byte channel,
-                          const bool forceAP);
+class WifiInterface {
+ public:
+  static bool setup(long serial_link_speed, const FSH* wifiESSID, const FSH* wifiPassword, const FSH* hostname, const int port, const byte channel,
+                    const bool forceAP);
@@ -43,6 +36,5 @@ public:
-  static void ATCommand(HardwareSerial * stream,const byte *command);
-  
-private:
-  static wifiSerialState setup(Stream &setupStream, const FSH *SSSid, const FSH *password,
-                    const FSH *hostname, int port, byte channel, bool forceAP);
-  static Stream *wifiStream;
+  static void ATCommand(HardwareSerial* stream, const byte* command);
+
+ private:
+  static wifiSerialState setup(Stream& setupStream, const FSH* SSSid, const FSH* password, const FSH* hostname, int port, byte channel, bool forceAP);
+  static Stream* wifiStream;
@@ -50,2 +42 @@ private:
-  static wifiSerialState setup2(const FSH *SSSid, const FSH *password,
-                     const FSH *hostname, int port, byte channel, bool forceAP);
+  static wifiSerialState setup2(const FSH* SSSid, const FSH* password, const FSH* hostname, int port, byte channel, bool forceAP);
@@ -53 +44 @@ private:
-  static bool checkForOK(const unsigned int timeout, const FSH *waitfor, bool echo, bool escapeEcho = true);
+  static bool checkForOK(const unsigned int timeout, const FSH* waitfor, bool echo, bool escapeEcho = true);
diff --git a/clang-format.sh b/clang-format.sh
new file mode 100755
index 0000000..66079ed
--- /dev/null
+++ b/clang-format.sh
@@ -0,0 +1,7 @@
+#!/bin/bash
+find . -maxdepth 1 -regex '.*\.\(cpp\|hpp\|c\|h\)' > files.txt
+while IFS= read -r file; do
+  echo "$file"
+  clang-format -i "$file"
+done < files.txt
+rm files.txt
\ No newline at end of file
diff --git a/config.example.h b/config.example.h
index 6aba226..d30d915 100644
--- a/config.example.h
+++ b/config.example.h
@@ -8 +8 @@
- *  
+ *
@@ -35 +35 @@ The configuration file for DCC-EX Command Station
-/* 
+/*
@@ -95 +95 @@ The configuration file for DCC-EX Command Station
-//#define DONT_TOUCH_WIFI_CONF
+// #define DONT_TOUCH_WIFI_CONF
@@ -98 +98 @@ The configuration file for DCC-EX Command Station
-// Do NOT change this if you want to use the WiFi in Access Point (AP) mode. 
+// Do NOT change this if you want to use the WiFi in Access Point (AP) mode.
@@ -114 +114 @@ The configuration file for DCC-EX Command Station
-// to the AP password you want. 
+// to the AP password you want.
@@ -138,2 +138 @@ The configuration file for DCC-EX Command Station
-//#define ENABLE_ETHERNET true
-
+// #define ENABLE_ETHERNET true
@@ -145,2 +144 @@ The configuration file for DCC-EX Command Station
-//#define IP_ADDRESS { 192, 168, 1, 200 }
-
+// #define IP_ADDRESS { 192, 168, 1, 200 }
@@ -159,4 +157,4 @@ The configuration file for DCC-EX Command Station
-//OR define OLED_DRIVER width,height[,address] in pixels (address auto detected if not supplied)
-// 128x32 or 128x64 I2C SSD1306-based devices are supported.
-// Use 132,64 for a SH1106-based I2C device with a 128x64 display.
-// #define OLED_DRIVER 0x3c,128,32
+// OR define OLED_DRIVER width,height[,address] in pixels (address auto detected if not supplied)
+//  128x32 or 128x64 I2C SSD1306-based devices are supported.
+//  Use 132,64 for a SH1106-based I2C device with a 128x64 display.
+//  #define OLED_DRIVER 0x3c,128,32
@@ -175,2 +173 @@ The configuration file for DCC-EX Command Station
-//#define MAX_CHARACTER_ROWS 12
-
+// #define MAX_CHARACTER_ROWS 12
@@ -197 +194 @@ The configuration file for DCC-EX Command Station
-// 
+//
@@ -231,4 +228,4 @@ The configuration file for DCC-EX Command Station
-// you want to change to that mode, do 
-//#define HIGHEST_SHORT_ADDR 99
-// If you want to run all your locos addressed long format, you could even do a 
-//#define HIGHEST_SHORT_ADDR 0
+// you want to change to that mode, do
+// #define HIGHEST_SHORT_ADDR 99
+// If you want to run all your locos addressed long format, you could even do a
+// #define HIGHEST_SHORT_ADDR 0
@@ -252 +249 @@ The configuration file for DCC-EX Command Station
-// versions of DCC++EX, a turnout throw command was implemented in the packet as 
+// versions of DCC++EX, a turnout throw command was implemented in the packet as
@@ -257 +254 @@ The configuration file for DCC-EX Command Station
-//#define DCC_TURNOUTS_RCN_213
+// #define DCC_TURNOUTS_RCN_213
@@ -264 +261 @@ The configuration file for DCC-EX Command Station
-//#define HAL_ACCESSORY_COMMAND_REVERSE
+// #define HAL_ACCESSORY_COMMAND_REVERSE
@@ -271 +268 @@ The configuration file for DCC-EX Command Station
-// DCC packet with D=1 (close turnout) and <a addr subaddr 1> generates D=0 
+// DCC packet with D=1 (close turnout) and <a addr subaddr 1> generates D=0
@@ -273,2 +270 @@ The configuration file for DCC-EX Command Station
-//#define DCC_ACCESSORY_COMMAND_REVERSE
-
+// #define DCC_ACCESSORY_COMMAND_REVERSE
@@ -285,6 +281,6 @@ The configuration file for DCC-EX Command Station
-//#define SERIAL1_COMMANDS
-//#define SERIAL2_COMMANDS
-//#define SERIAL3_COMMANDS
-//#define SERIAL4_COMMANDS
-//#define SERIAL5_COMMANDS
-//#define SERIAL6_COMMANDS
+// #define SERIAL1_COMMANDS
+// #define SERIAL2_COMMANDS
+// #define SERIAL3_COMMANDS
+// #define SERIAL4_COMMANDS
+// #define SERIAL5_COMMANDS
+// #define SERIAL6_COMMANDS
@@ -309 +305 @@ The configuration file for DCC-EX Command Station
-//#define SERIAL_BT_COMMANDS
+// #define SERIAL_BT_COMMANDS
@@ -315 +311 @@ The configuration file for DCC-EX Command Station
-//#define BOOSTER_INPUT 26
+// #define BOOSTER_INPUT 26
@@ -318 +314 @@ The configuration file for DCC-EX Command Station
-//#define BOOSTER_INPUT 32
+// #define BOOSTER_INPUT 32
@@ -322 +318 @@ The configuration file for DCC-EX Command Station
-//#define WIFI_LED 2
+// #define WIFI_LED 2
@@ -325 +321 @@ The configuration file for DCC-EX Command Station
-//#define WIFI_LED 33
+// #define WIFI_LED 33
@@ -336 +332 @@ The configuration file for DCC-EX Command Station
-//#define SABERTOOTH 1
+// #define SABERTOOTH 1
@@ -342 +338 @@ The configuration file for DCC-EX Command Station
-//#define SENSORCAM_VPIN 700
+// #define SENSORCAM_VPIN 700
@@ -344 +340 @@ The configuration file for DCC-EX Command Station
-//#define CAM SENSORCAM_VPIN+
+// #define CAM SENSORCAM_VPIN+
@@ -346,2 +342,2 @@ The configuration file for DCC-EX Command Station
-//#define SENSORCAM2_VPIN 600   //define other CAM's if installed.
-//#define CAM2 SENSORCAM2_VPIN+ //for EX-RAIL commands e.g. IFLT(CAM2 020,1)
+// #define SENSORCAM2_VPIN 600   //define other CAM's if installed.
+// #define CAM2 SENSORCAM2_VPIN+ //for EX-RAIL commands e.g. IFLT(CAM2 020,1)
diff --git a/defines.h b/defines.h
index 2c3ee55..e089fcd 100644
--- a/defines.h
+++ b/defines.h
@@ -31,5 +31,5 @@
-  #if __has_include ( "config.h")
-    #include "config.h"
-  #else
-    #include "config.example.h"
-  #endif
+#if __has_include("config.h")
+#include "config.h"
+#else
+#include "config.example.h"
+#endif
@@ -39 +39 @@
-// Create a cpu type we can share and 
+// Create a cpu type we can share and
@@ -43 +43 @@
-#undef USB_SERIAL     // Teensy has this defined by default...
+#undef USB_SERIAL  // Teensy has this defined by default...
@@ -50,4 +50,4 @@
-  #define ARDUINO_TYPE "UNO"
-  #undef HAS_ENOUGH_MEMORY
-  #define NO_EXTENDED_CHARACTERS
-  #undef I2C_EXTENDED_ADDRESS
+#define ARDUINO_TYPE "UNO"
+#undef HAS_ENOUGH_MEMORY
+#define NO_EXTENDED_CHARACTERS
+#undef I2C_EXTENDED_ADDRESS
@@ -55,4 +55,4 @@
-  #define ARDUINO_TYPE "NANO"
-  #undef HAS_ENOUGH_MEMORY
-  #define NO_EXTENDED_CHARACTERS
-  #undef I2C_EXTENDED_ADDRESS
+#define ARDUINO_TYPE "NANO"
+#undef HAS_ENOUGH_MEMORY
+#define NO_EXTENDED_CHARACTERS
+#undef I2C_EXTENDED_ADDRESS
@@ -60 +60 @@
-  #define ARDUINO_TYPE "MEGA"
+#define ARDUINO_TYPE "MEGA"
@@ -62 +62 @@
-  #define ARDUINO_TYPE "MEGA"
+#define ARDUINO_TYPE "MEGA"
@@ -64,4 +64,4 @@
-  #define ARDUINO_TYPE "MEGAAVR"
-  #undef HAS_ENOUGH_MEMORY
-  #define NO_EXTENDED_CHARACTERS
-  #undef I2C_EXTENDED_ADDRESS
+#define ARDUINO_TYPE "MEGAAVR"
+#undef HAS_ENOUGH_MEMORY
+#define NO_EXTENDED_CHARACTERS
+#undef I2C_EXTENDED_ADDRESS
@@ -69,10 +69,10 @@
-  #define ARDUINO_TYPE "TEENSY3132"
-  #undef USB_SERIAL
-  #define USB_SERIAL SerialUSB
-  #ifndef DISABLE_EEPROM
-    #define DISABLE_EEPROM
-  #endif
-  // Teensy support for native I2C is awaiting development 
-  #ifndef I2C_USE_WIRE
-  #define I2C_USE_WIRE
-  #endif
+#define ARDUINO_TYPE "TEENSY3132"
+#undef USB_SERIAL
+#define USB_SERIAL SerialUSB
+#ifndef DISABLE_EEPROM
+#define DISABLE_EEPROM
+#endif
+// Teensy support for native I2C is awaiting development
+#ifndef I2C_USE_WIRE
+#define I2C_USE_WIRE
+#endif
@@ -80,11 +80,11 @@
-  #define ARDUINO_TYPE "TEENSY35"
-  #undef USB_SERIAL
-  #define USB_SERIAL SerialUSB
-  // Teensy support for I2C is awaiting development 
-  #ifndef DISABLE_EEPROM
-    #define DISABLE_EEPROM
-  #endif
-  // Teensy support for native I2C is awaiting development 
-  #ifndef I2C_USE_WIRE
-  #define I2C_USE_WIRE
-  #endif
+#define ARDUINO_TYPE "TEENSY35"
+#undef USB_SERIAL
+#define USB_SERIAL SerialUSB
+// Teensy support for I2C is awaiting development
+#ifndef DISABLE_EEPROM
+#define DISABLE_EEPROM
+#endif
+// Teensy support for native I2C is awaiting development
+#ifndef I2C_USE_WIRE
+#define I2C_USE_WIRE
+#endif
@@ -92,10 +92,10 @@
-  #define ARDUINO_TYPE "TEENSY36"
-  #undef USB_SERIAL
-  #define USB_SERIAL SerialUSB
-  #ifndef DISABLE_EEPROM
-    #define DISABLE_EEPROM
-  #endif
-  // Teensy support for native I2C is awaiting development 
-  #ifndef I2C_USE_WIRE
-  #define I2C_USE_WIRE
-  #endif
+#define ARDUINO_TYPE "TEENSY36"
+#undef USB_SERIAL
+#define USB_SERIAL SerialUSB
+#ifndef DISABLE_EEPROM
+#define DISABLE_EEPROM
+#endif
+// Teensy support for native I2C is awaiting development
+#ifndef I2C_USE_WIRE
+#define I2C_USE_WIRE
+#endif
@@ -103,10 +103,10 @@
-  #define ARDUINO_TYPE "TEENSY40"
-  #undef USB_SERIAL
-  #define USB_SERIAL SerialUSB
-  #ifndef DISABLE_EEPROM
-    #define DISABLE_EEPROM
-  #endif
-  // Teensy support for native I2C is awaiting development 
-  #ifndef I2C_USE_WIRE
-  #define I2C_USE_WIRE
-  #endif
+#define ARDUINO_TYPE "TEENSY40"
+#undef USB_SERIAL
+#define USB_SERIAL SerialUSB
+#ifndef DISABLE_EEPROM
+#define DISABLE_EEPROM
+#endif
+// Teensy support for native I2C is awaiting development
+#ifndef I2C_USE_WIRE
+#define I2C_USE_WIRE
+#endif
@@ -114,10 +114,10 @@
-  #define ARDUINO_TYPE "TEENSY41"
-  #undef USB_SERIAL
-  #define USB_SERIAL SerialUSB
-  #ifndef DISABLE_EEPROM
-    #define DISABLE_EEPROM
-  #endif
-  // Teensy support for native I2C is awaiting development 
-  #ifndef I2C_USE_WIRE
-    #define I2C_USE_WIRE
-  #endif
+#define ARDUINO_TYPE "TEENSY41"
+#undef USB_SERIAL
+#define USB_SERIAL SerialUSB
+#ifndef DISABLE_EEPROM
+#define DISABLE_EEPROM
+#endif
+// Teensy support for native I2C is awaiting development
+#ifndef I2C_USE_WIRE
+#define I2C_USE_WIRE
+#endif
@@ -125,2 +125,2 @@
-  #define ARDUINO_TYPE "ESP8266"
-  #warning "ESP8266 platform untested, you are on your own"
+#define ARDUINO_TYPE "ESP8266"
+#warning "ESP8266 platform untested, you are on your own"
@@ -128,4 +128,4 @@
-  #define ARDUINO_TYPE "ESP32"
-  #ifndef DISABLE_EEPROM
-  #define DISABLE_EEPROM
-  #endif
+#define ARDUINO_TYPE "ESP32"
+#ifndef DISABLE_EEPROM
+#define DISABLE_EEPROM
+#endif
@@ -133,7 +133,7 @@
-  #define ARDUINO_TYPE "SAMD21"
-  #undef USB_SERIAL
-  #define USB_SERIAL SerialUSB
-  // SAMD no EEPROM by default 
-  #ifndef DISABLE_EEPROM
-    #define DISABLE_EEPROM
-  #endif
+#define ARDUINO_TYPE "SAMD21"
+#undef USB_SERIAL
+#define USB_SERIAL SerialUSB
+// SAMD no EEPROM by default
+#ifndef DISABLE_EEPROM
+#define DISABLE_EEPROM
+#endif
@@ -141,11 +141,11 @@
-  #define ARDUINO_TYPE "STM32"
-  // STM32 no EEPROM by default 
-  #ifndef DISABLE_EEPROM
-    #define DISABLE_EEPROM
-  #endif
-  // STM32 support for native I2C is awaiting development 
-  // #ifndef I2C_USE_WIRE
-  // #define I2C_USE_WIRE
-  // #endif
-
-/* TODO when ready 
+#define ARDUINO_TYPE "STM32"
+// STM32 no EEPROM by default
+#ifndef DISABLE_EEPROM
+#define DISABLE_EEPROM
+#endif
+// STM32 support for native I2C is awaiting development
+// #ifndef I2C_USE_WIRE
+// #define I2C_USE_WIRE
+// #endif
+
+/* TODO when ready
@@ -157 +157 @@
-  #define CPU_TYPE_ERROR
+#define CPU_TYPE_ERROR
@@ -162,2 +162,2 @@
-  #undef ARDUINO_TYPE
-  #define ARDUINO_TYPE BOARD_NAME
+#undef ARDUINO_TYPE
+#define ARDUINO_TYPE BOARD_NAME
@@ -172,9 +172,5 @@
-  #if defined(HAS_ENOUGH_MEMORY)
-    #define WIFI_ON true
-    #ifndef WIFI_CHANNEL
-      #define WIFI_CHANNEL 1
-    #endif
-  #else
-    #define WIFI_WARNING
-    #define WIFI_ON false
-  #endif
+#if defined(HAS_ENOUGH_MEMORY)
+#define WIFI_ON true
+#ifndef WIFI_CHANNEL
+#define WIFI_CHANNEL 1
+#endif
@@ -182 +178,5 @@
-  #define WIFI_ON false
+#define WIFI_WARNING
+#define WIFI_ON false
+#endif
+#else
+#define WIFI_ON false
@@ -186 +186,3 @@
-  #define WIFI_FORCE_AP false
+#define WIFI_FORCE_AP false
+#else
+#if WIFI_FORCE_AP == true || WIFI_FORCE_AP == false
@@ -188,4 +190,2 @@
-  #if WIFI_FORCE_AP==true || WIFI_FORCE_AP==false
-  #else
-    #error WIFI_FORCE_AP needs to be true or false
-  #endif
+#error WIFI_FORCE_AP needs to be true or false
+#endif
@@ -195,6 +195,2 @@
-  #if defined(HAS_ENOUGH_MEMORY)
-    #define ETHERNET_ON true
-  #else
-    #define ETHERNET_WARNING
-    #define ETHERNET_ON false
-  #endif
+#if defined(HAS_ENOUGH_MEMORY)
+#define ETHERNET_ON true
@@ -202 +198,5 @@
-  #define ETHERNET_ON false
+#define ETHERNET_WARNING
+#define ETHERNET_ON false
+#endif
+#else
+#define ETHERNET_ON false
@@ -206 +206 @@
- #error Command Station does not support WIFI and ETHERNET at the same time.
+#error Command Station does not support WIFI and ETHERNET at the same time.
@@ -208 +208 @@
-  
+
@@ -220 +220 @@
-// 
+//
@@ -222 +222 @@
-#define IO_NO_HAL // HAL too big whatever you disable otherwise
+#define IO_NO_HAL  // HAL too big whatever you disable otherwise
@@ -234,6 +234,6 @@
-#if __has_include ( "myAutomation.h")
-  #if defined(HAS_ENOUGH_MEMORY) || defined(DISABLE_EEPROM) || defined(DISABLE_PROG)
-    #define EXRAIL_ACTIVE
-  #else
-    #define EXRAIL_WARNING
-  #endif
+#if __has_include("myAutomation.h")
+#if defined(HAS_ENOUGH_MEMORY) || defined(DISABLE_EEPROM) || defined(DISABLE_PROG)
+#define EXRAIL_ACTIVE
+#else
+#define EXRAIL_WARNING
+#endif
diff --git a/myAutomation.example.h b/myAutomation.example.h
index 8338452..93f7805 100644
--- a/myAutomation.example.h
+++ b/myAutomation.example.h
@@ -5,3 +5,3 @@
- *  A task may 
- *  - Act as a ROUTE setup macro for a user to drive over 
- *  - drive a loco through an AUTOMATION 
+ *  A task may
+ *  - Act as a ROUTE setup macro for a user to drive over
+ *  - drive a loco through an AUTOMATION
@@ -9 +9 @@
- *  
+ *
@@ -11 +11 @@
- *  This task may simply follow a route, or may START  
+ *  This task may simply follow a route, or may START
@@ -13,2 +13,2 @@
- *  
- *  Where the loco id is not known at compile time, a new task 
+ *
+ *  Where the loco id is not known at compile time, a new task
@@ -16,3 +16,3 @@
- *  </ START [cab] route> 
- *  
- *  A ROUTE, AUTOMATION or SEQUENCE are internally identical in ExRail terms  
+ *  </ START [cab] route>
+ *
+ *  A ROUTE, AUTOMATION or SEQUENCE are internally identical in ExRail terms
@@ -23 +23 @@
- *  
+ *
@@ -26 +26 @@
-// This is the startup sequence, 
+// This is the startup sequence,
@@ -28,4 +28,4 @@ AUTOSTART
-POWERON        // turn on track power
-SENDLOCO(3,1) // send loco 3 off along route 1
-SENDLOCO(10,2) // send loco 10 off along route 2
-DONE     // This just ends the startup thread, leaving 2 others running.
+POWERON              // turn on track power
+    SENDLOCO(3, 1)   // send loco 3 off along route 1
+    SENDLOCO(10, 2)  // send loco 10 off along route 2
+    DONE             // This just ends the startup thread, leaving 2 others running.
@@ -33,48 +33,45 @@ DONE     // This just ends the startup thread, leaving 2 others running.
-/* SEQUENCE(1) is a simple shuttle between 2 sensors      
- *  S20 and S21 are sensors on arduino pins 20 and 21 
- *  S20                    S21                   
- *  === START->================
- */
-   SEQUENCE(1) 
-     DELAY(10000)   // wait 10 seconds
-     FON(3)       // Set Loco Function 3, Horn on
-     DELAY(1000)    // wait 1 second
-     FOFF(3)      // Horn off
-     FWD(80)      // Move forward at speed 80
-     AT(21)       // until we hit sensor id 21
-     STOP         // then stop
-     DELAY(5000)    // Wait 5 seconds
-     FON(2)       // ring bell
-     REV(60)      // reverse at speed 60
-     AT(20)       // until we get to S20
-     STOP         // then stop
-     FOFF(2)      // Bell off 
-     FOLLOW(1)    // and follow sequence 1 again
-   
-/* SEQUENCE(2) is an automation example for a single loco Y shaped journey
- *  S31,S32,S33 are sensors, T4 is a turnout
- *  
- *  S33                      T4                            S31
- *  ===-START->=============================================
- *                          //
- *  S32                    //
- *  ======================//
- *  
- *  Train runs from START to S31, back to S32, again to S31, Back to start.
- */
-  SEQUENCE(2)
-   FWD(60)     // go forward at DCC speed 60 
-   AT(31) STOP  // when we get to sensor 31 
-   DELAY(10000)  // wait 10 seconds 
-   THROW(4)    // throw turnout for route to S32
-   REV(45)     // go backwards at speed 45
-   AT(32) STOP  // until we arrive at sensor 32
-   DELAY(5000)   // wait 5 seconds
-   FWD(50)     // go forwards at speed 50
-   AT(31) STOP  // and stop at sensor 31
-   DELAY(5000)   // wait 5 seconds 
-   CLOSE(4)    // set turnout closed
-   REV(50)     // reverse back to S3
-   AT(33) STOP
-   DELAY(20000)  // wait 20 seconds 
-   FOLLOW(2)   // follow sequence 2... ie repeat the process
+    /* SEQUENCE(1) is a simple shuttle between 2 sensors
+     *  S20 and S21 are sensors on arduino pins 20 and 21
+     *  S20                    S21
+     *  === START->================
+     */
+    SEQUENCE(1) DELAY(10000)  // wait 10 seconds
+    FON(3)                    // Set Loco Function 3, Horn on
+    DELAY(1000)               // wait 1 second
+    FOFF(3)                   // Horn off
+    FWD(80)                   // Move forward at speed 80
+    AT(21)                    // until we hit sensor id 21
+    STOP                      // then stop
+    DELAY(5000)               // Wait 5 seconds
+    FON(2)                    // ring bell
+    REV(60)                   // reverse at speed 60
+    AT(20)                    // until we get to S20
+    STOP                      // then stop
+    FOFF(2)                   // Bell off
+    FOLLOW(1)                 // and follow sequence 1 again
+
+    /* SEQUENCE(2) is an automation example for a single loco Y shaped journey
+     *  S31,S32,S33 are sensors, T4 is a turnout
+     *
+     *  S33                      T4                            S31
+     *  ===-START->=============================================
+     *                          //
+     *  S32                    //
+     *  ======================//
+     *
+     *  Train runs from START to S31, back to S32, again to S31, Back to start.
+     */
+    SEQUENCE(2) FWD(60)       // go forward at DCC speed 60
+    AT(31) STOP               // when we get to sensor 31
+    DELAY(10000)              // wait 10 seconds
+    THROW(4)                  // throw turnout for route to S32
+    REV(45)                   // go backwards at speed 45
+    AT(32) STOP               // until we arrive at sensor 32
+    DELAY(5000)               // wait 5 seconds
+    FWD(50)                   // go forwards at speed 50
+    AT(31) STOP               // and stop at sensor 31
+    DELAY(5000)               // wait 5 seconds
+    CLOSE(4)                  // set turnout closed
+    REV(50)                   // reverse back to S3
+    AT(33) STOP DELAY(20000)  // wait 20 seconds
+    FOLLOW(2)                 // follow sequence 2... ie repeat the process
diff --git a/myEX-Turntable.example.h b/myEX-Turntable.example.h
index cbc1e54..fb712a3 100644
--- a/myEX-Turntable.example.h
+++ b/myEX-Turntable.example.h
@@ -3 +3 @@
- ************************************************************************************************** 
+ **************************************************************************************************
@@ -5 +5 @@
- ************************************************************************************************** 
+ **************************************************************************************************
@@ -7 +7 @@
- * 
+ *
@@ -13 +13 @@
- * 
+ *
@@ -15 +15 @@
- * 
+ *
@@ -22 +22 @@
- * 
+ *
@@ -24 +24 @@
- * 
+ *
@@ -40,6 +40,6 @@ DONE
-  ROUTE(route_id, desc) \
-    RESERVE(reserve_id) \
-    MOVETT(vpin, steps, activity) \
-    WAITFOR(vpin) \
-    FREE(reserve_id) \
-    DONE
+  ROUTE(route_id, desc)                                                 \
+  RESERVE(reserve_id)                                                   \
+  MOVETT(vpin, steps, activity)                                         \
+  WAITFOR(vpin)                                                         \
+  FREE(reserve_id)                                                      \
+  DONE
diff --git a/version.h b/version.h
index 2199e42..f8f9121 100644
--- a/version.h
+++ b/version.h
@@ -22,2 +22,2 @@
-// 5.2.90 - Bugfix: EXRAIL EXTT_TURNTABLE() now has description as optional in line with ocumentation (also fixed DCC_TURNTABLE) 
-// 5.2.89 - EXRAIL SET(vpin[,npins]) RESET(vpin,[,npins]) pin range manipulation 
+// 5.2.90 - Bugfix: EXRAIL EXTT_TURNTABLE() now has description as optional in line with ocumentation (also fixed DCC_TURNTABLE)
+// 5.2.89 - EXRAIL SET(vpin[,npins]) RESET(vpin,[,npins]) pin range manipulation
@@ -37,2 +37,2 @@
-//        - HAL driver 
-//        - EXRAIL NEOPIXEL and NEOPIXEL_SIGNAL   
+//        - HAL driver
+//        - EXRAIL NEOPIXEL and NEOPIXEL_SIGNAL
@@ -45 +45 @@
-// 5.2.71 -  Broadcasts of loco forgets. 
+// 5.2.71 -  Broadcasts of loco forgets.
@@ -47 +47 @@
-//        -  and included in IODEvice.h (circular dependency removed) 
+//        -  and included in IODEvice.h (circular dependency removed)
@@ -52 +52 @@
-//        -  AFTER(42) == AFTER(42,500) sets time sensor must 
+//        -  AFTER(42) == AFTER(42,500) sets time sensor must
@@ -56,2 +56,2 @@
-// 5.2.65 - Speedup Exrail SETFREQ 
-// 5.2.64 - Bugfix: <0 PROG> updated to undo JOIN 
+// 5.2.65 - Speedup Exrail SETFREQ
+// 5.2.64 - Bugfix: <0 PROG> updated to undo JOIN
@@ -73,2 +73,2 @@
-// 5.2.54 - Bugfix for EXRAIL signal handling for active high 
-// 5.2.53 - Bugfix for EX-Fastclock, call I2CManager.begin() before checking I2C address 
+// 5.2.54 - Bugfix for EXRAIL signal handling for active high
+// 5.2.53 - Bugfix for EX-Fastclock, call I2CManager.begin() before checking I2C address
@@ -76 +76 @@
-//        - Add support for ports G and H on STM32 for ADCee() and MotorDriver pins/shadow regs 
+//        - Add support for ports G and H on STM32 for ADCee() and MotorDriver pins/shadow regs
@@ -97 +97 @@
-// 5.2.38 - Exrail MESSAGE("text") to send a user message to all 
+// 5.2.38 - Exrail MESSAGE("text") to send a user message to all
@@ -105 +105 @@
-//        - Exrail intercept <A ...> for DCC Signals. 
+//        - Exrail intercept <A ...> for DCC Signals.
@@ -108 +108 @@
-// 5.2.31 - Exrail JMRI_SENSOR(vpin [,count]) creates <S> types.  
+// 5.2.31 - Exrail JMRI_SENSOR(vpin [,count]) creates <S> types.
@@ -118,3 +118,3 @@
-//        - include HAL_IGNORE_DEFAULTS macro in EXRAIL 
-// 5.2.25 - Fix bug causing <X> after working <D commands 
-// 5.2.24 - Exrail macro asserts to catch 
+//        - include HAL_IGNORE_DEFAULTS macro in EXRAIL
+// 5.2.25 - Fix bug causing <X> after working <D commands
+// 5.2.24 - Exrail macro asserts to catch
@@ -124 +124 @@
-// 5.2.23 - KeywordHasher _hk (no functional change) 
+// 5.2.23 - KeywordHasher _hk (no functional change)
@@ -135,2 +135,2 @@
-//        - Optional #define DISABLE_FUNCTION_REMINDERS 
-// 5.2.13 - EXRAIL STEALTH 
+//        - Optional #define DISABLE_FUNCTION_REMINDERS
+// 5.2.13 - EXRAIL STEALTH
@@ -142 +142 @@
-//        - include IO_PCA9555  
+//        - include IO_PCA9555
@@ -144 +144 @@
-// 5.2.9  - EXRAIL STASH feature 
+// 5.2.9  - EXRAIL STASH feature
@@ -159 +159 @@
-// 5.1.20 - EXRAIL Tidy and ROUTE_STATE, ROUTE_CAPTION 
+// 5.1.20 - EXRAIL Tidy and ROUTE_STATE, ROUTE_CAPTION
@@ -224,2 +224,2 @@
-// 4.2.49 - Exrail SPEED take notice of external direction change 
-// 4.2.48 - BROADCAST/WITHROTTLE Exrail macros 
+// 4.2.49 - Exrail SPEED take notice of external direction change
+// 4.2.48 - BROADCAST/WITHROTTLE Exrail macros
@@ -233 +233 @@
-//        - Fix DNOU8 output pin setup to all LOW  
+//        - Fix DNOU8 output pin setup to all LOW
@@ -241 +241 @@
-// 4.2.35 - add <z> direct pin manipulation command 
+// 4.2.35 - add <z> direct pin manipulation command
@@ -262 +262 @@
-//        - Reinstate <c> but remember its a bit useless when TM involved.   
+//        - Reinstate <c> but remember its a bit useless when TM involved.
@@ -272 +272 @@
-//        - EX-RAIL SCREEN function for writing to screens other 
+//        - EX-RAIL SCREEN function for writing to screens other
@@ -276 +276 @@
-//        - Layered HAL Drivers PCA9685pwm and Servo added for 
+//        - Layered HAL Drivers PCA9685pwm and Servo added for
@@ -282 +282 @@
-//        - Add UserAddin facility to allow a user-written C++ function to be 
+//        - Add UserAddin facility to allow a user-written C++ function to be
@@ -284 +284 @@
-//        - Add ability to configure clock speed of PCA9685 drivers 
+//        - Add ability to configure clock speed of PCA9685 drivers
@@ -328 +328 @@
-//       Float eliminated saving >1.5kb PROGMEM and speed. 
+//       Float eliminated saving >1.5kb PROGMEM and speed.
@@ -331,2 +331,2 @@
-//       TrackManager DCC & DC up to 8 Districts Architecture 
-//       Automatic ALIAS(name) 
+//       TrackManager DCC & DC up to 8 Districts Architecture
+//       Automatic ALIAS(name)
@@ -342 +342 @@
-//       FIX negative route ids in WIthrottle problem. 
+//       FIX negative route ids in WIthrottle problem.
@@ -345 +345 @@
-//       <t cab> command to obtain current throttle settings 
+//       <t cab> command to obtain current throttle settings
@@ -350 +350 @@
-//       </KILL ALL> and KILLALL command to stop all tasks. 
+//       </KILL ALL> and KILLALL command to stop all tasks.
@@ -352 +352 @@
-//       Servo signals (SERVO_SIGNAL) 
+//       Servo signals (SERVO_SIGNAL)
@@ -354 +354 @@
-//       Wait for analog value (ATGTE, ATLT)  
+//       Wait for analog value (ATGTE, ATLT)
@@ -356 +356 @@
-//       EXRAIL BROADCAST("msg") 
+//       EXRAIL BROADCAST("msg")
@@ -365 +365 @@
-//       New JMRI feature enhancements; 
+//       New JMRI feature enhancements;
@@ -368,2 +368,2 @@
-//         Provides for multiple additional DCC++EX WiFi connections as accessory controllers or CS for a programming track when Motor Shields are added
-//         Supports Multiple Command Station connections and individual tracking of Send DCC++ Command panes and DCC++ Traffic Monitor panes
+//         Provides for multiple additional DCC++EX WiFi connections as accessory controllers or CS for a programming track when Motor Shields are
+//         added Supports Multiple Command Station connections and individual tracking of Send DCC++ Command panes and DCC++ Traffic Monitor panes
@@ -393 +393 @@
-// 3.1.7 Bugfix: Unknown locos should have speed forward 
+// 3.1.7 Bugfix: Unknown locos should have speed forward
@@ -400 +400 @@
-// 3.0.16 Ignore CV1 bit 7 read rejected by decoder when identifying loco id.  
+// 3.0.16 Ignore CV1 bit 7 read rejected by decoder when identifying loco id.
@@ -402 +402 @@
-// 3.0.14 gap in ack tolerant fix,  prog track power management over join fix. 
+// 3.0.14 gap in ack tolerant fix,  prog track power management over join fix.
@@ -417 +417 @@
-//  <W addr> command to write loco address and clear consist 
+//  <W addr> command to write loco address and clear consist
